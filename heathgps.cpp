#define EXTERN extern
#include "heather.ch"


// not fully implemented SRO100 commands:
// SRO_MC
// SRO_TD SRO_DT  (we can set the date/time, but don't read and use it)
// R05 R06  (not needed... FC?????? does this?
// L05 L06  (only requested on startup)

//
// Thunderbolt TSIP monitor
//
// Copyright (C) 2008-2018 Mark S. Sims
// Win32 port by John Miles, KE5FX (john@miles.io)
// 
// This file contains the receiver message parsers and GPS receiver control
// code.  It also displays the basic GPS data.
//
//
// minor alarms
//    0x0001 - osc age alarm
//    0x0002 - antenna open
//    0x0004 - antenna short
//    0x0006 - antenna no power
//    0x0008 - no tracked sats
//    0x0010 - external osc control / undisciplined
//    0x0020 - survey mode
//    0x0040 - no saved position
//    0x0080 - leapsecond pending
//    0x0100 - calibration mode   
//    0x0200 - bad saved position
//    0x0400 - EEPROM
//    0x0800 - no almanac
//    0x1000 - PPS2 skipped
//
// critical alarms
//    0x0001 - ROM fail
//    0x0002 - RAM fail
//    0x0004 - power supply fail
//    0x0008 - fpga fail / gps fail
//    0x0010 - ocxo fail / rtc
//
// set_config(...)
//


#define TRUNC_YEAR  80       // two digit year values > this are in the 1900's
#define LEAP_THRESH (366/2)  // used to determine valid day count until leaspsecond

#define ROLL_THRESH 15       // number of consecutive bogus year values until rollover compensation kicks in
#define ROLL_FILT 0          // set to non-zero to enable rollover detecttion filtering
int roll_filter;             // used to filter out transient clock errors

#define MOTO_STATE 2         // the type of satellite state info we have
#define STAR_STATE 3
#define SIRF_STATE 4
#define UBX_STATE  5

int packet_end;              // used to pretty-print and label hex log packets
char packet_id[SLEN];

int info_row;                // used to format the INFO_ROW stuff
int info_avail;
int last_pp;                 // last pretty print row space
int did_crit;


double jd_zda;               // UTC time from GPZDA message

int last_survey;             // used to detect changes in the survey mode
int new_sat_azel;            // flag set when new sat az/el data received.

u16 early_end;               // flag set if receiver message ended early
int last_msg;                // the previous TSIP message type
int all_polled;
int saw_star_etx;            // OSA4530 end-of-response
int no_response_msg;         // message sent that does not have a response

int skip_starloc_time;       // used to filter out bogus STARLOC_TYPE time stamps
int this_pri_tow;
int last_pri_tow;
int last_misc_second = (-1);


int pt_hh;
int pt_min;
int pt_sec;
int pt_tow;

int st_hh;
int st_min;
int st_sec;


u08 rev_month;          // ebolt info
u08 rev_day;
u16 rev_year;
u08 rev_hour;
u32 ebolt_serno;

u16 sv6_week;           // SV6 info
float sv6_tow;


int eom_flag;         // end-of-message flag for send_byte()
int user_msg_num;

int tsip_send_count;
u08 try_nortel;       // if flag set, try nortel format osc messages
u08 waking;           // flag set if in wakeup mode
u08 luxor_time_set;   // flag set if luxor time message has been sent
#define LUXOR_ID 0xDC // luxor TSIP packets start with this code

char ticc_msg[NMEA_MSG_SIZE+1];     // ticc message buffer
char ticc_field[NMEA_MSG_SIZE+1];   // fields extracted from message buffer come here
int ticc_col;

char enviro_msg[NMEA_MSG_SIZE+1];   // environmental sensor message buffer
char enviro_field[NMEA_MSG_SIZE+1]; // fields extracted from message buffer come here
int enviro_col;



char dac_msg[NMEA_MSG_SIZE+1];      // ADC message buffer
char dac_field[NMEA_MSG_SIZE+1];    // fields extracted from message buffer come here
int dac_col;

#define UBX_NAV        0x0102
#define UBX_STATUS     0x0103
#define UBX_DOP        0x0104
#define UBX_SOL        0x0106   //rtklib
#define UBX_SPEED      0x0112
#define UBX_GPS        0x0120
#define UBX_UTC        0x0121
#define UBX_CLOCK      0x0122
#define UBX_SVN        0x0130
#define UBX_SBAS       0x0132   //rtklib
#define UBX_ORB        0x0134   //rtklib
#define UBX_RAW        0x0210   //rtklib
#define UBX_SFRB       0x0211   //rtklib Ublox6
#define UBX_SFRBX      0x0213   //rtklib Ublox8
#define UBX_RAWX       0x0215   //rtklib Ublox8
#define TRK_MEAS       0x030F   //rtklib Ublox8
#define TRK_SFRBX      0x0310   //rtklib Ublox8
#define UBX_NAK        0x0500
#define UBX_ACK        0x0501
#define UBX_SET_RATE   0x0601
#define UBX_DATUM      0x0606
#define UBX_PPS        0x0607
#define UBX_NAV_RATE   0x0608
#define UBX_EEPROM     0x0609
#define UBX_CFG_ANT    0x0613
#define UBX_CFG_TMODE  0x061D 
#define UBX_NAVX5      0x0623 
#define UBX_CFG        0x0624
#define UBX_TP5        0x0631
#define UBX_CFG_TMODE2 0x063D 
#define UBX_GNSS       0x063E
#define UBX_VER        0x0A04
#define UBX_MON        0x0A09
#define UBX_LEAP       0x0B02
#define UBX_TP         0x0D01
#define UBX_SVIN       0x0D04 


u08 ubx_txa, ubx_txb; // calculates ubx transmit checksum bytes to send
u08 ubx_rxa, ubx_rxb; // received ubx message calculated checksum bytes
u08 ubx_msg_rxa, ubx_msg_rxb; // checksum bytes from the received ubx message

u08 ubx_rx_class;     // received ubx message class byte
u08 ubx_rx_id;        // received ubx message id byte
u16 ubx_msg_id;
u32 ubx_rx_len;       // length of ubx message payload remaining to be received
u32 ubx_msg_len;
u08 ubx_msg_cka;      // checksum bytes from the received ubx message
u08 ubx_msg_ckb;
int max_ubx_bytes;    // max number of bytes received between time messages

double elat;
double elon;
double ealt;
u32 ubx_svar;         // survey variance



u08 nmea_vfy_cksum;   // NMEA/TAIP message checksum
u08 nmea_msg_cksum;
u08 nmea_tx_cksum;
void decode_nmea_msg();

s16 ss_vfy_cksum;     // Novatel SuperStar II
s16 ss_msg_cksum;
s16 ss_tx_cksum;

u08 rt17_vfy_cksum;
u08 rt17_msg_cksum;
u08 rt17_tx_cksum;
void send_rt17_start(int msg, int len);
void send_rt17_end();
void flush_rt17_cmd();

u08 moto_vfy_cksum;   // MOTOROLA message checksum and parsing
u08 moto_msg_cksum;
u08 moto_tx_cksum;
int moto_msg_ptr;
int moto_msg_len;
char id_tag[6+1];     // moto vehicle id tag field



// messages from receiver
#define VENUS_SBAS_MSG    0x62
#define VENUS_QZSS_MSG    0x62
#define VENUS_TIME_MSG    0x64 
#define VENUS_JAMMING_MSG 0x64
#define VENUS_BOOT_MSG    0x64
#define VENUS_GNSS_MSG    0x64
#define VENUS_PPS_MSG     0x65
#define VENUS_RTK_MSG     0x6A
#define VENUS_VERSION_MSG 0x80
#define VENUS_ACK_MSG     0x83
#define VENUS_NAK_MSG     0x84
#define VENUS_RATE_MSG    0x86
#define VENUS_MEAS_MSG    0x89
#define VENUS_RTCM_MSG    0x8A
#define VENUS_BASE_MSG    0x8B   // like VENUS_SURVEY_MSG for RTK devices
#define VENUS_NAV_MSG     0xA8
#define VENUS_MASK_MSG    0xB0
#define VENUS_CABLE_MSG   0xBB
#define VENUS_SURVEY_MSG  0xC2
#define VENUS_MTIME_MSG   0xDC
#define VENUS_RAW_MSG     0xDD
#define VENUS_SV_MSG      0xDE
#define VENUS_XNAV_MSG    0xDF
#define VENUS_EXTRAW_MSG  0xE5

// message id, message subcode (-1 if none)
#define QUERY_VENUS_VERSION  0x02,0x01
#define QUERY_VENUS_RATE     0x10,-1
#define QUERY_VENUS_MEAS     0x1F,-1
#define QUERY_VENUS_RTCM     0x21,-1
#define QUERY_VENUS_BASE     0x23,-1    // like QUERY_VENUS_SURVEY for RTK devices
#define QUERY_VENUS_MASKS    0x2F,-1
#define QUERY_VENUS_SURVEY   0x44,-1
#define QUERY_VENUS_CABLE    0x46,-1
#define QUERY_VENUS_SBAS     0x62,0x02  // has sub-code
#define QUERY_VENUS_QZSS     0x62,0x04  // has sub-code
#define QUERY_VENUS_BOOT     0x64,0x01  // has sub-code
#define QUERY_VENUS_JAMMING  0x64,0x07  // has sub-code
#define QUERY_VENUS_GNSS     0x64,0x1A  // has sub-code
#define QUERY_VENUS_LEAP     0x64,0x20  // has sub-code
#define QUERY_VENUS_WIDTH    0x65,0x02  // has sub-code
#define QUERY_VENUS_FREQ     0x65,0x04  // has sub-code
#define QUERY_VENUS_RTK_MODE 0x6A,0x02  // has sub-code

// message id, message len
#define SET_VENUS_RESTART    0x01,15
#define VENUS_FACTORY_RESET  0x04,2
#define SET_VENUS_BAUD       0x05,4
#define SET_VENUS_BINARY     0x09,3
#define SET_VENUS_FW         0x0B,0
#define SET_VENUS_POWER      0x0C,3
#define SET_VENUS_NAV_RATE   0x0E,3
#define SET_VENUS_OUT_RATE   0x11,3
#define SET_VENUS_RAW        0x1E,9
#define SET_VENUS_RTCM       0x20,17
#define SET_VENUS_RTK_SURVEY 0x22,31  // like SET_VENUS_SURVEY for RTK devices
#define SET_VENUS_MASKS      0x2B,5
#define SET_VENUS_PINNING    0x39,3
#define SET_VENUS_CABLE      0x45,6
#define SET_VENUS_SURVEY     0x54,31
#define SET_VENUS_QZSS       0x62,5  // has sub-code
#define SET_VENUS_SBAS       0x62,9  // has sub-code
#define SET_VENUS_JAMMING    0x64,4  // has sub-code
#define SET_VENUS_GNSS       0x64,5  // has sub-code
#define SET_VENUS_NAV_MODE   0x64,5  // has sub-code
#define SET_VENUS_FREQ       0x65,7  // has sub-code
#define SET_VENUS_WIDTH      0x65,7  // has sub-code
#define SET_VENUS_RTK_MODE   0x6A,4  // has sub-code

#define VENUS_SAVE eeprom_save  // 0=SRAM  1=SRAM and flash
#define VENUS_RATE 1            // default nav update rate

u08 venus_tx_cksum;   // Venus message checksum and parsing 
u08 venus_vfy_cksum;
u32 venus_rx_len;
u32 venus_msg_len;
u08 venus_msg_id;
int venus_nmea;       // used to process mixed Venus binary and NMEA messages
int venus_start, venus_len;



#define SIRF_NAV2_MSG         2
#define SIRF_TRACK_MSG        4
#define SIRF_SW_VER_MSG       6
#define SIRF_CLOCK_MSG        7
#define SIRF_THROUGHPUT_MSG   9
#define SIRF_ACK_MSG         11
#define SIRF_NAK_MSG         12
#define SIRF_VIS_MSG         13
#define SIRF_NAV_PARAM_MSG   19
#define SIRF_DGPS_MSG        27
#define SIRF_NAV_MSG         41
#define SIRF_PPS_MSG         52

#define SET_SIRF_NMEA       129
#define GET_SIRF_SW_VER     132
#define SET_SIRF_BINARY     134
#define SET_SIRF_EL_MASK    139
#define SET_SIRF_AMU_MASK   140
#define SET_STATIC_MODE     143
#define GET_SIRF_NAV_PARAMS 152

u16 sirf_rx_cksum;    // calculated checksum of the received sirf message
u16 sirf_msg_cksum;   // checksum in the received message
u16 sirf_tx_cksum;
u16 sirf_msg_id;
u32 sirf_rx_len;      // length of sirf message payload remaining to be received
u32 sirf_msg_len;



#define send_nvs_start(x) send_tsip_start(x)
#define NVS_GLONASS_PRN 64

u16 nvs_rx_crc;
u16 nvs_msg_crc;
u16 nvs_tx_crc;

int nvs_test;      // receiver test results
double nvs_msecs;  // milliseconds value from time packet


#define ZOD_POSN_MSG         1000
#define ZOD_SNR_MSG          1002
#define ZOD_VIS_MSG          1003
#define ZOD_BEST_MSG         1008  // best user data
#define ZOD_ID_MSG           1011
#define ZOD_SETTINGS_MSG     1012
#define ZOD_RAM_MSG          1050  // ram status
#define ZOD_TRAIM_CONFIG_MSG 1055
#define ZOD_TRAIM_STATUS_MSG 1056
#define ZOD_ACCEL_STATUS_MSG 1092  // hardware accelerator status
#define ZOD_DIAG_MSG         1100
#define ZOD_MARK_MSG         1108
#define ZOD_TEMP_MSG         1110
#define ZOD_POWER_MSG        1117
#define ZOD_EE_WRITE_MSG     1135
#define ZOD_EE_STATUS_MSG    1136
#define ZOD_ACCEL_DATA_MSG   1191  // hardware accelerator data

#define ZOD_SET_EL_MASK      1212
#define ZOD_SET_SAT_MASK     1213
#define ZOD_SET_PLATFORM     1220
#define ZOD_SET_NAV_MODE     1221
#define ZOD_SET_CONFIG       1255
#define ZOD_SET_ACCEL        1292  // enable hardware accelerator
#define ZOD_SET_POWER        1317
#define ZOD_REQ_DIAGS        1300
#define ZOD_REQ_RESTART      1303
#define ZOD_SET_BAUD         1330
#define ZOD_SET_PROTOCOL     1331
#define ZOD_FW_UPDATE        1380

u16 zodiac_tx_cnt;    // used to keep track of even/odd bytes being sent
u16 zodiac_tx_cksum;  // checksum of message payload being sent
u16 zodiac_vfy_cksum; // checksum word from the message
u16 zodiac_rx_cksum;  // calculated checksum of the received message
u16 zodiac_rx_len;    // count of bytes being read from a message payload
u16 zodiac_hdr[4];    // msg id,  msg len, msg flags, msg checksum
u16 zod_seq_num;      // sequence number of sent messages
u16 zod_nav_flags;
u16 zodiac_low_byte;


#define queue_brandy_cmd(a,b) queue_polled_cmd(a, b)
#define queue_cs_cmd(a, b)    queue_polled_cmd(a, b)
#define queue_lpfrs_cmd(a, b) queue_polled_cmd(a, b)
#define queue_prs_cmd(a, b)   queue_polled_cmd(a, b)
#define queue_scpi_cmd(a, b)  queue_polled_cmd(a, b)
#define queue_sro_cmd(a, b)   queue_polled_cmd(a, b)
#define queue_sa35_cmd(a, b)  queue_polled_cmd(a, b)
#define queue_star_cmd(a, b)  queue_polled_cmd(a, b)
#define queue_uccm_cmd(a, b)  queue_polled_cmd(a, b)
#define queue_x72_cmd(a, b)   queue_polled_cmd(a, b)

#define POLLED_Q_SIZE 100  // size of pending polled message query queue

// msecs to Sleep() for after sending a command
#define BRANDY_SLEEP  200
#define CS_SLEEP      50
#define DEFAULT_SLEEP 200
#define ENVIRO_SLEEP  0
#define ESIP_SLEEP    0
#define LPFRS_SLEEP   100
#define OSA_SLEEP     200
#define PRS_SLEEP     100
#define SA35_SLEEP    100
#define SCPI_SLEEP    200 
#define SRO_SLEEP     100
#define STAR_SLEEP    0     // was 200 piss3
#define TM4_SLEEP     50
#define X72_SLEEP     100
#define Z12_SLEEP     50

#define SCPI_TIME_MSG       999
#define SCPI_NULL_MSG       1
#define SCPI_CLS_MSG        2
#define SCPI_TIMEFMT_MSG    3
#define SCPI_ELEV_MSG       10
#define SCPI_EFC_MSG        11
#define SCPI_VIS_MSG        12
#define SCPI_TRACK_MSG      13
#define SCPI_GET_CABLE_MSG  14
#define SCPI_UTC_OFS_MSG    15
#define SCPI_TINT_MSG       16
#define SCPI_STATUS_MSG     17
#define SCPI_PROGRESS_MSG   18
#define SCPI_SURVEY_MSG     19
#define SCPI_RESET_MSG      20
#define SCPI_POSN_MSG       21
#define SCPI_HOLDOVER_MSG   22
#define SCPI_UTC_MSG        23
#define SCPI_TUNC_MSG       24
#define SCPI_TEST_MSG       25
#define SCPI_HARDWARE_MSG   26
#define SCPI_LEAPTIME_MSG   27
#define SCPI_ID_MSG         28
#define SCPI_POS_MSG        29  // stop self survey
#define SCPI_IGNORE_MSG     30
#define SCPI_IGN_COUNT_MSG  31
#define SCPI_INCLUDE_MSG    32
#define SCPI_JAMSYNC_MSG    33
#define SCPI_EDGE_MSG       34
#define SCPI_LIFE_MSG       35
#define SCPI_POWER_MSG      36
#define SCPI_USER_MSG       37
#define SCPI_SET_CABLE_MSG  38
#define SCPI_FFOM_MSG       50  // NORTEL_TYPE
#define SCPI_ANTENNA_MSG    51  // NORTEL_TYPE 
#define SCPI_OPERATION_MSG  52  // NORTEL_TYPE 
#define SCPI_FDUP_MSG       53

char scpi_status_line[128+1];
int scpi_col;



#define UCCM_RATE_MSG       100  // UCCM messages
#define UCCM_STATUS_MSG     101
#define UCCM_LOOP_MSG       102
#define UCCM_EFC_MSG        103
#define UCCM_SETDAC_MSG     104
#define UCCM_LED_MSG        105
#define UCCM_OUTP_MSG       106
#define UCCM_STATE_MSG      107
#define UCCM_SET_PULLIN_MSG 108
#define UCCM_GET_PULLIN_MSG 109
#define UCCM_GET_HW_ALARM   110
#define UCCM_GET_OPER_ALARM 111

int sent_uccm_status;


 // scpi_cmd() message codes for STAR 4 receivers
#define STAR_POS_MSG        299  // position and time
#define STAR_ALARM_MSG      200
#define STAR_ALMASK_MSG     201
#define STAR_CONF_MSG       202
#define STAR_INP_TYPE_MSG   203
#define STAR_HBSQ_MSG       204
#define STAR_VIS_MSG        205
#define STAR_TRACK_MSG      206
#define STAR_GPS_TIME_MSG   207
#define STAR_INV_MSG        208
#define STAR_ANGLE_MSG      209
#define STAR_STATE_MSG      210
#define STAR_STATUS_MSG     211
#define STAR_TEMP_MSG       212
#define STAR_TOD_MSG        213
#define STAR_TYPE_MSG       214
#define STAR_ATDC_MSG       215
#define STAR_PERF_MSG       216
#define STAR_TZONE_MSG      217

#define STAR_WTR_MSG        218  // messages for 453x
#define STAR_CLEAR_GPS_MSG  219
#define STAR_CLEAR_AUX_MSG  220  // !!!! 4531
#define STAR_ZDA_MSG        221
#define STAR_AUX_MSG        222  // !!!! 4531
#define STAR_BAUD_MSG       223 
#define STAR_OUTPUT_MSG     224  // !!!! 4531
#define STAR_PRIOR_MSG      225  // !!!! 4531
#define STAR_ADM_MSG        226  // !!!! 4531

#define STAR_TAU_MSG        250  // command output only messages
#define STAR_RESTART_MSG    251
#define STAR_HOLD_MSG       252
#define STAR_CABLE_MSG      253
#define STAR_OFFSET_MSG     254



#define CS_TIME_MSG         300  // HP5071 messages
#define CS_MJD_MSG          301
#define CS_CBTID_MSG        302
// #define CS_EFC_MSG          303  // we use the SCPI_EFC_MSG for this
#define CS_BEAM_MSG         304
#define CS_PUMP_MSG         305
#define CS_GAIN_MSG         306
#define CS_RFAM_MSG         307
#define CS_GLOB_MSG         308
#define CS_SUPPLY_MSG       309
#define CS_TEMP_MSG         310
#define CS_COVEN_MSG        311
#define CS_EMUL_MSG         312
#define CS_HWI_MSG          313
#define CS_MSP_MSG          314
#define CS_PLL_MSG          315
#define CS_QOVEN_MSG        316   // oven monitor
#define CS_VOLT_MSG         317
#define CS_CFIELD_MSG       318
#define CS_FREQ1_MSG        319
#define CS_FREQ2_MSG        320
#define CS_STER_MSG         321
#define CS_SYNC_MSG         322
#define CS_STANDBY_MSG      323
#define CS_SLEW_MSG         324
#define CS_DISP_MSG         325
#define CS_REM_MSG          326
#define CS_LEAPSTAT_MSG     327
#define CS_LEAPDUR_MSG      328
#define CS_LEAPMJD_MSG      329
#define CS_LOGCOUNT_MSG     330
#define CS_LOGINFO_MSG      331
#define CS_CLEARLOG_MSG     332
#define CS_LAMP_MSG         333


// Brandywine messages
#define BRANDY_VERSION_MSG  400  // a - also has time
#define BRANDY_PULSE_MSG    401  // c
#define BRANDY_CODE_MSG     402  // e
#define BRANDY_FREQ_MSG     403  // f
#define BRANDY_HEALTH_MSG   404  // h
#define BRANDY_LEAP_MSG     405  // j
#define BRANDY_SATINFO_MSG  406  // l -> $GPGSV
#define BRANDY_FW_MSG       407  // n
#define BRANDY_ZONE_MSG     408  // o
#define BRANDY_POSN_MSG     409  // p -> $GPGGA
#define BRANDY_INFO_MSG     410  // s -> $GPRMC
#define BRANDY_TIME_MSG     411  // t
#define BRANDY_DOP_MSG      412  // d -> $GPGSA
#define BRANDY_RESET_MSG    420 


// PRS10 messages
#define PRS_RC_MSG          500  // factory reset
#define PRS_RS_MSG          501  // warm reset
#define PRS_ID_MSG          502  // id
#define PRS_SN_MSG          503  // serial number
#define PRS_VB_MSG          504  // verbose
#define PRS_ST_MSG          505  // status
#define PRS_LM_MSG          506  // lock mode
#define PRS_LO_MSG          507  // loop params
#define PRS_FC_MSG          508  // freq control
#define PRS_DS_MSG          509  // detectd signals
#define PRS_SF_MSG          510  // set freq
#define PRS_SS_MSG          511  // set slope
#define PRS_GA_MSG          512  // set gain
#define PRS_PH_MSG          513  // set phase
#define PRS_SP_MSG          514  // set params
#define PRS_MS_MSG          515  // magnetic switching
#define PRS_MO_MSG          516  // magnetic offset
#define PRS_MR_MSG          517  // magnetic read
#define PRS_TT_MSG          518  // time tag
#define PRS_TS_MSG          519  // time slope
#define PRS_TO_MSG          520  // time offset
#define PRS_PS_MSG          521  // pulse slope
#define PRS_PL_MSG          522  // pll lock
#define PRS_PT_MSG          523  // pll time constant
#define PRS_PF_MSG          524  // pll stability
#define PRS_PI_MSG          525  // pll integrator
#define PRS_PP_MSG          526  // place pulse (can't be read back)
#define PRS_FC2_MSG         527  // FC eeprom info
#define PRS_EP_MSG          528  // enable power
#define PRS_SD0_MSG         530  // dac read
#define PRS_SD1_MSG         531  // dac read
#define PRS_SD2_MSG         532  // dac read
#define PRS_SD3_MSG         533  // dac read
#define PRS_SD4_MSG         534  // dac read
#define PRS_SD5_MSG         535  // dac read
#define PRS_SD6_MSG         536  // dac read
#define PRS_SD7_MSG         537  // dac read
#define PRS_AD0_MSG         600  // analog read
#define PRS_AD1_MSG         601  // analog read
#define PRS_AD2_MSG         602  // analog read
#define PRS_AD3_MSG         603  // analog read
#define PRS_AD4_MSG         604  // analog read
#define PRS_AD5_MSG         605  // analog read
#define PRS_AD6_MSG         606  // analog read
#define PRS_AD7_MSG         607  // analog read
#define PRS_AD8_MSG         608  // analog read
#define PRS_AD9_MSG         609  // analog read
#define PRS_AD10_MSG        610  // analog read
#define PRS_AD11_MSG        611  // analog read
#define PRS_AD12_MSG        612  // analog read
#define PRS_AD13_MSG        613  // analog read
#define PRS_AD14_MSG        614  // analog read
#define PRS_AD15_MSG        615  // analog read
#define PRS_AD16_MSG        616  // analog read
#define PRS_AD17_MSG        617  // analog read
#define PRS_AD18_MSG        618  // analog read
#define PRS_AD19_MSG        619  // analog read

// X72 messages
#define X72_SET_FC_MSG      700  // a - ok
#define X72_SET_DDS_MSG     701  // f - ok
#define X72_SET_DMODE_MSG   702  // g
#define X72_HELP_MSG        703  // h - not used
#define X72_INFO_MSG        704  // i - ok
#define X72_GET_PPS_MSG     705  // j - ok
#define X72_SET_TIC_MSG     706  // k - ok
#define X72_SET_SRVC_MSG    707  // l - ok
#define X72_SET_FREQ_MSG    708  // o - ok
#define X72_GET_CREG_MSG    709  // p - ok
#define X72_SET_CREG_MSG    710  // q - ok
#define X72_RUNR_MSG        711  // r - not used
#define X72_SAVE_TUNE_MSG   712  // t - ok
#define X72_HEALTH_MSG      713  // w - ok
#define X72_RUNX_MSG        714  // x - not used
#define X72_TC_MSG          715  // y1
#define X72_DAMPING_MSG     716  // y2
#define X72_SAVE_DMODE_MSG  717  // z


// SRO100 messages
#define SRO_M_MSG           800
#define SRO_ID_MSG          801
#define SRO_SN_MSG          802
#define SRO_RESET_MSG       803
#define SRO_ST_MSG          804
#define SRO_TR_MSG          805
#define SRO_SY_MSG          806
#define SRO_DE_MSG          807
#define SRO_PW_MSG          808
#define SRO_FC_MSG          809
#define SRO_FS_MSG          810
#define SRO_TW_MSG          811
#define SRO_AW_MSG          812
#define SRO_TC_MSG          813
#define SRO_CO_MSG          814
#define SRO_VS_MSG          815
#define SRO_VT_MSG          816
#define SRO_RA_MSG          817
#define SRO_GF_MSG          818
#define SRO_DT_MSG          819
#define SRO_TD_MSG          820
#define SRO_RAQUIK_MSG      823
#define SRO_BT_MSG          824

#define SRO_L05_MSG         830
#define SRO_L06_MSG         831
#define SRO_R05_MSG         832
#define SRO_R06_MSG         833
#define SRO_R14_MSG         834
#define SRO_R15_MSG         835
#define SRO_R48_MSG         836
#define SRO_R49_MSG         837
#define SRO_R4F_MSG         838


// LPFRS messages
#define LPFRS_M_MSG         900
#define LPFRS_ID_MSG        901
#define LPFRS_RESET_MSG     902
#define LPFRS_C_READ_MSG    903
#define LPFRS_F_READ_MSG    904
#define LPFRS_C_WRITE_MSG   905
#define LPFRS_F_WRITE_MSG   906

// SA35 messages
#define SA35_TELEM_CMD      1000   // ^
#define SA35_SAVE_CMD       1001   // <FS>
#define SA35_EFC_CMD        1002   // <NX0> and <NX1>  EFC enable/disable
#define SA35_DDS_CMD        1003   // <FGxxx> (1E-15 res)



#define X72_STATE_START0     0   // X72 discipling state
#define X72_STATE_START1     1
#define X72_STATE_START2     2
#define X72_STATE_HOLDOVER   3
#define X72_STATE_JAM1       4
#define X72_STATE_JAM2       5
#define X72_STATE_DISCIPLINE 6
#define X72_STATE_PIDCALC    7
#define X72_STATE_PIDUPDATE  8
#define X72_STATE_SLOPECALC  9



int x72_response;        // flag set if processing a multi-line query response
int x72_line;            // line number of the response
int x72_restore_timeout; // countdown timer set when X72 state has been restored (inhibits discipline updates)
int need_x72_resync;     // flag set if we see an unexpected response to a message query
int need_x72_restore;    // flag set if we should restore the device settings from the simulated eeprom file
int x72_msg_id;          // the message id of the message we are currently processing
int x72_user_state;      // user disiplining algorithm state
int last_x72_pps;        // the previous value of the PPS offset
int x72_pps_diff;        // the difference between the last two PPS offset readings
int x72_run_time;        // used to hold off PID routine until sufficent data is availab;e
int x72_tic_changed;     // flag set whenever TIC register is changed

int prs_poll_tick;
#define SLOW_PRS_POLL 1  // 1=request high priority messages every 2 seconds (all messages polled in 25 seconds)


int use_a_time = 0;  // if flag set use Brandywine "a" message for time, else use "t" message

int polled_msg_id;   // the id of the last command we sent to a polled receiver
int lpfrs_msg_id;
int prs_msg_id;
int scpi_msg_id;
int sa35_msg_id;
int sro_msg_id;


int star_tod;            // STAR-4 TOD state
int star_hold_perf;
int star_atdc_on;
int star_atdc_time;
int set_al_mask;


char this_acron_cmd;     // the ACRON_RCVR command we just sent
int need_acron_sync;     // flag set if reception attempt is requested

int bad_prs_val;         // flags bad response to a PRS10 query

struct POLLED_Q {        // queue of pending SCPI/UCCM/STAR/BRANDYWINE messages to send
   char msg[128];
   int  id;
} polled_q[POLLED_Q_SIZE];

int polled_q_in;           // SCPI message send queue pointers
int polled_q_out;
int polled_q_entries;
int polled_req;            // used to cycle through the info request messages we send each second
unsigned polled_seq;

int scpi_status;           // the section of the SCPI status screen we are processing

int no_uccm_ref;
int uccm_loop;

#define TRIMBLE_FMT     0
#define SYMMETRICOM_FMT 1
#define SAMSUNG_FMT     2
int loop_fmt;


int true_wait;             // TRUEPOSN holdover wait type

extern char *months[];
extern char *dst_list[];


void primary_timing(int get_tsip);
void secondary_timing(int get_tsip);
void request_misc_msg(void);
void show_state_info(void);
void show_operation_info(int why);
void show_lla(int why);
void show_cable_delay(void);
void update_plot_data(void);
int get_norcvr_message(void);
u08 tsip_byte(void);

void send_brandy_cmd(char *s);
void poll_next_brandy(void);

void send_esip_cmd(char *s);

void send_moto_start(char *s);
void send_moto_end(void);
void send_nmea_end(int do_cksum);
void request_moto_leap(int rate);

void set_ubx_rate(int id, int rate);
void set_ubx_nav_rate(DATA_SIZE rate, int align);
void set_ubx_antenna(u08 mode);
void set_ubx_config(int mode, double slat,double slon,double salt);
void set_ubx_amu(float amu);
void set_ubx_pps(int chan, u08 pps_rate, u08 pps_enable,  u08 pps_polarity,  double delay, double pps_delay, int save);
void request_ubx_msg(int id);
void request_ubx_tp5(int chan);

void query_venus_msg(int id, int subid);
void send_venus_start(int id, int len);
void send_venus_end(void);
void send_venus_save(int allow_eeprom);

void poll_next_x72(void);
void parse_x72_val(int id);
void x72_reset_filter(void);

void send_zod_start(u16 id, u16 len, u16 flags);
void send_zod_end(void);
void query_zod_msg(int msg);
void send_zod_seq(void);
void set_zod_power(int power);
void set_zod_config(int mode, double slat,double slon,double salt, u32 traim, int why);
void set_zod_nav_mode(int flags);
void set_zod_sat_mask(u32 val);

void send_polled_cmd(char *s, int id);
void queue_polled_cmd(char *s, int id);
int send_queued_cmd(int why);

void poll_next_cs(void);
void poll_next_lpfrs(void);
void poll_next_prs(void);
void poll_next_sa35(void);
void poll_next_scpi(void);
void poll_next_sro(void);
void poll_next_star(int why);
void poll_next_uccm(void);

void decode_cs_msg(void);
void set_cs_remote(int mode);
void restart_prs_polling();
void parse_scpi_user();

void send_sirf_start(u16 sirf_cmd, int len);
void send_sirf_end(void);
void query_sirf_msg(int msg);

void send_ss_start(int id, int len);
void send_ss_end(void);
void send_ss_string(char *s);
void request_ss_msg(int id);

void send_nmea_string(char *s, int comma);
void send_nmea_cmd(char *s);
void send_furuno_cmd(char *s);
void send_z12_cmd(char *s);
void drive_nmea_screen(int system, int why);

void send_taip_cmd(char *cmd);
void send_tm4_cmd(char *s);

#define send_rftg_start(x) send_tsip_start(x)
#define send_rftg_end()    send_tsip_end()
void start_rftg_request(int flag);
void set_rftg_traim(int mode);
void set_rftg_cable(double delay);
void set_rftg_lla(S32 slat, S32 slon, S32 salt);
void rftg_clear_errlog(void);
void request_rftg_reset(int type);

void init_receiver(int why, int reset_ok);

void enable_gpsd(void);

void parse_uccm_loop(void);

void decode_nvs_message(void);

void send_zyfer_cmd(char *s);
void decode_zyfer_message(void);

void decode_true_message(void);
void send_true_cmd(char *s);

void send_acron_cmd(char *s);
void init_acron_time(void);

void send_brandy_char(u08 c);


void utc_to_gps(void);
void gps_to_utc(void);
void adjust_rcvr_time(double seconds);

void show_test_warning(void);
void show_serial_info(void);
void primary_misc(void);
void update_gps_screen(int why);
int get_fixed_field(int width);
void start_fake_seconds(int why);

void decode_ticc_msg(unsigned port);


//
//
//   Low level serial port handlers
//
//

void flush_debug()
{
   // if enabled, flush the debug file every time a new message comes in

   if(debug_file && dbg_flush_mode) {
      fflush(debug_file);
   }
}

void drain_port(unsigned port)
{
   // drain all received data from port buffers
   if(port >= NUM_COM_PORTS) return;
   if(com[port].process_com == 0) return;
   if(com[port].com_running <= 0) return;

   while(SERIAL_DATA_AVAILABLE(port)) {  // drain any input data from the ECHO_PORT
      get_serial_char(port);  // !!!! we should have a timeout on this loop
   }
}

void echo_log(char *s)
{
unsigned i;
int c;

   if(s == 0) return;

   if(zoom_screen == 'H') {
      for(i=0; i<strlen(s); i++) {
         c = s[i];
         echo_term(monitor_port, c, monitor_hex, 0);
      }
   }

   if(log_file == 0) return;
   fprintf(log_file, "%s", s);
}


void echo_stream(unsigned c)
{
static char buf[16];
int i;
char fmt[SLEN];

   // This routine dumps the serial port data stream to a file and/or com 
   // device.  

   if(log_stream) ;
else if(zoom_screen == 'H') ;
   else if((rcvr_type == THERMO_RCVR) && (enviro_type == LFS_ENVIRO)) ;
   else if(ASCII_RCVR && (crlf_seen == 0)) return;  // !!!! dont start logging until a full message has been seen
   else if(0 && (saw_rcvr_msg == 0)) {  //lfs
      return;  // !!!! dont start logging until a full message has been seen 
   }

   if((log_stream & LOG_RAW_STREAM) && raw_file) {  // recording raw receiver data
      fprintf(raw_file, "%c", c);
      if(raw_flush_mode) fflush(raw_file);  // sync raw data stream to disk every byte (for crash analysis)
//else fflush(raw_file);
   }

   if((com[ECHO_PORT].com_running > 0) && (com[RCVR_PORT].com_running > 0)) { // echo receiver data to another com device
      // see if we have a byte that indicates a possible packet boundary
      // that can be used to send the buffered characters
      if(pkt_end2 >= 0) {  // packets end in a two byte sequence
         if(c == (unsigned) pkt_end2) sendout(ECHO_PORT, c, EOM);  // flush buffer on packet end
         else                         sendout(ECHO_PORT, c, ADD_CHAR);
      }
      else if(pkt_end1 >= 0) {  // packets end with a known byte
         if(c == (unsigned) pkt_end1) sendout(ECHO_PORT, c, EOM);  // flush buffer on packet end 
         else                         sendout(ECHO_PORT, c, ADD_CHAR);
      }
      else if(pkt_start1 >= 0) {  // packets start with a known byte
         if(c == (unsigned) pkt_start1) sendout(ECHO_PORT, c, EOM); // flush buffer on packet start... kludge
         else                           sendout(ECHO_PORT, c, ADD_CHAR);
      }
      else {  // packets have no known start/end markers
         sendout(ECHO_PORT, c, EOM);  // ship them out byte-by-byte
      }

      drain_port(ECHO_PORT);
   }                                                    

   if(zoom_screen != 'H') {
      if((log_stream & LOG_HEX_STREAM) == 0) return;
      if(log_file == 0) return;
   }

   // logging hex data to log_file or zoom screen
   if(0 && TSIP_FMT_RCVR) {  // we can pretty-print format the packets
      ++kol;
      if(last_was_dle) {  
         if(c == DLE) {
            if(kol >= 16) {
               echo_log("\n      ");
               kol = (-1);
            }
            sprintf(fmt, "%02X:%02X ", c,c);
            echo_log(fmt);
         }
         else if(c == ETX) {
            sprintf(fmt, "%02X:%02X ", DLE,(unsigned) (c&0xFF));
            echo_log(fmt);
         }
         else {
            sprintf(fmt, "\n%02X:%02X", DLE,(unsigned) (c&0xFF));
            echo_log(fmt);
            if(c == 0x8F) echo_log("-");
            else          echo_log(" ");
            kol = (-1);
         }
         if(log_flush_mode && log_file) fflush(log_file);
         last_was_dle = 0;
      }
      else if(c == DLE) last_was_dle = 1;
      else {
         if(kol >= 16) {
            echo_log("\n      ");
            kol = 0;
         }
         sprintf(fmt, "%02X ", (unsigned) (c&0xFF));
         echo_log(fmt);
         if(log_flush_mode && log_file) fflush(log_file);
      }
   }
   else {  // hex dump the packets
      if((last_was_dle == 2) || (kol >= 16) || packet_end) {
         for(i=kol; i<16; i++) {
            if((i % 4) == 0) echo_log(" ");
            echo_log("   ");
         }

         for(i=0; i<kol; i++) {
            if((i % 4) == 0) echo_log(" ");
            if((buf[i] >= ' ') && (buf[i] <= 0x7E)) {
               sprintf(fmt, "%c", buf[i]);
               echo_log(fmt);
            }
            else echo_log(".");
         }

         if(packet_end) {
            sprintf(fmt, "   {%s}\n", packet_id);
            echo_log(fmt);
            strcpy(packet_id, "");
            packet_end = 0;
         }
         else echo_log("\n");

         if(last_was_dle == 2) {
            echo_log("\n");
            last_was_dle = 0;
         }
         if(log_flush_mode && log_file) fflush(log_file);

         kol = 0;
      }
      if((kol % 4) == 0) echo_log(" ");
//    if((kol % 8) == 0) echo_log(" ");
      sprintf(fmt, "%02X ", (unsigned) (c&0xFF));
      echo_log(fmt);
      if(log_flush_mode && log_file) fflush(log_file);
      buf[kol] = c;
      ++kol;

      if(last_was_dle) {  // used to do pretty printing some packet boundaries
         if(c == (unsigned) pkt_end2) last_was_dle = 2;
         else last_was_dle = 0;
      }
      else if(c == (unsigned) pkt_end1) last_was_dle = 1;
   }
}

void echo_ticc(unsigned c)
{
   if(ticc_file) {
      fprintf(ticc_file, "%c", c);
   }
}


void echo_enviro(unsigned c)
{
   if(enviro_file) {
      fprintf(enviro_file, "%c", c);
   }
}


int get_com_char()
{
u08 c;

   // Get the next byte from the receiver (or simulation file)

   c = get_serial_char(RCVR_PORT);
   if(rcvr_type == ACRON_RCVR) c &= 0x7F;

   if((rcvr_type == TICC_RCVR) && ticc_file) {
      echo_ticc(c);
   }
   else {
      echo_stream(c); // echo receiver char to a file or com device
   }
   return c;
}  

int get_ticc_char() 
{
u08 c;

   // Get the next byte from the TICC port (or simulation file)

   if(rcvr_type == TICC_RCVR) c = get_serial_char(RCVR_PORT);
   else                       c = get_serial_char(TICC_PORT);

   if((rcvr_type == TICC_RCVR) && (ticc_file == 0)) {  // aaattt
      echo_stream(c); // echo ticc char to a file or com device
   }
   else if(ticc_file) {  // echo ticc data to TICC capture file
      echo_ticc(c);
   }
   return c;
}


int get_enviro_char() 
{
u08 c;

   // Get the next byte from the environmental sensor port (or simulation file)

   if(rcvr_type == THERMO_RCVR) {
      c = get_serial_char(RCVR_PORT);
   }
   else {
      c = get_serial_char(THERMO_PORT);
   }

   if((rcvr_type == THERMO_RCVR) && (enviro_file == 0)) {  // aaattt
      echo_stream(c); // echo enviro char to a file or com device
   }
   else if(enviro_file) {  // echo enviro data to capture file
      echo_enviro(c);
   }
   return c;
}


int get_dac_char() 
{
u08 c;

   // Get the next byte from the ADC port (or simulation file)

//   if(rcvr_type == THERMO_RCVR) c = get_serial_char(RCVR_PORT);
//   else                         c = get_serial_char(THERMO_PORT);
   c = get_serial_char(DAC_PORT);

//   if((rcvr_type == DAC_RCVR) && (dac_file == 0)) {  // aaattt
//      echo_stream(c); // echo ADC char to a file or com device
//   }
//   else if(dac_file) {  // echo DAC data to DAC capture file
//      echo_dac(c);
//   }
   return c;
}


void drain_com_data()
{
   // drain any data from the serial input buffer

   if(sim_file) return;
   if(rcvr_type == NO_RCVR) return;

   Sleep(250);
   while(SERIAL_DATA_AVAILABLE(RCVR_PORT)) {
      update_pwm();
      if((this_msec-com[RCVR_PORT].last_com_time) > 1000.0) { 
         break;
      }
      get_serial_char(RCVR_PORT);
   }
}

void get_sync_time()
{
int bits;

   // get the approximate time the receiver sent the start bit of the message
   // (this assumes no delay through the operating system buffers)

   if(com[RCVR_PORT].baud_rate == 0) return;

   bits = 1 + com[RCVR_PORT].data_bits + com[RCVR_PORT].stop_bits;
   if(com[RCVR_PORT].parity) ++bits;
   msg_sync_msec = 0.0 - ((double) bits / (double) com[RCVR_PORT].baud_rate);

   msg_sync_msec += GetMsecs();
}


void check_utc_ofs(int redraw)
{
   if(have_utc_ofs) return;
   else if((pri_year > 2016) && (utc_offset < 18)) return;
   else if(utc_offset < MIN_UTC_OFFSET) return;

   if((redraw > 0) && (have_utc_ofs == 0)) need_redraw = 2000+redraw;
   if(redraw < 0) have_utc_ofs = (0 - redraw);
   else           have_utc_ofs = redraw;
}

//
//
//   Get basic binary items from the serial port data stream
//
//   Although they are labeled tsip_ routines they are used for all
//   receiver type.
//
//


void get_unkn_message()
{
u08 c;

   // This routine reads and throws away messages from unknown receiver types.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
   }

   tsip_wptr = 0;
   tsip_sync = 0;
}



unsigned get_next_tsip()
{
   early_end = 0;
   if(tsip_rptr >= tsip_wptr) {  // attempt to read past end of message
      return EOL_ERROR;
   }

   return tsip_buf[tsip_rptr++];
}

unsigned get_next_tsip_byte()
{
u16 c;

   if(1 && early_end) {  // we are skipping message data
      if(log_comments && (log_stream & LOG_HEX_STREAM) && log_file) {
         fprintf(log_file, "[%04X]", early_end);
         if(log_flush_mode) fflush(log_file);
      }
      return early_end;
   }

   c = get_next_tsip();  // get next data stream element
   if(c & 0xFF00) {      // we saw something that was not expected
      if(log_comments && (log_stream & LOG_HEX_STREAM) && log_file) {
         fprintf(log_file, "<%04X>", c);
         if(log_flush_mode) fflush(log_file);
      }
      early_end = c;
   }
   return c;
}


u08 tsip_byte()   
{
u16 c;

   c = get_next_tsip_byte();
   if(c & 0xFF00) tsip_error |= BYTE_ERROR;
   return (u08) (c & 0xFF);
}

u16 tsip_word()   /* get next two byte (word) field from binary message */
{
u08 i;
u08 word[2];
u16 c;

   for(i=0; i<2; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= WORD_ERROR; 
      if(ENDIAN) word[i] = (u08) c;
      else       word[1-i] = (u08) c;
   }
   return * ((u16 *) (void *) &word[0]);
}

u32 tsip_tbyte()   /* get next 3 byte field from binary message */
{
u08 i;
u08 word[3];
u16 c;

   for(i=0; i<3; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= DWORD_ERROR;
      if(ENDIAN) word[i] = (u08) c;
      else       word[2-i] = (u08) c;
   }
   return * ((u32 *) (void *) &word[0]);
}

u32 tsip_dword()   /* get next dword field from binary message */
{
u08 i;
u08 word[4];
u16 c;

   for(i=0; i<4; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= DWORD_ERROR;
      if(ENDIAN) word[i] = (u08) c;
      else       word[3-i] = (u08) c;
   }
   return * ((u32 *) (void *) &word[0]);
}

u48 tsip_tword()   /* get next tword field (48 bit) from binary message */
{
u08 i;
u08 word[3];
u16 c;

   for(i=0; i<3; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= TWORD_ERROR;
      if(ENDIAN) word[i] = (u08) c;
      else       word[2-i] = (u08) c;
   }
   return * ((u48 *) (void *) &word[0]);
}


float check_float(float val) 
{
   // validate a float as being resonable

   if(val != val) {
      tsip_error |= NAN_ERROR;
      return 0.0F;  // kludgy NAN check
   }
   if(val > 1.0E30F) {
      tsip_error |= RANGE_ERROR;
      return 1.0E30F;        // prevent run-away printf's
   }
   if(val < (-1.0E30F)) {
      tsip_error |= RANGE_ERROR;
      return (-1.0E30F);
   }
   return val;
}

float tsip_single()   /* get next four byte floating number from binary message */
{
u08 i;
u08 word[4];
u16 c;
float val;

   for(i=0; i<4; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= FLOAT_ERROR;
      if(ENDIAN) word[i] = (u08) c;
      else       word[3-i] = (u08) c;
   }

   val = (* ((float *) (void *) &word[0]));
   val = check_float(val);   // checks for NAN's
   return val;
}


double check_double(double val) 
{
   // validate a double as being resonable

   if(val != val) {
      tsip_error |= NAN_ERROR;
      return 0.0;  // kludgy NAN check
   }
   if(val > 1.0E30) {
      tsip_error |= RANGE_ERROR;
      return 1.0E30;        // prevent runaway printf's
   }
   if(val < (-1.0E30)) {
      tsip_error |= RANGE_ERROR;
      return (-1.0E30);
   }
   return val;
}

double tsip_double()   /* get next eight byte floating number from binary message */
{
u08 i;
u08 word[8];
u16 c;
double val;

   for(i=0; i<8; i++) {
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= DOUBLE_ERROR;
      if(ENDIAN) word[i] = (u08) c;
      else       word[7-i] = (u08) c;
   }

   val = (* ((double *) (void *) &word[0]));
   val = check_double(val);   // checks for NAN's, etc
   return val;
}


double tsip_fp80()  
{
u08 i;
u08 x[10];
u08 d[8];
u16 c;
int exponent;
s64 mantissa;
double val;

   // get FP80 10 byte floating number from binary message (in Intel byte order!)
   // and return it as a standard double 

   for(i=0; i<10; i++) {  // get 10 bytes from the receiver (always in intel byte order)
      c = get_next_tsip_byte();
      if(c & 0xFF00) tsip_error |= FP80_ERROR;
      x[i] = (u08) c;
   }

   for(i=0; i<8; i++) d[i] = 0;

   exponent = (((x[9] << 8) | x[8]) & 0x7FFF);
   mantissa =
       ((u64)x[7] << 56) | ((u64)x[6] << 48) | ((u64)x[5] << 40) | ((u64)x[4] << 32) | 
       ((u64)x[3] << 24) | ((u64)x[2] << 16) | ((u64)x[1] << 8) | (u64)x[0];

   d[7] = x[9] & 0x80; // Set sign

   if((exponent == 0x7FFF) || (exponent == 0)) { // Infinite, NaN or denormal 
      if(exponent == 0x7FFF) {  // Infinite or NaN 
         d[7] |= 0x7F;
         d[6] = 0xF0;
      }
      else { // It's denormal. It cannot be represented as double. Translate as zero.
         return 0.0;
      }
   }
   else {  // Normal number
      exponent = exponent - 0x3FFF + 0x03FF; // exponent for double precision.

      if(exponent <= -52) { // too small to represent. Translate as (signed) zero.
         return 0.0;
      }
      else if(exponent < 0) {  // Denormal, exponent bits are already zero here.
      }
      else if(exponent >= 0x7FF) { // Too large to represent. Translate as infinite.
         d[7] |= 0x7F;
         d[6] = 0xF0;
         goto got_it;
      }
      else { // Representable number 
         d[7] |= (exponent & 0x7F0) >> 4;
         d[6] |= (exponent & 0xF) << 4;
      }
   }

   // Translate mantissa

   mantissa >>= 11;

   if(exponent < 0) { // Denormal, further shifting is required here.
      mantissa >>= (-exponent + 1);
   }

   d[0]  = (u08) ((mantissa >> 0) & 0xFF);  // break down the mantissa
   d[1]  = (u08) ((mantissa >> 8) & 0xFF);
   d[2]  = (u08) ((mantissa >> 16) & 0xFF);
   d[3]  = (u08) ((mantissa >> 24) & 0xFF);
   d[4]  = (u08) ((mantissa >> 32) & 0xFF);
   d[5]  = (u08) ((mantissa >> 40) & 0xFF);
   d[6] |= (u08) ((mantissa >> 48) & 0x0F);

   got_it:
   if(!ENDIAN) {  // need to reverse the result byte order
      i = d[0];  d[0] = d[7];  d[7] = i;
      i = d[1];  d[1] = d[6];  d[6] = i;
      i = d[2];  d[2] = d[5];  d[5] = i;
      i = d[3];  d[3] = d[4];  d[4] = i;
   }

   val = (* ((double *) (void *) &d[0]));
   val = check_double(val);   // checks for NAN's, etc
   return val;
}

void tsip_string(char *s, int len)
{
int i;

   // get a 'len" byte string into 's'.  Terminate string with a 0 byte

   if(s == 0) return;

   i = 0;
   s[i] = 0;
   if(len < 0) return;

   while(len--) {
      s[i++] = tsip_byte();
      s[i] = 0;
   }
}


void log_packet_id(char *s)
{
   if((log_stream & LOG_PACKET_ID) || (zoom_screen == 'H')) {
      if(HEX_PACKET_IDS) {
         if(s) strcpy(packet_id, s);
         else  strcpy(packet_id, "{null packet id string}\n");
      }
      else if(s) {
         if(log_file) fprintf(log_file, "   {%s}\n", s);
      }
      else {
         if(log_file) fprintf(log_file, "   {null packet id string}\n");
      }
      if(log_flush_mode && log_file) fflush(log_file);
   }
}


u08 check_tsip_end(u08 report_err)
{
   // handle the end of a TSIP message and check the error flags

   if(tsip_rptr != tsip_wptr) {  // we are not at the end of the message
      tsip_error |= END_ERROR;
   }
   if(tsip_error) {
      sprintf(out, "#     Bad packet. Err=%04X!", tsip_error);
      if(tsip_error & 0x08)   strcat(out, " byte ");
      if(tsip_error & 0x10)   strcat(out, " word ");
      if(tsip_error & 0x20)   strcat(out, " dword ");
      if(tsip_error & 0x40)   strcat(out, " float ");
      if(tsip_error & 0x80)   strcat(out, " double ");
      if(tsip_error & 0x100)  strcat(out, " tword ");
      if(tsip_error & 0x200)  strcat(out, " fp80 ");
      if(tsip_error & 0x400)  strcat(out, " NAN ");
      if(tsip_error & 0x800)  strcat(out, " range err ");
      if(tsip_error & 0x1000) strcat(out, " end err ");
      if(tsip_error & 0x2000) strcat(out, " eol ");
      if(tsip_error & 0x4000) strcat(out, " cksum ");
      if(tsip_error & 0x8000) strcat(out, " ovfl ");
      strcat(out, "\n");
      if(log_flush_mode && log_file) fflush(log_file);
      log_packet_id(out);

      ++bad_packets;
      return 1;
   }
   tsip_rptr = tsip_wptr = 0;
   return 0;
}


//
//
//   Send basic items items out the serial port
//
//

u16 nvs_crc_table[256] = {   // calculate the CRC for a NVS message
   0x0000,0x1021,0x2042,0x3063,0x4084,0x50A5,0x60C6,0x70E7,
   0x8108,0x9129,0xA14A,0xB16B,0xC18C,0xD1AD,0xE1CE,0xF1EF,
   0x1231,0x0210,0x3273,0x2252,0x52B5,0x4294,0x72F7,0x62D6,
   0x9339,0x8318,0xB37B,0xA35A,0xD3BD,0xC39C,0xF3FF,0xE3DE,
   0x2462,0x3443,0x0420,0x1401,0x64E6,0x74C7,0x44A4,0x5485,
   0xA56A,0xB54B,0x8528,0x9509,0xE5EE,0xF5CF,0xC5AC,0xD58D,
   0x3653,0x2672,0x1611,0x0630,0x76D7,0x66F6,0x5695,0x46B4,
   0xB75B,0xA77A,0x9719,0x8738,0xF7DF,0xE7FE,0xD79D,0xC7BC,
   0x48C4,0x58E5,0x6886,0x78A7,0x0840,0x1861,0x2802,0x3823,
   0xC9CC,0xD9ED,0xE98E,0xF9AF,0x8948,0x9969,0xA90A,0xB92B,
   0x5AF5,0x4AD4,0x7AB7,0x6A96,0x1A71,0x0A50,0x3A33,0x2A12,
   0xDBFD,0xCBDC,0xFBBF,0xEB9E,0x9B79,0x8B58,0xBB3B,0xAB1A,
   0x6CA6,0x7C87,0x4CE4,0x5CC5,0x2C22,0x3C03,0x0C60,0x1C41,
   0xEDAE,0xFD8F,0xCDEC,0xDDCD,0xAD2A,0xBD0B,0x8D68,0x9D49,
   0x7E97,0x6EB6,0x5ED5,0x4EF4,0x3E13,0x2E32,0x1E51,0x0E70,
   0xFF9F,0xEFBE,0xDFDD,0xCFFC,0xBF1B,0xAF3A,0x9F59,0x8F78,
   0x9188,0x81A9,0xB1CA,0xA1EB,0xD10C,0xC12D,0xF14E,0xE16F,
   0x1080,0x00A1,0x30C2,0x20E3,0x5004,0x4025,0x7046,0x6067,
   0x83B9,0x9398,0xA3FB,0xB3DA,0xC33D,0xD31C,0xE37F,0xF35E,
   0x02B1,0x1290,0x22F3,0x32D2,0x4235,0x5214,0x6277,0x7256,
   0xB5EA,0xA5CB,0x95A8,0x8589,0xF56E,0xE54F,0xD52C,0xC50D,
   0x34E2,0x24C3,0x14A0,0x0481,0x7466,0x6447,0x5424,0x4405,
   0xA7DB,0xB7FA,0x8799,0x97B8,0xE75F,0xF77E,0xC71D,0xD73C,
   0x26D3,0x36F2,0x0691,0x16B0,0x6657,0x7676,0x4615,0x5634,
   0xD94C,0xC96D,0xF90E,0xE92F,0x99C8,0x89E9,0xB98A,0xA9AB,
   0x5844,0x4865,0x7806,0x6827,0x18C0,0x08E1,0x3882,0x28A3,
   0xCB7D,0xDB5C,0xEB3F,0xFB1E,0x8BF9,0x9BD8,0xABBB,0xBB9A,
   0x4A75,0x5A54,0x6A37,0x7A16,0x0AF1,0x1AD0,0x2AB3,0x3A92,
   0xFD2E,0xED0F,0xDD6C,0xCD4D,0xBDAA,0xAD8B,0x9DE8,0x8DC9,
   0x7C26,0x6C07,0x5C64,0x4C45,0x3CA2,0x2C83,0x1CE0,0x0CC1,
   0xEF1F,0xFF3E,0xCF5D,0xDF7C,0xAF9B,0xBFBA,0x8FD9,0x9FF8,
   0x6E17,0x7E36,0x4E55,0x5E74,0x2E93,0x3EB2,0x0ED1,0x1EF0
};

u16 calc_nvs_crc(u16 crc, u08 c)
{
u16 cval;

   cval = ((crc >> 8) ^ c) & 0xFF;

   crc = (crc << 8) ^ nvs_crc_table[cval]; // new CRC
   return crc & 0xFFFF;
}


u08 superpacket;
int sts;  // sent tsip start

void send_byte(u08 val)
{
   // send a byte to the receiver and update the message checksum
   // NEW_RCVR
   if(log_file && (log_stream & LOG_PACKET_START)) {
      if(superpacket) fprintf(log_file, "Superpacket:    %02X\n", val);
   }
   if(log_file && (log_stream & LOG_SENT_DATA) && sts) fprintf(log_file, "{%02X} ", val);

   superpacket = 0;

   sendout(RCVR_PORT, val, eom_flag);  
   ++tsip_send_count;

   nmea_tx_cksum ^= val;  // we always update these since we may need to send
   moto_tx_cksum ^= val;  // ... messaages in these formats to wake up other receivers
   venus_tx_cksum ^= val;
   sirf_tx_cksum += val;
   ss_tx_cksum += val;
   rt17_tx_cksum += val;

   if(rcvr_type == TSIP_RCVR) {
      if(val == DLE) {  // we are sending a TSIP message
         sendout(RCVR_PORT, DLE, eom_flag);  // DLE character must be sent twice
         ++tsip_send_count;
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      nvs_tx_crc = calc_nvs_crc(nvs_tx_crc, val);
      if(val == DLE) {  // we are sending a TSIP message
         nvs_tx_crc = calc_nvs_crc(nvs_tx_crc, DLE);
         sendout(RCVR_PORT, DLE, eom_flag);  // DLE character must be sent twice
         ++tsip_send_count;
      }
   }
   else if(rcvr_type == UBX_RCVR) { // sending ublox ubx message
      ubx_txa += val;    // add byte to message checksums
      ubx_txb += ubx_txa;
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(zodiac_tx_cnt & 1) zodiac_tx_cksum += ( (((u16) val) * 256) + zodiac_low_byte );
      else zodiac_low_byte = (u16) val;
      ++zodiac_tx_cnt;
   }

   eom_flag = ADD_CHAR;
}


void send_word(u16 val)
{
u08 *s;
int i;

   s = (u08 *) (void *) &val;
   for(i=0; i<2; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[1-i]);
   }
}

void send_dword(u32 val)
{
u08 *s;
int i;

   s = (u08 *) (void *) &val;
   for(i=0; i<4; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[3-i]);
   }
}

void send_tword(u48 val)
{
u08 *s;
int i;

   s = (u08 *) (void *) &val;
   for(i=0; i<3; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[2-i]);
   }
}

void send_single(float val)
{
u08 *s;
int i;

   s = (u08 *) (void *) &val;
   for(i=0; i<4; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[3-i]);
   }
}

void send_double(double val)
{
u08 *s;
int i;

   s = (u08 *) (void *) &val;
   for(i=0; i<8; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[7-i]);
   }
}

void send_fp80(FP80 val)
{
u08 *s;
int i;

// !!!!!!!!!!!! this does not work on machines that don't support native
//              80-bit floating point formats.  We need to do format conversions.
//              before this can be useful.  Note that Heather currently does
//              not ever call this routine... it is just a placeholder for
//              future functionality.

   s = (u08 *) (void *) &val;
   for(i=0; i<10; i++) {
      if(ENDIAN) send_byte(s[i]);
      else       send_byte(s[9-i]);
   }
}

//
//
//   NMEA echo routines - converts receiver data to NMEA format and sends
//   it out the NMEA echo port (if enabled)
//
//

#define ECHO_SECS  0x0001     // times to seconds (default)
#define ECHO_HSECS 0x0002     // times to hundreths of a second (default = seconds)
#define ECHO_MSECS 0x0004     // times to msecs (default = seconds)
#define ECHO_LLA   0x0080     // lat/lon to 4 decimals (default=3 decimals)

#define ECHO_ZDA   0x0100     // which NMEA messages to generate
#define ECHO_VTG   0x0200
#define ECHO_RMC   0x0400
#define ECHO_GGA   0x0800
#define ECHO_GSA   0x1000
#define ECHO_GSV   0x2000

int echo_fmt = (ECHO_HSECS | (ECHO_RMC | ECHO_GGA | ECHO_GSA | ECHO_GSV));  // flags to control NMEA echo data type and resolution


DATA_SIZE average_dop()
{
DATA_SIZE dop, div;

   // returns the average of all dop values
   // (this should probably be a geometric average or maybe an AGM average !!!!!)

   dop = 0.0;
   div = 0.0;

   if((have_dops & TDOP) && tdop) { dop += tdop; ++div; }
   if((have_dops & HDOP) && hdop) { dop += hdop; ++div; }
   if((have_dops & VDOP) && vdop) { dop += vdop; ++div; }
   if((have_dops & PDOP) && pdop) { dop += pdop; ++div; }
   if((have_dops & GDOP) && gdop) { dop += gdop; ++div; }
   if((have_dops & EDOP) && edop) { dop += edop; ++div; }
   if((have_dops & NDOP) && ndop) { dop += ndop; ++div; }
   if((have_dops & XDOP) && xdop) { dop += xdop; ++div; }
   if((have_dops & YDOP) && ydop) { dop += ydop; ++div; }
   if(div) dop /= div;

   avg_dop = dop;
   return dop;
}


int nmea_prn(int prn)
{
   // convert sat PRN to NMEA values

   if(rcvr_type == NMEA_RCVR) return prn;

   if((prn >=120) && (prn <= 151)) return prn-87; // SBAS
   return prn;
}

void echo_nmea_string(char *ss)
{
u08 cksum;
char buf[2048+1];
unsigned i;

   // send a NMEA command out the NMEA_PORT.  Leading '$' and checksum are added.

   if(ss == 0) return;
   strcpy(buf,ss);

   sendout(NMEA_PORT, '$', ADD_CHAR);
   cksum = 0;

   for(i=0; i<strlen(buf); i++) {
      sendout(NMEA_PORT, buf[i], ADD_CHAR);
      cksum ^= buf[i];
   }

   sendout(NMEA_PORT, '*', ADD_CHAR);  
   i = (cksum >> 4) & 0x0F;
   if(i > 9) i += ('A'-10);
   else      i += '0';
   sendout(NMEA_PORT, (u08) i, ADD_CHAR);  
   i = cksum & 0x0F;
   if(i > 9) i += ('A'-10);
   else      i += '0';
   sendout(NMEA_PORT, (u08) i, ADD_CHAR);  

   sendout(NMEA_PORT, 0x0D, ADD_CHAR);
   sendout(NMEA_PORT, 0x0A, EOM);

   drain_port(NMEA_PORT);   // we ignore any data comming in the NMEA echo port

// if(debug_file) fprintf(debug_file, "echo nmea:%s\n", s);
}


double nmea_time()
{
double time;

   // return UTC time as a floating point number

//   gregorian(0, jd_utc);
   time = ((double) g_hours) * 100 * 100.0;
   time += ((double) g_minutes) * 100.0;
   time += ((double) g_seconds);
   time += g_frac;

   return time;
}

int nmea_date()
{
int date;

   // return date as an integer (year modulo 100)

   date = g_day * 100 * 100;
   date += g_month * 100;
   date += (g_year % 100);

   return date;
}


char *nmea_lat()
{
static char s[256];
double val;
int deg;
char c;

   // return latitude as a NMEA format string

   if(lat < 0.0) c = 'S';
   else          c = 'N';

   val = fabs(lat) * 180.0 / PI;
   deg = (int) val;
   val -= (double) deg;        // fractional degrees
   val *= 60.0;                // fractional minutes
   val += (double) (deg*100);  // NMEA location

   s[0] = 0;
   if(echo_fmt & ECHO_LLA) sprintf(s, "%.4f,%c", val,c);
   else                    sprintf(s, "%.3f,%c", val,c);
   return &s[0];
}

char *nmea_lon()
{
static char s[256];
double val;
int deg;
char c;

   // return longitude as a NMEA format string

   s[0] = 0;
   if(lon < 0.0) c = 'W';
   else          c = 'E';

   val = fabs(lon) * 180.0 / PI;
   deg = (int) val;
   val -= (double) deg;        // fractional degrees
   val *= 60.0;                // fractional minutes
   val += (double) (deg*100);  // NMEA location
   

   if(echo_fmt & ECHO_LLA) sprintf(s, "%.4f,%c", val,c);
   else                    sprintf(s, "%.3f,%c", val,c);
   return &s[0];
}

char *nmea_alt()
{
static char s[256];

   // return altitude (in meters) as a NMEA format string

   s[0] = 0;
   sprintf(s, "%.1f,%c", alt,'M');
   return &s[0];
}

char *nmea_speed()
{
static char s[256];

   // return speed as a NMEA format string

   s[0] = 0;
   if(have_speed) {
      sprintf(s, "%.2f", speed / 0.514444);
   }
   return &s[0];
}

char *nmea_heading()
{
static char s[256];

   // return heading as a NMEA format string

   s[0] = 0;
   if(have_heading) {
      sprintf(s, "%.2f", heading);
   }
   return &s[0];
}


void send_zda()
{
   // send time/date as a NMEA GPZDA sentence
   
//   gregorian(0, jd_utc);

   if     (echo_fmt & ECHO_MSECS) sprintf(out, "GPZDA,%010.3f,%02d,%02d,%04d,00,00", nmea_time(), g_day,g_month,g_year);
   else if(echo_fmt & ECHO_HSECS) sprintf(out, "GPZDA,%09.2f,%02d,%02d,%04d,00,00", nmea_time(), g_day,g_month,g_year);
   else                           sprintf(out, "GPZDA,%06d,%02d,%02d,%04d,00,00", (int)nmea_time(), g_day,g_month,g_year);
   echo_nmea_string(out);
}


void send_rmc()
{
char valid;

   // send NMEA GPRMC sentence
   // !!!!!! we should handle GLONASS/GALILEO/BEIDOU

   valid = 'V';
   if     (rcvr_type == NO_RCVR)   valid = 'A';
   else if(rcvr_type == TIDE_RCVR) valid = 'A';
   else if(lat || lon)             valid = 'A';

//   gregorian(0, jd_utc);
   if     (echo_fmt & ECHO_MSECS) sprintf(out, "GPRMC,%010.3f,%c,%s,%s,%s,%s,%06d,,", nmea_time(),valid,nmea_lat(),nmea_lon(),nmea_speed(),nmea_heading(),nmea_date());
   else if(echo_fmt & ECHO_HSECS) sprintf(out, "GPRMC,%09.2f,%c,%s,%s,%s,%s,%06d,,", nmea_time(),valid,nmea_lat(),nmea_lon(),nmea_speed(),nmea_heading(),nmea_date());
   else                           sprintf(out, "GPRMC,%06d,%c,%s,%s,%s,%s,%06d,,", (int) nmea_time(),valid,nmea_lat(),nmea_lon(),nmea_speed(),nmea_heading(),nmea_date());
   echo_nmea_string(out);
}


void send_gga()
{
char valid;
double dop;

   // send NMEA GPGGA sentence
   // !!!!!! we should handle GLONASS/GALILEO/BEIDOU

   valid = '0';
   if     (rcvr_type == NO_RCVR)   valid = '1';
   else if(rcvr_type == TIDE_RCVR) valid = '1';
   else if(lat || lon)             valid = '1';

   if((have_dops & HDOP) && hdop) dop = (double) hdop;
   else dop = (double) average_dop();  // calculate a composite DOP value

// gregorian(0, jd_utc);
   if(echo_fmt & ECHO_MSECS) {
      sprintf(out, "GPGGA,%010.3f,%s,%s,%c,%d,%.1f,%s,%s,,",
         nmea_time(),nmea_lat(),nmea_lon(),valid,sat_count,dop,nmea_alt(),"0.0,M");
   }
   else if(echo_fmt & ECHO_HSECS) {
      sprintf(out, "GPGGA,%09.2f,%s,%s,%c,%d,%.1f,%s,%s,,",
         nmea_time(),nmea_lat(),nmea_lon(),valid,sat_count,dop,nmea_alt(),"0.0,M");
   }
   else {
      sprintf(out, "GPGGA,%06d,%s,%s,%c,%d,%.1f,%s,%s,,",
         (int) nmea_time(),nmea_lat(),nmea_lon(),valid,sat_count,dop,nmea_alt(),"0.0,M");
   }

   echo_nmea_string(out);
}


void send_gsa()
{
int prn;
int i;
char s[256];

   // send NMEA GPGSA sentence
   // !!!!!! we should handle GLONASS/GALILEO/BEIDOU

   fix_mode = 3;
   if(rcvr_mode == RCVR_MODE_2D) fix_mode = 2;
   sprintf(out, "GPGSA,A,%d", fix_mode);

   i = 0;
   for(prn=1; prn<=MAX_PRN; prn++) {
      if(sat[prn].tracking > 0) {  // tracked sat
         sprintf(s, ",%02d",nmea_prn(prn));
         strcat(out, s);
         ++i;
         if(i > 12) break;
      }
   }

   while(1) {  // fill out null fields
      if(i > 12) break;
      strcat(out, ",");   
      ++i;
   }

   if((have_dops & PDOP) && pdop) {
      sprintf(s, "%.1f,", pdop);
   }
   else strcpy(s, ",");
   strcat(out, s);

   if((have_dops & HDOP) && hdop) {
      sprintf(s, "%.1f,", hdop);
   }
   else strcpy(s, ",");
   strcat(out, s);

   if((have_dops & VDOP) && vdop) {
      sprintf(s, "%.1f", vdop);
   }
   else strcpy(s, "");
   strcat(out, s);

   echo_nmea_string(out);
}


void send_gsv()
{
int num_msgs;
int prn;
int i;
int msg_num;
char s[256];
int seen, tracked;

   // send NMEA GPGSV sky view sentences
   // !!!!!! we should handle GLONASS/GALILEO/BEIDOU

   num_msgs = (track_count + 3) / 4;
   i = 0;
   msg_num = 0;

   seen = tracked = 0;
   for(prn=1; prn<=MAX_PRN; prn++) {
      if(sat[prn].tracking) {
         ++seen;
         if((i%4) == 0) {  // start of new sentence
            sprintf(out, "GPGSV,%d,%d,%02d", num_msgs,(i/4)+1,track_count);
         }

         if(sat[prn].tracking > 0) {  // tracked sat
            sprintf(s, ",%02d,%02d,%03d,%02d",nmea_prn(prn),(int)sat[prn].elevation,(int)sat[prn].azimuth,(int)sat[prn].sig_level);
            ++tracked;
         }
         else {  // untracked sat
            sprintf(s, ",%02d,%02d,%03d,",nmea_prn(prn),(int)sat[prn].elevation,(int)sat[prn].azimuth);
         }
         strcat(out, s);
         
         ++i;
         if((i%4) == 0) {  // 4 sats per message
            echo_nmea_string(out);
            out[0] = 0;
            ++msg_num;
            if(msg_num >= num_msgs) break;
         }
      }
   }

   i = i%4;
   if(i) {  // fill out last message with null fields
      i = 4-i;
      while(i--) {
         strcat(out, ",,,,");   
      }
      echo_nmea_string(out);
   }
}

void send_vtg()
{
   // send NMEA GPVTG sentence
}


void echo_nmea()
{
int last_sec = 99;

   // send receiver data formmated as NMEA to the NMEA_PORT

   if(com[NMEA_PORT].process_com == 0) return;  // NMEA_PORT not open
   if(com[NMEA_PORT].com_running <= 0) return;
//ffff if(fake_time_stamp) return;   // don't echo faked time stamps so NTP works better?

   gregorian(0, jd_utc + jtime(0,0,0,TSX_TWEAK));

   if(echo_fmt & ECHO_ZDA) send_zda();
   if(echo_fmt & ECHO_VTG) send_vtg();  // we don't do this one for now
   if(echo_fmt & ECHO_RMC) send_rmc();
   if(echo_fmt & ECHO_GGA) send_gga();


   if(POLLED_RCVR) {
      if(g_seconds == (SCPI_STATUS_SECOND+10)) {
         if(echo_fmt & ECHO_GSA) send_gsa();
         if(echo_fmt & ECHO_GSV) send_gsv();
      }
   }
   else if((g_seconds % 10) == (SCPI_STATUS_SECOND%10)) {
      if(echo_fmt & ECHO_GSA) send_gsa();
      if(echo_fmt & ECHO_GSV) send_gsv();
   }

   last_sec = g_seconds;
}



//
//
//   General support routines
//
//

void primary_misc()
{
   //  This routine is called once a time stamp message has been received.
   //  It handles time conversions, event handling, etc.
   //

   last_misc_second = seconds;

   if(time_flags & TFLAGS_UTC) {  // receiver time is in UTC
      jd_gps = jd_utc + jtime(0,0,utc_offset,0.0);
   }
   else {  // receiver time is in GPS - convert GPS time to UTC time
      jd_utc -= jtime(0,0,utc_offset,0.0);
   }

   jd_tt = jd_gps + utc_delta_t() - jtime(0,0,0,((double) utc_offset)+TSX_TWEAK);  // TT is 51.184 seconds ahead of GPS

   jd_local = jd_utc + time_zone() + jtime(0,0,0,TSX_TWEAK);  // local time (UTC adjusted for time zone)
   gregorian(0, jd_local);
   this_year = g_year;  // the current year in the local time zone

   have_time = 1;
   if(have_year != year) {    // it's the first valid year we have seen or year has changed
      have_year = year;
      init_dsm(this_year);    // tweek month tables for possible leap year
      calc_dst_times(this_year, dst_list[dst_area]);  // find daylight savings change times
      calc_dst_times(this_year, dst_list[dst_area]);  // do it again to get things right if starting up near DST switch time
   }                                       // and recalculate the seasons, etc

   ticker ^= 1;               // used to flash the alarm on the screen
   adjust_tz(10);             // tweak pri_xxxx time variables for time zone and daylight savings time

   if(hours != last_hours) {
      dst_ofs = dst_offset();
      jd_local = jd_utc + time_zone() + jtime(0,0,0,TSX_TWEAK);
      last_hours = hours;
   }

   have_sun_el = 0;
   eclipsed = 0;
   if((lat != 0.0) || (lon != 0.0)) {
      sun_el = sun_posn(jd_utc, 0);   // calculate sun position
      set_sat_azel(SUN_PRN, (float) sun_az, (float) sun_el);
      have_sun_el = 1;
      log_sun_posn();

      moon_posn(jd_tt);               // calculate moon position
      if(need_posns > 0) --need_posns;
      eclipse();
   }

   if(realtime_sun || need_sunrise || ((pri_minutes == 00) && (pri_seconds == SUN_SECOND))) {  // update sunrise time
      if(have_utc_ofs) {
         if(do_moonrise) calc_moonrise();
         else            calc_sunrise(0.0, 20);
         if((lat != 0.0) || (lon != 0.0) || NO_SATS) {
            need_sunrise = 0;
         }
      }
   }

   moon_info(jd_utc);       // calculate moon phase, etc

   #ifdef SAT_TRAILS
      update_sat_trails();  // update sat az/el position array
   #endif


   if(set_time_minutely) {  // we do it a xx:xx:06 local time every minute
      if(pri_seconds == SYNC_SECOND) {
         need_time_set();
      }
   }
   else if(set_time_hourly) {  // we do it a xx:05:06 local time every hour
      if((pri_minutes == SYNC_MINUTE) && (pri_seconds == SYNC_SECOND)) {
         need_time_set();
      }
   }
   else if(set_time_daily) {  // we do it a 4:05:06 local time every day
      if((pri_hours == SYNC_HOUR) && (pri_minutes == SYNC_MINUTE) && (pri_seconds == SYNC_SECOND)) {
         need_time_set();
      }
   }

   set_cpu_clock();           // set system clock to receiver time

   // Apparently some X11 libs have an internal 32 bit counter that
   // causes a "resource temporarily unavailable" exit when it overflows.
   // Here we periodically re-init the screen in an attempt to prevent
   // this from happening.  The counter overflow seems to happen after
   // several days to weeks so we re-init the screen once a day.
   // Also, we rebuild the lla scattergram plot from plot queue data
   // so it remains "fresh".  The screen re-init is only done if the keyboard
   // has been idle for over REINIT_IDLE_TIME seconds.

   if(reinit_jd == 0.0) reinit_jd = (jd_utc + REINIT_INTERVAL);
   if((jd_utc > reinit_jd) && (idle_time >= REINIT_IDLE_TIME) && (pri_seconds == REINIT_SECOND)) {
      reinit_jd = (jd_utc + REINIT_INTERVAL);
      #ifdef USE_X11
         init_screen(9101);
         need_redraw = 9101;
      #endif

      rebuild_lla_plot(0);  // keep LLA plot fresh
   }

   #ifdef GREET_STUFF
      if(new_moon_info || (pri_day != last_day)) {    // calculate new moon info for the month
         if(new_moon_info || (pri_seconds == MOON_STUFF)) {
            calc_moons(jd_local, 10);
            last_day = pri_day;
            new_moon_info = 0;

            if(MAX_AVG_COUNT == 0.0F) {  // keep signal level info fresh
               freshen_sig_info();       // restart signal averaging from the current averages
            }
         }
      }
   #endif

   greet_on = 1;        // it's now OK to calculate greetings
   get_delta_t();       // try to get delta_t from external file deltat.dat
   check_end_times();   // exit program at preset time

   silly_clocks();      // do alarm clock and cuckoo clock
   grav_force(jd_utc);  // calculate gravity and earth tides
   show_satinfo();      // show satellite info
   dump_prn_info();     // write sat PRN az/el/sig level file if open
   draw_maps();         // draw maps and analog watch

   echo_nmea();         // if NMEA echo is enabled sent out NMEA formatted data

   if(time_flags != last_time_flags) {     // redo big clock if time settings have changed
      sync_log_file();  // time reference changed,  note it in the log file
      last_time_flags = time_flags;
   }

   if(set_gps_mode || set_utc_mode) {
      if(luxor) {
         if(set_gps_mode) time_flags |= TFLAGS_UTC;
         else if(set_utc_mode) time_flags &= (~TFLAGS_UTC);
      }

      if(time_flags & TFLAGS_UTC) {  // we are in UTC mode
         if(set_gps_mode) set_timing_mode(TMODE_GPS, 10);
         set_utc_mode = set_gps_mode = 0;
      }
      else { // we are in GPS mode
         if(set_utc_mode) set_timing_mode(TMODE_UTC, 11);
         set_utc_mode = set_gps_mode = 0;
      }
   }

   show_time_info();   // draw primary timing data
   if(configed_mode == RCVR_MODE_DGPS) {   // secondary timing not available in DGPS mode
      refresh_page();
   }

   if(user_fix_set) {  // command line option enabled fix map display
      config_fix_display();
   }
}


void set_gregorian_time(double jd)
{
   // set the receiver time/date variables to jd decoded to gregorian

   gregorian(0, jd);  // convert julian date to gregorian

   pri_year = year = g_year;  // update date/time variables to the gregorian values
   pri_month = month = g_month;
   pri_day = day = g_day;

   pri_hours = hours = g_hours;
   pri_minutes = minutes = g_minutes;
   pri_seconds = seconds = g_seconds;
   pri_frac = raw_frac = g_frac;
}


void adjust_rcvr_time(double delta)
{
double jd;

   // adjust the raw receiver clock reading by "delta" seconds
   //
   // NOTE! This routine uses the pri_xxxx time variables.  At the points where
   //       it is called, these variables contain the receiver time (UTC or GPS)
   //       and NOT the local time!

   jd = jdate(pri_year,pri_month,pri_day);
   jd += jtime(pri_hours,pri_minutes,pri_seconds, delta+pri_frac);

   set_gregorian_time(jd);
}


void utc_to_gps()
{
   // convert receiver UTC time to GPS time by adding the utc_offset
   adjust_rcvr_time(0.0 + (double) utc_offset);
   time_flags &= (~TFLAGS_UTC);
   have_timing_mode = 1;
}

void gps_to_utc()
{
   // convert receiver GPS time to UTC time by subtracting the utc_offset
   adjust_rcvr_time(0.0 - (double) utc_offset);
   time_flags |= TFLAGS_UTC;
   have_timing_mode = 1;
}


void lla_to_ecef(double lat, double lon, double alt)
{   
double clat;
double slat;
double clon;
double slon;
double N;

   // convert lat/lon/alt values (in radians/meters) to ECEF coordinates

   clat = cos(lat);
   slat = sin(lat);
   clon = cos(lon);
   slon = sin(lon);

   N = WGS84_A / sqrt(1.0 - WGS84_E * WGS84_E * slat * slat);

   ecef_x = (N + alt) * clat * clon;
   ecef_y = (N + alt) * clat * slon;
   ecef_z = (N * (1.0 - WGS84_E * WGS84_E) + alt) * slat;
// sprintf(plot_title, "ecef: %f %f %f", ecef_x,ecef_y,ecef_z);
}


void ecef_to_lla(double x, double y, double z)
{
  // convert ECEF coordinate to geocentric lat/lon/alt in radians/meters

  double b = sqrt( (WGS84_A*WGS84_A) * (1.0-(WGS84_E*WGS84_E)) );
  double bsq = (b * b);
  double ep = sqrt( (WGS84_A*WGS84_A - bsq) / bsq);
  double p = sqrt( (x*x) + (y*y) );
  double th = atan2(WGS84_A*z, b*p);

  elon = atan2(y,x);
  elat = atan2( (z + (ep*ep)*b*(sin(th)*sin(th)*sin(th)) ), (p - (WGS84_E*WGS84_E)*WGS84_A*(cos(th)*cos(th)*cos(th))) );

  double N = WGS84_A / ( sqrt(1.0-(WGS84_E*WGS84_E)*(sin(elat)*sin(elat))) );
  ealt = (p / cos(elat)) - N;

  // mod lon to 0-2pi
  elon = fmod(elon,(2.0*PI));
  // correction for altitude near poles left out.  // zork
}

void calc_jd_leap(int why)
{
double days;

   // calculate the Julian date of the next leapsecond and how many days
   // until the event

   days = jd_leap - jd_utc;
   if(days < 0.0) have_jd_leap = have_leap_days = 0;
   else if(days >= ((double) LEAP_THRESH)) have_jd_leap = have_leap_days = 0;
   else have_jd_leap = have_leap_days = why;

   leap_days = (int) days;

//gregorian(0, jd_leap);
//sprintf(plot_title, "jd_leap %d:  have:%d  %04d/%02d/%02d %02d:%02d:%02d   days:%f", 
//why, have_jd_leap, g_year,g_month,g_day, g_hours,g_minutes,g_seconds, days);
}


void calc_leap_days(double wn_lsf, unsigned short dn, int why)
{
double jd;

   jd = GPS_EPOCH + (wn_lsf * 7.0) + (dn) - jtime(0,0,0,1.0); // Julian day of leapsecond
if(wn_lsf < 1024) jd += rollover / (1024.0 * 7.0 * 24.0*60.0*60.0);
   jd_leap = jd;
   calc_jd_leap(1);
   return;
}


void guess_leap_days()
{
double today;
double days;

   // If receiver has no day of leapsecond info, we attempt to guess it
   // assuming the leapsecond occurs on 30 Jun or 31 Dec.

   if((minor_alarms & MINOR_LEAP_PEND) == 0) return;  // no leap pending flag
   if(have_leap_days) return;  // receiver provided the leap day

   today = jdate(year,month,day);
   if(month >= 7) {
      days = jdate(year,12,31);
   }
   else {
      days = jdate(year,6,30);
   }
   jd_leap = days + jtime(23,59,59, 0.0);
   have_jd_leap = 2;
//   calc_jd_leap(2);

   days = days-today;
   if(days < 180.0) leap_days = (int) days;
   else leap_days = (-1);
   guessed_leap_days = '?';
}


void reset_leap_flags()
{
   leaped = 0;
   leap_pending = 0;
   minor_alarms &= (~MINOR_LEAP_PEND);
}


void record_sig_levels(int prn)
{
float sig;

   // check the signal level for sat PRN "prn", update the sats' max signal
   // level,  and update the signal level map info

   if(prn < 0) return;
   if(prn > MAX_PRN) return;
   if(rcvr_type == RFTG_RCVR) ; 
   else if((lat == 0.0) && (lon == 0.0)) return;

#ifdef SIG_LEVELS
   if(sat[prn].level_msg != 0) { 
      sig = sat[prn].sig_level;
      if(sig < 0.0F) sig = 0.0F - sig;

      if(sat[prn].sig_level > max_sat_db[prn]) {
         max_sat_db[prn] = sig;
      }

      if(sig > max_sig_level) {
         max_sig_level = sig;
      }
      if(sig) {
         if(sig < min_sig_level) {
            min_sig_level = sig;
         }
      }

      sig_level_sum += sig;
      ++sig_level_count;

      if(pause_data) ;
      else if(reading_signals == 0) {
         log_signal(sat[prn].azimuth+0.5F, sat[prn].elevation+0.5F, sig, amu_mode);
      }
      have_snr |= rinex_gnss(prn);
   }
#endif
}

void set_sat_azel(int prn, float az, float elev)
{
int count;

   // record the current elevation of sat PRN "prn" and flag how its elevation
   // if changing

   if(prn < 0) return;
   if(prn > MOON_PRN) return;

   // range check az, el
   if(elev > 90.0) return;  //elev = 90.0F;
   else if(elev < (-90.0F)) return; //elev = (-90.0F);

   if(sat[prn].elevation == 0.0) sat[prn].el_dir = ' ';
   else if(elev == 0.0) sat[prn].el_dir = ' ';
   else if(elev > sat[prn].elevation) sat[prn].el_dir = UP_ARROW;
   else if(elev < sat[prn].elevation) sat[prn].el_dir = DOWN_ARROW;

   if(prn < SUN_PRN) {
      if(prn > max_sat_prn) max_sat_prn = prn;
   }

   count = 10;
   while(az < 0.0F) {
      az += 360.0F;
      if(--count < 0) break;
   }
   az = (float) fmod((double) az, 360.0);
   if(az > 360.0F) return; // az = 0.0F;
   else if(az < 0.0F) return; //az = (0.0F);

   if(sat[prn].azimuth == 0.0) sat[prn].az_dir = ' ';
   else if(az == 0.0) sat[prn].az_dir = ' ';
   else if(az > sat[prn].azimuth) sat[prn].az_dir = UP_ARROW;
   else if(az < sat[prn].azimuth) sat[prn].az_dir = DOWN_ARROW;

   sat[prn].azimuth = az;
   sat[prn].elevation = elev;

   if(1 && (NO_SATS == 0) && ((prn == SUN_PRN) || (prn == MOON_PRN))) ;  // only write whan sats change
   else new_sat_azel = 1;  // update PRN file if open
}


float set_el_level(void)
{
float level;

   // set the satellite elevation level mask to the elevation where the
   // signal levels begin to fall off rapidly.

   #ifdef SIG_LEVELS
      level = (float) good_el_level();
   #else
      level = GOOD_EL_LEVEL;
   #endif

   set_el_mask(level);
   return level;
}


void reset_sat_tracking()
{
int prn;

   // reset all sat tracking flags

   for(prn=0; prn<=MAX_PRN; prn++) {
      sat[prn].tracking = 0;
      sat[prn].level_msg = 0;
   }
}

void reset_sat_health()
{
int prn;

   // reset all satellite health flags to unknown

   for(prn=0; prn<=MAX_PRN; prn++) { 
      sat[prn].health_flag = 0;
   }
}

void update_disable_list(u32 val)
{
int i;

   // transfer data from a 32 bit bitmask of enabled sats to the sat disabled flags

   for(i=1; i<=32; i++) {
      if(val & (1 << (i-1))) sat[i].disabled = 0;
      else                   sat[i].disabled = 1;
   }
}


void saw_ebolt()
{
   // This routine is called if message that is only supported
   // on the Thunderbolt-E is received or when the received satellite count 
   // changes.

   temp_sats = max_sat_count;

   if((small_font == 1) && (SCREEN_HEIGHT < SHORT_SCREEN) && (text_mode == 0)) {
      temp_sats = 8;
      eofs = 1;
   }
   else if((TEXT_HEIGHT <= 12) || (SCREEN_HEIGHT >= MEDIUM_HEIGHT)) {
      if(rcvr_type != TSIP_RCVR) ;
      else temp_sats = 12;
      eofs = 1;
   }
   else {
      if(rcvr_type != TSIP_RCVR) ;
      else if(plot_stat_info) temp_sats = 11;
      else if(res_t == RES_T) temp_sats = 12;
      else if(res_t)          temp_sats = 14;
      else                    temp_sats = 12;
      eofs = 0;
   }
if(ACU_GG) ;
else if(ACU_360) ;
else if(ACUTIME);
else if(PALISADE) ;
else if(SV6_FAMILY) temp_sats = 8;

   // there is no room to show all the sats if the big clock is on
   if(0 && plot_digital_clock && (time_col >= (TEXT_COLS/2))) { 
      temp_sats = 8; //// what if sat_info is in plot area?
   }

   ebolt = 1;
   if(ebolt != last_ebolt) {
      max_sats = temp_sats;
if(res_t == RES_T) max_sats = 12;
else if(res_t) max_sats = 14;
if(max_sats > max_sat_display) max_sats = max_sat_display;
config_sat_rows();
      last_ebolt = ebolt;
config_screen(200);
      erase_screen();
      need_redraw = 2000;
   }
}


void config_sat_rows()
{
   // calculate how many rows on the screen the sat info display will use

   if(sat_cols <= 0) return;

   sat_rows = max_sat_display / sat_cols;
   ms_row = ms_col = 0;
   if(sat_cols > 1) {
      if(max_sat_display & 1) ++sat_rows;
   }
}

void config_sat_count(int sat_count)
{
   // configure the display for the number of satellite channels

   if(first_key) return;  // delay screen size update until not in a menu
// sprintf(debug_text3, "csc:%d   msd:%d  msc:%d", sat_count, max_sat_display, max_sat_count);
   if(sat_count > max_sat_display) {
      sat_count = max_sat_display;
      have_count = 30;
   }

   if(sat_count > max_sat_count) {
      max_sat_count = sat_count;
      last_ebolt = (-1);
      saw_ebolt();  // !!!! we should do this better  zzzzz
   }

   config_sat_rows();
}


u08 this_const[MAX_PRN+1];
u08 last_const[MAX_PRN+1];


int star_sat_sec()
{
   // The Star receivers use two messages to get the sat info.  We don't want
   // to update the sat count plot during the period between the two messages
   // or else we get spikes on the sat count plot.
   //
   // Returns true if time is such that the sat count info might be invalid
   if(rcvr_type != STAR_RCVR) return 0;

   if(star_msg && star_line) {  // don't update sat table during faked seconds
      return 1;  // ... otherwise you get spikes on the sat count plot
   }

   // piss3
   if(pri_seconds == (SCPI_STATUS_SECOND+0)) {  // don't update sat table during sat info retreival
      return 1;  // ... otherwise you get spikes on the sat count plot
   }
   if(pri_seconds == (SCPI_STATUS_SECOND+1)) {  // don't update sat table during sat info retreival
      return 1;  // ... otherwise you get spikes on the sat count plot
   }
   return 0;
}

void find_sat_changes()
{
int prn, j;
int sats_changed;

   // see if the satellite constellation has changed
   // Also converts sat_count from number of visible sats to tracked sats.

   for(prn=1; prn<=MAX_PRN; prn++) {  // save old tracking list
      last_const[prn] = this_const[prn];
      this_const[prn] = 0;
   }

   j = 0;
   sat_count = track_count = vis_count = 0;
   sats_changed = 0;
   for(prn=1; prn<=MAX_PRN; prn++) { 
      if(sat[prn].level_msg == 0x00) continue;
//    if(++j > max_sats) break;

      if(sat[prn].tracking > 0) {
         this_const[prn] = 1;
         if(last_const[prn] != this_const[prn]) ++sats_changed;
         ++sat_count;
         ++track_count;
         ++vis_count;
         have_count = 100;
      }
      else if(sat[prn].tracking < 0) {
         ++track_count;
      }
   }
   if(lte_lite && (have_sawtooth == 0)) sat_count = jackson_sat_count;

   if(sats_changed) {
      if(sat_count > SAT_COUNT_MASK) new_const = (SAT_COUNT_MASK | CONST_CHANGE);
      else                           new_const = (sat_count | CONST_CHANGE);
   }
}



void fmt_fp(int v1,int v2,int v3,int v4)
{
unsigned char v[4];

   // debug routine for show showing four integers as a floating point value

   v[3] = v1;
   v[2] = v2;
   v[1] = v3;
   v[0] = v4;
   sprintf(plot_title, "%02X:%02X:%02X:%02X -> %f", v1,v2,v3,v4, *((float *) (void *) &v));
}


void calc_msg_ofs()
{
double rcvr_jd;

   rcvr_jd = jd_utc;
   rcvr_jd *= (24.0*60.0*60.0*1000.0);  // convert Julian to milliseconds

   get_clock_time();   // the system clock time when the message arrived
   clk_jd *= (24.0*60.0*60.0*1000.0);
   if(1 || !fake_time_stamp) {
      msg_ofs = clk_jd - rcvr_jd;  // ffff offset from message time to time the message arrived
   }

   if(measure_jitter) {   // rrrrrr
      sprintf(plot_title, "rcvr-clock %d: %f  rcvr:%f  clk:%f  /tsx=%f", fake_time_stamp,msg_ofs, fmod(rcvr_jd,10000.0), fmod(clk_jd,10000.0), time_sync_offset);
   }
}



//
//
//   Trimble TSIP receiver stuff
//
//


void send_tsip_start(u08 id)
{
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend tsip start %02X\n", id);
   }
// if(log_file && (log_stream & LOG_SENT_DATA)) fprintf(log_file, "send start: %02X\n", id); //wax 
   sts = 1;

   sendout(RCVR_PORT, DLE, ADD_CHAR);
   nvs_tx_crc = 0;
   send_byte(id);
   tsip_send_count = 2;

   if(id == 0x8E) superpacket = id;
}

void send_tsip_end()
{
   if(log_file && (log_stream & LOG_SENT_DATA)) fprintf(log_file, "tsip end\n"); //wax 
   sendout(RCVR_PORT, DLE, ADD_CHAR);
   sendout(RCVR_PORT, ETX, EOM);  // sending last byte of a TSIP message
   tsip_send_count += 2;
   if(sim_file == 0) Sleep(20); 

   sts = 0;
}

void send_nvs_end()
{
u16 crc;

if(1) {  // send CRC
   crc = nvs_tx_crc;
   sendout(RCVR_PORT, DLE, ADD_CHAR);
   sendout(RCVR_PORT, 0xFF, ADD_CHAR);
   sendout(RCVR_PORT, crc & 0xFF, ADD_CHAR);
   sendout(RCVR_PORT, (crc/256) & 0xFF, ADD_CHAR);
}

   sendout(RCVR_PORT, DLE, ADD_CHAR);
   sendout(RCVR_PORT, ETX, EOM);  // sending last byte of a TSIP message to an NVS receiver
   tsip_send_count += 2;
   if(sim_file == 0) Sleep(50);
}


void send_ascii_string(char *s, int add_crlf)
{
   if(s) {
      send_nmea_string(s, 0);
   }

   if(add_crlf) {
      send_byte(0x0D);
      eom_flag = EOM;
      send_byte(0x0A);
      eom_flag = ADD_CHAR;
   }
}

void send_user_cmd(char *s)
{
unsigned i;
int val;
int p;
char *u;
int show_user_cmd;

   // send a user specified (ASCII) command to a receiver
   if(s == 0) return;
   // NEW_RCVR
   ++user_msg_num;

   debug_text2[0] = 0;
   show_user_cmd = 0;
   u = "user";

   strcpy(last_user_cmd, s);
   if(rcvr_type == ACRON_RCVR) {
      send_acron_cmd(s);
      show_user_cmd = 2;
   }
   else if(rcvr_type == BRANDY_RCVR) {
      if(s[0] == '$') queue_brandy_cmd(&s[0], SCPI_USER_MSG);
      else            queue_brandy_cmd(&s[0], SCPI_USER_MSG); 
      show_user_cmd = 1;
   }
   else if(rcvr_type == CS_RCVR) {
      queue_cs_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd(s);
      show_user_cmd = 2;
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd(s);
      show_user_cmd = 2;
   }
   else if(rcvr_type == GPSD_RCVR) { // send ascii string
      send_nmea_string(s, 0);
      eom_flag = EOM;
      send_byte(0x0A);
      eom_flag = ADD_CHAR;
      show_user_cmd = 2;
   }
   else if(rcvr_type == LPFRS_RCVR) {
      queue_sro_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == NMEA_RCVR) {
      if(s[0] == '$') send_nmea_cmd(&s[1]);
      else            send_nmea_cmd(&s[0]);
      show_user_cmd = 2;
   }
   else if(rcvr_type == PRS_RCVR) {
      if(strchr(s, '?'))       queue_prs_cmd(s, SCPI_USER_MSG);
      else if(prs_vb == 0)     queue_prs_cmd(s, -SCPI_USER_MSG);  // commands have no response
      else if(strstr(s, "LM")) queue_prs_cmd(s, -SCPI_USER_MSG);
      else if(strstr(s, "lm")) queue_prs_cmd(s, -SCPI_USER_MSG);
      else if(strstr(s, "LO")) queue_prs_cmd(s, -SCPI_USER_MSG);
      else if(strstr(s, "lo")) queue_prs_cmd(s, -SCPI_USER_MSG);
      else                     queue_prs_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == SA35_RCVR) {
      queue_sa35_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == SCPI_RCVR) {
      queue_scpi_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == SRO_RCVR) {
      queue_sro_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == STAR_RCVR) {
      queue_star_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == THERMO_RCVR) { // send ascii string
      send_nmea_string(s, 0);
      eom_flag = EOM;
      send_byte(0x0D);
      eom_flag = ADD_CHAR;
      show_user_cmd = 2;
   }
   else if(rcvr_type == TM4_RCVR) {
      send_tm4_cmd(s);
      show_user_cmd = 2;
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd(s);   // send a user specified message
      show_user_cmd = 2;
   }
   else if(rcvr_type == TSERVE_RCVR) {
      send_nmea_string(s, 0);
      send_byte(0x0D);
      eom_flag = EOM;
      send_byte(0x0A);
      eom_flag = ADD_CHAR;
      show_user_cmd = 2;
   }
   else if(rcvr_type == UCCM_RCVR) {
      queue_uccm_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 1;
   }
   else if(rcvr_type == X72_RCVR) {
      queue_x72_cmd(s, SCPI_USER_MSG);
      show_user_cmd = 2;
   }
   else if(rcvr_type == Z12_RCVR) {
      if(s[0] == '$') send_z12_cmd(&s[1]);
      else            send_z12_cmd(&s[0]);
      show_user_cmd = 2;
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(s[0] == '$') send_nmea_cmd(&s[1]);
      else            send_nmea_cmd(&s[0]);
      show_user_cmd = 2;
   }
   else if(ASCII_RCVR) { // send ascii string
      send_ascii_string(s, 1);
      show_user_cmd = 2;
   }
   else if(1) {  // send hex string
      strupr(s);
      p = 0;
      val = 0;
      for(i=0; i<strlen(s); i++) {
         if((s[i] >= '0') && (s[i] <= '9')) {
            val = (val*16) + (s[i] - '0');
            p = 1;
         }
         else if((s[i] >= 'A') && (s[i] <= 'F')) {
            val = (val*16) + (s[i] - 'A' + 10);
            p = 1;
         }
         else if(p) {
            eom_flag = EOM;
            send_byte(val & 0xFF);
            eom_flag = ADD_CHAR;
            val = 0;
            p = 0;
         }
      }
      if(p) {
         eom_flag = EOM;
         send_byte(val & 0xFF);
         eom_flag = ADD_CHAR;
         val = 0;
         p = 0;
      }
      show_user_cmd = 3;
      u = "user hex";
   }

   if(show_user_cmd) {
      sprintf(debug_text3, "sent %s cmd %d:%s", u, user_msg_num, s);
      if(debug_file) fprintf(debug_file, "sent %s cmd %d:%s\n", u, user_msg_num, s);
   }
}




void send_ubx_start(u16 ubx_cmd, int len)
{
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend UBX start %04X  len:%d+6\n", ubx_cmd, len);
   }
   if(1 && debug_file) {  //plugh
      fprintf(debug_file, "Sent UBX start %04X  len:%d+6\n", ubx_cmd, len);
   }

   // start sending a ublox message
   sendout(RCVR_PORT, 0xB5, ADD_CHAR);  // send message start code
   sendout(RCVR_PORT, 0x62, ADD_CHAR);
   ubx_txa = ubx_txb = 0; // init transmit checksum bytes

   send_byte((ubx_cmd >> 8) & 0xFF);  // send message class
   send_byte(ubx_cmd & 0xFF);         // send message identifier

   send_byte((len % 256) & 0xFF);     // send message length
   send_byte((len/256) & 0xFF);
}

void send_ubx_end()
{
u08 a,b;

   // end the ublox message
   a = ubx_txa;  // transmitted message checksum
   b = ubx_txb;
   sendout(RCVR_PORT, a, ADD_CHAR);  // send checksum
   sendout(RCVR_PORT, b, EOM);

   if(sim_file == 0) Sleep(50);
}



void send_nmea_start()
{
   sendout(RCVR_PORT, '$', ADD_CHAR);
   nmea_tx_cksum = 0;
}

void send_nmea_string(char *s, int comma)
{
int i, j;

   if(s == 0) return;

   j = strlen(s);
   for(i=0; i<j; i++) send_byte((u08) s[i]);

   if(comma) send_byte((u08) ',');
}

void send_nmea_end(int do_cksum)
{
char cksum[10];

   sprintf(cksum, "%02X", (nmea_tx_cksum & 0xFF));

   if(rcvr_type == ZYFER_RCVR) {
      sendout(RCVR_PORT, '*', ADD_CHAR);
   }
   else if(do_cksum) {
      sendout(RCVR_PORT, '*', ADD_CHAR);
      sendout(RCVR_PORT, cksum[0], ADD_CHAR);
      sendout(RCVR_PORT, cksum[1], ADD_CHAR);
   }
   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);

   if(sim_file == 0) Sleep(50);
}

void send_nmea_cmd(char *s)
{
   if(s == 0) return;

   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend nmea cmd: %s\n", s);
   }

   send_nmea_start();
   if(s[0] == '$')    send_nmea_string(&s[1], 0);
   else               send_nmea_string(&s[0], 0);
   if(strchr(s, '*')) send_nmea_end(0);
   else               send_nmea_end(1);
}


void send_z12_cmd(char *s)
{
   // Ashtech Z12

   if(s == 0) return;

   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend Z12 cmd: %s\n", s);
   }
if(debug_file) fprintf(debug_file, "\nSend Z12 cmd: %s\n", s);

   send_nmea_start();
   if(s[0] == '$')    send_nmea_string(&s[1], 0);
   else               send_nmea_string(&s[0], 0);
   if(strchr(s, '*')) send_nmea_end(0);
   else               send_nmea_end(1);

   if(Z12_SLEEP) Sleep(Z12_SLEEP);
}


void send_tm4_cmd(char *s)
{
   // Spectrum TM4

   if(s == 0) return;

   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend TM4 cmd: %s\n", s);
   }
if(debug_file) fprintf(debug_file, "\nSend TM4 cmd: %s\n", s);

   sendout(RCVR_PORT, '#', ADD_CHAR);
   if(s[0] == '#')    send_nmea_string(&s[1], 0);
   else               send_nmea_string(&s[0], 0);
   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);

   if(TM4_SLEEP) Sleep(TM4_SLEEP);
}

void request_tm4_msg(char *s)
{
return; // !!!! only works in polled mode, we do broadcast mode
   if(s == 0) return;
   sprintf(out, "#13,%s", s);
   send_tm4_cmd(out);
}


void send_fan_cmd(char *s)
{
int i, j;
unsigned port;

   // send a command to the temperature control device

   if(s == 0) return;
   port = fan_port;

   if((com[port].process_com == 0) || (com[port].com_running <= 0)) {  // fan port not open
      if(enviro_mode() && (enviro_type == HEATHER_ENVIRO)) {  // Heather environmental sensor in use
         if(rcvr_type == THERMO_RCVR) port = RCVR_PORT;
         else                         port = THERMO_PORT;
         if((com[port].process_com == 0) || (com[port].com_running <= 0)) return;  // sensor not running
      }
      else return;
   }

   j = strlen(s);
   for(i=0; i<j; i++) sendout(port,(u08) s[i], ADD_CHAR);
   sendout(port, 0x0D, ADD_CHAR);
   sendout(port, 0x0A, EOM);
}


int set_rcvr_baud(int baud, int data_bits, int parity, int stop_bits)
{
int i;

   // future command to set receiver serial port settings
   // !!!!! data_bits, parity, stop_bits not currently implemented
   //       We currentlu always set 8:N:1
   // returns: 0=baud set  1=improper rate   2=baud change not supported

   if(read_only) return 2;

   i = (-1);
   if     (baud == 150) return 1;   // don't allow non-standard values
   else if(baud == 300)    i = 0;   
   else if(baud == 600)    i = 1;   
   else if(baud == 1200)   i = 2;  
   else if(baud == 2400)   i = 3;  
   else if(baud == 4800)   i = 4;  
   else if(baud == 9600)   i = 5;  
   else if(baud == 19200)  i = 6; 
   else if(baud == 38400)  i = 7; 
   else if(baud == 57600)  i = 8; 
   else if(baud == 115200) i = 9; 
   else if(baud == 230400) {
      if(0 && (rcvr_type == VENUS_RCVR)) i = 10;
      else return 1;
   }
   else return 1;

   if(rcvr_type == ESIP_RCVR) {
      sprintf(out, "PERDCFG,UART1,%d", baud);
      send_esip_cmd(out);
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(0 && (rcvr_type == NVS_RCVR)) {
      if(i < 4) return 1;
      send_nvs_start(0x0B);
      send_byte(0);    // current port
      send_dword(baud);
      send_byte(0);    // current protocol
      send_nvs_end();
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(1 && (rcvr_type == SIRF_RCVR)) {
      if(i < 2) return 1;
      send_sirf_start(SET_SIRF_BINARY, 8+1);
      send_dword(baud);
      send_byte(8);
      send_byte(1);
      send_byte(0);
      send_byte(0);
      send_sirf_end();
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(rcvr_type == TM4_RCVR) {  // time port baud rate
      i -= 2;
      if(i < 0) return 1;
      sprintf(out, "#10,%d", i);
      send_tm4_cmd(out);
      return 0;   // does not change control serial port baud rate !!!
   }
   else if(0 && (rcvr_type == TSIP_RCVR)) {
      if((baud >= 9600) && (baud <= 115200)) {
         set_trimble_protocol(baud, 8, NO_PAR, 1, 2,2);
         com[RCVR_PORT].baud_rate = baud;
      }
      else return 1;
   }
   else if(rcvr_type == UBX_RCVR) {
      rcvr_type = NMEA_RCVR;
      sprintf(out, "PUBX,41,1,0003,0001,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox binary output mode (port 1)
      send_nmea_cmd(out);
      rcvr_type = UBX_RCVR;
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(rcvr_type == VENUS_RCVR) {
      i -= 4;
      if(i < 0) return 1;
      send_venus_start(SET_VENUS_BAUD);
      send_byte(0);  // com1
      send_byte(i); 
      send_venus_save(1);
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(rcvr_type == Z12_RCVR) {
      com[RCVR_PORT].baud_rate = baud;
      sprintf(out, "PASHS,SPD,A,%d", i);
      send_z12_cmd(out);
      com[RCVR_PORT].baud_rate = baud;
   }
   else if(0 && (rcvr_type == ZODIAC_RCVR)) {
      if(i == 9) i += 2;
      else       i += 1;
      if(i == 10) return 1;   // we don't allow 76800 baud

      send_zod_start(ZOD_SET_BAUD, 20, 0);
      send_zod_seq();

      send_word(0x0001);  // port 1

      send_word(1);       // 8 bits
      send_word(0);       // 1 stop
      send_word(0);       // no parity
      send_word(i);       // baud
      send_word(0);
      send_word(0);

      send_word(1);       // 8 bits
      send_word(0);       // 1 stop
      send_word(0);       // no parity
      send_word(i);       // baud
      send_word(0);
      send_word(0);

      send_zod_end();

      com[RCVR_PORT].baud_rate = baud;
   }
   else return 2;

   Sleep(COM_INIT_SLEEP);
   init_com(RCVR_PORT, 150);
   return 0;
}


void send_esip_cmd(char *s)
{
int p;

   if(s == 0) return;

   if(debug_file) fprintf(debug_file, "Sent eSIP:%s\n", s);

   send_nmea_start();
   if(s[0] == '$')    send_nmea_string(&s[1], 0);
   else               send_nmea_string(&s[0], 0);
   if(strchr(s, '*')) send_nmea_end(0);
   else               send_nmea_end(1);

   if(ESIP_SLEEP) Sleep(ESIP_SLEEP);

   s = strstr(s, "PERDCFG,UART1");  // baud rate change command was just sent
   if(s) {  // adjust com port setting
      Sleep(1000);
      s += 14;   // skip over the command and get the baud rate
      p = atoi(s);

      if     (p == 4800) ;
      else if(p == 9600) ;
      else if(p == 19200) ;
      else if(p == 38400) ;
      else if(p == 57600) ;
      else if(p == 115200) ;
      else if(p == 230400) ;
      else p = 0;
      if(p) {
         have_doppler = 0;
         have_range = 0;
         com[RCVR_PORT].baud_rate = p;
         init_com(RCVR_PORT, 100);
         Sleep(800);
         need_redraw = 9600;
         init_receiver(9600, 0);   // setup the receiver
      }
   }
}

void send_furuno_cmd(char *s)
{
   if(s == 0) return;


   send_nmea_start();
   if(strstr(s, "PFEC") || (strstr(s, "pfec"))) {
      if(s[0] == '$') {
         if(debug_file) fprintf(debug_file, "Sent1 furuno:$%s\n", &s[1]);
         send_nmea_string(&s[1], 0);
      }
      else {
         if(debug_file) fprintf(debug_file, "Sent2 furuno:$%s\n", &s[0]);
         send_nmea_string(&s[0], 0);
      }
   }
   else {
      if(s[0] == '$') {
         if(debug_file) fprintf(debug_file, "Sent3 furuno:%s\n", &s[0]);
         send_nmea_string(&s[1], 0);
      }
      else {
         if(debug_file) fprintf(debug_file, "Sent furuno:$PFEC,%s\n", &s[0]);
         send_nmea_string("PFEC,", 0);
         send_nmea_string(&s[0], 0);
      }
   }

send_nmea_end(0);  // !!!!! don't send checksums
return;
   if(strchr(s, '*')) send_nmea_end(0);
   else               send_nmea_end(1);
}

void send_enviro_cmd(char *s, unsigned port)
{
unsigned i,j;

   // send a command to the environmental sensor
   if(s == 0) return;
   if(port >= NUM_COM_PORTS) return;

   j = strlen(s);
   for(i=0; i<j; i++) {
      sendout(port, (u08) s[i], ADD_CHAR);
   }
   sendout(port, 0, FLUSH_COM);
if(ENVIRO_SLEEP) Sleep(ENVIRO_SLEEP);
if(0 && debug_file) fprintf(debug_file, "send thermo port %d[%d]:%s\n", port,com[port].com_port, s);
}



//
//
//   Message request and parameter setting messages
//
//

void request_fw_ver()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x1C);   //!!! ThunderBolt-E, Resolution only
      send_byte(0x01);
      send_tsip_end();
   }
}

void request_unk_ver()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x1C);   //!!! ??? receiver only
   send_byte(0x02);
   send_tsip_end();
}

void request_hw_ver()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x1C);   //!!! ThunderBolt-E, Resolution only
      send_byte(0x03);
      send_tsip_end();
   }
}

void request_c2()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0xC2);   //!!! ??? receiver
   send_tsip_end();
}

void request_7A_00()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;
   // config NMEA output

   send_tsip_start(0x7A);   //!!! ??? receiver
   send_byte(0x00);
   send_tsip_end();
}

void request_rcvr_health()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x26);   //!!! ThunderBolt-E only
   send_tsip_end();
}

void request_utc_info()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("j", BRANDY_LEAP_MSG);
   }
   else if(rcvr_type == FURUNO_RCVR) {
//    send_furuno_cmp("GPint,tlp00");  // we get this from GPtps message
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(saw_version == 0) return;
      if(res_t == RES_T) return;   // this message can hose up this receiver for 3 seconds
      if(SV6_FAMILY) {
         send_tsip_start(0x2F);       // get UTC (leapsecond) info from sat data
         send_tsip_end();
      }
      else {
         send_tsip_start(0x38);       // get UTC (leapsecond) info from sat data
         send_byte(0x01);
         send_byte(0x05);
         send_byte(0x00);
         send_tsip_end();
      }
   }
   else if(rcvr_type == MOTO_RCVR) {
      request_moto_leap(0);
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x2B);
      send_nvs_end();
   }
   else if(rcvr_type == SS_RCVR) {  // get leapsecond info
//    request_ss_msg(75);           // ... now set in conig_rcvr
   }
   else if(rcvr_type == UBX_RCVR) {  // get leapsecond info
      request_ubx_msg(UBX_LEAP);
   }
   else if(rcvr_type == ZYFER_RCVR) {  // get leapsecond info
      send_zyfer_cmd("$LEAP");
   }
}

void request_sv6_config(int force)
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      if(SV6_FAMILY && (force == 0)) return;  //ttttt qqqqq  doing this screws up the decice!
      if(ACU_GG) return;
      if(ACU_360) return;

      send_tsip_start(0x2C);       // get SV6 config
      send_byte(0);
      send_single(-1.0);
      send_single(-1.0);
      send_single(-1.0);
      send_single(-1.0);
      send_tsip_end();
      if(sim_file == 0) Sleep(200);
   }
}

void request_osc_offset()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x2D);       // get SV6 osc offset in Hz
      send_tsip_end();
   }
}


void write_all_nvs()
{
   if(read_only) return;
   if(luxor) return;
   if(no_eeprom_writes) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;

      send_tsip_start(0x8E);   //!!! ThunderBolt-E only
      send_byte(0x26);
      send_tsip_end();
   }

   BEEP(500);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
}


void restart_gpsdo()
{
   // re-awaken a GPSDO after a reset
   if(saw_nortel || saw_ntpx || (rcvr_type == MOTO_RCVR) || (rcvr_type == NVS_RCVR)) {
      vidstr(EDIT_ROW+4, EDIT_COL, PROMPT_COLOR, "There is a 20 second reset delay...");
      refresh_page();
      Sleep(20000);
      SetDtrLine(RCVR_PORT, 1);
      if(NO_SCPI_BREAK && (rcvr_type == SCPI_RCVR)) ; 
      else SendBreak(RCVR_PORT);
      Sleep(2000);
   }
}

void restart_zodiac_rcvr()
{
   // re-init ZODIAC receiver message format after a restart
   if(force_mode_change) {     // leave the receiver in Motorola mode
      rcvr_type = MOTO_RCVR;
      config_rcvr_type(0);
      need_msg_init = 2000;
      force_mode_change = 0;
   }
   else {
      send_moto_start("Wb");  // set Jupiter-T receiver protocol to Zodiac mode
      send_byte(1);
      send_moto_end();
      Sleep(1000);

      tsip_sync = 0;
      tsip_wptr = 0;
      tsip_rptr = 0;
      init_messages(70, 1);
   }

   Sleep(250);
}



#define UBX_EE_IO  0x0001
#define UBX_EE_MSG 0x0002
#define UBX_EE_INF 0x0004
#define UBX_EE_NAV 0x0008
#define UBX_EE_TP  0x0010
#define UBX_EE_INV 0x0000   // 0x0200  not supported on LEA-5
#define UBX_EE_ANT 0x0400

#define UBX_EE_ALL (UBX_EE_IO | UBX_EE_MSG | UBX_EE_INF | UBX_EE_NAV | UBX_EE_TP | UBX_EE_INV | UBX_EE_ANT)

void update_ubx_config(u32 clear, u32 save, u32 load)
{
#define EE_MSG_SIZE 12

   send_ubx_start(UBX_EEPROM, EE_MSG_SIZE);
   send_dword(clear);   // reset params from permanent config
   send_dword(save);    // save params to EEPROM
   send_dword(load);    // load config from EEPROM

   if(EE_MSG_SIZE == 13) {  // storage device select
      send_byte(0x17);      // all devices
   }
   send_ubx_end();

   if(save) {
      BEEP(501);
      ++ee_write_count;
      Sleep(1000);
   }
}

void venus_restart(int mode)
{
s16 val;

   send_venus_start(SET_VENUS_RESTART);
   send_byte(mode);
   send_word(pri_year);
   send_byte(pri_month);
   send_byte(pri_day);
   send_byte(pri_hours);
   send_byte(pri_minutes);
   send_byte(pri_seconds);

   val = (s16) (lat * 180.0 / PI * 100.0);
   send_word(val);

   val = (s16) (lon * 180.0 / PI * 100.0);
   send_word(val);

   val = (s16) alt;
   send_word(val);

   send_venus_end();

   Sleep(5000);
   init_messages(50, 1);
}

void enable_moto_binary()
{
   // switch motorola receiver to binary mode

   rcvr_type = NMEA_RCVR;
   send_nmea_cmd("PMOTG,GGA,0000");
   send_nmea_cmd("PMOTG,GLL,0000");
   send_nmea_cmd("PMOTG,GSA,0000");
   send_nmea_cmd("PMOTG,GSV,0000");
   send_nmea_cmd("PMOTG,RMC,0000");
   send_nmea_cmd("PMOTG,VTG,0000");
   send_nmea_cmd("PMOTG,ZDA,0000");

   send_nmea_cmd("PMOTG,FOR,0");
   Sleep(500);

   com[RCVR_PORT].baud_rate = 9600;
   com[RCVR_PORT].data_bits = 8;
   com[RCVR_PORT].parity = NO_PAR;
   com[RCVR_PORT].stop_bits = 1;
   init_com(RCVR_PORT, 103);
   Sleep(100);
   drain_port(RCVR_PORT);

   tsip_sync = 0;
   tsip_wptr = 0;
   tsip_rptr = 0;
   auto_detect(0);
}

void xxx_enable_moto_binary()
{
   // put Motorola receiver into BINARY mode

   rcvr_type = NMEA_RCVR;
   send_nmea_cmd("PMOTG,FOR,0");
   Sleep(500);

   com[RCVR_PORT].baud_rate = 9600;
   com[RCVR_PORT].data_bits = 8;
   com[RCVR_PORT].parity = NO_PAR;
   com[RCVR_PORT].stop_bits = 1;
   init_com(RCVR_PORT, 103);
   Sleep(100);

   rcvr_type = MOTO_RCVR;
   auto_detect(0);
}

void enable_moto_nmea()
{
//send_moto_start("Eq"); // testing ASCII position message
//send_byte(0);
//send_moto_end();
//return;

   // put Motorola receiver into NMEA mode

   send_moto_start("Ci");
   if(furuno_moto == 0) send_byte(1);       // !!!!!! ESIP_RCVR motorola mode  !!!!!!!!!!
   send_moto_end();
   Sleep(500);

   if(furuno_moto) {  // switch to ESIP_RCVR mode
      force_mode_change = 0;
      com[RCVR_PORT].baud_rate = 38400;
      com[RCVR_PORT].data_bits = 8;
      com[RCVR_PORT].parity = NO_PAR;
      com[RCVR_PORT].stop_bits = 1;
      init_com(RCVR_PORT, 101);
      Sleep(100);
      rcvr_type = ESIP_RCVR;
   }
   else {
      com[RCVR_PORT].baud_rate = 4800;
      com[RCVR_PORT].data_bits = 8;
      com[RCVR_PORT].parity = NO_PAR;
      com[RCVR_PORT].stop_bits = 1;
      init_com(RCVR_PORT, 102);
      Sleep(100);

      rcvr_type = NMEA_RCVR;
      send_nmea_cmd("PMOTG,GGA,0001");
      send_nmea_cmd("PMOTG,GLL,0001");
      send_nmea_cmd("PMOTG,GSA,0001");
      send_nmea_cmd("PMOTG,GSV,0001");
      send_nmea_cmd("PMOTG,RMC,0001");
      send_nmea_cmd("PMOTG,VTG,0001");
      send_nmea_cmd("PMOTG,ZDA,0001");
   }

// auto_detect(0);
   config_rcvr_type(0);
   need_msg_init = 2001;
}

void extend_com_timeout(double timeout)
{
   // this routine extends the com timeout for commands that may take
   // a long time to process.  If timeout is 0, uses a default value for the
   // receiver type, 
   // NEW_RCVR

   timeout_extended = 0;
   if(timeout) {  // recalulating overflowed adevs can take a while on slow machines
      timeout_extended = (int) (timeout+0.9999);     // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = timeout;
   }
   else if(rcvr_type == BRANDY_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 10 secs of time messages
      com[RCVR_PORT].com_timeout = 10000.0;
   }
   else if(rcvr_type == LPFRS_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == MOTO_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == PRS_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == RFTG_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 90000.0;  // reset can take 90 seconds
   }
   else if(rcvr_type == SA35_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == SCPI_RCVR) { 
      timeout_extended = 10;   // resume normal timeout after 25 secs of time messages
      com[RCVR_PORT].com_timeout = 25000.0;
   }
   else if(rcvr_type == SRO_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 20 secs of time messages
      com[RCVR_PORT].com_timeout = 20000.0;
   }
   else if(rcvr_type == TICC_RCVR) { 
      timeout_extended = 10;   // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == UCCM_RCVR) {  // not for UCCM? only UCCMP? uuuuuu
      timeout_extended = 10;   // resume normal timeout after 25 secs of time messages
      com[RCVR_PORT].com_timeout = 25000.0;
   }
   else if(rcvr_type == X72_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
   else if(rcvr_type == ZYFER_RCVR) {
      timeout_extended = 5;    // resume normal timeout after 15 secs of time messages
      com[RCVR_PORT].com_timeout = 15000.0;
   }
}

void restore_cs_remote()
{
   // set HP5071A back to the user desired state after we forced REMOTE mode on
   // to set a parameter

   if(user_set_remote == 0) {  // user wants unit left in LOCAL mode
      set_cs_remote(user_set_remote);
   }
}


void init_z12(int mode)
{
int baud;
int i;

   // mode 0 -> no mem reset
   // mode 1 -> reset internal memory
   // mode 2 -> reset external memory
   // mode 3 -> reset all memory

   i = (-1);
   baud = com[RCVR_PORT].baud_rate;
   if     (baud == 150) ;   // don't allow non-standard values
   else if(baud == 300) i = 0;   
   else if(baud == 600) i = 1;   
   else if(baud == 1200) i = 2;  
   else if(baud == 2400) i = 3;  
   else if(baud == 4800) i = 4;  
   else if(baud == 9600) i = 5;  
   else if(baud == 19200) i = 6; 
   else if(baud == 38400) i = 7; 
   else if(baud == 57600) i = 8; 
   else if(baud == 115200) i = 9; 
   else if(baud == 230400) i = (-1);
   sprintf(out, "PASHS,INI,%d,%d,%d,%d,%d,0", i,i,i,i,mode);
//lfs sprintf(debug_text, "baud:%d  i:%d  msg:%s", baud,i,out);
   if(i < 0) return;

   send_z12_cmd(out);
}

void request_cold_reset()
{
   if(read_only) return;
   if(no_poll) return;

   reset_leap_flags();

   extend_com_timeout(0.0);

   if(luxor) {
      send_tsip_start(LUXOR_ID);
      send_byte(0x10);
      send_tsip_end();
      Sleep(100);

      set_luxor_time();
   }
   else if(rcvr_type == ACRON_RCVR) {
      need_acron_sync = 'h';
   }
   else if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("$PRCCG,Z,0", BRANDY_RESET_MSG);
   }
   else if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      queue_cs_cmd("DIAG:CONT:RESET", CS_LAMP_MSG);
      restore_cs_remote();
      queue_cs_cmd("DIAG:CONT:STAT?", CS_LAMP_MSG);
   }
   else if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd("PERDAPI,RESTART,COLD");
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPclr,3");
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x01);
      send_byte(0x00); 
      send_byte(0x01); 
      send_byte(0x21); 
      send_byte(0x01); 
      send_byte(0x00); 
      send_byte(0x00); 
      send_nvs_end();

      Sleep(5000);
      init_messages(5445, 1);
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("RS1", PRS_RS_MSG);
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_reset('C');
   }
   else if(rcvr_type == SCPI_RCVR) {
//    queue_scpi_cmd(":SYST:PON", SCPI_POWER_MSG);   // no NORTEL_TYPE
      queue_scpi_cmd("*TST?", SCPI_TEST_MSG);  // causes a system reset
   }
   else if(rcvr_type == SRO_RCVR) {
      queue_sro_cmd("RESET", SRO_RESET_MSG);
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) queue_star_cmd("RESTART;", STAR_RESTART_MSG);
      else                      queue_star_cmd("RESTART(C);", STAR_RESTART_MSG);
   }
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("SRTCOLD");
   }
   else if(rcvr_type == TICC_RCVR) {
      set_ticc_config(RCVR_PORT, " R");   // reset config to standard defaults
Sleep(2000);
      get_ticc_config(RCVR_PORT);
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x1E);
      send_byte('K');
      send_tsip_end();
      restart_gpsdo();
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$RESET");   // warm reset unit
   }
   else if(rcvr_type == UBX_RCVR) {
      update_ubx_config(0x0000, 0x0000, UBX_EE_ALL);
      Sleep(1000);
      restart_gpsdo();
      init_messages(20, 1);
      rcvr_reset = 1;
   }
   else if(rcvr_type == UCCM_RCVR) {
      queue_uccm_cmd("SYST:PON", SCPI_POWER_MSG);
      queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
   }
   else if(rcvr_type == VENUS_RCVR) {
      venus_restart(3);
   }
   else if(rcvr_type == Z12_RCVR) {
      init_z12(1);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      send_zod_start(ZOD_REQ_RESTART, 8, 0);
      send_zod_seq();
      send_word(0x8003);
      send_zod_end();

      Sleep(5000);
      restart_zodiac_rcvr();
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$RSTG,C");
   }
}

void request_warm_reset()
{
   if(read_only) return;
   if(no_poll) return;

   reset_leap_flags();
   extend_com_timeout(0.0);

   if(luxor) {
      set_luxor_time();
   }
   else if(rcvr_type == ACRON_RCVR) {
      need_acron_sync = 'h';
   }
   else if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("$PRCCG,Z,0", BRANDY_RESET_MSG);
   }
   else if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      queue_cs_cmd("DIAG:CONT:RESET", CS_LAMP_MSG);
      restore_cs_remote();
      queue_cs_cmd("DIAG:CONT:STAT?", CS_LAMP_MSG);
   }
   else if(rcvr_type == ESIP_RCVR) {
      if(force_mode_change) {
         force_mode_change = 0;
         send_esip_cmd("PERDCFG,FORMAT,M12");
         Sleep(5000);

         tsip_sync = 0;
         tsip_wptr = 0;
         tsip_rptr = 0;
         rcvr_type = MOTO_RCVR;
         auto_detect(0);
      }
      else {
         send_esip_cmd("PERDAPI,RESTART,WARM");
      }
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPclr,2");
   }
   else if(rcvr_type == MOTO_RCVR) {
enable_moto_nmea();

      if(force_mode_change) {
         force_mode_change = 0;
         send_moto_start("Wb");  // set Resolution-T TEP receiver protocol to TSIP mode
         send_moto_end();
         Sleep(1000);

         tsip_sync = 0;
         tsip_wptr = 0;
         tsip_rptr = 0;
         rcvr_type = TSIP_RCVR;
auto_detect(0);
//         init_messages(70, 1);
      }
   }
   else if(rcvr_type == NMEA_RCVR) {
      if(force_mode_change) {
         force_mode_change = 0;
         enable_moto_binary();
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x01);
      send_byte(0x00); 
      send_byte(0x01); 
      send_byte(0x21); 
      send_byte(0x01); 
      send_byte(0x00); 
      send_byte(0x01); 
      send_nvs_end();

      Sleep(5000);
      init_messages(5454, 1);
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("RS1", PRS_RS_MSG);
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_reset('W');
   }
   else if(rcvr_type == SIRF_RCVR) {
      if(force_mode_change) {
         force_mode_change =0;
         send_sirf_start(SET_SIRF_NMEA, 23+1);  // set to NMEA protocol
         send_byte(2);    // don't change debug state
         send_byte(1); send_byte(1);  // GGA
         send_byte(0); send_byte(1);  // GLL
         send_byte(1); send_byte(1);  // GSA
         send_byte(5); send_byte(1);  // GSV
         send_byte(1); send_byte(1);  // RMC
         send_byte(0); send_byte(1);  // VTG
         send_byte(0); send_byte(1);  // MSS
         send_byte(0); send_byte(1);  // EPE
         send_byte(0); send_byte(1);  // ZDA
         send_byte(0); send_byte(1);  // rsvd
         send_word(com[RCVR_PORT].baud_rate);  // 9600 bps
         send_sirf_end();
         Sleep(4000);

         tsip_sync = 0;
         tsip_wptr = 0;
         tsip_rptr = 0;
         rcvr_type = NMEA_RCVR;
auto_detect(0);
      }
   }
   else if(rcvr_type == SRO_RCVR) {
      queue_sro_cmd("RESET", SRO_RESET_MSG);
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) queue_star_cmd("RESTART;", STAR_RESTART_MSG);
      else                      queue_star_cmd("RESTART(W);", STAR_RESTART_MSG);
   }
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("SRT");
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$RESET");   // warm reset unit
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x25);
      send_tsip_end();
      restart_gpsdo();
   }
   else if(rcvr_type == UBX_RCVR) {
      update_ubx_config(0x0000, 0x0000, UBX_EE_ALL);  // load config from eeprom
      max_ubx_bytes = 0;

      if(force_mode_change) {
         Sleep(500);
         rcvr_type = NMEA_RCVR;
         sprintf(out, "PUBX,41,1,0003,0002,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox NMEA output mode (port 1)
         send_nmea_cmd(out);
//       sprintf(out, "PUBX,41,2,0003,0002,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox NMEA output mode (port 2)
//       send_nmea_cmd(out);
         Sleep(500);
         force_mode_change = 0;
         auto_detect(0);
      }

      init_messages(21, 1);
      rcvr_reset = 2;
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(force_mode_change) {
         force_mode_change = 0;
         set_venus_mode(1);
         Sleep(1000);

         tsip_sync = 0;
         tsip_wptr = 0;
         tsip_rptr = 0;
         rcvr_type = NMEA_RCVR;
auto_detect(0);
      }
      else {
         venus_restart(2);
      }
   }
   else if(rcvr_type == Z12_RCVR) {
      init_z12(2);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      send_zod_start(ZOD_REQ_RESTART, 8, 0);
      send_zod_seq();
      send_word(0x0001);
      send_zod_end();

      Sleep(5000);
      restart_zodiac_rcvr();
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$RSTG,W");
   }
}

void request_factory_reset()
{
   if(read_only) return;
   if(no_poll) return;

   reset_leap_flags();
   extend_com_timeout(0.0);

   if(luxor) {
      send_tsip_start(LUXOR_ID);   // erase EEPROM config
      send_byte(0x08);
      send_tsip_end();
      Sleep(100);

      request_cold_reset();
   }
   else if(rcvr_type == ACRON_RCVR) {
      need_acron_sync = 'h';
   }
   else if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("$PRCCG,Z,0", BRANDY_RESET_MSG);
   }
   else if(rcvr_type == CS_RCVR) {
//    set_cs_remote(1);
      queue_cs_cmd("*RST", SCPI_NULL_MSG);
//    restore_cs_remote();

      queue_cs_cmd("DIAG:CONT:STAT?", CS_LAMP_MSG);
      queue_cs_cmd("DISP:ENAB?", CS_DISP_MSG);
      queue_cs_cmd("SYST:REM?", CS_REM_MSG);

      user_set_remote = 1;   // *RST forces remote mode
      cs_remote = 1;
   }
   else if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd("PERDAPI,FLASHBACKUP,0x00");  // erase flash settings
      Sleep(2000);
      send_esip_cmd("PERDAPI,RESTART,FACTORY");
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPclr,1");
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Cf");
      send_moto_end();
      rcvr_reset = 3;
//    restart_gpsdo();
//    Sleep(2000);
   }
   else if(rcvr_type == NVS_RCVR) {
      request_cold_reset();
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("RC1", PRS_RC_MSG);
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_reset('H');
   }
   else if(rcvr_type == SCPI_RCVR) {
      if(scpi_type == NORTEL_TYPE) queue_scpi_cmd("SYST:PRESET", SCPI_RESET_MSG);
      else                         queue_scpi_cmd(":SYST:PRES", SCPI_RESET_MSG);
   }
   else if(rcvr_type == SRO_RCVR) {
      queue_sro_cmd("RESET", SRO_RESET_MSG);
   }
   else if(rcvr_type == SS_RCVR) {
      send_ss_start(2, 12);
      send_ss_string("UGPS-000");
      send_ss_end();
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) queue_star_cmd("SET_DEFAULT", STAR_RESTART_MSG);
      else                      queue_star_cmd("RESTART(C);", STAR_RESTART_MSG);
   }
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("SRTFACTORY");
   }
   else if(rcvr_type == TICC_RCVR) {
      set_ticc_config(RCVR_PORT, " X");   // reset config to factory defaults
Sleep(4000);
      get_ticc_config(RCVR_PORT);
   }
   else if(rcvr_type == TM4_RCVR) {
      send_tm4_cmd("#08,1");
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$FACT");    // factory reset unit
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x1E);
      if(ACU_GG) send_byte('F');
      else if(ACU_360) send_byte('F');
      else if(ACUTIME) send_byte('F');
      else if(PALISADE) send_byte('F');
      else if(SV6_FAMILY) send_byte('K');
      else send_byte('F');
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      update_ubx_config(UBX_EE_ALL, 0x0000, UBX_EE_ALL);  // reset eeprom then re-load config from eeprom
      rcvr_reset = 4;
      Sleep(1000);
      init_messages(22, 1);
   }
   else if(rcvr_type == UCCM_RCVR) {
      queue_uccm_cmd("SYST:PRES", SCPI_RESET_MSG);
      queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
   }
   else if(rcvr_type == VENUS_RCVR) {
      send_venus_start(VENUS_FACTORY_RESET);
      send_byte(1);
      send_venus_end();
      Sleep(5000);
      init_messages(22, 1);
   }
   else if(rcvr_type == Z12_RCVR) {
      send_z12_cmd("PASHS,RST");
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      send_zod_start(ZOD_REQ_RESTART, 8, 0);
      send_zod_seq();
      send_word(0x8007);
      send_zod_end();

      Sleep(10000);
      restart_zodiac_rcvr();
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$FACTORYRESET");
   }
}


void request_manuf_params()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else if(PALISADE) ;
   else if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0x41);
   send_tsip_end();
}

void request_prodn_params()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else if(PALISADE) ;
   else if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0x42);
   send_tsip_end();
}




void start_rftg_request(int dont_do)
{
if(dont_do) return;

   send_rftg_start(0x34);
   send_byte(0x00);
   send_byte(0x40);
   send_byte(0x01);
   send_byte(0xFF);
   send_byte(0x02);
   send_rftg_end();

   send_rftg_start(0x34);
   send_byte(0x00);
   send_byte(0x40);
   send_byte(0x01);
   send_byte(0xFF);
   send_byte(0x01);
   send_rftg_end();
}

void start_rftg_request2(int dont_do)
{
if(dont_do) return;

   send_rftg_start(0x34);
   send_byte(0x00);
   send_byte(0x40);
   send_byte(0x01);
   send_byte(0xFF);
   send_byte(0x02);
   send_rftg_end();

   send_rftg_start(0x34);
   send_byte(0x00);
   send_byte(0x40);
   send_byte(0x01);
   send_byte(0xFF);
   send_byte(0x02);
   send_rftg_end();
}

void request_rftg_reset(int mode)
{
   start_rftg_request(0);

   send_rftg_start(0x30);
   send_byte(0x06);
   send_dword(0);
   send_rftg_end();

   set_rftg_normal();
}

void request_rftg_cable()
{
   start_rftg_request(1);    // request cable delay (in feet)

   send_rftg_start(0x35);
   send_byte(2);   // 2=req  1=set
   send_dword(0);
   send_rftg_end();
   set_rftg_normal();

}

void request_rftg_voltages()
{
// start_rftg_request(1);
   if(no_poll) return;

start_rftg_request2(0);

   send_rftg_start(0x43);
   send_rftg_end();

//send_rftg_start(0x48);  // ?? does not do anything
//send_rftg_end();

   set_rftg_normal();
}

void request_rftg_errlog()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x37);
   send_byte(2);  // 2=req 1=clear
   send_rftg_end();
/////   set_rftg_normal();
}

void request_rftg_corr_data()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x44);  // correction data
   send_rftg_end();
/////   set_rftg_normal();
}

void request_rftg_sats()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x46);   // 0x46->sat posn (sends msgs 0x25, 0x26)
   send_rftg_end();
/////   set_rftg_normal();
}

void request_rftg_additional_status()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x47);
   send_rftg_end();
/////   set_rftg_normal();
}

void request_rftg_corr_history()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x49);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_warmup_time()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x62);
   send_byte(0x02);  // 2=req 1=set
   send_word(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_delta_ape()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x65);
   send_byte(0x02);  // 2=req 1=set
   send_dword(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_const_ape()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x66);
   send_byte(0x02);  // 2=req 1=set
   send_dword(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_ape2()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x68);
   send_byte(0x02);  // 2=req 1=set
   send_dword(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_ape()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x69);
   send_byte(0x02);  // 2=req 1=set
   send_dword(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_delta_temp()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x70);   // 43=get voltages?
   send_byte(0x02);  // 2=req 1=set
   send_dword(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_corr_sched()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x74);
   send_byte(0x02);  // 2=req 1=set
   send_word(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_hw_ver()
{
   if(no_poll) return;

   start_rftg_request(1);  // was (1)
   send_rftg_start(0x71);
   send_byte(0x02);  // 2=req 1=set
   send_byte(0);
   send_rftg_end();

///   set_rftg_normal();
}

void request_rftg_avg_sample()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x72);
   send_byte(0x02);  // 2=req 1=set
   send_byte(0);
   send_rftg_end();
///   set_rftg_normal();
}

void request_rftg_traim()
{
   if(no_poll) return;

   start_rftg_request(1);
   send_rftg_start(0x83);
   send_rftg_end();
/////   set_rftg_normal();
}



void request_version()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("n", BRANDY_VERSION_MSG);
   }
   else if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd("PERDSYS,VERSION");
      send_esip_cmd("PERDSYS,GPIO");
   }
   else if(rcvr_type == GPSD_RCVR) {
      send_user_cmd("?DEVICES;");
      send_user_cmd("?VERSION;");
   }
   else if(rcvr_type == LPFRS_RCVR) {
      queue_lpfrs_cmd("V", LPFRS_ID_MSG);
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(!saw_version) {  // this message is rather long, only get the info once
         send_moto_start("Cj");  // request receiver ID string
         send_moto_end();
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x1B);
      send_nvs_end();
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("ID?", PRS_ID_MSG);
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_hw_ver();
   }
   else if(rcvr_type == SA35_RCVR) {
//      queue_sa35_cmd("V", LPFRS_ID_MSG);
   }
   else if(rcvr_type == SIRF_RCVR) {
      query_sirf_msg(GET_SIRF_SW_VER);
   }
   else if(rcvr_type == SS_RCVR) {
      request_ss_msg(45);  // hardware/software version
   }
   else if(rcvr_type == SRO_RCVR) {
      queue_prs_cmd("ID", SRO_ID_MSG);
   }
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("QVR");  // query version
      send_taip_cmd("QID");  // query unit id
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$GETVER");   // get receiver version
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x1F);
      if(0) {  // requests (undocumented) extended receiver configuration info
         send_byte(0x01);
         send_byte(0x00);
      }
      send_tsip_end();

      request_manuf_params();
      request_prodn_params();
      request_fw_ver();      // !!! testing ThunderBolt-E, Resolution messages
      request_hw_ver();
   }
   else if(rcvr_type == UBX_RCVR) {  // this is a rather wordy message
       if(saw_version == 0) request_ubx_msg(UBX_VER);  // don't request if we already have it
   }
   else if(rcvr_type == VENUS_RCVR) {
      query_venus_msg(QUERY_VENUS_VERSION);
   }
   else if(rcvr_type == Z12_RCVR) {
      if(have_info == 0) send_z12_cmd("PASHQ,RID");
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      query_zod_msg(ZOD_ID_MSG);
      query_zod_msg(ZOD_DIAG_MSG);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$VERS");
      send_zyfer_cmd("$UNID");
      send_zyfer_cmd("$MANI");
      send_zyfer_cmd("$PRID");
   }
}

void request_self_tests(int test)
{
   if(luxor) return;
   if(no_poll) return;
   if(read_only) return;

   if(rcvr_type == CS_RCVR) { 
      extend_com_timeout(0.0);
      set_cs_remote(1);
      queue_cs_cmd(":PTIM:STAN 1", CS_STANDBY_MSG);
      sprintf(out, "DIAG:TEST? %d", test);
      queue_cs_cmd(out, SCPI_TEST_MSG);
      restore_cs_remote();
      show_test_warning();
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPtrq,0");
   }
   else if(rcvr_type == MOTO_RCVR) {
      extend_com_timeout(0.0);
      send_moto_start("Ia");
      send_moto_end();

      send_moto_start("Fa");
      send_moto_end();

      send_moto_start("Ca");
      send_moto_end();
      show_test_warning();
   }
   else if(rcvr_type == NVS_RCVR) {
      extend_com_timeout(0.0);
      send_nvs_start(0x11);
      send_byte(0x00);
      send_nvs_end();
   }
   else if(rcvr_type == SCPI_RCVR) { 
      extend_com_timeout(0.0);
      queue_scpi_cmd("*TST?", SCPI_TEST_MSG);  // NORTEL_TYPE?
      show_test_warning();
   }
   else if(rcvr_type == SS_RCVR) {
      send_ss_start(51, 5);
      send_byte(1);
      send_ss_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x25);
      send_tsip_end();
      restart_gpsdo();
   }
   else if(rcvr_type == UCCM_RCVR) {  // not for UCCM? only UCCMP? uuuuuu
      extend_com_timeout(0.0);
      queue_uccm_cmd("*TST?", SCPI_TEST_MSG);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      extend_com_timeout(0.0);
      send_zod_start(ZOD_REQ_DIAGS, 8, 0);
      send_zod_seq();
      send_word(0);
      send_zod_end();
      show_test_warning();

      Sleep(10000);
      restart_zodiac_rcvr();
   }
}

void request_almanac(int prn)
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == NVS_RCVR) { 
      if(prn < NVS_GLONASS_PRN) {  // GPS
         send_nvs_start(0x20);
         send_byte(0x01);
         send_byte((u08) prn);
         send_nvs_end();
      }
      else { // GLONASS
         send_nvs_start(0x20);
         send_byte(0x02);
         send_byte(prn-NVS_GLONASS_PRN);
         send_nvs_end();
      }
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x20);
      send_byte((u08) prn);
      send_tsip_end();
   }
}

void request_atten()
{
   if(no_poll) return;

   if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$GETA");   // get attenuator value
   }
}


void set_atten(double val)
{
   if(read_only) return;

   if(rcvr_type == TRUE_RCVR) {
      sprintf(out, "$SETA %d", (int) val);
      send_true_cmd(out);       // $SETA %d - set attenuator value
   }
   request_atten();
}


void set_antenna(int i)
{
   if(read_only) return;

   if(rcvr_type == TM4_RCVR) {
      sprintf(out, "#23,%d", i);
      send_tm4_cmd(out);
   }
}




void request_sat_list()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == ESIP_RCVR) {
//    send_esip_cmd("PERDCFG,NMEAOUT,GSA,0");
//    send_esip_cmd("PERDCFG,NMEAOUT,GSV,0");
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPint,GSA00,GSV00,acc00,anc00,wav00");
      send_furuno_cmd("GPwaq");
      send_furuno_cmd("GPmgq");
      send_furuno_cmd("GPpsq");
      send_furuno_cmd("GPprq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(1 || (user_set_raw_rate == 0)) { 
         send_moto_start("Bb");  // sat visibility data
         send_byte(0);
         send_moto_end();
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x24);
      send_nvs_end();
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_sats();
set_rftg_normal();
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$GETPOS");  // get position
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x24);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      request_ubx_msg(UBX_DOP);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      query_zod_msg(ZOD_SNR_MSG);
      query_zod_msg(ZOD_VIS_MSG);
//query_zod_msg(ZOD_TRAIM_CONFIG_MSG);  //zork
   }
}

void request_gps_time()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {  // SV6_TYPE uses this
      send_tsip_start(0x21);
      send_tsip_end();
   }
}

void request_sig_levels()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x27);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(raw_msg_rate == 0) {   // poll for doppler, etc
         request_ubx_msg(UBX_SVN); // sat info
         request_ubx_msg(UBX_RAW);  
         request_ubx_msg(UBX_RAWX);
      }
   }
}

void request_alm_health()
{
   if(no_poll) return;
   if(res_t) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x29);
      send_tsip_end();
   }
}

void set_xyz(float x, float y, float z)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x31);
      send_single(x);
      send_single(y);
      send_single(z);
      send_tsip_end();
   }
}

void set_ref_input(int ref)
{
   // ref=0: GPS
   // ref=1: AUX PPS input

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == STAR_RCVR) {
      if     (ref == 0) queue_star_cmd("INPUT_TYPE(1)=GPS;", STAR_INP_TYPE_MSG);       // gps input
      else if(ref == 1) queue_star_cmd("INPUT_TYPE(1)=AUX;", STAR_INP_TYPE_MSG);  // pps input
      queue_star_cmd("INPUT_TYPE(1);", STAR_INP_TYPE_MSG);  // !!! this command is not valid for ATDC model
   }
   else request_rcvr_config(7788);
}


void set_venus_survey(int mode, double slat,double slon,double salt)
{
   if(read_only) return;

   if(saw_venus_raw) send_venus_start(SET_VENUS_RTK_SURVEY);
   else              send_venus_start(SET_VENUS_SURVEY);
   send_byte(mode);       // 0=timing pvt mode  1=do survey  2=posn hold mode
   send_dword(do_survey);
   send_dword(100);             // standard deviation
   send_double(slat*180.0/PI);  // lla only used for position hold mode
   send_double(slon*180.0/PI);
   send_single((float)salt);
   send_venus_save(1);
}

void set_filter_factor(DATA_SIZE val)
{
   if(read_only) return;

   if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x0D);
      send_byte(0x04);
      send_single((float) val);
      send_nvs_end();
   }
}

void set_rtcm_mode(int enable)
{
   if(rcvr_type == VENUS_RCVR) {  // raw Hz !!!!
      send_venus_start(SET_VENUS_RTCM);
      send_byte(enable);
      send_byte(0);   // 1Hz rnx2  0..6 -> 1/2/4/5/10/20/8 Hz

      send_byte(1);   // base station ARP
      if(gnss_mask & GPS)     send_byte(1);
      else                    send_byte(0);

      if(gnss_mask & GLONASS) send_byte(1);
      else                    send_byte(0);

      if(1)                   send_byte(0);  // reserved

      if(gnss_mask & SBAS)    send_byte(1);
      else                    send_byte(0);

      if(gnss_mask & QZSS)    send_byte(1);
      else                    send_byte(0);

      if(gnss_mask & BEIDOU)  send_byte(1);
      else                    send_byte(0);

      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_venus_save(1);
   }
}


void set_raw_rate()
{
int i;
int raw_rate;

   if(read_only) return;

   if(rcvr_type == ESIP_RCVR) {  // only outputs raw_msg_rate data at 1 Hz and if baud >= 115200
      if(raw_msg_rate) sprintf(out, "PERDAPI,CROUT,MN,%d", 1); 
      else             sprintf(out, "PERDAPI,CROUT,MN,%d", 0);
      send_esip_cmd(out);    // enable sat measurement and navigation data
      have_raw_rate = 1;
   }
   else if(rcvr_type == MOTO_RCVR) {  // raw Hz !!!! untested - no rcvr available that does this message
      if(moto_chans == 6) {
         send_moto_start("Bg");
         send_byte(raw_msg_rate);
         send_moto_end();
      }
      else if(moto_chans == 8) {
         send_moto_start("Eg");
         send_byte(raw_msg_rate);
         send_moto_end();
      }
      else {
         send_moto_start("Hr");  // differential (pseudorange) data at raw message rate
         if(user_set_raw_rate) send_byte(raw_msg_rate);
         else                  send_byte(10);
         send_byte('+');
         send_byte('+');
         send_byte('+');
         send_byte('+');
         send_byte('+');
         send_byte('+');
         send_moto_end();
      }

      if(0 && user_set_raw_rate) {  // !!!! only updates when data changes
         send_moto_start("Bb"); 
         send_byte(user_set_raw_rate);
         send_moto_end();
      }
      have_raw_rate = 1;
   }
   else if(rcvr_type == NVS_RCVR) {  // raw Hz !!!!
      send_nvs_start(0x24); // 0x54 sky view message rate raw rate or every 5 seconds
      if(raw_msg_rate) send_byte(raw_msg_rate);
      else             send_byte(5);
      send_nvs_end();

      send_nvs_start(0xF4); // 0xF4 raw data every second  //rawz
      send_byte(raw_msg_rate*10);  // 100 msec granularity
      send_nvs_end();
      have_raw_rate = 1;
   }
   else if(rcvr_type == RT17_RCVR) {  // toots rt17 fix needed
      have_raw_rate = 1;
   }
   else if(rcvr_type == SS_RCVR) {
      if(raw_msg_rate == 1) {
         send_ss_start(23 | 0x80, 5);
         send_byte(0);
      }
      else if(raw_msg_rate == 2) {
         send_ss_start(23 | 0x80, 5);
         send_byte(1);
      }
      else if(raw_msg_rate == 5) {
         send_ss_start(23 | 0x80, 5);
         send_byte(2);
      }
      else {
         send_ss_start(23, 5);
         send_byte(0);
         raw_msg_rate = 0;
      }
      send_ss_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(raw_msg_rate) {  // automatically send RAW and SFRB messages for RTKLIB use
         raw_rate = raw_msg_rate;
         raw_msg_rate = 1;  // raw Hz - we actually output raw data at the navigation rate
         set_ubx_rate(UBX_RAW,   raw_msg_rate);    // RAW info
         set_ubx_rate(UBX_RAWX,  raw_msg_rate);    // RAW info
         set_ubx_rate(UBX_SOL,   raw_msg_rate);    // SOL info
//       set_ubx_rate(UBX_ORB,   raw_msg_rate);    // ORB info
//       set_ubx_rate(UBX_SBAS,  raw_msg_rate);    // SBAS info
         set_ubx_rate(UBX_ORB,   0);               // ORB info
         set_ubx_rate(UBX_SBAS,  0);               // SBAS info
         set_ubx_rate(UBX_SFRB,  raw_msg_rate);    // SFRB info
         set_ubx_rate(UBX_SFRBX, raw_msg_rate);    // SFRBX info (ublox8)
         if(special_raw) {  // enable undocumented raw messages for early M8N's
            set_ubx_rate(TRK_SFRBX, raw_msg_rate);    // TRK_SFRBX info (ublox8 - undocumented, causes errors)
            set_ubx_rate(TRK_MEAS,  raw_msg_rate);    // TRK_MEAS info (ublox8 - undocumanted, causes errors)
         }
         set_ubx_rate(UBX_SVN, raw_msg_rate);     // sat info
         raw_msg_rate = raw_rate;
      }
      else {  // disable raw data messages to reduce serial port traffic
         set_ubx_rate(UBX_RAW,   0);    // RAW info
         set_ubx_rate(UBX_RAWX,  0);    // RAW info
         set_ubx_rate(UBX_SOL,   0);    // SOL info
//       set_ubx_rate(UBX_ORB,   0);    // ORB info
//       set_ubx_rate(UBX_SBAS,  0);    // SBAS info
         set_ubx_rate(UBX_SFRB,  0);    // SFRB info
         set_ubx_rate(UBX_SFRBX, 0);    // SFRBX info (ublox8)
         set_ubx_rate(TRK_SFRBX, 0);    // TRK_SFRBX info (ublox8 undocumented)
         set_ubx_rate(TRK_MEAS,  0);    // TRK_MEAS info (ublox8 undocumented)
         set_ubx_rate(UBX_SVN,   0);    // sat info - we now poll for this
      }
      have_raw_rate = 1;
   }
   else if(rcvr_type == VENUS_RCVR) {  // raw Hz !!!! 0..6 -> 1/2/4/5/10/20/8 Hz
      if(raw_msg_rate) i = 1;
      else             i = 0;
      send_venus_start(SET_VENUS_RAW);
      send_byte(0);  // always 1Hz rate, we drop unwanted messages if raw rate > 1 sec
      send_byte(i);  // enable meas time
      send_byte(i);  // enable raw data
      send_byte(i);  // SV/channel data   
      send_byte(0);  // RCV_State
      send_byte(0);  // subframe enable
      send_byte(i);  // extended raw data
      send_venus_save(1);
      have_raw_rate = 1;
   }
   else if(rcvr_type == Z12_RCVR) {  // raw Hz !!!!
      if(raw_msg_rate) {
         if(user_set_raw_rate) {
            sprintf(out, "PASHS,RCI,%.1f", (double) raw_msg_rate);
            send_z12_cmd(out);
         }
         // MBN -> MPC
         // PBN -> PBN
         // SAL -> ALM
         // SNV -> SNV 
         // DBN -> DBN (locks up);
         // EPB -> EPB (locks up);
//       send_z12_cmd("PASHS,OUT,A,PBN,MBN");  // enable RAW meessages -> MPC ascii
         send_z12_cmd("PASHS,OUT,A,PBN,MBN,SNV,SAL,BIN");  // enable RAW meessages -> MPC ascii
      }
      else {
send_z12_cmd("PASHS,REC,N");  // disable recording (raw messages)
//       send_z12_cmd("PASHS,OUT,A,NME");    // enable NMEA meessages //lfs
         send_z12_cmd("PASHS,OUT,A,NMEA");   // enable NMEA meessages
         send_z12_cmd("PASHS,NME,PER,1.0");  // 1Hz output rate
//       send_z12_cmd("PASHS,NME,GGA,A,ON"); // select NMEA command
//       send_z12_cmd("PASHS,NME,GLL,A,ON"); // select NMEA command
//       send_z12_cmd("PASHS,NME,GSA,A,ON"); // select NMEA command
//       send_z12_cmd("PASHS,NME,GSV,A,ON"); // select NMEA command
         send_z12_cmd("PASHS,NME,ZDA,A,ON"); // select NMEA command
//       send_z12_cmd("PASHS,NME,GGA,GLL,GSA,GSV,ZDA,ON"); // select NMEA command
//       send_z12_cmd("PASHS,NME,PER,1.0");  // 1Hz output rate
send_z12_cmd("PASHQ,ZDA"); //lfs
      }
      have_raw_rate = 1;
   }
}

void set_rinex_site(char *s)
{
   // set RINEX site name
   if(read_only) return;

   if(s == 0) return;

   if(rcvr_type == Z12_RCVR) {
      out[4] = 0;
      sprintf(out, "PASHS,SIT,%s", s);
      send_z12_cmd(out);
   }
}


void set_lla(double slat, double slon, double salt)
{
S32 v1,v2,v3;
char c;
char ns,ew;
double x;
int deg,mins;
double xmins;
double secs;
char lats[256];
char lons[256];
char alts[256];

// sprintf(debug_text2, "set lla:%.9lf %.9lf %.9lf", slat*180.0/PI, slon*180.0/PI, salt);

   if(read_only) return;

   need_posns = 1;
   need_sunrise = 1;
   if(luxor) {
      lat = slat;
      lon = slon;
      alt = salt;
   }
   else if((NO_SATS || (rcvr_type == ACRON_RCVR)) && (rcvr_type != TIDE_RCVR)) {
      lat = slat;
      lon = slon;
      alt = salt;
   }
   else if(rcvr_type == ESIP_RCVR) {
      slat = slat * 180.0 / PI;
      slon = slon * 180.0 / PI;
      sprintf(out, "PERDAPI,SURVEY,3,0,0,%.7f,%.7f,%d", slat,slon,(int)salt);
      send_esip_cmd(out);
   }
   else if(rcvr_type == FURUNO_RCVR) {
      x = salt - (double) (int) salt;
      if(salt < 0.0) {
         salt = 0.0-salt;
         deg = ((int) (x*10.0) % 10);
         sprintf(out, "GPset,Z2,H-%05d.%d", (int) (0.0-salt), deg);
      }
      else {
         deg = ((int) (x*10.0) % 10);
         sprintf(out, "GPset,Z2,H%06d.%d", (int) salt, deg);
      }
      send_furuno_cmd(out);

      slat = slat * 180.0 / PI;
      if(slat < 0.0) {
         ns = 'S';
         slat = 0.0 - slat;
      }
      else ns = 'N';

      deg = (int) slat;
      x = slat - (double) deg;
      mins = (int) (x*60.0*10000.0);
      sprintf(lats, "%02d%02d.%04d,%c", deg,mins/10000,mins%10000, ns);


      slon = slon * 180.0 / PI;
      if(slon < 0.0) {
         ew = 'W';
         slon = 0.0 - slon;
      }
      else ew = 'E';

      deg = (int) slon;
      x = slon - (double) deg;
      mins = (int) (x*60.0*10000.0);
      sprintf(lons, "%03d%02d.%04d,%c", deg,mins/10000,mins%10000, ew);

      sprintf(out, "$GPGGA,%s,%s", lats,lons);
      send_nmea_cmd(out);

      send_furuno_cmd("GPsrq");
   }
   else if(rcvr_type == NVS_RCVR) {
      set_rcvr_mode(RCVR_MODE_HOLD);  // position hold mode

//    send_nvs_start(0x1D);  // could be 0x0F 0x03 
//    send_byte(0x07);
      send_nvs_start(0x0F);  // could be 0x1D 0x07 
      send_byte(0x03);
      send_double(slat);
      send_double(slon);
      send_double(salt);
      send_nvs_end();
   }
   else if(rcvr_type == MOTO_RCVR) {
      v1 = (S32) ((slat * 180.0 / PI) * 3600000.0); // radians to milliarcseconds
      v2 = (S32) ((slon * 180.0 / PI) * 3600000.0); // radians to milliarcseconds
      v3 = (S32) (salt * 100.0);  // convert meters to cm

      if(0) {
         set_rcvr_mode(RCVR_MODE_HOLD);  // position hold mode

         send_moto_start("Ad");  // !!!! (moto_chans != 12)
         send_dword(v1);
         send_moto_end();
         send_moto_start("Ae");
         send_dword(v2);
         send_moto_end();
         send_moto_start("Af");
         send_dword(v3);
         send_byte(0);
         send_moto_end();
      }

      set_rcvr_mode(RCVR_MODE_3D);  // enter 3D mode so we can set position hold lla
      Sleep(2000);

      send_moto_start("As");   // set LLA
      send_dword(v1);
      send_dword(v2);
      send_dword(v3);
      send_byte(0);
      send_moto_end();

      Sleep(1000);
      set_rcvr_mode(RCVR_MODE_HOLD);  // position hold mode
   }
   else if(rcvr_type == RFTG_RCVR) {
      v1 = (S32) ((slat * 180.0 / PI) * 3600000.0); // radians to milliarcseconds
      v2 = (S32) ((slon * 180.0 / PI) * 3600000.0); // radians to milliarcseconds
      v3 = (S32) (salt * 100.0);  // convert meters to cm

      set_rftg_lla(v1, v2, v3);

      request_rftg_sats();  // readback the position
      set_rftg_normal();

      if(have_rftg_unit && (rftg_unit == 0) && (have_rftg_lla == 0)) {  // RB unit has no GPS, use user define coords
         lat = slat;
         lon = slon;
         alt = salt;
      }
   }
   else if((rcvr_type == SCPI_RCVR) || (rcvr_type == TM4_RCVR) || (rcvr_type == UCCM_RCVR) || (rcvr_type == Z12_RCVR) || (rcvr_type == ZYFER_RCVR)) {
      x = slat * 180.0 / PI;
      if(x >= 0.0) c = 'N';
      else {
         c = 'S';
         x = 0.0 - x;
      }

      deg = (int) x;

      x -= (double) deg; // x = decimal part of degrees
      x *= 60.0;         // x = minutes
      xmins = x;
      mins = (int) x;

      x -= (double) mins; 
      secs = (x * 60.0);   // x = seconds

      if(rcvr_type == TM4_RCVR) {
         sprintf(lats, "%02d%05.2f,%c", deg,xmins,c);
      }
      else if(rcvr_type == Z12_RCVR) {
         secs = (double) mins + secs/60.0;
         sprintf(lats, "%.8f,%c", ((double)deg*100.0)+secs,c);
      }
      else if(rcvr_type == ZYFER_RCVR) {
         secs = (double) mins + secs/60.0;
         sprintf(lats, "%d,%.8f,%c", deg,secs,c);
      }
      else {
         sprintf(lats, "%c,%d,%d,%f,", c,deg,mins,secs);
      }


      x = slon * 180.0 / PI;
      if(x >= 0.0) c = 'E';
      else {
         c = 'W';
         x = 0.0 - x;
      }

      deg = (int) x;

      x -= (double) deg; // x = decimal part of degrees
      x *= 60.0;         // x = minutes
      xmins = x;
      mins = (int) x;

      x -= (double) mins; 
      secs = (x * 60.0);   // x = seconds

      if(rcvr_type == TM4_RCVR) {
         if(alt >= 0) sprintf(alts, "+%05d", (int) salt);
         else         sprintf(alts, "%06d",  (int) salt);
         sprintf(lons, "%03d%05.2f,%c,%s", deg,xmins,c,alts);
      }
      else if(rcvr_type == Z12_RCVR) {
         secs = (double) mins + secs/60.0;
         sprintf(lons, "%.8f,%c", ((double)deg*100.0)+secs,c);

         if(alt >= 0) sprintf(alts, "+%.2f", salt);
         else         sprintf(alts, "%.2f", salt);
      }
      else if(rcvr_type == ZYFER_RCVR) {
         secs = (double) mins + secs/60.0;
         sprintf(lons, "%d,%.8f,%c,%.2f", deg,secs,c, salt);
      }
      else {
         sprintf(lons, "%c,%d,%d,%f,%f", c,deg,mins,secs,salt);
      }

      extend_com_timeout(0.0);
      if(rcvr_type == TM4_RCVR) {
         sprintf(out, "#19,%s,%s", lats,lons);
         send_tm4_cmd(out);
      }
      else if(rcvr_type == Z12_RCVR) {
//sprintf(debug_text, "set lla: %s %s %s", lats,lons,alts);
      }
      else if(rcvr_type == ZYFER_RCVR) {
         send_zyfer_cmd("$TRMO,K");
         sprintf(out, "$SPOS,%s,%s", lats,lons);
         send_zyfer_cmd(out);
      }
      else if(rcvr_type == UCCM_RCVR) {
         sprintf(out, "GPS:POS %s%s", lats,lons);
         queue_uccm_cmd(out, SCPI_NULL_MSG);  // !!!!!
         Sleep(1000);
         queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
      }
      else if(scpi_type == NORTEL_TYPE) {
         sprintf(out, "GPS:POSITION %s%s", lats,lons);
         queue_scpi_cmd(out, SCPI_NULL_MSG);  // !!!!!
      }
      else {  
         sprintf(out, ":PTIM:GPS:POS %s%s", lats,lons);
         queue_scpi_cmd(out, SCPI_NULL_MSG);  // !!!!!
      }
   }
   else if(rcvr_type == TAIP_RCVR) {  // sets receiver initial position
      strcpy(lats, "SIP");
      if(slat >= 0.0) sprintf(out, "+%02d", (int) (slat*180.0/PI));
      else            sprintf(out, "%03d", (int) (slat*180.0/PI));
      strcat(lats, out);

      if(slon >= 0.0) sprintf(out, "+%03d", (int) (slon*180.0/PI));
      else            sprintf(out, "%04d", (int) (slon*180.0/PI));
      strcat(lats, out);

      if(salt >= 0.0) sprintf(out, "+%04d", (int) (salt/10.0));
      else            sprintf(out, "%05d", (int) (salt/10.0));
      strcat(lats, out);

      send_taip_cmd(lats);
   }
   else if(rcvr_type == TIDE_RCVR) {
      if((lat == 0.0) && (lon == 0.0)) {    // first time position has been set...
         new_queue(RESET_ALL_QUEUES, 5467); // clear the queues so tides scale properly
      }

      lat = slat;
      lon = slon;
      alt = salt;

      ref_lat = slat;
      ref_lon = slon;
      ref_alt = salt;

      moon_posn(jd_tt);
      sun_posn(jd_utc, 0);
   }
   else if(rcvr_type == TRUE_RCVR) {
      sprintf(out, "$SETPOS %ld %ld %ld", (long) (slat*1.0E6*180.0/PI), (long) (slon*1.0E6*180.0/PI), (long) salt);
      send_true_cmd(out);  // $SETPOS %ld %ld %ld - set position (lat lon alt in same format as $GETPOS)
      send_true_cmd("$GETPOS");
   }
   else if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x32);
      send_single((float) slat);
      send_single((float) slon);
      send_single((float) salt);
      send_tsip_end();

      if(0 && SV6_FAMILY) {
         send_tsip_start(0x2A);   // !!!! altitude for 2D mode
         send_single((float) salt);
         send_tsip_end();
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      set_ubx_config(2, slat,slon,salt);
   }
   else if(rcvr_type == VENUS_RCVR) {
      set_venus_survey(2, slat,slon,salt);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      set_zod_config(6, slat,slon,salt, traim_threshold, 1);
   }

   need_redraw = 7780;
}

void request_io_options()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x35);
      send_tsip_end();
   }
}

void set_io_options(u08 posn, u08 vel, u08 timing, u08 aux)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x35);
      send_byte(posn);
      send_byte(vel);
      send_byte(timing);
      send_byte(aux);
      send_tsip_end();
   }
}

void request_last_posn()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x37);
      send_tsip_end();
   }
}

void request_gps_system_msg()
{
  // request GPS system message

   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x28);
      send_tsip_end();
   }
}

void request_system_data(u08 mode, int prn)
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(have_info == 0) return;

   if(res_t == RES_T) {  // this message can hose up the original res-t for 3 seconds
      if(raw_msg_rate < 3) {  // user can force raw data by setting the rate to 3 secs
         return;
      }
   }

   // mode 2: almanac
   // mode 3: health page
   // mode 4: ionosphere
   // mode 5: UTC params
   // mode 6: ephemeris

   if((prn >= 1) && (prn <= MAX_PRN)) {  // flag that we have asked about this sat
      eph_polled |= (0x01 << (prn-1));
   }

   send_tsip_start(0x38);
   send_byte(0x01);
   send_byte(mode);
   send_byte((u08) prn);
   send_tsip_end();
}



void set_health_config(u08 mode, int prn)
{
   // mode 1: enable sat
   // mode 2: disable sat
   // mode 3: get enable/disable status of all sats
   // mode 4: set sat healthy
   // mode 5: set sat unhealthy
   // mode 6: get health of all sats

   if(read_only) return;
   if(luxor) return;
   if((res_t && (res_t != RES_T))) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x39); 
   send_byte(mode);
   send_byte((u08) prn);
   send_tsip_end();
}


void request_sat_health()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("h", BRANDY_HEALTH_MSG);
   }
   else if(rcvr_type == FURUNO_RCVR) {
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Am");
      send_byte(0xFF);
      send_dword(0);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x35);
      send_nvs_end();
   }
   else if(rcvr_type == RFTG_RCVR) {  // this is not sat health requests...
      request_rftg_ape();             // but is part of rcvr_config.  We break
      request_rftg_ape2();            // it up into two groups to avoid overloading
      request_rftg_delta_ape();       // the receiver with requests
      request_rftg_const_ape();
      request_rftg_corr_sched();

      set_rftg_normal();
   }
   else if(rcvr_type == SS_RCVR) {
      request_ss_msg(50);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      set_health_config(3, 0x00);  // request enable/disable status of all sats
      set_health_config(6, 0x00);  // request heed/ignore status of all sats
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      query_zod_msg(ZOD_SETTINGS_MSG);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$SSLT");
      send_zyfer_cmd("$RSAH");
   }
}

void set_single_sat(int prn)
{
u32 val;
u32 old_gps;
u32 old_glonass;
u32 old_qzss;
u32 old_sbas;
u32 old_galileo;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == ESIP_RCVR) ;
   else if(prn > 32) return;
   if(prn < 0) return;

   if(rcvr_type == ESIP_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn == 0) {
         exclude_sat(0);  // restore all sats
      }
      else {  // delete selected sat
         old_gps = esip_deleted_gps;
         old_glonass = esip_deleted_glonass;  
         old_qzss = esip_deleted_qzss;  
         old_sbas = esip_deleted_sbas;  
         old_galileo = esip_deleted_galileo;  

         esip_deleted_gps = 0xFFFFFFFF;
         esip_deleted_glonass = 0xFFFFFFFF;
         esip_deleted_qzss = 0xFFFFFFFF;
         esip_deleted_sbas = 0xFFFFFFFF;
         esip_deleted_galileo = 0xFFFFFFFF;

         if((prn >= 1) && (prn <= 32)) {  // delete gps sat
            esip_deleted_gps &= (~(1U << (prn-1)));
         }
         else if((prn >= 65) && (prn <= 92)) {  // delete glonass sat
            esip_deleted_glonass &= (~(1U << (prn-65)));
         }
         else if((prn >= 93) && (prn <= 99)) {  // delete qzss sat
            esip_deleted_qzss &= (~(1U << (prn-93)));
         }
         else if((prn >= 33) && (prn <= 51)) {  // delete sbas sat
            esip_deleted_sbas &= (~(1U << (prn-33)));
         }
         else if(0 && (prn >= 211) && (prn <= 230)) {  // delete galileo sat !!!!!! what are galileo PRN's?
            esip_deleted_galileo &= (~(1U << (prn-211)));
         }
         else {
            esip_deleted_gps = old_gps;
            esip_deleted_glonass = old_glonass;  
            esip_deleted_qzss = old_qzss;  
            esip_deleted_sbas = old_sbas;  
            esip_deleted_galileo = old_galileo;  
            return;
         }

         set_amu_mask(amu_mask);     // this will set the sat disable flags

         esip_deleted_gps = old_gps;
         esip_deleted_glonass = old_glonass;  
         esip_deleted_qzss = old_qzss;  
         esip_deleted_sbas = old_sbas;  
         esip_deleted_galileo = old_galileo;  

         request_rcvr_config(8799);
      }
   }
   else if(rcvr_type == FURUNO_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn) {
         val = 1 << (prn-1);
      }
      else {
         val = 0xFFFFFFFF;
      }
      val ^= 0xFFFFFFFF;

      sprintf(out, "GPset,U%08X", val);
      send_furuno_cmd(out);

      reset_sat_tracking();
      send_furuno_cmd("GPsrq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      send_moto_start("Am");
      send_byte(0);
      if(prn) {
         val = 1 << (prn-1);
         val = (~val);
      }
      else {
         val = 0;
      }
      send_dword(val);
      send_moto_end();

      reset_sat_tracking();
      request_sat_health();
   }
   else if((rcvr_type == SCPI_RCVR) && (scpi_type == NORTEL_TYPE)) { 
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn) {
         queue_scpi_cmd("GPS:SAT:TRAC:IGNORE 0", SCPI_IGNORE_MSG);
         sprintf(out,"GPS:SAT:TRAC:INCLUDE %d", prn);
         queue_scpi_cmd(out,  SCPI_INCLUDE_MSG);
      }
      else {
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 1,2,3,4,5,6,7,8,9,10,11,12,13", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 14,15,16,17,18,19,20,21,22,23", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 24,25,26,27,28,29,30,31,32", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("SYNC:IMMEDIATE", SCPI_JAMSYNC_MSG);
      }
      queue_scpi_cmd(":GPS:SAT:TRAC:IGN?", SCPI_IGNORE_MSG);
   }
   else if(rcvr_type == SCPI_RCVR) {  // no NORTEL_TYPE
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn) {
         queue_scpi_cmd(":GPS:SAT:TRAC:IGN:ALL", SCPI_IGNORE_MSG);
         sprintf(out,":GPS:SAT:TRAC:INCL %d", prn);
         queue_scpi_cmd(out,  SCPI_INCLUDE_MSG);
      }
      else {
         queue_scpi_cmd(":GPS:SAT:TRAC:IGN:NONE", SCPI_IGNORE_MSG);
         queue_scpi_cmd(":GPS:SAT:TRAC:INCL:ALL", SCPI_INCLUDE_MSG);
         queue_scpi_cmd(":SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);    // ggggggg
      }
      queue_scpi_cmd(":GPS:SAT:TRAC:IGN?", SCPI_IGNORE_MSG);
   }
   else if(rcvr_type == SS_RCVR) {
      old_gps = ss_deleted_gps;
      old_sbas = ss_deleted_sbas;  

      if(prn <= 0) {  // restore all sats
         ss_deleted_gps = 0;
         ss_deleted_sbas = 0;  
      }
      else if((prn >= 1) && (prn <= 32)) {  // delete all byr one gps sat
         ss_deleted_gps = (1U << (prn-1));
         ss_deleted_gps = (~ss_deleted_gps);
         send_ss_start(90, 16);
         send_ss_string("UGPS-000");
         send_byte((ss_deleted_gps >> 0) & 0xFF);
         send_byte((ss_deleted_gps >> 8) & 0xFF);
         send_byte((ss_deleted_gps >> 16) & 0xFF);
         send_byte((ss_deleted_gps >> 24) & 0xFF);
         send_ss_end();
      }
      else if(0 && (prn >= 120) && (prn <= 138)) {  // !!!!! this needs work - delete sbas sat
         ss_deleted_sbas |= (1U << (prn-33));
         ss_deleted_sbas = (~ss_deleted_sbas);
         send_ss_start(90, 16);
         send_ss_string("UGPS-0G5");
         send_byte((ss_deleted_gps >> 0) & 0xFF);
         send_byte((ss_deleted_gps >> 8) & 0xFF);
         send_byte((ss_deleted_gps >> 16) & 0xFF);
         send_byte((ss_deleted_gps >> 24) & 0xFF);
         send_ss_end();
      }

      ss_deleted_gps = old_gps;
      ss_deleted_sbas = old_sbas;  
      request_rcvr_config(8799);
   }
   else if(rcvr_type == UCCM_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn) {
         queue_uccm_cmd("GPS:SAT:TRAC:IGN:ALL", SCPI_IGNORE_MSG);
         sprintf(out,"GPS:SAT:TRAC:INCL %d", prn);
         queue_uccm_cmd(out,  SCPI_INCLUDE_MSG);
      }
      else {
         queue_uccm_cmd("GPS:SAT:TRAC:INCL:ALL", SCPI_INCLUDE_MSG);
// queue_uccm_cmd("SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);    // ggggggg
      }
      queue_uccm_cmd("GPS:SAT:TRAC:IGN?", SCPI_IGNORE_MSG);
   }
   else if(rcvr_type == TSIP_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      if(!ACU_GG && !ACU_360) {
         send_tsip_start(0x34);
         send_byte((u08) prn);
         send_tsip_end();
      }

      if(SV6_FAMILY) {
         if((prn == 0) && (rcvr_mode == RCVR_MODE_SINGLE)) { // exit single sat mode
            set_rcvr_mode(RCVR_MODE_HOLD);
         }
         else {
            set_rcvr_mode(RCVR_MODE_SINGLE);
         }
      }
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      single_sat_prn = prn;
      have_single_prn = 1;
      if(prn) {
         val = 1 << (prn-1);
      }
      else {
         val = 0xFFFFFFFF;
      }

      set_zod_sat_mask(val);
   }

}

void exclude_sat(int prn)
{
u32 val;
int i;
u32 old_gps;
u32 old_glonass;
u32 old_qzss;
u32 old_sbas;
u32 old_galileo;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == ESIP_RCVR) {  
      old_gps = esip_deleted_gps;
      old_glonass = esip_deleted_glonass;  
      old_qzss = esip_deleted_qzss;  
      old_sbas = esip_deleted_sbas;  
      old_galileo = esip_deleted_galileo;  

      if(prn <= 0) {  // restore all sats
         esip_deleted_gps = 0;
         esip_deleted_glonass = 0;  
         esip_deleted_qzss = 0;  
         esip_deleted_sbas = 0;  
         esip_deleted_galileo = 0;  
      }
      else if((prn >= 1) && (prn <= 32)) {  // delete gps sat
         esip_deleted_gps |= (1U << (prn-1));
      }
      else if((prn >= 65) && (prn <= 92)) {  // delete glonass sat
         esip_deleted_glonass |= (1U << (prn-65));
      }
      else if((prn >= 93) && (prn <= 99)) {  // delete qzss sat
         esip_deleted_qzss |= (1U << (prn-93));
      }
      else if((prn >= 33) && (prn <= 51)) {  // delete sbas sat
         esip_deleted_sbas |= (1U << (prn-33));
      }
      else if(0 && (prn >= 211) && (prn <= 230)) {  // delete galileo sat !!!!!! what are galileo PRN's?
         esip_deleted_galileo |= (1U << (prn-211));
      }

      set_amu_mask(amu_mask);     // this will set the sat disable flags

      esip_deleted_gps = old_gps;
      esip_deleted_glonass = old_glonass;  
      esip_deleted_qzss = old_qzss;  
      esip_deleted_sbas = old_sbas;  
      esip_deleted_galileo = old_galileo;  

      request_rcvr_config(8799);
   }
   else if(rcvr_type == FURUNO_RCVR) {
      if((prn >= 120) && (prn < 120+32)) {  // !!!! handle disabling multiple sats
         i = (prn - 120);
         val = (1 << i);
         val |= excluded_sbas;
         sprintf(out,"GPmge,%05X", val);
         send_furuno_cmd(out);
      }
      else if(prn < 32) {
         if(prn) {
            val = 1 << (prn-1);   // val is bitmap of sats to exclude
            val = (~val);         // now it's bitmap of sats to include
            val &= sats_enabled;
         }
         else {  // enable all SBAS sats
            send_furuno_cmd("GPmge,00000");
            val = 0xFFFFFFFF;
         }

         val ^= 0xFFFFFFFF;
         sprintf(out, "GPset,U%08X", val);
         send_furuno_cmd(out);
      }

      reset_sat_tracking();
      send_furuno_cmd("GPsrq");
      send_furuno_cmd("GPmgq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(prn > 32) return;
      send_moto_start("Am");
      send_byte(0);
      if(prn) {
         val = 1 << (prn-1);     // val = bitmask of sats to exclude
         val |= (~sats_enabled);
      }
      else {
         val = 0;
      }
      send_dword(val);
      send_moto_end();

      reset_sat_tracking();
      request_sat_health();
   }
   else if(rcvr_type == NVS_RCVR) {
      if(prn) {  // exclude sat
         send_nvs_start(0x12);
         if(prn >= NVS_GLONASS_PRN) {
            send_byte(0x02);  // GLONASS
            send_byte(prn-NVS_GLONASS_PRN);
         }
         else {
            send_byte(0x01);  // GPS
            send_byte((u08) prn);
         }
         send_byte(0x02);  // disable
         send_nvs_end();
      }
      else {  // enable all excluded sats
         for(i=1; i<=32; i++) {  // GPS sats
            if(sat[i].disabled) {
               send_nvs_start(0x12);
               send_byte(0x01);  // GPS
               send_byte(i);
               send_byte(0x01);  // enable
               send_nvs_end();
            }
         }
         for(i=NVS_GLONASS_PRN+1; i<=NVS_GLONASS_PRN+24; i++) { // GLONASS sats
            if(sat[i].disabled) {
               send_nvs_start(0x12);
               send_byte(0x02);  // GLONASS
               send_byte(i-NVS_GLONASS_PRN);
               send_byte(0x01);  // enable
               send_nvs_end();
            }
         }
      }
   }
   else if(rcvr_type == SCPI_RCVR) {
      if(prn > 32) return;
      if(prn) {
         if(scpi_type == NORTEL_TYPE) sprintf(out, "GPS:SAT:TRAC:IGNORE %d", prn);
         else                         sprintf(out, ":GPS:SAT:TRAC:IGN %d", prn);
         queue_scpi_cmd(out, SCPI_IGNORE_MSG);
      }
      else if(scpi_type == NORTEL_TYPE) {
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 1,2,3,4,5,6,7,8,9,10,11,12,13", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 14,15,16,17,18,19,20,21,22,23", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE 24,25,26,27,28,29,30,31,32", SCPI_INCLUDE_MSG);
         queue_scpi_cmd("SYNC:IMMEDIATE", SCPI_JAMSYNC_MSG);
      }
      else {
         queue_scpi_cmd(":GPS:SAT:TRAC:IGN:NONE", SCPI_IGNORE_MSG);
         queue_scpi_cmd(":GPS:SAT:TRAC:INCL:ALL", SCPI_INCLUDE_MSG);
         queue_scpi_cmd(":SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
      }

      if(scpi_type == NORTEL_TYPE) {
         queue_scpi_cmd("GPS:SAT:TRAC:IGNORE?", SCPI_IGNORE_MSG);
         queue_scpi_cmd("GPS:SAT:TRAC:INCLUDE?", SCPI_INCLUDE_MSG);
      }
      else queue_scpi_cmd(":GPS:SAT:TRAC:IGN?", SCPI_IGNORE_MSG);
   }
   else if(rcvr_type == SS_RCVR) {
      old_gps = ss_deleted_gps;
      old_sbas = ss_deleted_sbas;  

      if(prn <= 0) {  // restore all sats
         ss_deleted_gps = 0;
         ss_deleted_sbas = 0;  
      }
      else if((prn >= 1) && (prn <= 32)) {  // delete gps sat
         ss_deleted_gps |= (1U << (prn-1));
         send_ss_start(90, 16);
         send_ss_string("UGPS-000");
         send_byte((ss_deleted_gps >> 0) & 0xFF);
         send_byte((ss_deleted_gps >> 8) & 0xFF);
         send_byte((ss_deleted_gps >> 16) & 0xFF);
         send_byte((ss_deleted_gps >> 24) & 0xFF);
         send_ss_end();
      }
      else if(0 && (prn >= 120) && (prn <= 138)) {  // !!!!! this needs work - delete sbas sat
         ss_deleted_sbas |= (1U << (prn-33));
         send_ss_start(90, 16);
         send_ss_string("UGPS-0G5");
         send_byte((ss_deleted_gps >> 0) & 0xFF);
         send_byte((ss_deleted_gps >> 8) & 0xFF);
         send_byte((ss_deleted_gps >> 16) & 0xFF);
         send_byte((ss_deleted_gps >> 24) & 0xFF);
         send_ss_end();
      }

      ss_deleted_gps = old_gps;
      ss_deleted_sbas = old_sbas;  
      request_rcvr_config(8799);
   }
   else if(rcvr_type == UCCM_RCVR) {
      if(prn > 32) return;
      if(prn) {
         queue_uccm_cmd("GPS:SAT:TRAC:INCL:ALL", SCPI_INCLUDE_MSG);
         sprintf(out, "GPS:SAT:TRAC:IGN %d", prn);
         queue_uccm_cmd(out, SCPI_IGNORE_MSG);
      }
      else {
         queue_uccm_cmd("GPS:SAT:TRAC:INCL:ALL", SCPI_INCLUDE_MSG);
// uuuu  queue_uccm_cmd("SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
      }
      queue_uccm_cmd("GPS:SAT:TRAC:IGN?", SCPI_IGNORE_MSG);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(prn) set_health_config(2, prn);
      else    set_health_config(1, 0);
      request_sat_health();  // request enable/disable and health status of all sats
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(prn > 32) return;
      if(prn) {
         val = 1 << (prn-1);   // val is bitmap of sats to exclude
         val = (~val);         // now it's bitmap of sats to include
         val &= sats_enabled;
      }
      else {
         val = 0xFFFFFFFF;
      }

      set_zod_sat_mask(val);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(prn > 32) return;
      if(prn) {
         sprintf(out, "$SSLT,%d,1", prn);
         send_zyfer_cmd(out);
      }
      else {
         for(prn=1; prn<=32; prn++) {
            send_zyfer_cmd("$SSLT,%d,0");
         }
      }
   }
}


void request_eph_status(int prn)
{
   if(res_t) return;
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x3B);
   send_byte((u08) prn);
   send_tsip_end();
}

void request_last_raw(int prn)
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x3A);
      send_byte((u08) prn);
      send_tsip_end();
   }
}

void request_sat_status(int prn)
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x3C);
   send_byte((u08) prn);
   send_tsip_end();
}

void request_eeprom_status()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) ;
   else if(PALISADE) return;
   else if(SV6_FAMILY) return;
   if(res_t) return;          // !!! Thunderbolt only
   if(saw_ntpx) return;

   send_tsip_start(0x3F);
   send_byte(0x11);
   send_tsip_end();
}

void request_diff_mode()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x62);
      send_byte(0xFF);
      send_tsip_end();
   }
}

void set_diff_mode(u08 mode)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x62);
      send_byte(mode);
      send_tsip_end();
   }
}


void request_posn_filter()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x71);
      send_tsip_end();
   }
}


void request_alt_filter()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x73);
      send_tsip_end();
   }
}


void request_high8_mode()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x75);
      send_tsip_end();
   }
}


void request_high6_mode()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x76);
      send_tsip_end();
   }
}

void request_diff_age()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x77);
      send_tsip_end();
   }
}


void request_filter_config()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;     // responds to filter commands, but settings do not stick
      if(PALISADE) return;

      if(ACUTIME) {
         send_tsip_start(0x70);
         send_tsip_end();
      }
      else if(SV6_FAMILY) {
         request_alt_filter();
         request_posn_filter();
      }
      else {
         send_tsip_start(0x70);
         send_tsip_end();
      }
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("AN");  // marine (velocity) filter
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("AQ");  // position filter
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("Aq");  // ionosphere corrections
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("Ar");  // fix type
      send_byte(0xFF);
      send_moto_end();
   }
}


void set_posn_filter(u08 static_mode, u08 dynamic_mode)
{
u08 val;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      if(static_mode || dynamic_mode) val = 1;
      else val = 0;
      send_tsip_start(0x71);
      send_byte(val);
      if(dynamic_mode) send_single(0.0625F);
      else             send_single(1.0F);
      send_byte(1);
      send_byte(1);
      send_byte(0);
      send_byte(6);
      send_single(0.1F);
      send_single(100.0F);
      send_single(1.21F);
      send_single(1.0E6F);
      if(static_mode) send_byte(6);
      else            send_byte(255);
      send_tsip_end();
   }
}

void set_filter_config(u08 pv, u08 stat, u08 alt, u08 kalman, u08 marine, int save)
{
u08 val;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      if(PALISADE) return;

      if(SV6_FAMILY) {
         set_alt_filter(alt);
         set_posn_filter(stat, pv);
      }
      else {
         send_tsip_start(0x70);
         send_byte(pv);
         send_byte(stat);
         send_byte(alt);
         send_byte(kalman); // rsvd on ThunderBolt,  kalman on ThunderBolt-E
         send_tsip_end();
         if(0 && save) save_segment(255, 20);
      }
   }
   else if(1 && (rcvr_type == MOTO_RCVR)) { // marine velocity filter - !!!! code in heathui.cpp will need to be changed to do this
      if((marine >= 10) && (marine <= 100)) {
         send_moto_start("AN");
         send_byte(marine);
         send_moto_end();
      }

      send_moto_start("AQ");
      send_byte(pv);
      send_moto_end();

      val = 0x00;
      if(stat) val |= 0x01;
      if(alt) val |= 0x02;
      send_moto_start("Aq");
      send_byte(val);
      send_moto_end();
   }
}

void set_alt_filter(u08 mode)
{
   if(read_only) return;
   if(luxor) return;

   // mode > 1: filter count
   // mode = 1: filter off
   // mode = 0: filter default
   if(mode) mode = 0;
   else     mode = 1;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x73);
      send_single((float) mode);
      send_tsip_end();
   }
}

void set_high8_mode(u08 mode)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x75);
      send_single((float) mode);
      send_tsip_end();
   }
}

void set_high6_mode(u08 mode)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x76);
      send_single((float) mode);
      send_tsip_end();
   }
}


void set_diff_age(u16 age)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == TSIP_RCVR) {
      send_tsip_start(0x77);
      send_word(age);
      send_tsip_end();
   }
}


void request_rcvr_config(int why)
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd("PERDAPI,FIXMASK,QUERY");
      send_esip_cmd("PERDAPI,FREQ,QUERY");
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPsrq");   // get config
      send_furuno_cmd("GPrrq");   // get pps info
//    send_furuno_cmd("GPstq");   // SBAS position fix method
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Ag"); // elevation mask
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("At"); // position hold mode
      send_byte(0xFF);
      send_moto_end();

//    request_timing_mode();
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x0D);  // sig level / elevation masks
      send_byte(0x03);
      send_nvs_end();

      send_nvs_start(0x0D);  // solution filtration factor
      send_byte(0x04);
      send_nvs_end();

      send_nvs_start(0x11);  // self test results
      send_byte(0x00);
      send_nvs_end();

      send_nvs_start(0x1D);  // survey mode info
      send_byte(0x00);
      send_nvs_end();

      send_nvs_start(0xD7);  // get nav rate (1 Hz)
      send_byte(0x02);
      send_nvs_end();
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_delta_temp();
      request_rftg_avg_sample();
      request_rftg_warmup_time();
      request_rftg_additional_status();
      request_rftg_traim();

      set_rftg_normal();
   }
   else if(rcvr_type == RT17_RCVR) {
flush_rt17_cmd();
//      send_rt17_start(0x06, 0);  // GETSERIAL
//      send_rt17_end();
//BEEP(5555);

      send_rt17_start(0x4A, 1);  // GETOPT   toots
      send_byte(1);
      send_rt17_end();
   }
   else if(rcvr_type == SIRF_RCVR) {
      query_sirf_msg(GET_SIRF_NAV_PARAMS);
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_line) return;  // dont do this in the middle of a multi-line response
      queue_star_cmd("CONF;", STAR_CONF_MSG);
//    queue_star_cmd("MASK_ANGLE;", STAR_ANGLE_MSG);
//    queue_star_cmd("INPUT_TYPE(1);", STAR_INP_TYPE_MSG);  // !!! this command is not valid for ATDC model
if(debug_file) fprintf(debug_file, "request_rcvr_config(%d)\n", why);
   }
   else if(rcvr_type == TM4_RCVR) {
      request_tm4_msg("55");  // mask angle
      request_tm4_msg("56");  // cable delay
      request_tm4_msg("57");  // timing mode
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$GETDELAY");   // get gps delay
      send_true_cmd("$GETBDELAY");  // get board delay
      send_true_cmd("$GETP");       // get pot values
      send_true_cmd("$GETSCALEFACTOR");       // get pot values
      request_atten();
   }
   else if(rcvr_type == SS_RCVR) {
      request_ss_msg(30);  // rcvr config
      request_ss_msg(49);  // rcvr status

      send_ss_start(51, 5);  // self test results
      send_byte(2);
      send_ss_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(SV6_FAMILY && !ACU_GG && !ACU_360 && !ACUTIME && !PALISADE) {
         request_sv6_config(1); 
      }
      else {
         send_tsip_start(0xBB); // receiver config packet
         send_byte(0x00);
         send_tsip_end();
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      request_ubx_msg(UBX_MON);
      request_ubx_msg(UBX_CFG);
      request_ubx_msg(UBX_CFG_ANT);
      request_ubx_msg(UBX_NAVX5);
      request_ubx_msg(UBX_NAV_RATE);
   }
   else if(rcvr_type == UCCM_RCVR) {
      queue_uccm_cmd("OUTP:STAT?", UCCM_STATE_MSG);
      queue_uccm_cmd("PULLINRANGE?", UCCM_GET_PULLIN_MSG);
   }
   else if(rcvr_type == VENUS_RCVR) {
      query_venus_msg(QUERY_VENUS_CABLE);    // get cable delay
      query_venus_msg(QUERY_VENUS_RTK_MODE); // get RTK mode
      query_venus_msg(QUERY_VENUS_MASKS);    // get el/sig mask values
      query_venus_msg(QUERY_VENUS_BOOT);     // get boot status
      query_venus_msg(QUERY_VENUS_JAMMING);  // get jamming mode
      query_venus_msg(QUERY_VENUS_LEAP);     // get UTC offset
      query_venus_msg(QUERY_VENUS_RATE);     // get nav rate
   }
   else if(rcvr_type == Z12_RCVR) {
//    send_z12_cmd("PASHQ,ELM");
//    send_z12_cmd("PASHQ,PEM");
//    send_z12_cmd("PASHQ,PDP");
//    send_z12_cmd("PASHQ,VDP");  // we set to same as PDOP
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      query_zod_msg(ZOD_SETTINGS_MSG);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$ALRM");
      send_zyfer_cmd("$ANTD");
      send_zyfer_cmd("$DRFT");
      send_zyfer_cmd("$MANG");
      send_zyfer_cmd("$STAT");
      send_zyfer_cmd("$TRMO");
   }

   request_gnss_system();
// request_gps_system_msg();  // request GPS system message
}


void set_config(u08 mode, u08 dynamics, float elev, float amu, float pdop_mask, float pdop_switch, u08 foliage)
{
int i;
int el;
int flag;
int last;
char s[SLEN+1];

   //!!! values of FF and -1.0 say to not change that value
   if(read_only) return;
   if(luxor) return;

   if(read_only == 0) {     // it's OK to change the receiver settings
      if(rcvr_type == ESIP_RCVR) {
         if(elev < 0.0F) elev = el_mask;
         else            elev = (elev * 180.0F / (float) PI) + 0.50F;
         if(elev < 0.0F) elev = 0.0F;
         else if(elev > 90.0F) elev = 90.0F;

         if(amu < 0.0F) amu = amu_mask;
         if(amu < 0.0F) amu = 0.0F;
         else if(amu > 90.0F) amu = 90.0F;

         sprintf(out, "PERDAPI,FIXMASK,USER,%d,0,%d,0", (int) elev, (int) amu);
////     strcat(out,",0x00,0x00,0x00,0x00,0x00");  // !!!!! sets no disabled sats
         sprintf(s, ",0x%X,0x%X,0x%X,0x%X,0x%X", esip_deleted_gps,esip_deleted_glonass,esip_deleted_galileo,esip_deleted_qzss,esip_deleted_sbas);
         strcat(out, s);
         send_esip_cmd(out);

         if(mode != 0xFF) {
            if(mode == RCVR_MODE_HOLD) {  // position hold mode
               set_lla(lat,lon,alt);
            }
            else {  // 3d positioning mode
               sprintf(out, "PERDAPI,SURVEY,0,0,0");
               send_esip_cmd(out);
            }
         }
      }
      else if(rcvr_type == FURUNO_RCVR) {

         if(amu >= 0.0) {
            if(amu > 100.0) amu = 100.0;
            sprintf(out, "GPset,S%02d", (int) amu);
            send_furuno_cmd(out);
         }

         if(pdop_mask >= 0.0) {
            if(pdop_mask > 10.0) pdop_mask = 10.0;
            else if(pdop_mask < 0.0) pdop_mask = 0.0;
            sprintf(out, "GPset,D%02d", (int) pdop_mask);
            send_furuno_cmd(out);
         }

         if(mode != 0xFF) {
            if(mode == RCVR_MODE_HOLD) {  // position hold mode
               sprintf(out, "GPset,Z2");
               send_furuno_cmd(out);
            }
            else {      // 3d positioning mode
               sprintf(out, "GPset,Z1");
               send_furuno_cmd(out);
            }
         }

         if((dynamics >= 1) && (dynamics <= 3)) {
            sprintf(out, "GPset,X%d", (int) dynamics);
            send_furuno_cmd(out);
         }
      }
      else if(rcvr_type == MOTO_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 89) el = 89;
            else if(el< 0) el = 0;
            send_moto_start("Ag");
            send_byte(el);
            send_moto_end();
         }

         if(mode != 0xFF) { // set receiver operating mode   zzzzz
            if(mode == RCVR_MODE_HOLD) {  // position hold mode
               send_moto_start("Gd");
               send_byte(1);           // position hold
               send_moto_end();

               send_moto_start("At");
               send_byte(1);           // position hold
               send_moto_end();

               send_moto_start("Av");
               send_byte(1);           // altitude hold
               send_moto_end();
            }
            else if(mode == RCVR_MODE_2D) {
               send_moto_start("Gd");
               send_byte(2);           // 2D mode
               send_moto_end();
            }
            else {      // 3d positioning mode
               send_moto_start("Gd");
               send_byte(0);           // 3D mode
               send_moto_end();

               send_moto_start("At");
               send_byte(0);           // 3D mode
               send_moto_end();

               send_moto_start("Av");
               send_byte(0);           // altitude hold
               send_moto_end();
            }
         }
      }
      else if(rcvr_type == NVS_RCVR) {
         if((elev >= 0.0F) || (amu >= 0.0F)) {
            if(elev < 0.0F) elev = el_mask;
            else            elev = (elev * 180.0F / (float) PI) + 0.50F;
            if(elev < 0.0F) elev = 0.0F;
            else if(elev > 90.0F) elev = 90.0F;

            if(amu < 0.0F) amu = amu_mask;
            send_nvs_start(0x0D);
            send_byte(0x03); // set elev and snr mask
            send_byte((u08) elev);
            send_byte((u08) amu);
            send_word(0x0000);    // leave position RMS error filter (meters) alone
            send_nvs_end();
         }

         if(mode != 0xFF) {  // 
            send_nvs_start(0x1D);
            send_byte(0);
            if(mode == RCVR_MODE_HOLD) {  // posn hold
               send_byte(1);
            }
            else {  // 3D mode
               send_byte(0);
            }
            send_nvs_end();
         }
      }
      else if(rcvr_type == SCPI_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 89;
            else if(el < 0) el = 0;

            if(scpi_type == NORTEL_TYPE) {
               sprintf(out, "GPS:SAT:TRAC:EMANGLE %d", el);
               queue_scpi_cmd(out, SCPI_ELEV_MSG);  
               queue_scpi_cmd("GPS:SAT:TRAC:EMANGLE?", SCPI_ELEV_MSG);
            }
            else {
               sprintf(out, ":PTIM:GPS:EMAN %d", el);
               queue_scpi_cmd(out, SCPI_ELEV_MSG);  
               queue_scpi_cmd(":PTIM:GPS:EMAN?", SCPI_ELEV_MSG);
            }
         }
      }
      else if(rcvr_type == SIRF_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            send_sirf_start(SET_SIRF_EL_MASK, 4+1);
            send_word((int) (el * 10.0F));
            send_word((int) (el * 10.0F));
            send_sirf_end();
         }

         if(amu >= 0.0) {
            send_sirf_start(SET_SIRF_AMU_MASK, 2+1);
            send_byte((int) amu);
            send_byte((int) amu);
            send_sirf_end();
         }
      }
      else if(rcvr_type == STAR_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 90;
            else if(el < 5) el = 5;

            sprintf(out, "MASK_ANGLE=%d;", el);
            queue_star_cmd(out, STAR_ANGLE_MSG);
            queue_star_cmd("MASK_ANGLE;", STAR_ANGLE_MSG);
         }
      }
      else if(rcvr_type == TM4_RCVR) {
         if(mode != 0xFF) {
            if(mode == RCVR_MODE_HOLD) {
               send_tm4_cmd("#07,1");
            }
            else {
               send_tm4_cmd("#07,0");
            }
         }

         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if     (el >= 20) send_tm4_cmd("#05,2");
            else if(el >= 15) send_tm4_cmd("#05,1");
            else              send_tm4_cmd("#05,0");
         }
      }
      else if(rcvr_type == UCCM_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 89;
            else if(el < 0) el = 0;

            sprintf(out, "GPS:SAT:TRAC:EMAN %d", el);
            queue_uccm_cmd(out, SCPI_ELEV_MSG);  
            queue_uccm_cmd("GPS:SAT:TRAC:EMAN?", SCPI_ELEV_MSG);
         }
      }
      else if(rcvr_type == TRUE_RCVR) {
      }
      else if(rcvr_type == TSIP_RCVR) {
         if(SV6_FAMILY && !ACU_GG && !ACU_360  && !ACUTIME && !PALISADE) {
            if(mode != 0xFF) {
               if(mode == RCVR_MODE_2D_3D) mode = 0;
               else if(mode == RCVR_MODE_SINGLE) mode = 1;
               else if(mode == RCVR_MODE_2D) mode = 3;
               else if(mode == RCVR_MODE_3D) mode = 4;
               else if(mode == RCVR_MODE_HOLD) mode = 6;  // !!!! was mode = 10
               else if(ACUTIME) mode = 0;   // auto 2D/3D/CH
               else if(mode == RCVR_MODE_2DCLK) mode = 5;
               else mode = 6;   // auto 2D/3D/CH
//sprintf(debug_text, "set mode: %d", mode);

               send_tsip_start(0x22);
               send_byte(mode); 
               send_tsip_end();

               send_tsip_start(0x24);  // request fix mode
               send_tsip_end();
            }

            send_tsip_start(0x2C);
            send_byte(dynamics);
            send_single(elev);        // 0.175F = 10 degree mask angle
            send_single(amu);         // 10: 22.0 amu mask
            send_single(pdop_mask);   // 14: 12.0 pdop mask
            send_single(pdop_switch); // 18: 8.0 pdop switch
            send_tsip_end();

            request_sv6_config(1);
         }
         else {  // !!! Note: byte numbers show here may be offset by 1 from the documented value
            send_tsip_start(0xBB);
            send_byte(0x00);          // 0:  subcode
            send_byte(mode);          // 1:  4=full posn  7=overdetermined clock
            send_byte(0xFF);          // 2:  ignored (DGPS mode 0=off 1=only 2=auto
            send_byte(dynamics);      // 3:  4=stationary dynamics  
            send_byte(0xFF);          // 4:  ignored (solution mode 1=overdetermined fix  2=weighted OD fix
            send_single(elev);        // 5:  0.175F = 10 degree mask angle
            send_single(amu);         // 9:  4.0 amu mask
            send_single(pdop_mask);   // 13: 8.0 pdop mask
            send_single(pdop_switch); // 17: 6.0 pdop switch
            send_byte(0xFF) ;         // 21: 0xFF ignored  (DGPS age)
            send_byte(foliage) ;      // 22: 1 = some foliage //  saw_icm: anti-jam mode0=disabled 1=enabled

            last = 40;
            if(ACU_GG) last = 40;
            else if(ACU_360) last = 40;
            else if(ACUTIME && (acu_type == '1')) last = 43;  // !!!! 40 for newer models?
            else if(PALISADE) last = 44;

            for(i=23; i<last; i++) {
               // byte 23: low power mode (PALISADE)
               // byte 24: clock hold mode
               // byte 25: measurement rate (0=1Hz 1=5Hz 2=10Hz) - PALISADE
               // byte 26: fix rate (0=1Hz 1=5Hz 2=10Hz 3=at measurement rate) - ACUTIME/PALISADE
               // byte 27: sat type mask for OD clock mode for RES360, ICM
               //          0x01 GPS
               //          0x02 GLONASS
               //          0x08 Beidou
               //          0x10 Galileo
               //          0x20 QZSS 
               flag = 0xFF;
               if((i == 27) && (saw_icm || (res_t == RES_T_360) || ACU_GG || ACU_360)) {  // !!!!! should set this gnss_mask
                  if(have_gnss_mask) {
                     flag = 0x00;
                     if(gnss_mask & GPS) flag |= 0x01;
                     if(gnss_mask & GLONASS) flag |= 0x02;
                     if(gnss_mask & BEIDOU) flag |= 0x08;
                     if(gnss_mask & GALILEO) flag |= 0x10;
                     if(gnss_mask & QZSS) flag |= 0x20;
                     if(flag == 0) flag = 0xFF;
                  }
               }
               send_byte(flag);
            }

            send_tsip_end();
         }
      }
      else if(rcvr_type == UBX_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 89;
            else if(el < 0) el = 0;

            send_ubx_start(UBX_CFG, 36);
            send_word(0x0002);  // update elevation field
            for(i=2; i<12; i++) send_byte(0);
            send_byte(el);
            for(i=13; i<36; i++) send_byte(0);
            send_ubx_end();
         }

         if(mode != 0xFF) {  // zorky
            if(mode == RCVR_MODE_HOLD) {  // posn hold
               set_ubx_config(2, lat,lon,alt);  // hold:current posn
            }
            else {  // 3D mode
               set_ubx_config(0, lat,lon,alt);
            }
         }

         if(amu >= 0.0) {
            set_ubx_amu(amu);
            request_ubx_msg(UBX_NAVX5);
         }
         request_ubx_msg(UBX_CFG);
      }
      else if(rcvr_type == VENUS_RCVR) {
         if((elev >= 0.0F) || (amu >= 0.0F)) {
            if(elev < 0.0F) elev = el_mask;
            else            elev = (elev * 180.0F / (float) PI) + 0.50F;
            if(elev < 3.0F) elev = 3.0F;
            else if(elev > 85.0F) elev = 85.0F;

            if(amu < 0.0F) amu = amu_mask;

            send_venus_start(SET_VENUS_MASKS);
            send_byte(1);
            send_byte((u08) elev);
            send_byte((u08) amu);
            send_venus_save(1);
         }

         if(foliage != 0xFF) {
            send_venus_start(SET_VENUS_JAMMING);
            send_byte(6);
            send_byte(foliage);
            send_venus_save(1);
         }

         if(mode != 0xFF) {
            if(mode == RCVR_MODE_HOLD) {  // posn hold
               set_venus_survey(2, lat,lon,alt);  // hold:current posn
            }
            else {  // 3D mode
               set_venus_survey(0, lat,lon,alt);
            }
         }

         if(saw_venus_raw) query_venus_msg(QUERY_VENUS_BASE);
         else              query_venus_msg(QUERY_VENUS_SURVEY);
      }
      else if(rcvr_type == Z12_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 90;
            else if(el < 0) el = 0;
            sprintf(out, "PASHS,ELM,%d", el);
            send_z12_cmd(out);
            sprintf(out, "PASHS,PEM,%d", el);
            send_z12_cmd(out);
have_el_mask = 0x12;    // Z12 has no read-back of the elevation mask
el_mask = (float) el;
         }

         if(pdop_mask >= 0.0) {
            if(pdop_mask > 99.0) pdop_mask = 99.0;
            else if(pdop_mask < 0.0) pdop_mask = 0.0;
            sprintf(out, "PASHS,PDP,%d", (int) pdop_mask);
            send_z12_cmd(out);
            sprintf(out, "PASHS,VDP,%d", (int) pdop_mask);
            send_z12_cmd(out);
         }
      }
      else if(rcvr_type == ZODIAC_RCVR) {  
         if(elev >= 0.0) {
            elev = elev * 1000.0F;
            send_zod_start(ZOD_SET_EL_MASK, 8, 0);
            send_zod_seq();
            send_word((u16) elev);
            send_zod_end();
         }

         if(mode != 0xFF) {
            if(mode == RCVR_MODE_HOLD) {  // posn hold
               set_zod_config(5, 0.0,0.0,0.0, traim_threshold, 2);  // hold:current posn
            }
            else {  // 3D mode
               set_zod_config(1, 0.0,0.0,0.0, traim_threshold, 3);   // normal nav mode
            }
         }
      }
      else if(rcvr_type == ZYFER_RCVR) {
         if(elev >= 0.0) {
            el = (int) (((double) elev * 180.0 / PI) + 0.50);
            if(el > 90) el = 89;
            else if(el < 0) el = 0;
            sprintf(out, "$MANG,%d", el);
            send_zyfer_cmd(out);
         }
      }
   }

   have_rcvr_mode = 0;
   request_filter_config();
   request_sat_list();     
   request_rcvr_config(1); 

   if(mode != 0xFF) {
      if(mode == RCVR_MODE_HOLD) fix_mode = 0;
      else                       fix_mode = 1;
      configed_mode = mode;
   }
   else if(read_only == 0) {
      save_segment(3, 21);    // save receiver config
   }
}

void set_rcvr_smoothing(int val)
{
   if(read_only) return;

   if(rcvr_type == FURUNO_RCVR) {
      if((val >= 1) && (val <= 3)) {
         sprintf(out, "GPset,W%d", val);
         send_furuno_cmd(out);
         send_furuno_cmd("GPsrq");
      }
   }
}

void request_serial_config(u08 port)
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0xBC);
   send_byte(port);
   send_tsip_end();
}

int set_trimble_protocol(int baud,int data_bits,int parity,int stop_bits, int in_prot,int out_prot)
{
   if(read_only) return 2;
   if(rcvr_type != TSIP_RCVR) return 2;

   // in_prot, out_prot:  2=TSIP  4=NMEA
   in_prot = out_prot = 2;  // !!!! always use TSIP

   if     (baud == 4800)   baud = 6;
   else if(baud == 9600)   baud = 7;
   else if(baud == 19200)  baud = 8;
   else if(baud == 38400)  baud = 9;
   else if(baud == 57600)  baud = 10;
   else if(baud == 115200) baud = 11;
   else return 1;

   data_bits = 3;   // !!!! we always use 8 bits

   if     (parity == ODD_PAR)  parity = 1;
   else if(parity == EVEN_PAR) parity = 2;
   else                        parity = 0;

   if(stop_bits == 2) stop_bits = 1;
   else               stop_bits = 0;

   send_tsip_start(0xBC);
   send_byte(0xFF);       // current com port (0=main com)
   send_byte(baud);       // 9600 baud
   send_byte(baud);       // 9600 baud
   send_byte(3);          // 8-bit
   send_byte(parity);     // no parity
   send_byte(stop_bits);  // 1 stop bit
   send_byte(0);          // rsvd (flow control)
   send_byte(in_prot);    // 2=tsip 4=nmea
   send_byte(out_prot);   // 
   send_byte(0);          // rsvd
   send_tsip_end();

   return 0;
}

void set_serial_config()
{
   //!!!
   if(read_only) return;
   if(luxor) return;
}


void request_datum()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == FURUNO_RCVR) {
//      send_furuno_cmd("GPsrq");  // we get this from request_rcvr_config()
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Ao");
      send_byte(0xFF);
      send_moto_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(SV6_FAMILY && !ACU_GG && !ACU_360) return;
      send_tsip_start(0x8E);
      send_byte(0x15);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      request_ubx_msg(UBX_DATUM);
   }
}

void revert_segment(u08 segment)
{
   if(read_only) return;
   if(luxor) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x8E);
   send_byte(0x45);
   send_byte(segment);
   send_tsip_end();
}


void request_osc_sense()
{
   if(luxor) return;
   if(no_poll) return;
   if(res_t) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);  // not available on ThunderBolt-E or early ThunderBolts
   send_byte(0xA1);
   send_tsip_end();
}


void request_pps_info()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("c", BRANDY_PULSE_MSG);
      queue_brandy_cmd("e", BRANDY_CODE_MSG);
   }
   else if(rcvr_type == FURUNO_RCVR) {
//    GPrrq,GPrrm;   // get pps/traim settings
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Az");     // antenna cable delay
      send_dword(0xFFFFFFFF);
      send_moto_end();

      send_moto_start("Ay");     // pps delay
      send_dword(0xFFFFFFFF);
      send_moto_end();

      send_moto_start("Gc");
      send_byte(0xFF);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0xD7);  // get pps info
      send_byte(0x05);
      send_nvs_end();

      send_nvs_start(0xD7);  // get cable delay
      send_byte(0x06);
      send_nvs_end();

      send_nvs_start(0xD7);  // get traim mode, 2D OK, single sat OK
      send_byte(0x07);
      send_nvs_end();
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("LM?", PRS_LM_MSG);
   }
   else if(rcvr_type == RFTG_RCVR) {
      request_rftg_cable();
      request_rftg_corr_data();
   }
   else if(rcvr_type == SS_RCVR) {
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0x4A);
      send_tsip_end();

      request_osc_sense();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(!saw_ubx_tp5) request_ubx_msg(UBX_PPS);
      request_ubx_tp5(0);
      request_ubx_tp5(1);
   }
   else if(rcvr_type == VENUS_RCVR) {
      query_venus_msg(QUERY_VENUS_WIDTH);
      query_venus_msg(QUERY_VENUS_FREQ);
      query_venus_msg(QUERY_VENUS_CABLE);    // get cable delay
   }
   else if(rcvr_type == Z12_RCVR) {
      if(have_z12_pps == 0) send_z12_cmd("PASHQ,PPS");
      if(have_z12_ext == 0) send_z12_cmd("PASHQ,EXT");
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$ANTD");
      send_zyfer_cmd("$PULP");
      send_zyfer_cmd("$PULR");
   }
}


void set_pps(u08 pps_enable,  u08 pps_polarity,  double delay, double pps_delay, float threshold, int save)
{
int val;
int i;
u08 flags;
double dly;
char s[SLEN+1];

   if(read_only) return;
   if(luxor) return;

   // pps_polarity 0=positive  1=negative

   if(rcvr_type == BRANDY_RCVR) {
      i = brandy_pps_width;  // pulse width
      if(i < 0) i = 0 - i;
if(i == 0) i = 1;
      if(pps_polarity) i = 0-i;

      if(pps_enable) {  // enable J10 PPS output
         if(i > 0) sprintf(out, "$PRCCG,C,P%d,+%d", brandy_pps_rate, i);
         else      sprintf(out, "$PRCCG,C,P%d,%d", brandy_pps_rate, i);
         queue_brandy_cmd(out, BRANDY_PULSE_MSG);
      }
      else {  // disable PPS output
         queue_brandy_cmd("$PRCCG,E,X,0,X,X", BRANDY_CODE_MSG);
      }
   }
   else if(rcvr_type == ESIP_RCVR) {
      sprintf(out, "PERDAPI");
      strcat(out, ",PPS");
      if(esip_pps_type) strcat(out, ",GCLK");
      else              strcat(out, ",LEGACY");

      if(pps_enable) strcat(out, ",1");
      else           strcat(out, ",0");

      if(pps_rate == RATE_PP2S) strcat(out, ",1");    // PPS2S rate
      else                      strcat(out, ",0");    // 1PPS rate

      sprintf(s, ",%d", esip_pps_width);  // pps pulse width
      strcat(out, s); 

      sprintf(s, ",%d", (int) (delay*1.0E9));
      strcat(out, s);  // cable delay

      if((esip_pps_type == 0) || (pps_polarity == 0)) strcat(out, ",0"); // only rising edge avail in LEGACY mode
      else strcat(out, ",1");  // falling edge (only available in GCLK mode)

threshold = 300.0F;
      sprintf(s, ",%d", (int) (threshold));  // accuracy threshold
      strcat(out, s); 
      send_esip_cmd(out);

      request_rcvr_config(8787);
   }
   else if(rcvr_type == FURUNO_RCVR) {
      if(delay < 0.0) sprintf(out, "GPset,t-%06d", (int) (delay*1.0E9*(-1.0)));
      else            sprintf(out, "GPset,t+%06d", (int) (delay*1.0E9));
      send_furuno_cmd(out); 

      if(pps_enable) {  // !!!! pps output enabled if sats tracked
         sprintf(out, "GPrrs,%d,%d,%d", traim_mode,furuno_traim,2);
      }
      else {
         sprintf(out, "GPrrs,%d,%d,%d", traim_mode,furuno_traim,0);
      }
      send_furuno_cmd(out);

      request_rcvr_config(7531);
   }
   else if(rcvr_type == MOTO_RCVR) {  // !!! moto_chans
      val = (int) (delay*1.0E9);
      send_moto_start("Az");
      send_dword(val);
      send_moto_end();

      send_moto_start("Ay");
      send_dword((S32) pps_delay);
      send_moto_end();

      send_moto_start("Gc");
      send_byte(pps_enable);
      send_moto_end();

      send_moto_start("Bn");  // 6 chan traim control
      send_byte(1);
      if(traim_threshold) {
         send_byte(1);
         send_word(traim_threshold);
      }
      else {
         send_byte(0);
         send_word(1000);
      }
      send_byte(pps_enable);
      for(i=0; i<10; i++) send_byte(0);
      send_moto_end();

      send_moto_start("En");  // 8 chan traim control
      send_byte(1);
      if(traim_threshold) {
         send_byte(1);
         send_word(traim_threshold);
      }
      else {
         send_byte(0);
         send_word(1000);
      }
      send_byte(pps_enable);
      for(i=0; i<10; i++) send_byte(0);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) { 
      send_nvs_start(0xD7);
      send_byte(0x06);
      send_double(delay * 1.0E6);   
      send_nvs_end();

      flags = 0x02;    // software PPS every second
      if(pps_polarity == 0)       flags |= 0x08;  // rising edge (direct PPS)
      if(time_flags & TFLAGS_UTC) flags |= 0x30;  // sync PPS to UTC time
      else                        flags |= 0x10;  // sync PPS to GPS time
      send_nvs_start(0xD7); // qqqqqqqqq !!!!! can also sync to GLONASS or UTC-SU
      send_byte(0x05);
      send_byte(flags);     // PPS config byte
      send_byte(1);         // keep internal time scale aligned
      if(pps_enable) {
         if(nvs_pps_width) send_dword(nvs_pps_width); // set pps width in nanoseconds
         else if(last_nvs_pps_width) send_dword(last_nvs_pps_width); // set pps width in nanoseconds
         else send_dword(NVS_PPS_WIDTH); // set pps width in nanoseconds
      }
      else send_dword(0); // set pps width in nanoseconds
      send_nvs_end();

      Sleep(200);
      request_pps_info();
   }
   else if(rcvr_type == PRS_RCVR) {
      if(pps_enable) {
         // !!!!! LM command does not respond with "OK" in verbose mode... use -PRS_LM_MSG kludge
         if(pps_polarity) {
            queue_prs_cmd("LM0", -PRS_LM_MSG);  // pps enabled - no lock filter
         }
         else {
            queue_prs_cmd("LM1", -PRS_LM_MSG);  // pps enabled -  with lock filter
         }
      }
      else {
         if(pps_polarity) {
            queue_prs_cmd("LM2", -PRS_LM_MSG);  // pps diabled, active  low on lock
         }
         else {
            queue_prs_cmd("LM3", -PRS_LM_MSG);  // pps diabled, active high on lock
         }
      }
      request_pps_info();
   }
   else if(rcvr_type == RFTG_RCVR) {
      set_rftg_cable(delay);
      set_rftg_offset(pps_delay);
      request_pps_info();
   }
   else if(rcvr_type == SCPI_RCVR) {
      extend_com_timeout(0.0);
      if(cable_nsecs) delay *= 1.0E9;
      if(scpi_type == NORTEL_TYPE) {
         sprintf(out, "GPS:REF:ADELAY %.9f", delay);
         queue_scpi_cmd(out, SCPI_SET_CABLE_MSG);
         queue_scpi_cmd("GPS:REF:ADELAY?", SCPI_GET_CABLE_MSG);
      }
      else {
         sprintf(out, ":PTIM:GPS:ADEL %.9f", delay);
         queue_scpi_cmd(out, SCPI_SET_CABLE_MSG);
         queue_scpi_cmd("PTIM:GPS:ADEL?", SCPI_GET_CABLE_MSG);
      }

      if((scpi_type == HP_TYPE) || (scpi_type == HP_TYPE2)) {
         if(pps_polarity) {  // falling edge  Z3816 HP59xxx
            queue_scpi_cmd(":PTIM:PPS:EDGE FALL", SCPI_EDGE_MSG);
         }
         else {  // rising edge
            queue_scpi_cmd(":PTIM:PPS:EDGE RIS", SCPI_EDGE_MSG);
         }
         queue_scpi_cmd(":PTIM:PPS:EDGE?", SCPI_EDGE_MSG);  // HP_TYPE2 only
      }

      // !!!! Z3816 / HP5xxxx can set pps rate
      // :PULSE:CONT:PER seconds
      // :PULSE:CONT:STAT (0 | 1)
   }
   else if(rcvr_type == SS_RCVR) {
      send_ss_start(69, 31);
      send_dword((int) (delay*1.0E9));
      send_dword((int) (pps_delay*1.0E9));
      val = (int) (ss_pps_width+50.0);  // in nsec (rounded up)
      val /= 100;
      send_dword(val);
      send_byte(2);     // keep pps aligned continuously
      if(pps_enable) send_byte(0); // pps always on
      else           send_byte(4); // disable pps
      send_byte(0);  // reserved
      send_word(ss_intrinsic_delay);  // intrinsic delay in ns
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_byte(0);  // reserved
      send_ss_end();
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) {
         if(delay < 0.0) delay = 0.0 - delay;  // uses positive values

         sprintf(out, "PPS_USER_OFFSET=%d;", (int) (pps_delay));
         queue_star_cmd(out, STAR_OFFSET_MSG);
      }
      else {
         if(delay > 0.0) delay = 0.0 - delay;  // uses negative values
      }
      sprintf(out, "PPS_CABLE_DELAY=%d;", (int) (delay*1.0E9));
      queue_star_cmd(out, STAR_CABLE_MSG);

      request_rcvr_config(4965);  // CONF command returns the setting
   }
   else if(rcvr_type == TM4_RCVR) {
      delay *= 1.0E9;
      if(delay >= 0) sprintf(out, "#06,+%05d", (int) delay);
      else           sprintf(out, "#06,%06d", (int) delay);
      send_tm4_cmd(out);

      if(pps_enable) {
         send_tm4_cmd("#09,7");
      }
      else {
         send_tm4_cmd("#09,8");
      }
      request_rcvr_config(4998); 
   }
   else if(rcvr_type == TRUE_RCVR) {
      sprintf(out, "$SETDELAY %d", (int) (delay*1.0E9));
      send_true_cmd(out);  // $SETDELAY %d
      sprintf(out, "$SETBDELAY %d", (int) pps_delay);
      send_true_cmd(out);  // $SETBDELAY %d
      request_rcvr_config(4966);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) ;
      else if(SV6_FAMILY) return;

      send_tsip_start(0x8E);
      send_byte(0x4A);
      send_byte(pps_enable);
      if(ACUTIME || PALISADE) {
         send_byte(0x01);   // !!!!!!!!!!!  use timing mode
      }
      else {
         send_byte(0x00);           // ACUTIME/PALISADE  0=GPS PPS   1=UTC PPS
      }
      send_byte(pps_polarity);
      send_double(delay);
      send_single(threshold);
      send_tsip_end();

      if(save) save_segment(6, 22);  // save timing config in EEPROM
   }
   else if(rcvr_type == UBX_RCVR) {  // !!!! zorky TP5
      set_ubx_pps(0, pps_rate, pps_enable, pps_polarity, delay, pps_delay, save);
   }
   else if(rcvr_type == UCCM_RCVR) {   // can't change polarity
      sprintf(out, "GPS:REF:ADEL %.9f", delay);
      extend_com_timeout(0.0);
      queue_uccm_cmd(out, SCPI_SET_CABLE_MSG);
      queue_uccm_cmd("GPS:REF:ADEL?", SCPI_GET_CABLE_MSG);

      if(pps_enable) queue_uccm_cmd("OUTP:ACT:ENAB", UCCM_OUTP_MSG);
      else           queue_uccm_cmd("OUTP:ACT:DIS", UCCM_OUTP_MSG);
      queue_uccm_cmd("OUTP:STAT?", UCCM_STATE_MSG);

      // !!!! Z3816 / HP5xxxx can set pps rate
      // :PULSE:CONT:PER seconds
      // :PULSE:CONT:STAT (0 | 1)
   }
   else if(rcvr_type == VENUS_RCVR) {
      send_venus_start(SET_VENUS_CABLE);
      send_dword((S32) (delay*1.0E11));
      send_venus_save(1);
   }
   else if(rcvr_type == X72_RCVR) {
      val = x72_creg;
      if(pps_enable) val &= (~0x0008);
      else           val |= (0x0008);
      set_x72_creg(val);

      if(pps_enable) last_x72_pps_enable = pps_enable;
      user_set_x72_pps_enable = 1;
      save_x72_state();
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      dly = cable_delay;
      cable_delay = delay;
      set_zod_config(0, 0.0,0.0,0.0, traim_threshold, 4);  // cable delay
      cable_delay = dly;
   }
   else if(rcvr_type == ZYFER_RCVR) {
      sprintf(out, "$ANTD,%d", (int) (delay*1.0E9));
      send_zyfer_cmd(out);

      sprintf(out, "$OFST,%d", (int) (pps_delay*1.0E9));
      send_zyfer_cmd(out);

      if(pps_polarity) send_zyfer_cmd("$PULP,-");      
      else             send_zyfer_cmd("$PULP,+");      
   }
}

void set_pps_source(int source)
{
   if(read_only) return;

   if(rcvr_type == TM4_RCVR) {
      sprintf(out, "#24,%d", source);
      send_tm4_cmd(out);
   }
}


void set_time_code(char mode)
{
   // set time code output format
   if(read_only) return;

   if(rcvr_type == BRANDY_RCVR) {
      if(mode == 'D') {  // enable digital time code
         sprintf(out, "$PRCCG,E,X,1,X,X");
      }
      else {
         sprintf(out, "$PRCCG,E,%c,X,X,X", mode);
      }
      queue_brandy_cmd(out, BRANDY_CODE_MSG);
   }
   else if(rcvr_type == TM4_RCVR) {
      if     (mode == '0') send_tm4_cmd("#16,0"); // IRIG
      else if(mode == '1') send_tm4_cmd("#16,1"); // NASA36
   }
}


void set_timeport_format(int format)
{
   if(read_only) return;

   if(rcvr_type == TM4_RCVR) {
      sprintf(out, "#15,%d", format);
      send_tm4_cmd(out);
   }
}


void request_pps_mode()
{
   if(read_only) return;    // !!!Resolution-T, RES360 only
   if(no_poll) return;
   if(luxor) return;
   if(saw_ntpx) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("c", BRANDY_PULSE_MSG);
      queue_brandy_cmd("e", BRANDY_CODE_MSG);
   }
   else if(rcvr_type == FURUNO_RCVR) {
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Gc");
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("AP");   // get pps rate
      send_byte(0xFF);
      send_moto_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0x4E);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(saw_ubx_tp5) request_ubx_tp5(0);
      else            request_ubx_msg(UBX_PPS);
   }
}

void request_pps_width()
{
   if(read_only) return;    // !!!Which receivers can do this?
   if(no_poll) return;
   if(luxor) return;

   if(rcvr_type == BRANDY_RCVR) {
      queue_brandy_cmd("c", BRANDY_PULSE_MSG);
      queue_brandy_cmd("e", BRANDY_CODE_MSG);
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0xD7);
      send_byte(0x05);
      send_nvs_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0x4F);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(saw_ubx_tp5) request_ubx_tp5(0);
      else            request_ubx_msg(UBX_PPS);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$PULW");
   }
}

void set_pps_mode(int mode)
{
int old_rate;

   // mode 0x02 - 1PPS
   // mode 0x82 - PP2S / 100 pps mode (Motorola)
   // mode 0x83 - 10000 PPS mode / 100 pps mode (Brandywine)

   if(read_only) return;    // !!! Resolution-T only
   if(luxor) return;

   if(rcvr_type == BRANDY_RCVR) {
      if(brandy_pps_width < 0) {  // negative polarity
         if     (mode == 0x82) sprintf(out, "$PRCCG,C,P2000,%d", brandy_pps_width);  // PP2S
         else if(mode == 0x83) sprintf(out, "$PRCCG,C,P10,%d",   brandy_pps_width);  // 100 PPS
         else                  sprintf(out, "$PRCCG,C,P1000,%d", brandy_pps_width);
      }
      else {  // positive polarity
         if     (mode == 0x82) sprintf(out, "$PRCCG,C,P2000,+%d", brandy_pps_width);  // PP2S
         else if(mode == 0x83) sprintf(out, "$PRCCG,C,P10,+%d",   brandy_pps_width);  // 100 PPS
         else                  sprintf(out, "$PRCCG,C,P1000,+%d", brandy_pps_width);
      }
      queue_brandy_cmd(out, BRANDY_PULSE_MSG);
   }
   else if(rcvr_type == ESIP_RCVR) {
       old_rate = pps_rate;
       pps_rate = mode;
       set_pps(user_pps_enable, pps_polarity,  cable_delay, pps1_delay,  pps_threshold, 10);
       pps_rate = old_rate;
       have_pps_rate = 1;
   }
   else if(rcvr_type == MOTO_RCVR) {
//sprintf(debug_text, "set pps mode:%d  oldr:%d  oldm:%d", mode, pps_rate,pps_mode);
      send_moto_start("AP");
      if(mode == RATE_100PPS) send_byte(1);  // 100 pps
      else                    send_byte(0);  // 1 PPS
      send_moto_end();
   }
   else if(rcvr_type == STAR_RCVR) {  // !!!!! we use this to toggle the TOD output
      if(star_type == OSA_TYPE) {
         if(mode == RATE_NO_TOD) {  // disable TOD message
            queue_star_cmd("TOD_STATE=D", STAR_TOD_MSG);
         }
         else {
            queue_star_cmd("TOD_STATE=E", STAR_TOD_MSG);
         }
         queue_star_cmd("TOD_STATE", STAR_TOD_MSG);
      }
      else {
         if(mode == RATE_NO_TOD) {  // disable TOD message
            queue_star_cmd("TOD_STATE=0;", STAR_TOD_MSG);
         }
         else {
            queue_star_cmd("TOD_STATE=1;", STAR_TOD_MSG);
         }
         queue_star_cmd("TOD_STATE;", STAR_TOD_MSG);
      }
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0x4E);
      mode &= 0xFE;
      send_byte(mode);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {
       old_rate = pps_rate;
       pps_rate = mode;
       set_pps(user_pps_enable, pps_polarity,  delay_value, pps1_delay,  pps_threshold, 10);
       pps_rate = old_rate;
       have_pps_rate = 1;
   }
   else if(rcvr_type == UCCM_RCVR) {
      if(mode == RATE_PP2S) queue_uccm_cmd("OUTP:TP:SEL PP2S", UCCM_RATE_MSG);
      else                  queue_uccm_cmd("OUTP:TP:SEL PP1S", UCCM_RATE_MSG);
      queue_uccm_cmd("OUTP:TP:SEL?", UCCM_RATE_MSG);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(mode == RATE_PP2S) send_zyfer_cmd("$PULR,2");      // PP2S
      else if(mode == RATE_1PPS) send_zyfer_cmd("$PULR,1"); // PPS
   }
}


void save_segment(u08 segment, int why)
{
int val;

   // save config info into EEPROM
   //     3 = receiver config
   //     6 = timing config  (ESIP_RCVR TIMEALIGN setting)
   //     7 = survey config
   //     9 = discipline config
   //   128 = ESIP_RCVR DEFLS default leap second info
   //   129 = ESIP_RCVR default FREQ command info
   //   255 = all info

   if(read_only) return;
   if(luxor) return;
   if(no_eeprom_writes) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      queue_cs_cmd("SYST:SCON", SCPI_NULL_MSG);
      restore_cs_remote();
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == ESIP_RCVR) {
      val = 0;
      if     (segment == 6)   val |= 0x04;  // TIMEALIGN timing info
      else if(segment == 128) val |= 0x02;  // DEFLS default leap second
      else if(segment == 129) val |= 0x01;  // FREQ command info
      else if(segment == 255) val |= 0x07;  // all info
      else return;

      sprintf(out, "PERDAPI,FLASHBACKUP,0x%02X", val);
      send_esip_cmd(out);  // update flash memory settings
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == SA35_RCVR) {
      queue_sa35_cmd("<FS>", SA35_SAVE_CMD);
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("SRTSAVE_CONFIG");  // update flash memory settings
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$UPDATE FLASH");  // update flash memory settings
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME);
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      if(res_t) {
         if(segment == 7) start_self_survey(1, 3);  // save survey params
         else             write_all_nvs();          // save current config
      }
      else if(ACUTIME) {
         write_all_nvs();  // save current config
      }
      else {
         send_tsip_start(0x8E);
         send_byte(0x4C);
         send_byte(segment);
         send_tsip_end();
      }
      ++ee_write_count;
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == UBX_RCVR) {
      if     (segment == 3)   update_ubx_config(0x0000, UBX_EE_NAV, UBX_EE_NAV);
      else if(segment == 6)   update_ubx_config(0x0000, UBX_EE_TP, UBX_EE_TP);
      else if(segment == 255) update_ubx_config(0x0000, UBX_EE_ALL, UBX_EE_ALL);
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }
   else if(rcvr_type == X72_RCVR) {
      save_x72_tune();
      if(x72_fw_discipline()) {
         save_x72_dmode();
      }
      BEEP(502);   // !!! if you hear lots of beeps,  you may be wearing out the EEPROM
   }

}

void save_prs_param(char *s)
{
   if(s == 0) return;
   if(!strcmp(s, "AL")) {
      queue_prs_cmd("LM!", SCPI_USER_MSG);  // in verbose mode, these return an OK response
      queue_prs_cmd("FC!", SCPI_USER_MSG);  // ... so no need for -SCPI_USER_MSG
      queue_prs_cmd("GA!", SCPI_USER_MSG);
      queue_prs_cmd("SP!", SCPI_USER_MSG);
      queue_prs_cmd("MO!", SCPI_USER_MSG);
      queue_prs_cmd("TO!", SCPI_USER_MSG);
      queue_prs_cmd("PL!", SCPI_USER_MSG);
      queue_prs_cmd("PF!", SCPI_USER_MSG);
      queue_prs_cmd("PT!", SCPI_USER_MSG);
   }
   else {
      strcpy(out, s);
      strcat(out, "!");
      queue_prs_cmd(out, SCPI_USER_MSG);
   }
}

void clear_eeprom_data()
{
   if(read_only) return;

   if(rcvr_type == RFTG_RCVR) {
      rftg_clear_errlog();
   }
}


void request_dac_voltage()
{
   if(luxor) return;
   if(no_poll) return;
   if(res_t) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xA0);
   send_tsip_end();
}

void set_dac_voltage(DATA_SIZE volts, int why)
{
int val;
int i,j;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      sprintf(out, ":ROSC:CONT %f", volts);
      queue_cs_cmd(out, SCPI_EFC_MSG);
      restore_cs_remote();
      queue_cs_cmd(":ROSC:CONT?", SCPI_EFC_MSG);
   }
   else if(rcvr_type == PRS_RCVR) {
      val = (int) volts;
      i = val / 4096;
      j = val % 4096;
      sprintf(out, "FC%d,%d", i,j);
      queue_prs_cmd(out, PRS_FC_MSG);
      queue_prs_cmd("FC?", PRS_FC_MSG);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      if(PALISADE) return;
      if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA0);
      send_byte(0x00);
      send_single((float) volts);
      send_tsip_end();
   }
   else if(rcvr_type == UCCM_RCVR) {
      val = (int) volts;  // this is DAC setting, not volts
      sprintf(out, "DIAG:ROSC:EFC:DATA %x", val);
      queue_uccm_cmd(out, UCCM_SETDAC_MSG);
      queue_uccm_cmd("DIAG:ROSC:EFC:DATA?", UCCM_EFC_MSG);
      discipline_mode = DIS_MODE_MANUAL_HOLD;  // manual control
//sprintf(plot_title, "Set dac to %f   why:%d", volts,why);
if(debug_file) fprintf(debug_file, "Set dac to %f   why:%d\n", volts,why);
   }
}

void set_dac_value(u32 value)
{
   if(read_only) return;
   if(luxor) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xA0);
   send_byte(0x01);
   send_dword(value);
   send_tsip_end();
}


void set_osc_sense(u08 mode, int save)
{
   if(read_only) return;
   if(luxor) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);  // not available on ThunderBolt-E or early ThunderBolts
   send_byte(0xA1);
   send_byte(mode);
   send_tsip_end();

   if(save) save_segment(6, 24);       // save timing config in EEPROM
}


void request_traim_info()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPrrq");   // get traim settings
      send_furuno_cmd("GPint,rrm00");  // get pps info
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Ge");  // 12 chan traim data
      send_byte(0xFF);
      send_moto_end();
      send_moto_start("Gf");  // 12 chan traim data
      send_word(0xFFFF);
      send_moto_end();
   }
}

void request_timing_mode()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == FURUNO_RCVR) {
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Aw");  // get GPS/UTC mode
      send_byte(0xFF);
      send_moto_end();

      send_moto_start("Bo");  // get UTC offset command
      send_byte(0);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x1E);  // !!!! gets leapsecond info, timing mode comes from request_pps_info()
      send_nvs_end();
   }
   else if(rcvr_type == TM4_RCVR) {
      request_tm4_msg("57");  // timing mode
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) return;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;

      send_tsip_start(0x8E);
      send_byte(0xA2);
      send_tsip_end();
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$TIMM");
   }

   request_traim_info();
}

void set_timing_mode(u08 mode, int why)
{
int old_tf;

   // set the receiver to report time in either GPS or UTC
   // !!!!! should we always do manual_time if user set the UTC offset?
   // NEW_RCVR:

   if(read_only) return;

   if(rcvr_type == ACRON_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == BRANDY_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == CS_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == ESIP_RCVR) {
      if     (mode == TMODE_GPS) send_esip_cmd("PERDAPI,TIMEALIGN,1");  // gps time
      else if(mode == TMODE_UTC) send_esip_cmd("PERDAPI,TIMEALIGN,2");  // utc time
      else if(mode == TMODE_SU)  send_esip_cmd("PERDAPI,TIMEALIGN,3");  // utc(su) time
      save_segment(6, 87);  // we don't do this automatically
   }
   else if(rcvr_type == FURUNO_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == LPFRS_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == LUXOR_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Aw");
      if(mode) send_byte(1);
      else     send_byte(0);
      send_moto_end();
   }
   else if(rcvr_type == NMEA_RCVR) {
      manual_time:     // receiver does not support output in GPS time, we do the conversion (if utc_offset is available)

      if(mode == 0) {  // GPS time
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else {  // UTC time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      old_tf = time_flags;
      if(mode == 0) {  // GPS time
         time_flags &= (~TFLAGS_UTC);
      }
      else {  // UTC time
         time_flags |= (TFLAGS_UTC);
      }
      set_pps(user_pps_enable, pps_polarity,  delay_value, pps1_delay,  pps_threshold, 44);
      time_flags = old_tf;
   }
   else if(rcvr_type == NO_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == PRS_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == RFTG_RCVR) {
      goto manual_time;
   }
   else if(1 && (rcvr_type == RT17_RCVR)) {
      goto manual_time;
   }
   else if(rcvr_type == SA35_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == SCPI_RCVR) {
      if(scpi_type == NORTEL_TYPE) {
         goto manual_time;
      }

      if(mode == 0) queue_scpi_cmd(":DIAG:GPS:UTC 0", SCPI_UTC_MSG);
      else          queue_scpi_cmd(":DIAG:GPS:UTC 1", SCPI_UTC_MSG);
      queue_scpi_cmd("*TST?", SCPI_TEST_MSG);  // cause a system reset
      show_test_warning();
//    queue_scpi_cmd(":DIAG:GPS:UTC?", SCPI_UTC_MSG);
   }
   else if(rcvr_type == SIRF_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == SRO_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == SS_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == STAR_RCVR) {
      goto manual_time;
   }
   else if(SV6_FAMILY || ACU_360 || ACU_GG || ACUTIME || PALISADE) {
      if(ACU_GG || ACU_360) {   // !!!!!! bork ACU_360
         goto tsip_tmode;
      }
      else if(mode) {  // utc
         set_io_options(0x32, 0x02, 0x03, BROADCAST_5A | DOPPLER_SMOOTH);  // LLA+DBL PRECISION, ENU vel,  UTC, PACKET 5A
      }
      else {
         set_io_options(0x32, 0x02, 0x02, BROADCAST_5A | DOPPLER_SMOOTH);  // LLA+DBL PRECISION, ENU vel,  GPS, PACKET 5A
      }
      request_io_options();
   }
   else if(rcvr_type == TAIP_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == THERMO_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == TICC_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == TIDE_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == TM4_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == TRUE_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == TSERVE_RCVR) {
      goto manual_time;
   }
   else if((rcvr_type == TSIP_RCVR) && (tsip_type == STARLOC_TYPE)) {
      send_tsip_start(0x8E);
      send_byte(0xA2);
      send_byte(TMODE_GPS);  // always set GPS mode, STARLOC always reports it is in GPS mode
      send_tsip_end();
      goto manual_time; // ... so we have to always manualy adjust the time
   }
   else if(rcvr_type == TSIP_RCVR) {
      tsip_tmode:
//sprintf(debug_text2, "set timing mode: %02X  why:%d", mode, why);
      send_tsip_start(0x8E);
      send_byte(0xA2);
      send_byte(mode);
      send_tsip_end();
      request_timing_mode();

      if(have_gnss_mask) {
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == UCCM_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == VENUS_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == X72_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == Z12_RCVR) {
      goto manual_time;
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(mode == 0) {  // GPS time
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else {  // utc time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
      set_zod_config(0, 0.0,0.0,0.0, traim_threshold, 5);  // timing mode alignment
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(mode == 0) send_zyfer_cmd("$TIMM,1,0,0");  // gps
      else          send_zyfer_cmd("$TIMM,2,0,0");  // utc
   }
}


void set_rcvr_utc_ofs(int i)
{
   // sets the receiver default UTC offset value
   if(read_only) return;

   if(rcvr_type == ESIP_RCVR) {
      sprintf(out, "PERDAPI,DEFLS,%d,AUTO", i);
      send_esip_cmd(out);
      Sleep(1000);
      save_segment(128,8787);
   }
}

void set_traim_mode(int thresh, int save)
{
int old_thresh;

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == FURUNO_RCVR) {
      if(thresh <= 0) thresh = 0;
      else            thresh = 1;
      if(pps_enabled) sprintf(out, "GPrrs,%d,%d,%d", thresh,furuno_traim,2);
      else            sprintf(out, "GPrrs,%d,%d,%d", thresh,furuno_traim,0);
      send_furuno_cmd(out);
      send_furuno_cmd("GPrrq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(thresh <= 0) {  // 12-channel disable traim
         send_moto_start("Ge");
         send_byte(0);
         send_moto_end();
      }
      else {  // 12-channel enable traim
         send_moto_start("Gf");
         send_word(thresh);
         send_moto_end();

         send_moto_start("Ge");
         send_byte(1);
         send_moto_end();
      }

      // 6/8 channel traim control
      old_thresh = traim_threshold;
      traim_threshold = thresh;
      set_pps(pps_mode, pps_polarity, delay_value, pps1_delay, pps_threshold, save);
      traim_threshold = old_thresh;
set_pps_mode(pps_rate);
   }
   else if(rcvr_type == NVS_RCVR) { 
      send_nvs_start(0xD7);
      send_byte(0x07);
      send_word(thresh);
      send_nvs_end();

      request_pps_info();
   }
   else if(rcvr_type == RFTG_RCVR) {
      if(thresh <= 0) set_rftg_traim(0);
      else            set_rftg_traim(1);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(thresh < 0) thresh = 0;
      set_zod_config(0, 0.0,0.0,0.0, thresh, 6);
   }
}


void set_discipline_mode(u08 mode)
{
   if(read_only) return;
   if(luxor) return;

   // mode 0: jam sync
   // mode 1: enter recovery
   // mode 2: manual holdover
   // mode 3: exit manual holdover
   // mode 4: disable disciplining
   // mode 5: enable disciplining

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      if     (mode == SET_DIS_MODE_DISABLE) queue_cs_cmd(":PTIM:STAN 0", CS_STANDBY_MSG);
      else if(mode == SET_DIS_MODE_ENABLE)  queue_cs_cmd(":PTIM:STAN 1", CS_STANDBY_MSG);
      restore_cs_remote();
      queue_cs_cmd(":PTIM:STAN?", CS_STANDBY_MSG);
   }
   else if(rcvr_type == PRS_RCVR) {
      // !!!!! LO command does not respond with "OK" in verbose mode... use -PRS_LO_MSG kludge
      if     (mode == SET_DIS_MODE_HOLDOVER) queue_prs_cmd("LO0", -PRS_LO_MSG);
      else if(mode == SET_DIS_MODE_DISABLE)  queue_prs_cmd("LO0", -PRS_LO_MSG);
      else if(mode == SET_DIS_MODE_NORMAL)   queue_prs_cmd("LO1", -PRS_LO_MSG);
      else if(mode == SET_DIS_MODE_ENABLE)   queue_prs_cmd("LO1", -PRS_LO_MSG);
      queue_prs_cmd("LO?", PRS_LO_MSG);
      queue_prs_cmd("ST?", PRS_ST_MSG);
   }
   else if(rcvr_type == SRO_RCVR) {
      if(mode == SET_DIS_MODE_JAMSYNC) {      // sync now
         set_sro_sy(1);
      }
      else if(mode == SET_DIS_MODE_DISABLE) { // free run
         set_sro_tr(0);
      }
      else if(mode == SET_DIS_MODE_ENABLE) {  // track now+always
         set_sro_tr(3);
      }
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) {
         if     (mode == SET_DIS_MODE_HOLDOVER) queue_star_cmd("MODE=HOLDOVER", STAR_HOLD_MSG);
         else if(mode == SET_DIS_MODE_NORMAL)   queue_star_cmd("MODE=AUTOMATIC", STAR_HOLD_MSG);
      }
      else {
         if     (mode == SET_DIS_MODE_HOLDOVER) queue_star_cmd("MODE=H;", STAR_HOLD_MSG);
         else if(mode == SET_DIS_MODE_NORMAL)   queue_star_cmd("MODE=A;", STAR_HOLD_MSG);
      }
      request_rcvr_config(8855);
   }
   else if(rcvr_type == SCPI_RCVR) {  // 2=exit holdover  3=force holdover
      z_rcvr:
if(debug_file) fprintf(debug_file, "set_dmode(%d)\n", mode);
      extend_com_timeout(0.0);
      if(scpi_type == NORTEL_TYPE) {
         if     (mode == SET_DIS_MODE_NORMAL)   queue_scpi_cmd("ROSC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_HOLDOVER) queue_scpi_cmd("ROSC:HOLD:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_JAMSYNC)  queue_scpi_cmd("SYNC:IMMEDIATE", SCPI_JAMSYNC_MSG);
         queue_scpi_cmd("ROSC:HOLD:DUR?", SCPI_HOLDOVER_MSG);
      }
      else {
         if     (mode == SET_DIS_MODE_NORMAL)   queue_scpi_cmd(":SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_HOLDOVER) queue_scpi_cmd(":SYNC:HOLD:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_JAMSYNC)  queue_scpi_cmd(":SYNC:IMM", SCPI_JAMSYNC_MSG);
         queue_scpi_cmd(":ROSC:HOLD:DUR?", SCPI_HOLDOVER_MSG);
      }
   }
   else if(rcvr_type == UCCM_RCVR) { 
      if(scpi_type == UCCMP_TYPE) goto z_rcvr;
      else if(scpi_type == SAMSUNG_TYPE) {  // samsung
         if     (mode == SET_DIS_MODE_NORMAL)   queue_scpi_cmd("SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_HOLDOVER) queue_scpi_cmd("SYNC:HOLD:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_DISABLE)  queue_scpi_cmd("SYNC:HOLD:INIT", SCPI_HOLDOVER_MSG);
         else if(mode == SET_DIS_MODE_ENABLE)   queue_scpi_cmd("SYNC:HOLD:REC:INIT", SCPI_HOLDOVER_MSG);
      }
      else if((mode == SET_DIS_MODE_HOLDOVER) || (mode == SET_DIS_MODE_DISABLE)) {  // disable disciplining at current EFC
         set_dac_voltage(uccm_voltage, 20);
      }
      else if((mode == SET_DIS_MODE_RECOVER) || (mode == SET_DIS_MODE_NORMAL) || (mode == SET_DIS_MODE_ENABLE)) {  // enable disciplining
         queue_uccm_cmd("DIAG:ROSC:EFC:DATA GPS", UCCM_SETDAC_MSG);
         queue_uccm_cmd("DIAG:ROSC:EFC:DATA?", UCCM_EFC_MSG);
         discipline_mode = DIS_MODE_RECOVERY;  // recovery
      }
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      if(PALISADE) return;
      if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA3);
      send_byte(mode);
      send_tsip_end();
   }
   else if(rcvr_type == X72_RCVR) {
      if     (mode == SET_DIS_MODE_HOLDOVER) set_x72_discipline(0);
      else if(mode == SET_DIS_MODE_DISABLE)  set_x72_discipline(0);
      else if(mode == SET_DIS_MODE_NORMAL)   set_x72_discipline(1);
      else if(mode == SET_DIS_MODE_ENABLE)   set_x72_discipline(1);
      else if(mode == SET_DIS_MODE_JAMSYNC) {
         update_x72_tic(x72_pps, 4);
      }
   }

   if(mode == SET_DIS_MODE_JAMSYNC) {
      osc_integral = 0.0;
      have_osc = 0;
   }
}


void exit_test_mode()
{
   // this is a set_() type function
   if(read_only) return;
   if(luxor) return;
   if(rcvr_type != TSIP_RCVR) return;

   send_tsip_start(0x8E);
   send_byte(0xA4);
   send_byte(0x00);
   send_tsip_end();
}

void set_test_mode()
{
   // !!!!! do something?  TSIP_RCVR only
   if(read_only) return;
   if(luxor) return;
}


void request_packet_mask()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else if(PALISADE) ;
   else if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xA5);
   send_tsip_end();
}

void set_venus_mode(int mode)
{
   // mode 1: NMEA output (accepts binary input) 2:binary output
   if(read_only) return;  // !!!!!!!!!!!!!!!!!

   send_venus_start(SET_VENUS_BINARY);
   send_byte(mode);
   send_venus_save(1);
}

void set_rtk_mode(int mode)
{
   if(read_only) return;

   if(rcvr_type == VENUS_RCVR) {
      if(mode < 0) mode = ROVER_MODE;
      else if(mode > 1) mode = BASE_MODE;

      send_venus_start(SET_VENUS_RTK_MODE);
      send_byte(1); 
      send_byte(mode);  // 0=rover  1=base
      send_venus_save(1);

      query_venus_msg(QUERY_VENUS_RTK_MODE);
   }
}


void set_nav_rate(DATA_SIZE hz)
{
   if(read_only) return;

   if(hz <= 0.0) hz = 1.0;

   if(rcvr_type == CS_RCVR) {
      if(!pause_data) nav_rate = hz;
   }
   else if((rcvr_type == NO_RCVR) || (rcvr_type == TIDE_RCVR) || (rcvr_type == THERMO_RCVR)) {
      if(!pause_data) nav_rate = hz;
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0xD7); // set nav rate (1 Hz)
      send_byte(0x02);
      send_byte((u08) hz);
      send_nvs_end();
   }
   else if(rcvr_type == TICC_RCVR) {
      if(!pause_data) nav_rate = hz;
   }
   else if(rcvr_type == UBX_RCVR) {
      if(time_flags & TFLAGS_UTC) {       // sync to UTC time
         set_ubx_nav_rate((DATA_SIZE) 1000.0/hz, 1); // 1Hz, align to UTC
      }
      else {
         set_ubx_nav_rate((DATA_SIZE) 1000.0/hz, 0); // 1Hz, align to GPS
      }
   }
   else if(rcvr_type == VENUS_RCVR) {
      send_venus_start(SET_VENUS_OUT_RATE);
      send_byte(1);  // 1 Hz
      send_venus_save(1);
      Sleep(1000);

      // doing this causes the receiver to effectively warm start
      send_venus_start(SET_VENUS_NAV_RATE);
      send_byte((u08) hz);  // raw Hz !!!!
      send_venus_save(1);
   }

   log_written = 0;  // force new log header
}


void set_rcvr_tzone(int hh, int mm)
{
   // send command to set the receiver's time zone offset (must be 0:0 for Heather)
   if(read_only) return;

   if(rcvr_type == BRANDY_RCVR) {
      if((hh == 0) && (mm == 0)) {
         queue_brandy_cmd("$PRCCG,O,U,+00:00", BRANDY_ZONE_MSG);
      }
      else {
         if(hh >= 0) sprintf(out,"$PRCCG,O,L,+%02d:%02d", hh, mm);
         else        sprintf(out,"$PRCCG,O,L,-%02d:%02d", 0-hh, mm);
         queue_brandy_cmd(out, BRANDY_ZONE_MSG);
      }
   }
   else if(rcvr_type == ESIP_RCVR) {
      if(hh >= 0) sprintf(out, "PERDAPI,TIMEZONE,0,%02d:%02d", hh,mm);
      else        sprintf(out, "PERDAPI,TIMEZONE,1,%02d:%02d", 0-hh,mm);
      send_esip_cmd(out);
   }
   else if(rcvr_type == SCPI_RCVR) {
      sprintf(out, ":PTIM:TZON %d,%d", hh,mm);  // GMT time zone (Heather does time zone conversions)
      queue_scpi_cmd(out, SCPI_NULL_MSG);     
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_type == OSA_TYPE) {
         if(hh >= 0) sprintf(out, "GMT_OFFSET=+%02d:%02d", hh,mm);
         else        sprintf(out, "GMT_OFFSET=-%02d:%02d", 0-hh,mm);
      }
      else {
         if(hh >= 0) sprintf(out, "UTC_OFFSET=+%02d:%02d;", hh,mm);
         else        sprintf(out, "UTC_OFFSET=-%02d:%02d;", 0-hh,mm);
      }
      queue_star_cmd(out, STAR_TZONE_MSG);
   }
   else if(rcvr_type == Z12_RCVR) {
      if(hh >= 0) sprintf(out,"PASHS,LTZ,+%02d,+%02d", hh, mm);
      else        sprintf(out,"PASHS,LTZ,+%02d,+%02d", 0-hh, 0-mm);
      send_z12_cmd(out);
   }
}

void set_rftg_normal()
{
   start_rftg_request(0);

   send_rftg_start(0x45);   // send 0x20,0x21,0x22 msgs and goto normal?
   send_rftg_end();
}

void init_enviro(unsigned port)
{
   // intialize the environmental sensor device to start sending data
   // We request the device ID.

   if(port >= NUM_COM_PORTS) return;
   drain_port(port);
   reset_com_timer(port);

   last_enviro = ENV_ID;
   if(enviro_type == DOG_ENVIRO) {
      send_enviro_cmd("GI\r", port);
      send_enviro_cmd("GI\r", port);
   }
   else if(enviro_type == LFS_ENVIRO) {
      send_enviro_cmd("GETID\r", port);
      send_enviro_cmd("GETID\r", port);
   }
   else if(enviro_type == DETECT_ENVIRO) {
      send_enviro_cmd("GI\n", port); 
      send_enviro_cmd("GI\n", port);
      send_enviro_cmd("\n", port);

      send_enviro_cmd("GETID\r", port);  //lfs
      send_enviro_cmd("GETID\r", port);
      if(rcvr_type == THERMO_RCVR) {  //lfs
         send_enviro_cmd("GETID\r", port);
         send_enviro_cmd("GETID\r", port);
      }
   }
}

#define ZDA_TIME 1

void poll_z12_time(int sleep)
{
   if(rcvr_type == Z12_RCVR) {
if(raw_msg_rate) return; //lfs // !!!!! we get time from the system clock
      if(ZDA_TIME) send_z12_cmd("PASHQ,ZDA");
      else         send_z12_cmd("PASHQ,RID");
      if(sleep) Sleep(150);
   }
}

void init_receiver(int why, int reset_ok)
{
int i;
u16 mask1, mask2;

   // initialze GPS receiver to send periodic messages

   reset_com_timer(RCVR_PORT);  //plugh
   reset_sat_health();

   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == ACRON_RCVR) {
      this_acron_cmd = 0;
      if(0) {  // initialize receiver time zone, etc
         init_acron_time();
         Sleep(500);
      }
      send_acron_cmd("o");
   }
   else if(rcvr_type == BRANDY_RCVR) {
      Sleep(100);
      polled_req = 0;
      queue_brandy_cmd("f", BRANDY_FREQ_MSG);
      set_rcvr_tzone(0,0);
      queue_brandy_cmd("a", BRANDY_VERSION_MSG);
      queue_brandy_cmd("n", BRANDY_FW_MSG);
      queue_brandy_cmd("p", BRANDY_POSN_MSG);
      send_brandy_char('t');  // start ball rolling with time request
      request_utc_info();  // "j"
      request_pps_info();
   }
   else if(rcvr_type == CS_RCVR) {  // HP5071 cesium beam oscillator
      Sleep(100);
      polled_req = 0;
      send_polled_cmd("", SCPI_NULL_MSG);
Sleep(100);
      queue_cs_cmd("*CLS", SCPI_CLS_MSG);
      queue_cs_cmd("DIAG:TEMP?", CS_TEMP_MSG);
      queue_cs_cmd(":PTIM:MJD?", CS_MJD_MSG);
      queue_cs_cmd(":PTIM:TIME?", CS_TIME_MSG);

      poll_next_cs();  // start the ball rolling
   }
   else if(rcvr_type == ESIP_RCVR) {
      set_raw_rate();
      set_rcvr_tzone(0,0);
      send_esip_cmd("PERDCFG,NMEAOUT,ALL,1");
      send_esip_cmd("PERDAPI,CROUT,WXYZ,1");
   }
   else if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPint,VTG00,ZDA01,GLL01,GGA01,RMC01");
      send_furuno_cmd("GPint,tps01,gpt01");
      send_furuno_cmd("GPwas,D3,T02");
request_self_tests(1);
   }
   else if(rcvr_type == GPSD_RCVR) {  // gggg - send ?WATCH cmd here
      enable_gpsd();
   }
   else if(rcvr_type == LPFRS_RCVR) {
      drain_port(RCVR_PORT);
      queue_lpfrs_cmd("V", LPFRS_ID_MSG);  // ask for version
      queue_lpfrs_cmd("V", LPFRS_ID_MSG);
      poll_next_lpfrs();
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Wb");  // set Jupiter-T to Motorola mode
      send_byte(0);
      send_moto_end();

      Sleep(250);
      if(1 && debug_file) {  // !!!! gggg
         send_moto_start("Cj");  // request receiver ID string
         send_moto_end();
      }

      send_moto_start("Cg");  // enable 6/8 chan reciever to do fixes
      send_byte(1);
      send_moto_end();

      send_moto_start("Ba");  // 6 chan position data
      send_byte(1);
      send_moto_end();

      send_moto_start("Bk");  // 6 chan extended position data 
      send_byte(1);
      send_moto_end();

      send_moto_start("Ea");  // 8 chan position data
      send_byte(1);
      send_moto_end();

      send_moto_start("Ek");  // 8 chan extended position data
      send_byte(1);
      send_moto_end();

      send_moto_start("Ha");  // 12 chan position data
      send_byte(1);
      send_moto_end();

      set_raw_rate();

      send_moto_start("Bn");  // 6 chan traim status
      send_byte(1);
//      send_byte(0);
//      send_word(1000);
      send_byte(0xFF);  // values should be rejected
      send_word(0xFFFF);
      send_byte(0xFF);
      for(i=0; i<10; i++) send_byte(0xFF);
      send_moto_end();

      send_moto_start("En");  // 8 chan traim status
      send_byte(1);
//      send_byte(0);
//      send_word(1000);
      send_byte(0xFF); // values should be rejected
      send_word(0xFFFF);
      send_byte(0xFF);
      for(i=0; i<10; i++) send_byte(0xFF);
      send_moto_end();

      send_moto_start("Hn");  // 12 chan traim
      send_byte(1);
      send_moto_end();

      request_pps_mode();
   }
   else if(rcvr_type == NMEA_RCVR) {
      sprintf(out, "PUBX,41,1,0003,0002,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox NMEA output mode (port 1)
      send_nmea_cmd(out);
//    sprintf(out, "PUBX,41,2,0003,0002,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox NMEA output mode (port 2)
//    send_nmea_cmd(out);
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0xB2);
      send_word(0x0004);    // no CRC, ellisoid altitude, geodetic coords
//    send_word(0x0006);    // CRC, ellisoid altitude, geodetic coords
      send_nvs_end();

//    set_nav_rate(1.0);    // 1Hz nav solutions

      send_nvs_start(0x27); // 0x88 PVT nav message every nav solution
      send_byte(0x01);
      send_nvs_end();

      send_nvs_start(0x1F); // 0x72 time message every second
      send_byte(0x01);
      send_nvs_end();

      send_nvs_start(0x13); // 0x41 course/speed every second
      send_byte(0x01);
      send_nvs_end();

      set_raw_rate();

      send_nvs_start(0x31); // 0x61 DOPs message every 10 seconds
      send_byte(10);
      send_nvs_end();

      send_nvs_start(0x12); // get excluded sats
      send_nvs_end();
   }
   else if(rcvr_type == PRS_RCVR) {
      queue_prs_cmd("VB1", PRS_VB_MSG);  // turn on verbose mode
      queue_prs_cmd("ST?", PRS_ST_MSG);  // get unit status
      if(user_set_osc_param) {
         have_osc_params = user_set_osc_param;
         update_osc_params();
      }

      poll_next_prs();
   }
   else if(rcvr_type == RFTG_RCVR) {
// 10 34 00 40 01 FF 02 10 03   10 34 00 40 01 FF 02 10 03   10 45 10 03  
//return;
      if(0 && reset_ok) {
         rftg_enable_cpu();  // make sure CPU is enabled
      }
      else set_rftg_normal();     // return rftg to normal mode
   }
   else if(rcvr_type == RT17_RCVR) {
      flush_rt17_cmd();
      send_byte(0x05);  // protocol check
      set_raw_rate();
   }
   else if(rcvr_type == SA35_RCVR) {
      drain_port(RCVR_PORT);
      queue_lpfrs_cmd("^", SA35_TELEM_CMD);  // ask for telem info
      queue_lpfrs_cmd("^", SA35_TELEM_CMD);
      poll_next_sa35();
   }
   else if(rcvr_type == SCPI_RCVR) {
      Sleep(100);
      polled_req = 0;
      drain_port(RCVR_PORT);
      if(1) {
         polled_q_in = polled_q_out = 0;
         polled_q_entries = 0;
         polled_msg_id = 0;
         scpi_msg_id = 0;
         do_survey = 0;
         do_median_survey = 0;  //medsurv
         rcvr_reset = 0;
         tsip_sync = 0;
         tsip_wptr = 0;
         tsip_rptr = 0;
         did_init1 = 0;
      }
      init_com(RCVR_PORT, 104);
      send_polled_cmd("", SCPI_NULL_MSG);
      Sleep(100);
      init_com(RCVR_PORT, 105);
      Sleep(100);
      send_polled_cmd("", SCPI_NULL_MSG);
      queue_scpi_cmd(":SYST:COMM:SER1:FDUP 0", SCPI_FDUP_MSG); // for Z3816 HP5xxxx (could be :FDUP OFF)
      queue_scpi_cmd("*CLS", SCPI_CLS_MSG);
      queue_scpi_cmd("*IDN?", SCPI_ID_MSG);
      if(detect_rcvr_type || (scpi_type == HP_TYPE) || (scpi_type == HP_TYPE2)) {  // gggg
         queue_scpi_cmd("PTIME:TCOD:CONT 0", SCPI_NULL_MSG);     // for Z3816 HP5xxxx
         queue_scpi_cmd(":SYST:COMM:SER1:PACE NONE", SCPI_NULL_MSG);   // for Z3816 HP5xxxx
         queue_scpi_cmd(":FORM:CONT:DATA ASC", SCPI_NULL_MSG);   // ascii data  Z3816 HP5xxxx 
         set_rcvr_tzone(0,0);
      }
//    queue_scpi_cmd(":PTIM:TCOD:FORM F1", SCPI_TIMEFMT_MSG);  // hex time format
      queue_scpi_cmd(":PTIM:TCOD:FORM F2", SCPI_TIMEFMT_MSG);  // decimal time format
      queue_scpi_cmd(":PTIM:GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);

      poll_next_scpi();
   }
   else if(rcvr_type == SIRF_RCVR) {
//    send_nmea_cmd("PSRF100,0,9600,8,1,0");  // 9600 bps switch SIRF to binary mode
      sprintf(out, "PSRF100,0,%d,%d,1,0", com[RCVR_PORT].baud_rate, com[RCVR_PORT].data_bits);  // 9600 bps switch SIRF to binary mode
      send_nmea_cmd(out);
      Sleep(500);
      send_sirf_start(SET_STATIC_MODE, 2);  // disable static nav mode
      send_byte(0);
      send_sirf_end();
   }
   else if(rcvr_type == SRO_RCVR) {
      drain_port(RCVR_PORT);
      send_polled_cmd("BT0", SRO_BT_MSG);      // turn off any BTx "beating" messages... note: BT0 does not send a response!
      queue_sro_cmd("ID", SRO_ID_MSG);
      queue_sro_cmd("L05", SRO_L05_MSG); 
      queue_sro_cmd("L06", SRO_L06_MSG); 
      poll_next_sro();
   }
   else if(rcvr_type == STAR_RCVR) {
      // When a STAR receiver is powered up, it won't send time messages
      // until a RESTART command is sent!!!  Here, we kick it in its
      // sorry ass.
      if(restart_count > 2) {  // send warm reset after 2 consecutive loss of data restart attempts
         saw_star_time = 0;
         star_restart_ok = 1;
      }
      if(star_restart_ok && (saw_star_time == 0) && (why == 0)) {  // loss of com data
         star_restart_ok = 0;   // avoid RESTART(W) cascade
         if(star_type != OSA_TYPE) queue_star_cmd("RESTART(W);", STAR_RESTART_MSG);
      }

      sat_count = 0;
      have_time = 0;

      if(star_type == OSA_TYPE) {
         set_al_mask = 1;
         queue_star_cmd("XYZZY;", SCPI_USER_MSG);    // flush any initial corrupted message
         set_rcvr_tzone(0, 0);
         queue_star_cmd("INFO_GPS;", STAR_POS_MSG);  // request time and location message
         queue_star_cmd("INV;", STAR_INV_MSG);       // get inventory
         queue_star_cmd("STATUS;", STAR_STATUS_MSG);
         queue_star_cmd("TOD_STATE;", STAR_TOD_MSG); // get TOD output state
      }
      else {
         set_rcvr_tzone(0, 0);  // seems to always return PARAM_ERROR
         queue_star_cmd("INFO_GPS_POS;", STAR_POS_MSG);    // request time and location message
         queue_star_cmd("ALARM_MASK=N;", STAR_ALMASK_MSG); // enable all alarms
         queue_star_cmd("STATUS;", STAR_STATUS_MSG);
         queue_star_cmd("TOD_STATE;", STAR_TOD_MSG);       // get TOD output state
      }

      request_rcvr_config(7766);  // CONF; and elevation mask
      if(user_set_osc_param) {
         have_osc_params = user_set_osc_param;
         update_osc_params();
      }
      poll_next_star(3);
   }
   else if(rcvr_type == SS_RCVR) {
      send_ss_start(63, 12);      // init link
      send_ss_string("UGPS-000");
      send_ss_end();

      request_ss_msg(20 | 0x80);  // nav data at 1Hz
      request_ss_msg(33 | 0x80);  // sat visibility at 1Hz
      request_ss_msg(113 | 0x80); // pps info at 1Hz
      request_ss_msg(75 | 0x80);  // leapsecond info at 1Hz
   }  
   else if(rcvr_type == TAIP_RCVR) {
      send_taip_cmd("FPV00000000");   // turn posn/velocity off
      send_taip_cmd("FTM00010000");   // send time every second
      send_taip_cmd("FLN00010000");   // send long posn/velocity every second
      send_taip_cmd("FST00100001");   // send status every 10 seconds starting at seconds=1
   }
   else if(rcvr_type == THERMO_RCVR) {
      init_enviro(RCVR_PORT);
   }
   else if(rcvr_type == TICC_RCVR) {
//    if(reset_ok && (enable_terminal == 0) && (user_set_ticc_mode == 0)) { 
      if(reset_ok && (enable_terminal == 0)) { 
         get_ticc_config(RCVR_PORT);
      }
   }
   else if(rcvr_type == TM4_RCVR) {
      send_tm4_cmd("#17,0");  // broadcast mode
      send_tm4_cmd("#12,0");  // enable all messages
   }
   else if(rcvr_type == TRUE_RCVR) {
      send_true_cmd("$PROCEED");  // get out of boot mode
      send_true_cmd("$GETVER");   // get receiver version info
      send_true_cmd("$PPSDBG");   // gives temperature at 1Hz (alas, value only updates every 5 secs)
//    send_true_cmd("$KALDBG 1"); // Kalman filter debug messages - gives temperature at 1Hz
   }
   else if(rcvr_type == TSERVE_RCVR) {  // TymServe 2000
      Sleep(100);
      send_user_cmd("C");
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(PALISADE || (SV6_FAMILY && !ACUTIME && !ACU_GG && !ACU_360)) {  // PALISADE or SV6 family
         // LLA+DBL PRECISION, ENU vel,  UTC, no PACKET 5A
         set_timing_mode(timing_mode, 12);  // this does a set_io_options();
      }
      else {
         if(tsip_type == STARLOC_TYPE) {  // !!!! does not accept standard TSIP packet mask values
            mask1 = 0xFFFF;
            mask2 = 0xFFFF;
         }
         else if(ACU_GG) {
            mask1 = 0x00E1;  // broadcast primary and supplemntal timing packets
            mask2 = 0x0000;  // also broadcast satellite solutions, gps system data,  and ephemeris data
         }
         else if(ACU_360) {
            mask1 = 0x00E1;  // broadcast primary and supplemntal timing packets
            mask2 = 0x0000;  // also broadcast satellite solutions, gps system data,  and ephemeris data
         }
         else if(ACUTIME) {
            mask1 = 0x00E1;  // broadcast primary and supplemntal timing packets
            mask2 = 0x0000;  // also broadcast satellite solutions, gps system data,  and ephemeris data
         }
         else if(res_t) {
            mask1 = 0x0055;  // broadcast primary and supplemntal timing packets
            mask2 = 0x0000;  // also broadcast satellite solutions, gps system data,  and ephemeris data
         }
         else {
            mask1 = 0x0055;  // broadcast primary and supplemntal timing packets
mask1 = 0x00D5;   // this also has the ACUTIME secondary timing packet mask enable bit set
            mask2 = 0x0000;  // also broadcast satellite solutions, gps system data,  and ephemeris data
         }

         send_tsip_start(0x8E);
         send_byte(0xA5);
         send_word(mask1);
         send_word(mask2);
         send_tsip_end();

         // !!!! If you change this also change it in the edit_option_value() call
         //      in heathui.cpp where the amu_mask is set !!!!
         // ACU_GG and ACU_360 docs say packet 5A is supported, but you cannot
         // actually request it!
         if(1 && (ACU_GG || ACU_360)) {
         }
         else if(SV6_FAMILY) set_timing_mode(timing_mode, 13);
         else set_io_options(0x32, 0x02, 0x03, 0x08 | BROADCAST_5A | DOPPLER_SMOOTH);  // LLA+DBL PRECISION, ENU vel,  UTC, PACKET 5A
//       set_io_options(0x13, 0x03, 0x01, 0x08 | BROADCAST_5A | DOPPLER_SMOOTH);  // ECEF+LLA+DBL PRECISION, ECEF+ENU vel,  UTC, PACKET 5A
      }

      if(0 && user_set_osc_param) {  // set osc params from command line values
         update_osc_params();
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      rcvr_type = NMEA_RCVR;
//com[RCVR_PORT].baud_rate = 115200;  //lfs !!!!!!! testing raw data messages
//com[RCVR_PORT].baud_rate = 9600;  //lfs !!!!!!! testing raw data messages
      sprintf(out, "PUBX,41,1,0003,0001,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox binary output mode (port 1)
      send_nmea_cmd(out);
//    sprintf(out, "PUBX,41,2,0003,0001,%d,0", com[RCVR_PORT].baud_rate);  // 9600 bps ublox binary output mode (port 2)
//    send_nmea_cmd(out);
      rcvr_type = UBX_RCVR;
Sleep(1000);

reset_com_timer(RCVR_PORT); //plugh
      set_ubx_rate(UBX_NAV, 1);     // nav solution
      set_ubx_rate(UBX_UTC, 1);     // time solution
      set_ubx_rate(UBX_SPEED,1);    // course / speed
      set_ubx_rate(UBX_GPS, 1);     // gps-utc offset
      set_ubx_rate(UBX_STATUS, 1);  // operating mode
      set_ubx_rate(UBX_CLOCK, 1);   // clock info
      set_ubx_rate(UBX_TP, 1);      // time pulse (sawtooth)

//    set_nav_rate(1.0);  // 1 Hz nav rate
      set_raw_rate();

      set_ubx_antenna(0x1F);       // make sure open circuit monitoring is on
   }
   else if(rcvr_type == UCCM_RCVR) {
      Sleep(100);
      polled_req = 0;
      send_polled_cmd("", SCPI_NULL_MSG);
      queue_uccm_cmd("TOD EN", SCPI_NULL_MSG); 
      queue_uccm_cmd("SYNC:REF:DISABLE LINK", SCPI_NULL_MSG);
      queue_uccm_cmd("SYNC:REF:DISABLE EXT", SCPI_NULL_MSG);    // samsung
      queue_uccm_cmd("SYNC:REF:ENABLE GPS", SCPI_NULL_MSG);
      queue_uccm_cmd("REF:TYPE GPS", SCPI_NULL_MSG);
      queue_uccm_cmd("OUTP:STAT?", UCCM_STATE_MSG);
      queue_uccm_cmd("LED:GPSL?", UCCM_LED_MSG);
///    queue_uccm_cmd("OUTP:TP:SEL PP1S", UCCM_RATE_MSG);
//!!!! queue_uccm_cmd("DIAG:ROSC:EFC:DATA GPS", UCCM_SETDAC_MSG);  // make sure gps ref is enabled, but this causes a recovery state
      queue_uccm_cmd(":GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);  // kkkkkk
      if(user_set_osc_param) {
         have_osc_params = user_set_osc_param;
         update_osc_params();
      }
      queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);

      poll_next_uccm();
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(saw_venus_raw) set_venus_mode(2);  // binary mode 
      else              set_venus_mode(1);  // NMEA (mostly) output, NMEA/binary in

      set_rtcm_mode(0);

      send_venus_start(SET_VENUS_PINNING);
      send_byte(2);       // diable pinning
      send_venus_save(0+1);

      send_venus_start(SET_VENUS_POWER);
      send_byte(0);       // normal power
      send_venus_save(0+1);

      send_venus_start(SET_VENUS_NAV_MODE);
      send_byte(0x17);
      send_byte(0);        // auto mode
      send_venus_save(0+1);

      if(venus_type == VENUS_RTK) {  // enable base mode
         saw_venus_raw |= 0x8000;
      }
      set_rtk_mode(rtk_mode);  //rnx2
      Sleep(500);
      set_raw_rate();
      set_rtk_mode(rtk_mode);

//    set_nav_rate(1.0);  // 1Hz nav rate
   }
   else if(rcvr_type == X72_RCVR) {
      need_x72_resync = 0;
//    queue_x72_cmd("r", X72_RUN_MSG);   // force run mode

if(reset_ok) {  // sending "I" command disrupts timing outputs
   queue_x72_cmd("i", X72_INFO_MSG);  // note: info mesage can disrupt device timing
   need_x72_restore = 1;
}
else {
      queue_x72_cmd("w", X72_HEALTH_MSG);
}
      if(user_set_osc_param) {
         have_osc_params = user_set_osc_param;
         update_osc_params();
      }
      poll_next_x72();
   }
   else if(rcvr_type == Z12_RCVR) {
      send_z12_cmd("PASHS,OUT,A");  // turn off all messages
      set_raw_rate();
poll_z12_time(0);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      send_moto_start("Wb");  // set Jupiter-T to Zodiac mode
      send_byte(1);
      send_moto_end();
      Sleep(250);

      query_zod_msg(ZOD_EE_STATUS_MSG);
//    set_zod_power(0);
      set_zod_nav_mode(0x000F);
   }
   else if(rcvr_type == ZYFER_RCVR) {
send_zyfer_cmd("$UNSL,XXXX,0");  // turn off all unsolicited messages
      send_zyfer_cmd("$UNSL,AZEL,1");   // get sat azel every 2 seconds
      send_zyfer_cmd("$UNSL,DACV,1");   // get dac voltage every second
//    send_zyfer_cmd("$UNSL,ESSD,1");   // get undocumeted value (it just increments)
      send_zyfer_cmd("$UNSL,ESSN,1");   // get tdev every second
      send_zyfer_cmd("$UNSL,EFER,1");   // get freq error every second
      send_zyfer_cmd("$UNSL,GDOP,1");   // get gdop every 2 seconds
      send_zyfer_cmd("$UNSL,HINT,1");   // get holdover integrity every 30 seconds
      send_zyfer_cmd("$UNSL,HEFE,1");   // get undocumeted value (holdover estimated freq error?)
      send_zyfer_cmd("$UNSL,HEST,1");   // get undocumeted value (holdover estimated something?)
      send_zyfer_cmd("$UNSL,HETE,1");   // get undocumeted value (holdover estimated time error?)
      send_zyfer_cmd("$UNSL,NTLC,1");   // get holdover time every 30 seconds
      send_zyfer_cmd("$UNSL,PAVG,1");   // position
      send_zyfer_cmd("$UNSL,SIGQ,1");   // get time sat info every second
      send_zyfer_cmd("$UNSL,TEMP,1");   // get temperature every 5 seconds
      send_zyfer_cmd("$UNSL,TIMD,1");   // get time every second
      send_zyfer_cmd("$UNSL,TIME,1");   // get time every second
   }
reset_com_timer(RCVR_PORT);  //plugh

   if(reset_ok && ticc_port_open() && (user_set_ticc_mode == 0)) {
      get_ticc_config(TICC_PORT);
   }
}

void request_gnss_system()
{
   // request the current GNSS system selections
   if(no_poll) return;
   if(luxor) return;

   if(rcvr_type == ESIP_RCVR) {
      send_esip_cmd("PERDAPI,GNSS,QUERY");
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x0D);  // gnss system info
      send_byte(0x02);
      send_nvs_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(PALISADE) return;
      if(SV6_FAMILY) return;

      if(saw_icm || (res_t == RES_T_360) || ACU_GG || ACU_360) {
         request_rcvr_config(666);
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      request_ubx_msg(UBX_GNSS);
   }
   else if(rcvr_type == VENUS_RCVR) {
      query_venus_msg(QUERY_VENUS_GNSS);
      query_venus_msg(QUERY_VENUS_SBAS);
      query_venus_msg(QUERY_VENUS_QZSS);
   }
}

#define NUM_UBX_SYS 7
void set_ubx_gnss(int system, int save)
{
int id;
int min_chans;
int max_chans;
int min_chan_count;
int max_chan_count;
u32 flags;

   if(read_only) return;

   send_ubx_start(UBX_GNSS, 4+NUM_UBX_SYS*8);
   send_byte((u08) 0);
   send_byte((u08) 32);
   send_byte((u08) 0xFF);
   send_byte((u08) NUM_UBX_SYS);

   min_chan_count = max_chan_count = 0;
   for(id=0; id<NUM_UBX_SYS; id++) {
      flags = 0x01010000;
      min_chans = 0;
      max_chans = 0;
      if(id == 0) {       // GPS
         if(system & GPS) {
            flags |= 0x00000001;
            min_chans = 8;   // 8;
            max_chans = 16;  // 16;
         }
      }
      else if(id == 1) {  // SBAS
         if(system & SBAS) {
            flags |= 0x00000001;
            min_chans = 1;
            max_chans = 3;
         }
      }
      else if(id == 2) {  // GALILEO
         if(system & GALILEO) {
            flags |= 0x00000001;
            min_chans = 4;    // 4;
            max_chans = 8;   // 8;
         }
      }
      else if(id == 3) {  // Beidou
         if(system & BEIDOU) {
            flags |= 0x00000001;
            min_chans = 8;    // 8;
            max_chans = 16;   // 16;
         }
      }
      else if(id == 4) {  // IMES
         if(system & IMES) {
            flags |= 0x00000001;
            flags |= 0x02000000;
            min_chans = 0;
            max_chans = 8;   // 8;
         }
      }
      else if(id == 5) {  // QZSS
         if(system & QZSS) {
            flags |= 0x00000001;
            flags |= 0x04000000;
            min_chans = 0;
            max_chans = 3;
         }
      }
      else if(id == 6) {  // GLONASS
         if(system & GLONASS) {
            flags |= 0x0001;
            min_chans = 8;  // 8;
            max_chans = 14; // 14;
         }
      }

      min_chan_count += min_chans;
      max_chan_count += max_chans;

      send_byte((u08) id);
      send_byte((u08) min_chans);
      send_byte((u08) max_chans);
      send_byte((u08) 0); // reserved
      send_dword(flags);
   }

   send_ubx_end();
Sleep(1000);
//sprintf(debug_text, "GNSS set gnss %04X: min:%d  max:%d", system, min_chan_count,max_chan_count);
   if(save) save_segment(6, 28);  // save PPS timing config in EEPROM
}

void set_gnss_system(int system)
{
u08 val;
int old_gnss_mask;
int old_have_gnss;

   // set the GNSS system/systems to use
   if(luxor) return;
   if(read_only) return;
//sprintf(plot_title, "GNSS set rcvr:%04X gnss:%04X", rcvr_type, system);

   if(rcvr_type == ESIP_RCVR) {
      sprintf(out, "PERDAPI,GNSS,AUTO");
      if(system & GPS) strcat(out, ",2");
      else             strcat(out, ",0");
      if(system & GLONASS) strcat(out, ",2");
      else                 strcat(out, ",0");
      if(system & GALILEO) {
         if(furuno_type == 87)        strcat(out, ",0");
         else if(furuno_type == 8736) strcat(out, ",0");
         else                         strcat(out, ",2");
      }
      else                 strcat(out, ",0");
      if(system & QZSS) strcat(out, ",2");
      else              strcat(out, ",0");
      if(system & SBAS) strcat(out, ",2");
      else              strcat(out, ",0");
      send_esip_cmd(out);
   }
   else if(rcvr_type == NVS_RCVR) {
      system &= (~BEIDOU);
      send_nvs_start(0x0D);
      send_byte(0x02);
      val = 0;
      if((system & GPS) && (system & GLONASS)) val = 0;
      else if(system & GPS) val = 1;
      else if(system & GLONASS) val = 2;
      else if(system & GALILEO) val = 3;
      if(system & GALILEO) ;            // can't do SBAS
      else if(system & SBAS) val += 10; // include SBAS 
      send_byte(val);
      send_nvs_end();
   }
   else if(rcvr_type == UBX_RCVR) {
      set_ubx_gnss(system, 0);
   }
   else if(rcvr_type == VENUS_RCVR) {
      send_venus_start(SET_VENUS_GNSS);
      send_byte(0x19);
      send_word((u16) (system & (GPS | GLONASS | BEIDOU | GALILEO)));
      send_venus_save(1);

      send_venus_start(SET_VENUS_QZSS);
      send_byte(0x03);
      if(system & QZSS) send_byte(1);
      else              send_byte(0);
      send_byte(1);       // channels
      send_venus_save(1);

if(1) {
      send_venus_start(SET_VENUS_SBAS);
      send_byte(0x01);
      if(system & SBAS) send_byte(1);
      else              send_byte(0);
      send_byte(2);     // auto select mode
      send_byte(8);     // URA
      send_byte(1);     // apply corrections
      send_byte(2);     // channels
      send_byte(0x0F);  // WAAS + EGNOS + MSAS + GAGAN
      send_venus_save(1);
}
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(saw_icm || (res_t == RES_T_360) || ACU_GG || ACU_360) {
         old_gnss_mask = gnss_mask;
         old_have_gnss = have_gnss_mask;
         have_gnss_mask = 666;
         gnss_mask = system;

         set_config(0xFF, 0xFF, -1.0F, -1.0F, -1.0F, -1.0F, 0xFF);
Sleep(500);
if(gnss_mask & GPS)          set_timing_mode(TMODE_UTC, 14);
else if(gnss_mask & GLONASS) set_timing_mode(TMODE_GLONASS, 15);
else                         set_timing_mode(TMODE_UTC, 16);

         gnss_mask = old_gnss_mask;
         have_gnss_mask = old_have_gnss;
      }
   }

   request_gnss_system();
}


void request_discipline_params(u08 type)
{
   if(luxor) return;
   if(no_poll) return;
   if(res_t) return;

   if(rcvr_type == PRS_RCVR) {
      if     (type == 0x00) {   // time constant
         queue_prs_cmd("PT?", PRS_PT_MSG);
      }
      else if(type == 0x01) {  // gain
         queue_prs_cmd("GA?", PRS_GA_MSG);
      }
      else if(type == 0x02) {  // stability
         queue_prs_cmd("PF?", PRS_PF_MSG);
      }
      else if(type == 0x03) {  // integrator
         queue_prs_cmd("PI?", PRS_PI_MSG);
      }
   }
   else if(rcvr_type == STAR_RCVR) {
      if(type == 0x00) {
         request_rcvr_config(5577);
      }
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      if(PALISADE) return;
      if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA8);
      send_byte(type);
      send_tsip_end();
   }
}

void request_all_dis_params()
{
   if(luxor) return;
   if(no_poll) return;

   request_discipline_params(0x00); // time constant
   request_discipline_params(0x01); // gain / DAC range
   request_discipline_params(0x02); // sync / freq thresholds
   request_discipline_params(0x03); // initial DAC voltage
   request_discipline_params(0x04); // undocumented - allowable DAC range?
}



void set_pullin_range(int i)
{
   if(read_only) return;

   if(rcvr_type == UCCM_RCVR) {
      sprintf(out, "PULLINRANGE %d", i/10);
      queue_uccm_cmd(out, UCCM_SET_PULLIN_MSG);
      queue_uccm_cmd("PULLINRANGE?", UCCM_GET_PULLIN_MSG);
   }
}


void set_discipline_params(int save)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == PRS_RCVR) {
      // !!!!!!! do something
      if(have_osc_params & PARAM_TC) {  // set time constant
         set_prs_pt((int) user_time_constant);
      }

      if(have_osc_params & PARAM_DAMP) {  // set damping factor
         set_prs_pf((int) user_damping_factor);
      }

      if(have_osc_params & PARAM_GAIN) {  // set gain factor
         set_prs_ga((int) user_damping_factor);
      }

      if(have_osc_params & PARAM_INITV) {  // set integrator factor
         set_prs_pi((int) user_initial_voltage);
      }
   }
   else if(rcvr_type == SRO_RCVR) {
      if(have_osc_params & PARAM_TC) {  // set time constant
         set_sro_tc((int) user_time_constant);
      }
   }
   else if(rcvr_type == STAR_RCVR) {
      if(have_osc_params & PARAM_TC) {
         sprintf(out, "TAU=%d;", (int) user_time_constant);
         queue_star_cmd(out, STAR_TAU_MSG);
         request_rcvr_config(4565);
      }
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      if(PALISADE) return;
      if(SV6_FAMILY) return;

      if(have_osc_params & (PARAM_TC | PARAM_DAMP)) { 
         send_tsip_start(0x8E);
         send_byte(0xA8);
         send_byte(0x00);
         send_single((float) user_time_constant);
         send_single((float) user_damping_factor);
         send_tsip_end();
      }

      if(have_osc_params & (PARAM_GAIN | PARAM_MINV | PARAM_MAXV)) { 
         send_tsip_start(0x8E);
         send_byte(0xA8);
         send_byte(0x01);
         send_single((float) user_osc_gain);
         send_single((float) user_min_volts);
         send_single((float) user_max_volts);
         send_tsip_end();
      }

      if(have_osc_params & (PARAM_JAMSYNC | PARAM_MAXFREQ)) { 
         send_tsip_start(0x8E);
         send_byte(0xA8);
         send_byte(0x02);
         send_single((float) user_jam_sync);
         send_single((float) user_max_freq_offset);
         send_tsip_end();
      }

      if(have_osc_params & PARAM_INITV) { 
         send_tsip_start(0x8E);
         send_byte(0xA8);
         send_byte(0x03);
         send_single((float) user_initial_voltage);
         send_tsip_end();
      }

      if(have_osc_params & (PARAM_MINRANGE | PARAM_MAXRANGE)) { // !!!! undocumented - allowable dac range
         send_tsip_start(0x8E);
         send_byte(0xA8);
         send_byte(0x04);
         send_single((float) user_min_range);
         send_single((float) user_max_range);
         send_tsip_end();
      }

      if(save) {
         if((have_osc_params & PARAM_TBOLT) == PARAM_TBOLT) {  // !!!!! 0x0F: we have all osc params available
            save_segment(9, 25);
         }
         else if(saw_ntpx && ((have_osc_params & PARAM_NTPX) == PARAM_NTPX)) {
            save_segment(9, 26);
         }
      }
   }
   else if(rcvr_type == UCCM_RCVR) {
      if(have_osc_params & PARAM_PULLIN) {
         set_pullin_range(user_pullin);
      }
   }
   else if(rcvr_type == X72_RCVR) {
      if(have_osc_params & PARAM_MAXFREQ) {  // used to set DDS tuning word
         set_x72_dds(user_max_freq_offset);
      }

      if(have_osc_params & PARAM_JAMSYNC) {  // set time constant
         set_x72_jamthresh(user_jam_sync);
      }

      if(have_osc_params & PARAM_TC) {  // set time constant
         set_x72_tc((int) user_time_constant);
      }

      if(have_osc_params & PARAM_DAMP) {  // set damping factor
         set_x72_damping(user_damping_factor);
      }

      if(have_osc_params & PARAM_HOLDOVER) {  // set holdover analysis time
         set_x72_holdover(user_holdover_time);
      }
   }
}


void request_survey_params()
{
   if(luxor) return;
   if(no_poll) return;

   if(rcvr_type == FURUNO_RCVR) {
      send_furuno_cmd("GPtmq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      send_moto_start("Gd");
      send_byte(0xFF);
      send_moto_end();
   }
   else if(rcvr_type == TM4_RCVR) {
      request_tm4_msg("57");
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) return;
      else if(ACU_360) return;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA9);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) { 
      if     (have_ubx_tmode == 2) request_ubx_msg(UBX_CFG_TMODE2);  // M8T
      else if(have_ubx_tmode == 1) request_ubx_msg(UBX_CFG_TMODE);
      else {
         request_ubx_msg(UBX_CFG_TMODE2);  // M8T
         request_ubx_msg(UBX_CFG_TMODE);
      }
      request_ubx_msg(UBX_SVIN);
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(saw_venus_raw) query_venus_msg(QUERY_VENUS_BASE);
      else              query_venus_msg(QUERY_VENUS_SURVEY);
   }
}

void set_survey_params(u08 enable_survey,  u08 save_survey, u32 survey_len)
{
   if(read_only) return;
   if(luxor) return;

   if(rcvr_type == FURUNO_RCVR) {  //!!! zorky
   }
   else if(rcvr_type == MOTO_RCVR) {  //!!! moto_chans
      send_moto_start("Gd");
      if(enable_survey) send_byte(0x03);
      else              send_byte(0x00);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) {
      if(survey_len > 1440) survey_len = 1440;
      else if(survey_len < 20) survey_len = 20;
      send_nvs_start(0x1D);
      send_byte(0x06);
      send_word(survey_len);
      send_nvs_end();
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA9);
      send_byte(enable_survey);
      send_byte(save_survey);
      send_dword(survey_len);
      send_dword(0x0000);
      send_tsip_end();
   }
   else if(rcvr_type == TRUE_RCVR) {  // zorky
   }
   else if(rcvr_type == UBX_RCVR) {  // zorky
   }
}

void start_self_survey(u08 val, int why)
{
int hours;
   // val=0 - start survey
   // val=1 - save position (Tbolt-E)
   // val=2 - delete position (Tbolt-E)
   if(read_only) return;
   if(luxor) return;
stop_precision_survey(100);  // medsurv
if(0 && debug_file) fprintf(debug_file, "start self survey val:%d  why:%d\n", val,why); //plugh

   if(rcvr_type == ESIP_RCVR) { 
      sprintf(out, "PERDAPI,SURVEY,2,0,%ld", do_survey);
      send_esip_cmd(out);
   }
   else if(rcvr_type == FURUNO_RCVR) { 
      hours = do_survey;
      if(do_survey > 48) {  // assume time was in seconds
         hours = (do_survey+3599) / 3600;
         if(hours <= 0) hours = 1;
         else if(hours > 48) hours = 48;
         do_survey = hours;
      }
      survey_length = do_survey;
      sprintf(out, "GPset,Z3%02ld", do_survey);
      send_furuno_cmd(out);
      send_furuno_cmd("GPsrq");
   }
   else if(rcvr_type == MOTO_RCVR) {  //!!! moto_chans
      send_moto_start("Gd");
      send_byte(0x03);
      send_moto_end();
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x1D);
      send_byte(0x00);
      send_byte(0x02);
      send_nvs_end();
   }
   else if(rcvr_type == SCPI_RCVR) {
      extend_com_timeout(0.0);
      if(scpi_type == NORTEL_TYPE) {
         queue_scpi_cmd("GPS:POS:SURVEY:STAT ONCE", SCPI_SURVEY_MSG);
         queue_scpi_cmd("GPS:POS:SURVEY:PROGRESS?", SCPI_PROGRESS_MSG);
      }
      else {
         queue_scpi_cmd(":PTIM:GPS:POS:SURV:STAT ONCE", SCPI_SURVEY_MSG);
         queue_scpi_cmd(":PTIM:GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);
      }
if(debug_file) {
   fprintf(debug_file, "### start survey: why=%d  do_survey=%ld\n", why, do_survey);
   fflush(debug_file);
}
do_survey = 0;
do_median_survey = 0; //medsurv
survey_why = (-11);
   }
   else if(rcvr_type == TM4_RCVR) {
      send_tm4_cmd("#07,3");
   }
   else if(rcvr_type == TRUE_RCVR) {
      sprintf(out, "$SURVEY %ld", do_survey);
      send_true_cmd(out);  // $SURVEY %ld - do a self survey for %d hours
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_GG) ;
      else if(ACU_360) ;
      else if(ACUTIME) ;
      else if(PALISADE) return;
      else if(SV6_FAMILY) return;
      send_tsip_start(0x8E);
      send_byte(0xA6);
      send_byte(val);
      send_tsip_end();
   }
   else if(rcvr_type == UBX_RCVR) {  // zorky
      set_ubx_config(1, lat,lon,alt);  // go to survey mode
   }
   else if(rcvr_type == UCCM_RCVR) {
if(scpi_type == UCCMP_TYPE) {  // kkkkkk
      queue_uccm_cmd("GPS:POS:SURV:STAT ONCE", SCPI_SURVEY_MSG);
if(debug_file) {
   fprintf(debug_file, "### start survey: why=%d  do_survey=%ld\n", why, do_survey);
   fflush(debug_file);
}
do_survey = 0;
do_median_survey = 0;  // medsurv
survey_why = (-12);
      queue_uccm_cmd(":GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);
}
else {
      queue_uccm_cmd("SYST:PRES", SCPI_RESET_MSG);  // use factory reset to start survey mode
      queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
}
   }
   else if(rcvr_type == VENUS_RCVR) { // gggg
      set_venus_survey(1, lat,lon,alt);  // start self survey
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      set_zod_config(3, 0.0,0.0,0.0, traim_threshold, 7);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      send_zyfer_cmd("$TRMO,P");
   }

   if(val == 0) {
      surveying = 1;
   }
// plot_lla = 1;
// show_fixes = 1;
   if(trimble_save) ;
   else if(precision_survey) ;
   else if(lat || lon || alt) { // gggggggg
      precise_lat = lat;
      precise_lon = lon;
      precise_alt = alt;
      have_precise_lla = (-2);

      #ifdef BUFFER_LLA
         clear_lla_points(0);
      #endif
   }
   request_survey_params();
}

void stop_self_survey(int why)
{
// set_survey_params(0, 0, 0L);
// start_self_survey(0, 5);
   if(read_only) return;
   if(luxor) return;

if(0 && debug_file) fprintf(debug_file, "stop self survey:%d\n", why); //plugh

   if(rcvr_type == ESIP_RCVR) {
      set_lla(lat,lon,alt);
   }
   else if(rcvr_type == FURUNO_RCVR) {
      sprintf(out, "GPset,Z1");  // Z1=3D positioning
      minor_alarms &= (~MINOR_SURVEY);
      do_survey = 0;
      survey_length = 0;
      send_furuno_cmd("GPsrq");
   }
   else if(rcvr_type == MOTO_RCVR) {
      set_rcvr_mode(RCVR_MODE_HOLD);   // position hold mode
   }
   else if(rcvr_type == NVS_RCVR) {
      send_nvs_start(0x1D);
      send_byte(0x00);
      send_byte(0x01);
      send_nvs_end();
   }
   else if(rcvr_type == SCPI_RCVR) { 
if(debug_file) {
   fprintf(debug_file, "### stop survey\n");
   fflush(debug_file);
}
//    queue_scpi_cmd(":GPS:POS LAST", SCPI_POS_MSG);   // use old saved position
      extend_com_timeout(0.0);
      if(scpi_type == NORTEL_TYPE) {
         set_lla(lat,lon,alt);
         queue_scpi_cmd("GPS:POS:SURVEY:PROGRESS?", SCPI_PROGRESS_MSG);
      }
      else {
         queue_scpi_cmd(":GPS:POS SURV", SCPI_POS_MSG);   // use position calculated so far
         queue_scpi_cmd(":PTIM:GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);
      }
   }
   else if(rcvr_type == TM4_RCVR) {
      send_tm4_cmd("#07,1");
      set_lla(lat, lon, alt);
   }
   else if(rcvr_type == TRUE_RCVR) {
      set_lla(lat, lon, alt);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(ACU_360 || ACU_GG || saw_icm || (res_t == RES_T_360)) {
         set_lla(lat,lon,alt);
      }
      else {
         set_rcvr_mode(RCVR_MODE_HOLD);
      }
   }
   else if(rcvr_type == UBX_RCVR) {  // zorky // go to position hold at current LLA
      set_ubx_config(2, lat,lon,alt);  
   }
   else if(rcvr_type == UCCM_RCVR) {  // go to position hold at current LLA
      set_lla(lat,lon,alt);
   }
   else if(rcvr_type == VENUS_RCVR) { 
      set_venus_survey(2, lat,lon,alt); // go to position hold at current LLA 
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      set_zod_config(5, 0.0,0.0,0.0, traim_threshold, 8);
   }
   else if(rcvr_type == ZYFER_RCVR) {
      set_lla(lat, lon, alt);
   }
}


void request_primary_timing()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else if(PALISADE) return;
   else if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xAB);
   send_byte(0x02);
   send_tsip_end();
}

void request_secondary_timing()
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else if(PALISADE) return;
   else if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xAC);
   send_byte(0x02);
   send_tsip_end();
}

void request_ae_packet(u08 subcode)
{
   if(luxor) return;
   if(no_poll) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(ACU_GG) return;
   if(ACU_360) return;
   if(ACUTIME) return;
   if(PALISADE) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0xAE);
   send_byte(subcode);
   send_tsip_end();
}


//
//
//   Incoming TSIP message handlers
//
//

void get_ebolt_version()
{   // ThunderBolt-E only
u08 rsvd1;
u08 major;
u08 minor;
u08 build;
u08 len;
int i;

   log_packet_id("Packet 0x1C (Tbolt-E version)");

   rev_month = rev_day = rev_hour = 0;
   rev_year = 0;

   subcode = tsip_byte();
   if(subcode == 0x81) {  // firmware version
      rsvd1 = tsip_byte();
      major = tsip_byte();
      minor = tsip_byte();
      build = tsip_byte();
      rev_month = tsip_byte();
      rev_day = tsip_byte();
      rev_year = tsip_word();
      len = tsip_byte();
  
      out[0] = 0;
      for(i=0; i<len; i++) {
         if(i >= MAX_TEXT_COLS) {
            tsip_byte();
            continue;
         }
         out[i] = tsip_byte();
         out[i+1] = 0;
      }
  
      strupr(out);
   }
   else if(subcode == 0x83) {  // hardware version
      ebolt_serno = tsip_dword();
      rev_day = tsip_byte();
      rev_month = tsip_byte();
      rev_year = tsip_word();
      rev_hour = tsip_byte();
      hw_code = tsip_word();
      len = tsip_byte();

      for(i=0; i<UNIT_LEN; i++) unit_name[i] = ' ';
      unit_name[UNIT_LEN] = 0;

      out[0] = 0;
      for(i=0; i<len; i++) {   // get hardware id
         if(i >= MAX_TEXT_COLS) {
            tsip_byte();
            continue;
         }
         out[i] = tsip_byte();  // string can have: ICM, RES SMT, RES360, ACUTIME
         out[i+1] = 0;
         if(i < UNIT_LEN) {
            unit_name[i] = out[i];
         }
      }

      strupr(out);
      if(ACU_GG) ;
      else if(ACU_360) ;       // ACUTIME GG/360 already detected
      else if(ACUTIME) ;  // ACUTIME already detected
      else if(PALISADE) ; // PALISADE already detected
      else if(res_t) ;    // res_t already detected
      else if(saw_icm) ;  // icm already detected
      else { // attempt to identify TSIP receiver type
         if(strstr(out, "ACUTIME")) {
            tsip_type = ACUTIME_TYPE;
            acu_type = '1';
            if(strstr(out, "360")) {  // Acutime 360
               acu_type = '3';
            }
            else if(strstr(out, "GG")) {  // Acutime GG
               acu_type = 'G';
            }

            config_msg_ofs();
            config_rcvr_plots();
         }
         else if(strstr(out, "ICM")) { // !!!!!! ICM RES SMT
            saw_icm = 1;
            saw_gpsdo = 2;
            config_msg_ofs();
            config_rcvr_plots();
         }
         else if(strstr(out, "PALISADE")) {  // PALISADE does not actually output 0x1C-83 messages
            tsip_type = PALISADE_TYPE;
            config_msg_ofs();
            config_rcvr_plots();
         }
         else if(strstr(out, "RESOLUTION")) {
            if(user_set_res_t) ;
            else if(strstr(out, "SMT")) res_t = RES_T_SMT;
            else                        res_t = RES_T;
            config_msg_ofs();
            config_rcvr_plots();
         }
         else if(strstr(out, "RES SMT")) {
            if(!user_set_res_t) res_t = RES_T_RES;
            config_msg_ofs();
            config_rcvr_plots();
         }
         else if(strstr(out, "RES360")) {
            if(!user_set_res_t) res_t = RES_T_360;
            config_msg_ofs();
            config_rcvr_plots();
         }
      }

      if(mini_t == 0) {
         if(strstr(out, "MINI")) {
            mini_t = 1;
            saw_mini = 1;
            config_msg_ofs();
            config_rcvr_plots();
         }
      }

      strncpy(unit_name, out, UNIT_LEN);
      unit_name[UNIT_LEN-1] = 0;
   }
   else {  // unknown
      //!!! process packet contents
   }

   check_tsip_end(1);   
   if(tsip_error) return;

   saw_ebolt();
   tbolt_e |= 0x08;
   saw_version |= 0x02;

   if(1) {  //!!!!!
      if(rev_month > 12) return;
      if(rev_month == 0) return;
      if(rev_day > 31) return;
      if(rev_day == 0) return;
      if(rev_year < 1990) return;
      if(rev_year > 2100) return;
      if(rev_hour > 24) return;
   }

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(just_read) return;

   if(0 && (subcode == 0x83)) {  // !!! disabled since hw_code clashes with sn_prefix
      show_ebolt_info();
   }
}

void get_almanac_data()
{
int prn;

   log_packet_id("Packet 0x40 - Almanac data");

   prn = tsip_byte();
   tsip_single();   // seconds
   tsip_word();     // week
   tsip_single();   // eccentricity
   tsip_single();   // T_oa
   tsip_single();   // I_o
   tsip_single();   // OMEGA_dot
   tsip_single();   // sqrt(A)
   tsip_single();   // OMEGAo
   tsip_single();   // omega
   tsip_single();   // Mo
   check_tsip_end(1);
   if(tsip_error) return;
}

void get_gps_time()
{
float gps_tow;
u16 xgps_week;
float gps_utc_offset;

   log_packet_id("Packet 0x41 - GPS time");

   gps_tow = sv6_tow = tsip_single();
   xgps_week = sv6_week = tsip_word();
   faked_tow = 0;
   gps_utc_offset = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;

   saw_sv6_time = 1;

//sv6_tow = (float) (int) (gps_tow + 0.50);

   if(SV6_FAMILY || (have_pri_time == 0)) {
      have_week = 33;
      gps_week = xgps_week;
      tow = (u32) gps_tow;  
      pri_tow = tow;
      this_tow = tow;
      survey_tow = tow;

      if(have_tow == 0) need_redraw = 3029;
      have_tow = 55;
   }

   if(SV6_FAMILY || (have_pri_time == 0)) {
      if(!user_set_utc_ofs && gps_utc_offset) utc_offset = (int) gps_utc_offset;
      check_utc_ofs(33);
   }
}

void get_single_ecef_fix()
{
float fix_x,fix_y,fix_z;
float time_of_fix;

   log_packet_id("Packet 0x42 (XYZ ECEF)");

   fix_x = tsip_single();
   fix_y = tsip_single();
   fix_z = tsip_single();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;
}

void get_velocity_fix()
{
float x_vel,y_vel,z_vel;
float bias_rate;
float time_of_fix;

   log_packet_id("Packet 0x43 (XYZ ECEF velocity)");

   x_vel = tsip_single();
   y_vel = tsip_single();
   z_vel = tsip_single();
   bias_rate = tsip_single();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_sv6_sat_list()
{
int prn[4];
int mode;

   log_packet_id("Packet 0x44 (SV6_FAMILY sats and dops - nav mode)");

   mode = tsip_byte();   // mode
   if(ACU_GG) ;
   else if(ACU_360) ;
   else if(ACUTIME) ;
   else {
      if     (mode == 0x01) rcvr_mode = RCVR_MODE_SINGLE;    // auto modes
      else if(mode == 0x03) rcvr_mode = RCVR_MODE_2D;
      else if(mode == 0x04) rcvr_mode = RCVR_MODE_3D;
      else if(mode == 0x11) rcvr_mode = RCVR_MODE_SINGLE;    // maunal modes
      else if(mode == 0x13) rcvr_mode = RCVR_MODE_2D;
      else if(mode == 0x14) rcvr_mode = RCVR_MODE_3D;
      else                  rcvr_mode = RCVR_MODE_UNKNOWN;
   }

   prn[0] = tsip_byte();   // prn1
   prn[1] = tsip_byte();   // prn2
   prn[2] = tsip_byte();   // prn3
   prn[3] = tsip_byte();   // prn4

   have_dops = 0;
   pdop = tsip_single();
   hdop = tsip_single();
   vdop = tsip_single();
   tdop = tsip_single();

   if(pdop > 20.0) pdop = 20.0;
   if(hdop > 20.0) hdop = 20.0;
   if(vdop > 20.0) vdop = 20.0;
   if(tdop > 20.0) tdop = 20.0;

   have_dops |= (PDOP | HDOP | VDOP | TDOP);
}

int fix_month(int month)
{
   if(month < 0) return 0;
   if(month > 12) return 0;
   return month;
}


void get_version_info()
{
   log_packet_id("Packet 0x45 (Software version)");

   ap_major = tsip_byte();
   ap_minor = tsip_byte();
   ap_month = tsip_byte();
   ap_day = tsip_byte();
   ap_year = tsip_byte();
   if(ap_year > TRUNC_YEAR) ap_year += 1900;
   else                     ap_year += 2000;

   core_major = tsip_byte();
   core_minor = tsip_byte();
   core_month = tsip_byte();
   core_day = tsip_byte();
   core_year = tsip_byte();
   if(core_year > TRUNC_YEAR) core_year += 1900;
   else                       core_year += 2000;

   if(ap_month > 12) ap_month = 0;
   if(core_month > 12) core_month = 0;

   if((ap_major == 1) && (core_major == 1) && (core_year == 0)) {
      datum_flag = 1;
   }
   else if((ap_major == 5) && (ap_minor == 10) && (core_year == 1997)) {  // sv6 flag
      if(1 && (tsip_type == 0) && (sv6_flag == 0)) {  // most common SV6 firmware
         tsip_type = SV6_TYPE;
         config_rcvr_type(0);
         need_msg_init = 2002;
      }
      sv6_flag = 1;
   }

   check_tsip_end(1);
   if(tsip_error) return;

   saw_version |= 0x01;

   if(ap_month > 12) return;
   if(ap_month == 0) return;
   if(ap_day > 31) return;
   if(ap_day == 0) return;
   if(core_month > 12) return;
   if(core_month == 0) return;
   if(core_day > 31) return;
   if(core_day == 0) return;
   if(ap_year < 1980) return;
   if(ap_year > 2080) return;
   if(core_year < 1980) return;
   if(core_year > 2080) return;

   have_info |= VERSION_INFO;

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
if(just_read) return;

   show_version_header();
}

void get_ebolt_health1()
{
u08 sv_fix;
u08 antenna_fault;

   log_packet_id("Packet 0x46 (Tbolt-E health)");

   sv_fix = tsip_byte();
   antenna_fault = tsip_byte();
   check_tsip_end(1);
   if(tsip_error) return;

   saw_version |= 0x04;
   saw_ebolt();
   tbolt_e |= 0x01;

   if(SV6_FAMILY) {
      have_critical_alarms = 33;
//    if(antenna_fault & 0x01) critical_alarms |= CRIT_RAM;      // alarm could be no backup battery
//    else                     critical_alarms &= (~CRIT_RAM);
      if(antenna_fault & 0x02) critical_alarms |= CRIT_FPGA;
      else                     critical_alarms &= (~CRIT_FPGA);
      if(antenna_fault & 0x0C) critical_alarms |= CRIT_GPS;
      else                     critical_alarms &= (~CRIT_GPS);
      if(antenna_fault & 0x20) critical_alarms |= CRIT_OCXO;
      else                     critical_alarms &= (~CRIT_OCXO);

      if(antenna_fault & 0x10) minor_alarms |= MINOR_ANT_NO_PWR;
      else                     minor_alarms &= (~MINOR_ANT_NO_PWR);
      have_antenna = 33;
   }
}


void get_sig_levels()
{
u08 count;
int i;
int prn;
float sig_level;

   log_packet_id("Packet 0x47 (Signal levels)");

   for(i=1; i<=MAX_PRN; i++) {  
      sat[i].level_msg = 0x00;
      if(ACU_GG || ACU_360) sat[i].tracking = 0x00;  // rnx
      if(1 || log_db) sat[i].sig_level = 0;
   }

   count = tsip_byte();
   for(i=0; i<count; i++) {
      prn = tsip_byte();
      sig_level = tsip_single();
      if(prn > MAX_PRN) prn = 0;  // put any bogus data in unused entry in array
      sat[prn].sig_level = sig_level;
      sat[prn].level_msg = 0x47;
      have_snr |= rinex_gnss(prn);

      if(ACU_GG || ACU_360) {  // rnx
         if(sat[prn].azimuth == 0.0F) sat[prn].tracking = (-1);
         else if(sat[prn].elevation == 0.0F) sat[prn].tracking = (-1);
         else if(sig_level < 0.0) sat[prn].tracking = (-1);
         else if(sig_level > 0.0) sat[prn].tracking = (1);
      }
      if(SV6_FAMILY) {
         if(amu_mode == 0) {
            sat[prn].sig_level = amu_to_dbc(sat[prn].sig_level);
         }
      }
   }
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_system_msg()
{
int i;

// response to 0x28 GPS system message request
   log_packet_id("Packet 0x48 (GPS system message)");

   for(i=0; i<22; i++) msg_field[i] = tsip_byte();
   msg_field[22] = 0;
//strcpy(debug_text, msg_field);
if(debug_file) fprintf(debug_file, "# GPS system message:%s\n", msg_field);
}


void get_alm_health()
{
int i;

   log_packet_id("Packet 0x49 (Almanac health page)");
   for(i=1; i<=32; i++) {
//    sat[i].health_flag = tsip_byte();
      if(tsip_byte()) sat[i].health_flag = 1;  // unhealthy
      else            sat[i].health_flag = 0;  // healthy
   }
   check_tsip_end(1);
   if(tsip_error) return;
}

void get_single_lla_fix()
{
float lat, lon, alt;
float clock_bias;
float time_of_fix;

//  A different (9 byte) packet is sent in response to packet 2A:
//     single: alt above WGS84 or MSL
//     single: reserved
//     byte:   flag

   log_packet_id("Packet 0x4A (LLA fix)");
   lat = tsip_single();
   lon = tsip_single();
   alt = tsip_single();
   clock_bias = tsip_single();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;

// show_lla(100);
}

void get_ebolt_health2()
{
u08 id;
u08 rtc;
u08 superpackets;

   log_packet_id("Packet 0x4B (Tbolt-E health)");

   id = tsip_byte();           // sv6=1B
   rtc = tsip_byte();
   superpackets = tsip_byte();
   check_tsip_end(1);
   if(tsip_error) return;

   saw_version |= 0x08;
   saw_ebolt();
   tbolt_e |= 0x02;

   if(SV6_FAMILY) {
      if(rtc & 0x08) minor_alarms |= MINOR_ALMANAC;
      else           minor_alarms &= (~MINOR_ALMANAC);

//    if(rtc & 0x02) minor_alarms |= MINOR_ALMANAC;      // no time at power-up
//    else           minor_alarms &= (~MINOR_ALMANAC);

      if(rtc & 0x05) critical_alarms |= CRIT_FPGA;
      else           critical_alarms &= (~CRIT_FPGA);
      have_critical_alarms = 34;
   }
}


void get_sv6_config()
{
float el_val;
float amu_val;

   log_packet_id("Packet 0x4C (SV6_FAMILY receiver config)");

   dynamics_code = tsip_byte();
   el_val = tsip_single();
   amu_val = tsip_single();
   pdop_mask = tsip_single();
   have_pdop_mask |= 0x01;
   pdop_switch = tsip_single();
   have_pdop_mask |= 0x02;
   check_tsip_end(1);
   if(tsip_error) return;
//sprintf(debug_text, "got dyn:%d el:%f amu:%f pmask:%f sw:%f  aflag:%d  amode:%d", dynamics_code,el_val,amu_val,pdop_mask,pdop_switch, amu_flag, amu_mode);

   // stupid filtering required for STARLOC II devices
   el_val = (float) (int) ((el_val*RAD_TO_DEG) + 0.50F);
   if((el_val >= 0.0) && (el_val <= 90.0)) {
      el_mask = el_val;
      have_el_mask = 1;
   }

   if((amu_val >= 0.0) && (amu_val < 60.0)) {
      amu_mask = amu_val;
      have_amu = 1;
   }
}

void get_sv6_osc_offset()
{
float ofs;

   log_packet_id("Packet 0x4D (SV6_FAMILY osc offset)");
   ofs = tsip_single();
   check_tsip_end(1);

   osc_offset = (double)ofs/1000.0;
   have_osc_offset = 666;
   have_rcvr_osc = 666;
}

void get_set_time_response()
{
u08 ack;

   log_packet_id("Packet 0x4E (Set time response)");
   ack = tsip_byte();
   check_tsip_end(1);
}


void get_sv6_utc_info()
{
double a0;
float a1;
short delta_ls;
float tot;
double wn_lsf;
unsigned short wnt;
unsigned short dn;
short delta_lsf;
int wraps;

   log_packet_id("Packet 0x4F (UTC leapsecond info)");

   a0 = tsip_double();
   a1 = tsip_single();
   delta_ls = tsip_word();
   tot = tsip_single();
   wnt = tsip_word();
   wn_lsf = (double) (short) tsip_word();
   wraps = gps_week / 1024;
   wn_lsf += (wraps * 1024);
// while(wn_lsf < (double) gps_week) {  // adjust for week rollovers
//    wn_lsf += 1024.0;
// }
   dn = tsip_word();
   delta_lsf = tsip_word();

   minor_alarms &= (~MINOR_LEAP_PEND);
   if(delta_ls != delta_lsf) {
      minor_alarms |= MINOR_LEAP_PEND;
   }
   calc_leap_days(wn_lsf, dn, 10);
   have_leap_info = 33;
}


void sv6_time_code(float time_of_fix)
{
double jd;

   if(time_of_fix < 0.0F) {
      time_flags |= TFLAGS_INVALID;
   }
   else if(ACU_GG || ACU_360 || ACUTIME) {
      time_flags &= (~TFLAGS_INVALID);
      if(ACU_GG) return;
      if(ACU_360) return;
      if(ACUTIME) return;
      request_gps_time();
      request_osc_offset();
   }
   else {
      time_flags &= (~TFLAGS_INVALID);

      jd = GPS_EPOCH + ((double) sv6_week * 7.0) + jtime(0,0,0,(double)time_of_fix);
//    jd = GPS_EPOCH + ((double) sv6_week * 7.0) + jtime(0,0,1,(double)sv6_tow);
      
      set_gregorian_time(jd);

if(0 && log_file) {
   fprintf(log_file, "!@ tof:%f  %02d:%02d:%02d %f  ", time_of_fix, g_hours,g_minutes,g_seconds, g_frac);
   if(log_flush_mode) fflush(log_file);
}

      if(timing_mode == TMODE_GPS) {    // convert utc time to gps time
//mmmmm         utc_to_gps();
      }
      else {
//mmmmm         adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
      }

      update_gps_screen(666);

      request_gps_time();
      request_osc_offset();
   }
}


void get_clock_bias()
{
float bias;
float bias_rate;
float time_of_fix;
static int last_tof = (-1);

   log_packet_id("Packet 0x54 (single sat clock bias)");

   bias = tsip_single();
   bias_rate = tsip_single();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;

   if(last_tof != (int) time_of_fix) {
      if(SV6_FAMILY || PALISADE || (have_pri_time == 0)) {
         sv6_time_code(time_of_fix);
         sat_count = 1;
      }
      last_tof = (int) time_of_fix;
   }
}

void get_io_options()
{
u08 posn;
u08 vel;
u08 timing;
u08 aux;

   log_packet_id("Packet 0x55 (I/O options)");

   posn = tsip_byte();
   vel = tsip_byte();
   timing = tsip_byte();
   aux = tsip_byte();
//sprintf(debug_text, "posn:%02X  vel:%02X  timing:%02X  aux:%02X", posn,vel,timing,aux);

   if(ACU_GG || ACU_360) {  // aux not supported on these devices
      aux = amu_flag;
   }
   else if(SV6_FAMILY || ACUTIME | PALISADE) {
      aux ^= amu_flag;  // set polarity to match what a tbolt does

      if(timing & 0x01) {  // UTC time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
      else {  // GPS time
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
//sprintf(debug_text2, "tflags:%04X  tmode:%02X", time_flags, timing_mode);
      have_rcvr_tmode = 1;
   }

   if(aux & 0x08) {  // dbc mode
      level_type = "dBc";
      amu_mode = 0;
   }
   else { // amu mode
      level_type = "AMU";
      amu_mode = 1;
   }
   check_tsip_end(1);
   if(tsip_error) return;

   have_io_options = 1;
}


void get_enu_velocity_fix()
{
float x_vel,y_vel,z_vel;
float bias_rate;
float time_of_fix;

   log_packet_id("Packet 0x56 (ENU velocity)");

   x_vel = tsip_single();
   y_vel = tsip_single();
   z_vel = tsip_single();
   bias_rate = tsip_single();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_last_fix_info()
{
u08 source_of_fix;
u08 tracking_mode;
float time_of_fix;
u16 week_of_fix;

   log_packet_id("Packet 0x57 (last fix info)");

   source_of_fix = tsip_byte();
   tracking_mode = tsip_byte();
   time_of_fix = tsip_single();
   week_of_fix = tsip_word();
   check_tsip_end(1);
   if(tsip_error) return;
}

void check_eph_val(int i, int prn)
{
return;
   if(tsip_error & RANGE_ERROR) {
      if(log_file) fprintf(log_file, "#eph range error: in val %d. prn:%d  flag:%d  valid:%d\n", i, prn,sat[prn].eph_flag,sat[prn].eph_valid);
      tsip_error &= (~RANGE_ERROR);
   }
}

void parse_tsip_ephem(int prn, int len)
{
   // decode the satellite ephemeris message
   prn = tsip_byte();

   if(prn < 1) return;
   if(prn > 32) return;

   sat[prn].t_ephem = (double) tsip_single();
//sprintf(debug_text, "prn:%d  len:%d  flag:%02X  t_ephm:%.9f  polled:%08lX", prn,len, sat[prn].eph_flag, sat[prn].t_ephem, eph_polled);
//if(debug_file) fprintf(debug_file, "prn:%d  len:%d  flag:%02X  t_ephm:%.9f\n", prn,len, sat[prn].eph_flag, sat[prn].t_ephem);

   sat[prn].eph_week = tsip_word();   // !!!!! we need to fix for rollover !!!!!
   sat[prn].codeL2 = tsip_byte();   
   sat[prn].L2Pdata = tsip_byte();  
   sat[prn].sv_accu_raw = tsip_byte();
   sat[prn].sv_health = tsip_byte();
   sat[prn].iodc = tsip_word(); 
   sat[prn].tGD = (double) tsip_single();
check_eph_val(1, prn);
   sat[prn].toc = (double) tsip_single();
check_eph_val(2, prn);
   sat[prn].af2 = (double) tsip_single();
check_eph_val(3, prn);
   sat[prn].af1 = (double) tsip_single();
check_eph_val(4, prn);
   sat[prn].af0 = (double) tsip_single();
check_eph_val(5, prn);
   sat[prn].eph_sv_accu = (double) tsip_single();
check_eph_val(6, prn);
   sat[prn].eph_iode = tsip_byte();
check_eph_val(7, prn);
   sat[prn].fit_interval = tsip_byte();
check_eph_val(8, prn);
   sat[prn].Crs = (double) tsip_single();
check_eph_val(9, prn);
   sat[prn].delta_n = (double) tsip_single();
check_eph_val(10, prn);
   sat[prn].M0 = tsip_double();
check_eph_val(11, prn);
   sat[prn].Cuc = (double) tsip_single();
check_eph_val(12, prn);
   sat[prn].e = tsip_double();
check_eph_val(13, prn);
   sat[prn].Cus = (double) tsip_single();
check_eph_val(14, prn);
   sat[prn].sqrtA = tsip_double();
check_eph_val(15, prn);
   sat[prn].eph_toe = (double) tsip_single();
check_eph_val(16, prn);
   sat[prn].Cic = (double) tsip_single();
check_eph_val(17, prn);
   sat[prn].omega_0 = tsip_double();
check_eph_val(18, prn);
   sat[prn].Cis = (double) tsip_single();
check_eph_val(19, prn);
   sat[prn].io = tsip_double(); 
check_eph_val(20, prn);
   sat[prn].Crc = (double) tsip_single();
check_eph_val(21, prn);
   sat[prn].omega = tsip_double();
check_eph_val(22, prn);
   sat[prn].omega_dot = (double) tsip_single();
check_eph_val(23, prn);
   sat[prn].i_dot = (double) tsip_single();
check_eph_val(24, prn);
   sat[prn].axis = tsip_double(); // sqrt(A)2
check_eph_val(25, prn);
   sat[prn].n = tsip_double();
check_eph_val(26, prn);
   sat[prn].r1me2 = tsip_double();
check_eph_val(27, prn);
   sat[prn].omega_n = tsip_double();
check_eph_val(28, prn);
   sat[prn].odot_n = tsip_double();
check_eph_val(29, prn);

   sat[prn].eph_valid = 1;
   if(tsip_error) sat[prn].eph_valid = 0;
   if(sat[prn].t_ephem < 0.0) sat[prn].eph_valid = 0;
   if(sat[prn].sqrtA == 0.0)  sat[prn].eph_valid = 0;  // missing ephem will have 0.0 sqrtA
if(0 && log_file) fprintf(log_file, "#t_ephem: %f\n", sat[prn].t_ephem);

//sprintf(debug_text2, "omega_0: %.9f", sat[prn].omega_0); 
//if(debug_file) fprintf(debug_file, "omega_0:%.9f\n", sat[prn].omega_0); 
}


#define CP_WRAP 0    // don't do code phase wrap mode (Acutime GG)
// #define CP_WRAP 1    // do do code phase wrap mode (Thunderbolt)

void calc_sat_posn(int prn)
{
int j;
double mu;
double omega_dot_earth;
double A;
double cmm;
double tk;
double n;
double mk;
double Ek;
double nu;
double Phi;
double du,dr,di;
double u;
double r;
double i;
double x_prime;
double y_prime;
double sat_x, sat_y, sat_z;
double omega;
int compute_harmonic_correction;
double E;
double pr;

int iii;
int cp_wrap;
double p1,p2;
double pr0;
double pr1, pr2, pr3;
static double last_pr = 0.0;

   // calculate sat position from ephermeris data, then convert distance to
   // sat into a pseudorange value.
if(0 && log_file) fprintf(log_file, "# prn:%d  eph_flag:%d  eph_valid:%d\n", prn, sat[prn].eph_flag,sat[prn].eph_valid); // rnx3

   if(prn < 1) return;
   if(prn > 32) return;

   pr = 0.0;
   if(sat[prn].eph_flag == 0) {
      sat[prn].iii = (-1);
      goto no_range;
   }
   if(sat[prn].eph_valid == 0) {
      sat[prn].iii = (-1);
      goto no_range;
   }

   compute_harmonic_correction = 1;

   mu = 3.986005e14;
   omega_dot_earth = 7.2921151467e-5; //(rad/sec)

   // Now follow ICD table 20-IV
   A = sat[prn].sqrtA;
   A *= A;

   cmm = sqrt(mu/(A*A*A)); // computed mean motion
   tk = sat[prn].raw_time - sat[prn].eph_toe;

   // account for beginning of end of week crossover
   if(tk > 302400.0)  tk = tk - 604800.0;
   if(tk < -302400.0) tk = tk + 604800.0;

   // apply mean motion correction
   n = cmm + sat[prn].delta_n;

   // Mean anomaly
   mk = sat[prn].M0 + n*tk;

   // solve Kepler's equation for eccentric anomaly
   E = mk;
   Ek = 0.0;
   for(j=0; j<30; j++) {  // Kepler's equation
      Ek = E;
      E -= (E - sat[prn].e*sin(E) - mk) / (1.0-sat[prn].e*cos(E));
      if(fabs(E - Ek) < 1.0E-14) break;
   }

   // True anomaly:
   nu = atan2( (sqrt(1.0-(sat[prn].e*sat[prn].e))*sin(Ek)/(1.0-sat[prn].e*cos(Ek))), 
               ((cos(Ek)-sat[prn].e)/(1.0-sat[prn].e*cos(Ek))) );
   // Ek = acos((e + cos(nu)) / (1.0+e*cos(nu)));

   Phi = nu + sat[prn].omega;
   du = 0.0;
   dr = 0.0;
   di = 0.0;
   if(compute_harmonic_correction == 1) {    // compute harmonic corrections
      du = sat[prn].Cus*sin(2.0*Phi) + sat[prn].Cuc*cos(2.0*Phi);
      dr = sat[prn].Crs*sin(2.0*Phi) + sat[prn].Crc*cos(2.0*Phi);
      di = sat[prn].Cis*sin(2.0*Phi) + sat[prn].Cic*cos(2.0*Phi);
   }

   u = Phi + du;
   r = A*(1.0-sat[prn].e*cos(Ek)) + dr;

   // inclination angle at reference time
   i = sat[prn].io + sat[prn].i_dot*tk + di;
   x_prime = r*cos(u);
   y_prime = r*sin(u);
   omega = sat[prn].omega_0 + (sat[prn].omega_dot - omega_dot_earth)*tk - omega_dot_earth*sat[prn].toe;

   sat_x = x_prime*cos(omega) - y_prime*cos(i)*sin(omega);
   sat_y = x_prime*sin(omega) + y_prime*cos(i)*cos(omega);
   sat_z = y_prime*sin(i);
   if(sat_x != sat_x) goto no_range;  // rnx - kludgy NAN check
   if(sat_y != sat_y) goto no_range;
   if(sat_z != sat_z) goto no_range;

   lla_to_ecef(lat,lon,alt);
   du = (ecef_x - sat_x);
   dr = (ecef_y - sat_y);
   di = (ecef_z - sat_z);
   pr = sqrt(du*du + dr*dr + di*di);

   iii = (-1);
   if(1) { // piss - adjust raw pseudorange for code_phase
      pr0 = pr;
if(CP_WRAP == 0) sat[prn].iii = (-1);
      if(sat[prn].iii < 0) {
         iii = (int) (pr / (LIGHTSPEED*1000.0 * 1.0e-3));
         p1 = p2 = sat[prn].code_phase/(16.0*1023.0)*1e-3;
         p1 += (double) iii * 1.0e-3;
         p2 += (double) (iii+1) * 1.0e-3;
         if(fabs(pr - p1) > fabs(pr - p2)) ++iii;
         sat[prn].iii = iii;
      }
      iii = sat[prn].iii;

      cp_wrap = 0;
      if(CP_WRAP) { 
         if((sat[prn].code_phase > 15000.0) && (sat[prn].last_cp < 1000.0)) cp_wrap = (-1);
         else if((sat[prn].code_phase < 1000.0) && (sat[prn].last_cp > 15000.0)) cp_wrap = (1);
         iii += cp_wrap;
         sat[prn].iii = iii;
      }

if(0 && (prn == plot_prn) && debug_file) {  //piss
   if(cp_wrap) fprintf(debug_file, "code phase wrap %d!\n", cp_wrap);
   fprintf(debug_file, "prn:%-2d iii:%d  pr0:%.4f ", 
                        prn,     iii,    pr0);
}

      /* Check which is closest to pseudorange */
      pr1 = ((double) (iii-1) * 1.0e-3) + sat[prn].code_phase/(16.0*1023.0)*1e-3;
      pr1 *= (LIGHTSPEED*1000.0);
      pr2 = ((double) iii * 1.0e-3) + sat[prn].code_phase/(16.0*1023.0)*1e-3;
      pr2 *= (LIGHTSPEED*1000.0);
      pr3 = ((double) (iii+1) * 1.0e-3) + sat[prn].code_phase/(16.0*1023.0)*1e-3;
      pr3 *= (LIGHTSPEED*1000.0);

////  if(fabs(pr - p1) > fabs(pr - p2)) ++iii;
      pr = ((double) iii * 1.0e-3) + sat[prn].code_phase/(16.0*1023.0)*1e-3;
      pr *= (LIGHTSPEED*1000.0);
   }

if(0 && (prn == plot_prn) && debug_file) {  //piss
   fprintf(debug_file, "iii2:%d  iiix:%d pr1:%.3f pr2:%.3f pr3:%.3f pr:%.3f  cp:%g  dpr:%.3f\n", 
      iii, sat[prn].iii, pr1,pr2,pr3, pr, sat[prn].code_phase, pr-last_pr);
   last_pr = pr;
}


if(0 && debug_file) {
   fprintf(debug_file, "ex:%.9f ey:%.9f  ez:%.9f\n", ecef_x,ecef_y,ecef_z);
   fprintf(debug_file, "sx:%.9f sy:%.9f  sz:%.9f\n", sat_x,sat_y,sat_z);
   fprintf(debug_file, "dx:%.9f dy:%.9f  dz:%.9f\n", du,dr,di);
   fprintf(debug_file, "prn:%d  flag:%d  valid:%d  prange:%.9f  (pr0:%.9f)   time:%.9f\n", prn, sat[prn].eph_flag, sat[prn].eph_valid, pr, pr0, sat[prn].raw_time);
   fprintf(debug_file, "\n");
}
   
   if(pr) {
      have_range |= rinex_gnss(prn);
   }

   no_range:
   sat[prn].range = pr;
}

void parse_tsip_utc(int prn, int len)
{
int i;
double a0;
float a1;
short delta_ls;
float tot;
double wn_lsf;
unsigned short wnt;
unsigned short dn;
short delta_lsf;
int wraps;

   for(i=4; i<=16; i++) {
      tsip_byte();
   }                      
   a0 = tsip_double();
   a1 = tsip_single();
   delta_ls = tsip_word();
   tot = tsip_single();
   wnt = tsip_word();
   wn_lsf = (double) (short) tsip_word();
   wraps = gps_week / 1024;
   wn_lsf += (wraps * 1024);
//      while(wn_lsf < (double) gps_week) {  // adjust for week rollovers
//         wn_lsf += 1024.0;
//      }
   dn = tsip_word();
   delta_lsf = tsip_word();

   calc_leap_days(wn_lsf, dn, 10);

//sprintf(plot_title, "dls:%d  wnlsf:%g  dn:%d  dlsf:%d   wks:%d  days:%d  %d/%d/%d", 
//delta_ls, wn_lsf, dn, delta_lsf, (int) wn_lsf-gps_week, leap_days, g_year,g_month,g_day);
}


void get_packet_58()
{
int i;
u08 op;
u08 mode;
int prn;
u08 len;

   log_packet_id("Packet 0x58 (GPS system data)");
   op = tsip_byte();
   mode = tsip_byte();
   prn = tsip_byte();
   len = tsip_byte();

   // mode 2: almanac
   // mode 3: health page
   // mode 4: ionosphere
   // mode 5: UTC params
   // mode 6: ephemeris

   if(mode == 0x05) {  // UTC data
      parse_tsip_utc(prn, len);
   }
   else if(mode == 0x06) { // ephemeris
// if(debug_file) fprintf(debug_file, "get pkt 0x58: op:%d  mode:%d  prn:%d  len:%d\n", op,mode,prn,len);
      parse_tsip_ephem(prn, len);  // prn gotten from message contents
   }
   else {  // unsupported RAW data
      for(i=0; i<len; i++) {   //!!! we should probably process this data
         tsip_byte();
      }
   }

   check_tsip_end(1);
   if(tsip_error) return;
}

void get_sat_health()
{
u08 op;
u08 vals[1+32];
u08 i;
u32 val;

   log_packet_id("Packet 0x59 (Sat disable/health)");

   op = tsip_byte();
   if(op == 3) {  // sat selection enabled / disabled
      val = 0;
      for(i=1; i<=32; i++) {
         sat[i].disabled = tsip_byte();
         if(!sat[i].disabled) val |= 1 << (i-1);
      }
      sats_enabled = val;
   }
   else if(op == 6) {  // sat health enabled / disabled
      for(i=1; i<=32; i++) sat[i].forced_healthy = tsip_byte();
   }
   else if((op == 0) && (tsip_type == STARLOC_TYPE)) { // bogus packet!
      for(i=1; i<=31; i++) vals[i] = tsip_byte();  // note: 00 op plus 31 bytes of zeroes
   }
   else {  // unknown type field
      for(i=1; i<=32; i++) vals[i] = tsip_byte();
   }
   check_tsip_end(1);
   if(tsip_error) return;
}

void get_raw_data()
{
int prn;
double obs_time;
float dop;
float sig_level;
static int last_prn = (-1);

   log_packet_id("Packet 0x5A (Raw measurement data)");

   prn = tsip_byte();
   if(prn < 1) prn = 0;
   else if(prn > MAX_PRN) prn = 0;  // !!!! max_sat_check - put any bogus data in unused entry in array
   if(prn == last_prn) prn = 0;  // filter duplicate message  ACU_GG - rnx
   else last_prn = prn;

   sat[prn].sample_len = tsip_single();
   if(1 || (log_db == 0)) {
      sig_level = tsip_single();
      if(0 && SV6_FAMILY) {
         if(amu_mode == 0) {
            sat[prn].sig_level = amu_to_dbc(sat[prn].sig_level);
            sat[prn].level_msg = 0x5A;
            have_snr |= rinex_gnss(prn);
         }
      }
   }
   else tsip_single();

   sat[prn].last_cp = sat[prn].code_phase;
   sat[prn].code_phase = tsip_single();
   dop = tsip_single();
   sat[prn].doppler = dop;
   sat[prn].raw_time = tsip_double();    // gps time-of-week
   check_tsip_end(1);

if(0 && debug_file) fprintf(debug_file, "prn:%02d  time:%.7f\n", prn,sat[prn].raw_time);  //rnx3


   if(sat[prn].doppler != 0.0F) {
      if(have_doppler == 0) need_redraw = 2002;
      have_doppler |= rinex_gnss(prn);
   }

   if(raw_msg_rate && sat[prn].eph_valid && sat[prn].eph_flag) { // raw Hz !!!!
      obs_time = sat[prn].raw_time;
      if((((int) (obs_time + 0.005) % raw_msg_rate) == 0) || (res_t == RES_T)) {  // round up is for ACU_360  rnx
         obs_tow = (obs_time + rollover);
         jd_obs = GPS_EPOCH + ((double) gps_week * 7.0) + jtime(0,0,0,obs_time+rollover);
      }
   }

   if(0 && (sat[prn].code_phase != 0.0F)) {  //rnx
      if(have_phase == 0) need_redraw = 2003;
      have_phase |= rinex_gnss(prn);
   }
   if(raw_msg_rate) {
      calc_sat_posn(prn);  // calculate pesduorange from ephemeris data
   }

   if(tsip_error) return;
}

void get_eph_status()
{
int prn;

   log_packet_id("Packet 0x5B (Sat ephemeris status)");

   prn = tsip_byte();
if(0 && debug_file) fprintf(debug_file, "\neph status %02d\n", prn);  //rnx3
   if((prn == 0) && (tsip_type == STARLOC_TYPE)) {  // bogus message
      for(prn=1; prn<=15; prn++) tsip_byte();
   }
   else {
      if(prn > MAX_PRN) prn = 0;  // !!!! max_sat_check - put any bogus data in unused entry in array
      if(prn < 1) prn = 0;  // !!!! max_sat_check - put any bogus data in unused entry in array

      sat[prn].eph_time = tsip_single();
      sat[prn].eph_health = tsip_byte();
      sat[prn].iode = (u08) tsip_byte();
      sat[prn].toe = tsip_single();
      sat[prn].fit_flag = tsip_byte();
      sat[prn].sv_accuracy = tsip_single();
      check_tsip_end(1);

      if(have_accu == 0) need_redraw = 2004;
      have_accu = 1;
if(0 && debug_file) {
   gregorian(0, jd_utc);
   fprintf(debug_file, "got eph status %d: %02d/%02d/%02d\n", prn, g_hours,g_minutes,g_seconds);
}
   }
   if(tsip_error) return;
}

void get_sat_tracking(int msg_fmt)
{
int prn;
float az, el;
float sig_level;

   log_packet_id("Packet 0x5C (Sat tracking)");
// also packet 5d

   have_sat_azel = 1;
   prn = tsip_byte();
   if(prn > MAX_PRN) prn = 0; // !!!! max_sat_check -  put any bogus data in unused entry in array
   else if(prn < 1) prn = 0;  // !!!! max_sat_check -  put any bogus data in unused entry in array

   sat[prn].chan = tsip_byte();
   sat[prn].chan >>= 3;
   sat[prn].acq_flag = tsip_byte();
   sat[prn].eph_flag = tsip_byte();
   if(1 || (log_db == 0)) {
      sig_level = tsip_single();
      sat[prn].sig_level = sig_level;
      have_snr |= rinex_gnss(prn);
      sat[prn].level_msg = 0x5C;
      if(SV6_FAMILY) {
         if(amu_mode == 0) {
            sat[prn].sig_level = amu_to_dbc(sat[prn].sig_level);
         }
      }
   }
   else tsip_single();

   sat[prn].time_of_week = tsip_single();

   el = tsip_single() * (float) RAD_TO_DEG;
   az = tsip_single() * (float) RAD_TO_DEG;
   set_sat_azel(prn, az,el);

//sprintf(plot_title, "trk msg %02X prn:%02d  az:%p el:%p", msg_fmt, prn, sat[prn].azimuth,sat[prn].elevation);
   sat[prn].age = tsip_byte();
   sat[prn].msec = tsip_byte();
   sat[prn].bad_flag = tsip_byte();
   sat[prn].collecting = tsip_byte();
   if(msg_fmt == 0x5D) {  // RES 360 message 0x5D
      sat[prn].how_used = tsip_byte();
      // sv_type for icm receivers:
      //   0=GPS
      //   1=Glonass
      //   2=Beidou?
      //   3=Galileo?
      //   4=SBAS
      //   5=QZSS
      sat[prn].sv_type = tsip_byte();
   }

   check_tsip_end(1);
   if(tsip_error) {
      sat[prn].level_msg = 0x00;
      return;
   }

   record_sig_levels(prn);
}


void get_fix_status()
{
int fix_status;
int meas;

   log_packet_id("Packet 0x5E (Additional fix status)");

   fix_status = tsip_byte();
   meas = tsip_byte();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_eeprom_status()
{
u08 flag;
u16 ee_status;

   log_packet_id("Packet 0x5F (EEPROM status)");

   flag = tsip_byte();
   if(flag == 0x11) {
      ee_status = tsip_word();
   }

   check_tsip_end(1);
   if(tsip_error) return;
}


void get_sat_list(int flag)
{
u08 dimension;
u08 count;
int i;
int prn;

   if(flag) log_packet_id("Packet 0x6C (GNSS satellite list)");  // also 6C
   else     log_packet_id("Packet 0x6D (Satellite list)");  // also 6C

   dimension = count = tsip_byte();
   dimension &= 0x0F;
   count >>= 4;

   if(ACU_GG || ACU_360 || ACUTIME) {
      if(0) {  // we get this from the 0x8F-AC secondary timeing message
         if     (dimension == 0x0B) rcvr_mode = RCVR_MODE_2D;      // manual 2D
         else if(dimension == 0x0C) rcvr_mode = RCVR_MODE_3D;      // manual 3D
         else if(dimension == 0)    rcvr_mode = RCVR_MODE_2D_3D;
         else if(dimension == 1)    rcvr_mode = RCVR_MODE_SINGLE;
         else if(dimension == 2)    rcvr_mode = RCVR_MODE_NO_SATS; // 2D clock hold
         else if(dimension == 3)    rcvr_mode = RCVR_MODE_2D;
         else if(dimension == 4)    rcvr_mode = RCVR_MODE_3D;
         else if(dimension == 5)    rcvr_mode = RCVR_MODE_HOLD;
         else if(dimension == 6)    rcvr_mode = RCVR_MODE_DGPS;
         else                       rcvr_mode = RCVR_MODE_2D_3D;
      }
   }
   else if(SV6_FAMILY) {
      if     (dimension == 0x0B) rcvr_mode = RCVR_MODE_2D;   // manual 2D
      else if(dimension == 0x0C) rcvr_mode = RCVR_MODE_3D;   // manual 3D
      else if(dimension == 0x03) rcvr_mode = RCVR_MODE_HOLD; // auto 2d
      else if(dimension == 0x04) rcvr_mode = RCVR_MODE_HOLD; // auto 2d/3d
      else rcvr_mode = RCVR_MODE_UNKNOWN;
//sprintf(debug_text3, "dim:%02X  rmode:%d", dimension, rcvr_mode);
   }

   have_dops = 0;
   pdop = tsip_single();
   hdop = tsip_single();
   vdop = tsip_single();
   tdop = tsip_single();

   if(pdop > 20.0) pdop = 20.0;
   if(hdop > 20.0) hdop = 20.0;
   if(vdop > 20.0) vdop = 20.0;
   if(tdop > 20.0) tdop = 20.0;

   have_dops |= (PDOP | HDOP | VDOP | TDOP);

   for(i=1; i<=MAX_PRN; i++) {  // reset current tracking flags
      if(ACU_360 || ACU_GG) ;     //rnx
      else sat[i].tracking = 0;
   }

   if(flag) {
      count = tsip_byte();
   }

   for(i=0; i<count; i++) {
      prn = tsip_byte();
      if(ACU_360) ;
      else if(prn & 0x80) {  // prn tracked,  but not used
         prn |= (~0xFF);
      }

      if(prn > MAX_PRN) prn = 0;  // put any bogus data in unused entry in array
      else if(prn < (-MAX_PRN)) prn = 0;

      if(prn < 0) {
         sat[0-prn].tracking = (-1); // prn;
      }
      else {  // prn is used in solution
         sat[prn].tracking = (1); // prn;
      }
if(0 && log_file) fprintf(log_file, "track prn %d:%d\n", prn,sat[prn].tracking);
   }
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_filter_config()
{
   log_packet_id("Packet 0x70 (Filter config)");

   pv_filter = tsip_byte();
   static_filter = tsip_byte();
   alt_filter = tsip_byte();
   kalman_filter = tsip_byte();
   have_filter = (PV_FILTER | STATIC_FILTER | ALT_FILTER | KALMAN_FILTER);
   // Note: the ACUTIME and PALISADE return this value, but is not
   //       documented.  Can we set the filters?  !!!!!
   check_tsip_end(1);
   if(tsip_error) return;

   saw_version |= 0x80;
if(just_read) return;

   saw_kalman_on |= kalman_filter;
}


void get_posn_filter()
{
int mode;
float f1,f2,f3,f4,f5;
int i1,i2,i3,i4,i5;

   log_packet_id("Packet 0x72 (SV6_FAMILY position filter)");

   mode = tsip_word();
   f1 = tsip_single();
   i1 = tsip_word();
   i2 = tsip_word();
   i3 = tsip_word();
   i4 = tsip_word();
   f2 = tsip_single();
   f3 = tsip_single();
   f4 = tsip_single();
   f5 = tsip_single();
   i5 = tsip_word();
   check_tsip_end(1);
//sprintf(debug_text3, "i: %f %f %f %f %f", f1,f2,f3,f4,f5);
//sprintf(debug_text2, "i: %d %d %d %d %d", i1,i2,i3,i4,i5);
//sprintf(debug_text, "posn:%d  err:%04X", mode, tsip_error);
   if(i5 == 65535) static_filter = 0;
   else            static_filter = 1;
   have_filter |= STATIC_FILTER;

   if(f1 == 1.0) pv_filter = 0;
   else          pv_filter = 1;
   have_filter |= PV_FILTER;
}

void get_alt_filter()
{
float mode;

   log_packet_id("Packet 0x74 (High-8 mode)");

   mode = tsip_single();
   check_tsip_end(1);

   if(tsip_error) return;
   if(mode > 1) alt_filter = 1;
   else         alt_filter = 0;
   have_filter |= ALT_FILTER;
}

void get_high8_mode()
{
   log_packet_id("Packet 0x75 (High-8 mode)");

   high8_mode = tsip_byte();
   check_tsip_end(1);
}

void get_high6_mode()
{
   log_packet_id("Packet 0x76 (Best-4 / High-6 mode)");

   high6_mode = tsip_byte();
   check_tsip_end(1);
}

void get_diff_age()
{
u16 diff_age;

   log_packet_id("Packet 0x78 (Differential correction age)");

   diff_age = tsip_word();
   check_tsip_end(1);
}

void get_diff_mode()
{
u08 diff_mode;

   log_packet_id("Packet 0x82 (Differential correction age)");

   diff_mode = tsip_byte();
   check_tsip_end(1);
}


void get_ecef_fix()
{
double clock_bias;
double fix_x,fix_y,fix_z;
float time_of_fix;

   log_packet_id("Packet 0x83 (XYZ ECEF)");

   fix_x = tsip_double();
   fix_y = tsip_double();
   fix_z = tsip_double();
   clock_bias = tsip_double();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_lla_fix()
{
double xlat, xlon, xalt;
double clock_bias;
float time_of_fix;

   log_packet_id("Packet 0x84 (LLA fix)");

   xlat = tsip_double();
   xlon = tsip_double();
   xalt = tsip_double();
   clock_bias = tsip_double();
   time_of_fix = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;

   if(SV6_FAMILY || PALISADE || (have_pri_time == 0)) {
      sv6_time_code(time_of_fix);

      lat = xlat;
      lon = xlon;
      alt = xalt;
      #ifdef PRECISE_STUFF
         precise_check();
      #endif
   }
}

void get_datums()
{
int index;
double dx;
double dy;
double dz;
double a_axis;
double ecc;

   log_packet_id("Packet 0x8F.15 (Datums)");

   index = tsip_word();
   dx = tsip_double();
   dy = tsip_double();
   dz = tsip_double();
   a_axis = tsip_double();
   ecc = tsip_double();
   check_tsip_end(1);
   if(tsip_error) return;
}


void fix_manuf_params()
{
   if(luxor) return;
   if(rcvr_type != TSIP_RCVR) return;
   if(SV6_FAMILY) return;

   send_tsip_start(0x8E);
   send_byte(0x41);
   send_word(0x1234);           //prefix
   send_dword(0x56789ABCL);     // sn
   send_byte(10);               // yr
   send_byte(1);    // mo
   send_byte(2);    //day
   send_byte(3);    // hr
   send_single(0.0F);    // build offset
   send_word(0);    // test code
   send_tsip_end();

   save_segment(0xFF, 27);
}


void get_sv6_fix()
{
double east,north,up;
int xtow;
u08 scale;
 
   log_packet_id("Packet 0x8F.20 (XYZ ECEF)");
return;  // we don't do this anymore

   tsip_byte(); // key

   east = (double) (s16) tsip_word();  // velocities
   north = (double) (s16) tsip_word();
   up = (double) (s16) tsip_word();

   xtow = tsip_dword();
   lat = (double) (s32) tsip_dword();  // location
   lon = (double) (s32) tsip_dword();
   alt = (double) (s32) tsip_dword();
   scale = tsip_byte();

   tow = pri_tow = this_tow = survey_tow = xtow/1000;
   faked_tow = 0;

   lat =  lat * PI / pow(2.0,31);
   lon =  lon * PI / pow(2.0,31);
   alt /= 1000.0;
   
   speed = sqrt(east*east + north*north + up*up);
   if(scale & 0x01) speed *= 0.020;
   else             speed *= 0.005;

   if(SV6_FAMILY || PALISADE || (have_pri_time == 0)) {
      sv6_time_code((float) xtow / 1000.0F);
      #ifdef PRECISE_STUFF
         precise_check();
      #endif
   }
}

void get_manuf_params()
{
u16 test_code;
int sum;

   log_packet_id("Packet 0x8F.41 (Manufacturing Params)");

   sn_prefix = tsip_word();
   serial_num = tsip_dword();
   build_year = sum = tsip_byte();
   if(build_year > TRUNC_YEAR) build_year += 1900;
   else                        build_year += 2000;
   build_month = tsip_byte();
   build_day = tsip_byte();
   build_hour = tsip_byte();
   build_offset = tsip_single();
   test_code = tsip_word();
   check_tsip_end(1);
   if(tsip_error) return;

   if(build_month > 12) build_month = 0;

   sum += sn_prefix + serial_num + test_code + build_month + build_day + build_hour;  // check for zeroed build params
   build_ok = ((build_month <= 12) && (build_month != 0) && 
               (build_day <= 31) && (build_day != 0) &&
               (build_year >= 1980) && (build_year <= 2080) &&
               (build_hour <= 24));

   have_build |= 0x01;
   if(build_ok) have_build |= 0x02;


   if((sum == 0) || build_ok) {
      show_manuf_params();
   }

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(just_read) return;

////show_serial_info();
}

void get_prodn_params()
{
u16 rsvd2;
u16 rsvd1;

   log_packet_id("Packet 0x8F.42 (Production Params)");

   prodn_options = tsip_byte();
   prodn_extn = tsip_byte();
   case_prefix = tsip_word();
   case_sn = tsip_dword();
   prodn_num = tsip_dword();
   rsvd1 = tsip_word();
   machine_id = tsip_word();
   rsvd2 = tsip_word();
   check_tsip_end(1);
   if(tsip_error) return;

   have_info |= PRODN_PARAMS;
}


void get_segment_info()
{
u08 seg_info;

   log_packet_id("Packet 0x8F.45 (EEPROM Segment Info)");

   seg_info = tsip_byte();
   check_tsip_end(1);
   if(tsip_error) return;
   have_seg_info = 1;
}

void get_pps_settings()
{
u08 pps_rsvd;
float bias_threshold;

   log_packet_id("Packet 0x8F.4A (PPS settings)");

   pps_enabled = tsip_byte();
   have_pps_enable = 1;
   pps_rsvd = tsip_byte();
   pps_polarity = tsip_byte();
   have_pps_polarity = 1;
   cable_delay = tsip_double();
   bias_threshold = tsip_single();
   check_tsip_end(1);

// if(have_cable_delay == 0) need_redraw = 2005;
   have_cable_delay = 1;
   if(tsip_error) return;

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
if(just_read) return;

   saw_version |= 0x40;
   show_cable_delay();
}


void get_pps_mode()
{
   log_packet_id("Packet 0x8F.4E (pps rate)");

   pps_rate = tsip_byte();
   have_pps_rate = 2;
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_dac_values()
{
u32 dac_value;
float dac_voltage;
u08 dac_res;
u08 dac_format;
float dac_min, dac_max;

   log_packet_id("Packet 0x8F.A0 (DAC values)");

   dac_value = tsip_dword();
   dac_voltage = tsip_single();
   dac_res = tsip_byte();
   dac_format = tsip_byte();
   dac_min = tsip_single();
   dac_max = tsip_single();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_osc_sense()
{
   log_packet_id("Packet 0x8F.A1 (10 MHz sense)");
// not avilable on ThunderBolt-E or early ThunderBolts

   osc_polarity = tsip_byte();
   have_osc_polarity = 1;
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_timing_mode()
{
   log_packet_id("Packet 0x8F.A2 (Timing mode)");
   if(STARLOC) { // receiver randomly changes reported timing mode
      return;
   }

   timing_mode = tsip_byte();
timing_mode &= (TMODE_UTC);
if(timing_mode != TMODE_GPS) timing_mode = TMODE_UTC;
   have_rcvr_tmode = 1;
   have_timing_mode = 1;
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_packet_mask()
{
u16 mask1;
u16 mask2;

   log_packet_id("Packet 0x8F.A5 (Packet mask)");

   mask1 = tsip_word();
   mask2 = tsip_word();
   check_tsip_end(1);
   if(tsip_error) return;
}


void get_sat_solutions()
{   //not available on ThunderBolt-E
u08 format;
u32 time_of_week;
float clock_bias;
float clock_bias_rate;
float sat_bias;
int prn;
int i;

   log_packet_id("Packet 0x8F.A7 (Satellite solutions)");

   if(tsip_type == STARLOC_TYPE) {  // !!!! who knows what garbage this device craps out?
      // some of these are 9 bytes long, some are 13... we just ignore this message
      return;
   }

   format = tsip_byte();
   time_of_week = tsip_dword();

   if(format == 0) {     // floating point
      clock_bias = tsip_single();
      clock_bias_rate = tsip_single();
   }
   else if(format == 1) {   // integer values
      clock_bias = (float) (int) tsip_word();
      clock_bias *= 100.0e-12F;
      clock_bias_rate = (float) (int) tsip_word();
      clock_bias_rate *= 1.0e-12F;
   }
   else {  // invalid format
      check_tsip_end(1);
      if(tsip_error) return;
      return;
   }

   for(i=1; i<=MAX_PRN; i++) {  // reset current bias flags
      sat[i].last_bias_msg = 0;
   }

   for(i=0; i<8; i++) {  // get bias info from all satellites
      prn = tsip_byte();
      if(prn > MAX_PRN) prn = 0;  // put any bogus data in unused entry in array
      if(format == 0) {
         sat_bias = tsip_single();
      }
      else {
         sat_bias = (float) (int) tsip_word();
         sat_bias *= 100.0e-12F;
      }

      sat[prn].time_of_fix = (float) time_of_week;
      sat[prn].sat_bias = sat_bias;
      sat[prn].last_bias_msg = 1;

      if(have_bias == 0) need_redraw = 2006;
      have_bias = 1;
   }
   check_tsip_end(1);
   if(tsip_error) return;
}


void update_osc_params()
{
   user_time_constant = time_constant;           // get current values
   user_damping_factor = damping_factor;
   user_jam_sync = jam_sync;
   user_holdover_time = x72_holdover_val;

   user_osc_gain = osc_gain;
   user_pullin = pullin_range;

   user_initial_voltage = initial_voltage;
   user_min_volts = min_volts;
   user_max_volts = max_volts;
   user_min_range = min_dac_v;
   user_max_range = max_dac_v;

   user_max_freq_offset = max_freq_offset;

   // update current values with user set values from command line
   if(user_set_osc_param & PARAM_TC)       user_time_constant = cmd_tc;
   if(user_set_osc_param & PARAM_DAMP)     user_damping_factor = cmd_damp;
   if(user_set_osc_param & PARAM_GAIN)     user_osc_gain = cmd_gain;
   if(user_set_osc_param & PARAM_PULLIN)   user_pullin = cmd_pullin;

   if(user_set_osc_param & PARAM_INITV)    user_initial_voltage = cmd_initdac;
   if(user_set_osc_param & PARAM_MINV)     user_min_volts = cmd_minv;
   if(user_set_osc_param & PARAM_MAXV)     user_max_volts = cmd_maxv;

   if(user_set_osc_param & PARAM_JAMSYNC)  user_jam_sync = cmd_jamsync;
   if(user_set_osc_param & PARAM_MAXFREQ)  user_max_freq_offset = cmd_maxfreq;
   if(user_set_osc_param & PARAM_HOLDOVER) user_holdover_time = cmd_holdover;

   if(user_set_osc_param & PARAM_MINRANGE) user_min_range = cmd_minrange;
   if(user_set_osc_param & PARAM_MAXRANGE) user_max_range = cmd_maxrange;
   user_set_osc_param = 0;

   set_discipline_params(0);
}

void get_discipline_params()
{
u08 type;
float v1,v2,v3;
float v4,v5,v6,v7;
int osc_ok;

   log_packet_id("Packet 0x8F.A8 (Discipline params)");

   type = tsip_byte();

   if(type == 0) {
      v1 = tsip_single();
      v2 = tsip_single();
      if(STARLOC) ;
      else if(saw_ntpx) {
         v3 = tsip_single();
         v4 = tsip_single();
         v5 = tsip_single();
//sprintf(plot_title, "v: %f %f %f %f %f      ", v1,v2,v3,v4,v5);
      } 
      else if(try_nortel & 0x01) {
         v3 = tsip_single();
         v4 = tsip_single();
         v5 = tsip_single();
         v6 = tsip_single();
         v7 = tsip_single();
      }
      check_tsip_end(1);

      if(tsip_error) {
         try_nortel ^= 0x01;
         request_discipline_params(0x00);
         return;
      }

      time_constant = v1;
      have_tc = 0x01;

      damping_factor = v2;
      have_damp = 1;
      have_osc_params |= (PARAM_TC | PARAM_DAMP);

      if(STARLOC) ;
      else if(saw_ntpx) {
         osc_gain = v3;
         min_volts = v4;
         max_volts = v5;
         have_minv = have_maxv = 1;
         have_osc_params |= (PARAM_GAIN | PARAM_MINV | PARAM_MAXV);
      }
      else if(try_nortel & 0x01) {
         osc_gain = v3;
         min_volts = v4;
         max_volts = v5;
         have_minv = have_maxv = 1;
         have_osc_params |= (PARAM_GAIN | PARAM_MINV | PARAM_MAXV);

         jam_sync = v6;
         have_jam_sync = 1;
         max_freq_offset = v7;
         have_freq_ofs = 1;
         have_osc_params |= (PARAM_JAMSYNC | PARAM_MAXFREQ);

         saw_nortel |= 0x01;
         strcpy(unit_name, "Nortel NTGS/NTBW"); 
         saw_gpsdo = 4;
         if(user_set_temp_filter == 0) undo_fw_temp_filter = 0;
      }
   }
   else if(type == 1) {
      v1 = tsip_single();
      v2 = tsip_single();
      v3 = tsip_single();
      if(STARLOC) ;
      else if(try_nortel & 0x02) {
         v4 = tsip_single();
         v5 = tsip_single();
      }
      check_tsip_end(1);
      if(tsip_error) {
         try_nortel ^= 0x02;
         request_discipline_params(0x01);
         return;
      }
      if(pause_data) return;   // in case reading log file,  we don't want to change the OSC_GAIN
                               // since the user may be calculating osc parameters
      gain_color = WHITE;
      osc_gain = v1;
      have_gain = 1;
      min_volts = v2;
      max_volts = v3;
      have_minv = have_maxv = 1;
      have_osc_params |= (PARAM_GAIN | PARAM_MINV | PARAM_MAXV);

      if(STARLOC);
      else if(try_nortel & 0x02) {
         jam_sync = v4;
         have_jam_sync = 1;
         max_freq_offset = v5;
         have_freq_ofs = 1;
         saw_nortel |= 0x02;
         strcpy(unit_name, "Nortel NTGS/NTBW"); 
         saw_gpsdo = 5;
         have_osc_params |= (PARAM_JAMSYNC | PARAM_MAXFREQ);
         if(user_set_temp_filter == 0) undo_fw_temp_filter = 0;
      }
   }
   else if(saw_ntpx) {  // packets 2,3,4 have no data
      check_tsip_end(1);
      if(tsip_error) return;
   }
   else if(type == 2) {
      v1 = tsip_single();
      v2 = tsip_single();
      check_tsip_end(1);
      if(tsip_error) return;

      jam_sync = v1;
      have_jam_sync = 1;
      max_freq_offset = v2;
      have_freq_ofs = 1;
      have_osc_params |= (PARAM_JAMSYNC | PARAM_MAXFREQ);
   }
   else if(type == 3) {
      v1 = tsip_single();
      check_tsip_end(1);
      if(tsip_error) return;

      initial_voltage = v1;
      have_initv = 1;
      have_osc_params |= (PARAM_INITV);
   }
   else if(type == 4) {     // undocumented - allowable dac range?
      v1 = tsip_single();
      v2 = tsip_single();
      check_tsip_end(1);
      if(tsip_error) return;

      min_dac_v = v1;
      max_dac_v = v2;
      have_dac_range = 1;
      have_osc_params |= (PARAM_MINRANGE | PARAM_MAXRANGE);
   }
   else {
      check_tsip_end(1);
      if(tsip_error) return;
   }

   if((have_osc_params & PARAM_TBOLT) == PARAM_TBOLT) {  // !!!!! 0x0F: we have all osc params available
      osc_ok = 1;
   }
   else if(saw_ntpx && ((have_osc_params & PARAM_NTPX) == PARAM_NTPX)) {
      osc_ok = 1;
   }
   else osc_ok = 0;


   if(1 && user_set_osc_param && osc_ok) {  // set osc params from command line values
      update_osc_params();
   }
}

void get_survey_params()
{
u08 survey_flag;
u32 rsvd;

   log_packet_id("Packet 0x8F.A9 (Survey params)");

   survey_flag = tsip_byte();
   survey_save = tsip_byte();
   survey_length = tsip_dword();
   rsvd = tsip_dword();
   check_tsip_end(1);
   if(tsip_error) return;
}


void check_for_leapsecond()
{
   // see if the receiver time code could be a leapsecond

   leap_time = 0;   // see if the time could be a leap second, if so do a screen grab and a log entry
   leap_sixty = 0;
   if(time_flags & TFLAGS_NO_UTC_OFS) return;  // time is not valid
   if(time_flags & TFLAGS_INVALID) return;
   if(rcvr_type == THERMO_RCVR) return;
   if(rcvr_type == TICC_RCVR) return;
   if((rcvr_type == TSIP_RCVR) && (tsip_type == STARLOC_TYPE)) return;  // STARLOC has too many bogus time stamps

if(0 && (pri_minutes == 00) && (pri_seconds == 0)) {  // simulate leap second time code
   pri_seconds = 60;
   pri_minutes = 59;
   if(--pri_hours < 0) pri_hours = 23;
}

   if((pri_minutes == 59) && (pri_seconds == 60)) {  // xx:59:60 leapsecond
      leap_sixty = 1;  // used to restore xx:59:60 leapsecond value from jd value
   }

   if((nav_rate != 1.0) && (raw_frac != 0.0)) ;
   else if((pri_minutes == 59) && (pri_seconds == 60)) {
      leap_time = 1;  // xx:59:60
   }
   else if((pri_minutes == 0) && (pri_seconds == 0) && (last_second == 0)) {
      leap_time = 2;  // repeated xx:00:00 second
   }
   else if((pri_minutes == 59) && (pri_seconds == 59) && (last_second == 59)) {
      leap_time = 3;  // repeated xx:59:59 second
   }

   if(leap_file && leap_time) {
      leaped = leap_time;
   }

   last_second = pri_seconds;
}


void get_comp_time()
{
int i;
char sat_id[8];

   log_packet_id("Packet 0x8F.0B (Comprehensive timing)");

   tsip_word();   // event count
   tsip_dword();  // time of week
   tsip_byte();   // day
   tsip_byte();   // month
   tsip_word();   // year
   tsip_byte();   // receiver mode
   tsip_word();   // utc offset
   tsip_double(); // osc bias  (meters)
   tsip_double(); // osc drift (meters/sec)
   tsip_single(); // osc bias uncertainty (meters)
   tsip_single(); // osc drift uncertainty (meters/sec)
   tsip_double(); // lat
   tsip_double(); // lon
   tsip_double(); // alt

   for(i=0; i<8; i++) { // id of tracking/usable sats
      sat_id[i] = tsip_byte();
   }
}

double rolls;  // how many time the gps week has rolled over

void fix_rollover()
{
double jd;

   // See if date from the receiver is likely incorrect due to week rollover
   // issues.  Attempt to fix it if it is wrong.

   if(user_set_rollover) ;    // user forced a rollover offset
   else if(fake_time_stamp) ; // faked time stamp (for Symmetricom UCCM-P)
   else if(auto_rollover && (user_set_rollover == 0) && (pri_year >= ROLLOVER_YEAR)) {  // receiver is now sending valid years
      rollover = 0.0;       // cancel the rollover fix
      auto_rollover = 0.0;
      rolled = 0;

      last_log_hours = 1234;  // force new log header write
      sprintf(log_text, "#! automatic week rollover compensation triggered. year:%d", pri_year);
      write_log_comment(1);

      if(1 && (roll_timing_msg < (ROLL_THRESH+5))) {  // reset the plot queue if rollover detection occured at Heather startup
         reset_queues(RESET_ALL_QUEUES, 4598);
      }
   }
   else if(ROLL_FILT && (time_flags & TFLAGS_NO_UTC_OFS)) {  // GPS time is not valid
      roll_filter = 0;
   }
   else if(ROLL_FILT && !have_utc_ofs) {              // no UTC offset seen yet
      roll_filter = 0;
   }
   else if(ROLL_FILT && (pri_year < 1980)) {            // should never happen
      roll_filter = 0;
   }
   else if(0 && (gps_week == 0) && ((pri_year == 1980) || (pri_year == 1999))) {  // years of first two rollover events
      get_clock_time();       // ... probably a receiver in startup mode
      pri_year = clk_year;    // ... so substitute system clock date/time
      pri_month = clk_month;
      pri_day = clk_day;
      pri_hours = clk_hours;
      pri_minutes = clk_minutes;
      pri_seconds = clk_seconds;
      pri_frac = raw_frac = clk_frac;
   }
   else if((pri_year > 0) && (pri_year < ROLLOVER_YEAR)) {   // GPS year looks bogus
      if(ROLL_FILT && (roll_filter < ROLL_THRESH)) {    // we need a few consecutive bogo years
         ++roll_filter;
      }
      else {
         get_clock_time();  // figure out how many times we rolled over from the system clock
         jd = jdate(pri_year,pri_month,pri_day) + jtime(pri_hours,pri_minutes,pri_seconds, pri_frac);
         rolls = (clk_jd -jd) / (19.0*365.0);  // 19.0 is (1024/52) rounded down (to allow for some system clock error)
//sprintf(debug_text3, "clkjd:%.9f rjd:%.9f  diff:%.9f rolls:%f", clk_jd, jd, clk_jd-jd, rolls);
         rolls = (double) (int) rolls;
         if(rolls <= 1.0) rolls = 1.0;
         rollover = rolls * (1024.0 * 7.0 * 24.0*60.0*60.0);  // rollover one 1024 week epoch
         if(rollover != auto_rollover) {  // new rollover value
            auto_rollover = rollover;

            last_log_hours = 1234;  // force log header write
            sprintf(log_text, "#! automatic week rollover compensation triggered. year:%d  rolls:%g", pri_year, rolls);
            write_log_comment(1);

            if(1 && (roll_timing_msg < (ROLL_THRESH+5))) {  // reset the plot queue if rollover detection occured at Heather startup
               reset_queues(RESET_ALL_QUEUES, 4598);
            }
//          setup_calendars(10);
         }
      }
   }
   else roll_filter = 0;

   if(rollover || user_set_rollover) {  // adjust GPS receiver time by xxx seconds
// sprintf(debug_text, "rover:%f  rolled:%d  pyear:%d", rollover, user_set_rollover, pri_year);
      adjust_rcvr_time(rollover);
      if(rolled == 0) rolled = 1;
   }
}

void fix_starloc_time()
{
double this_jd;
double delta_jd;
static double last_jd = 0.0;

   // attempt to fix skipped time stamps from the STARLOC receivers by backing
   // them up one second.  This works more times than it doesn't...

   this_jd = jdate(pri_year,pri_month,pri_day) + jtime(pri_hours,pri_minutes,pri_seconds, 0.0);
   delta_jd = this_jd - (last_jd + jtime(0,0,2, 0.0));
   if(show_debug_info && debug_file) fprintf(debug_file, "thisjd:%f  lastjd:%f  delta:%.12f (%f)\n", this_jd,last_jd, delta_jd, delta_jd*60.0*60.0*24.0);
   if(this_jd < last_jd) ; 
   else if((fabs(delta_jd) <= 0.0000001)) {  // time stamp skip detected
      this_jd -= jtime(0,0,1, 0.0); // ... back this time up a second

      gregorian(0, this_jd);
      pri_year = g_year;
      pri_month = g_month;
      pri_day = g_day;
      pri_frac = 0.0;
      pri_hours = pt_hh = g_hours;
      pri_minutes = pt_min = g_minutes;
      pri_seconds = pt_sec = g_seconds;
      this_jd = jdate(pri_year,pri_month,pri_day) + jtime(pri_hours,pri_minutes,pri_seconds, 0.0);
      if(show_debug_info && debug_file) fprintf(debug_file, "!! time stamp skip fixed! %02d:%02d:%02d -> %.6f\n", g_hours,g_minutes,g_seconds, this_jd);
      starloc_skip_delay = 3; // inhibit next 3 time stamp skip checks
   }

   last_jd = this_jd;
}


void primary_timing(int get_tsip)
{
int i;

   // process the receiver primary timing message.  For TSIP receivers, gets
   // the timing message.

   if(get_tsip) log_packet_id("Packet 0x8F.AB (Primary timing)");

   skip_starloc_time = 0;
   last_pri_tow = pt_tow;
   ++got_timing_msg;    // prevents keyboard lockup with high nav rate receivers
   ++roll_timing_msg;   // used to reset queues during startup rollover detection

   if(timeout_extended) {  // com timeout has been increased due to special commands
      --timeout_extended;
      if(timeout_extended <= 0) { // it's safe to restore the com timeout to its normal value
         com[RCVR_PORT].com_timeout = com[RCVR_PORT].user_timeout;
      }
   }

   if(get_tsip) {
      have_pri_time = 1;
      pri_tow = this_pri_tow = pt_tow = tsip_dword();
      gps_week = tsip_word();
      faked_tow = 0;

      i = (int) (s16) tsip_word();
      if(!user_set_utc_ofs && (i >= 0) && (i < 64)) {    // filter bogus values
         utc_offset = i;
         if(utc_offset != 0) utc_offset_flag = utc_offset;
         if(tsip_type == STARLOC_TYPE) {
            if(utc_offset_flag && (utc_offset == 0)) {
               utc_offset = utc_offset_flag;  // sometimes sends random 0 utc_offset value
            }
            tsip_byte();  // STARLOC_TYPE always sends bogus 0 time_flags value
         }
         else time_flags = tsip_byte();
      }
      else if(STARLOC) tsip_byte(); // STARLOC_TYPE always sends bogus 0 time_flags value 
      else time_flags = tsip_byte();
//sprintf(debug_text4, "time flag byte: %02X", time_flags);

      pri_seconds = pt_sec = tsip_byte();
      pri_minutes = pt_min = tsip_byte();
      pri_hours = pt_hh = tsip_byte();
      pri_day = tsip_byte();
      pri_month = tsip_byte();
      pri_year = tsip_word();
      pri_frac = 0.0;

      if(STARLOC) {
         if(show_debug_info && debug_file) fprintf(debug_file, "starloc time: %04d/%02d/%02d %02d:%02d:%02d\n", pri_year,pri_month,pri_day, pri_hours,pri_minutes,pri_seconds);
         if((pri_year < 1980) || (pri_year > 2100)) {  // totally bogus time/date
            goto pt_err;
         }
         fix_starloc_time();  // try to fixup time stamp skips
      }

      check_tsip_end(1);

      if(have_week == 0) need_redraw = 2007;
      have_week = 1;

      if(have_tow == 0) need_redraw = 2008;
      have_tow = 1;

      check_utc_ofs(2);
   }

   pri_month = fix_month(pri_month);

   if(have_utc_ofs) time_flags &= (~TFLAGS_NO_UTC_OFS);
   else             time_flags |= TFLAGS_NO_UTC_OFS;

   last_time_msec = this_time_msec;  // used to measure timing message jitter
   this_time_msec = GetMsecs();

   if(tsip_type == STARLOC_TYPE) {
      if(time_flags & TFLAGS_UTC) {  // stupid DATUM receiver can output UTC time
         gps_to_utc();               // but always says it is GPS time.  We always run
      }                              // those turds in GPS mode and convert to UTC
   }

   check_for_leapsecond();  // see if the time represents a leapsecond

   if(force_day) {
      pri_day = force_day;
      pri_month = force_month;
      pri_year = force_year;
   }

   fix_rollover();

   if(log_db) request_sig_levels();

   if(rcvr_type != TSIP_RCVR) ;  // ggggg
   else if(user_pps_len) {  // send string of user specified bytes each time a timing message is received
      for(i=0; i<user_pps_len; i++) {
         sendout(RCVR_PORT, user_pps_cmd[i], ADD_CHAR);
      } 
      sendout(RCVR_PORT, 0, FLUSH_COM);
   }

   if     (rcvr_type == SCPI_RCVR) ;
   else if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == UCCM_RCVR) ;
   else if(tsip_error) {
      goto pt_exit; 
   }

   if(just_read) goto pt_exit; 

   if(1) {   // filter bogus time values
      pt_err:
      i = 0;

//    if(pri_tow >= (60L*60L*24L*7L))   { write_log_error("tow", pri_tow);            ++i; }
      if(pri_seconds > 61)              { write_log_error("seconds>61", pri_seconds); ++i; } 
      if(pri_seconds < 0)               { write_log_error("seconds<0", pri_seconds);  ++i; } 

      if(pri_minutes > 60)              { write_log_error("minutes>60", pri_minutes); ++i; } 
      if(pri_minutes < 0)               { write_log_error("minutes<0", pri_minutes);  ++i; } 

      if(pri_hours > 24)                { write_log_error("hours>24", pri_hours);     ++i; } // accomodate weird leap seconds
      if(pri_hours < 0)                 { write_log_error("hours<0", pri_hours);      ++i; } // accomodate weird leap seconds

      if(pri_day > 31)                  { write_log_error("day>31", pri_day);         ++i; } 
      if(pri_day <= 0)                  { write_log_error("day<=0", pri_day);         ++i; } 

      if(pri_month > 12)                { write_log_error("month>12", pri_month);     ++i; } 
      if(pri_month <= 0)                { write_log_error("month<=0", pri_month);     ++i; } 

      if(pri_year < 1980)               { write_log_error("year<1980", pri_year);     ++i; } 
      if(pri_year > 2100)               { write_log_error("year>2100", pri_year);     ++i; } 


      if(i) {
         if(STARLOC) bad_starloc_time = i;  // inhibt duplicated time stamp errs when bogus time seen
         goto pt_exit;
      }
   }

   // the time message seems to have valid time
   seconds = pri_seconds;     // save GPS/UTC time and date in global variables
   minutes = pri_minutes;
   hours = pri_hours;
   day = pri_day;
   month = pri_month;
   year = pri_year;
   raw_frac = pri_frac;

   tow = pri_tow;  
   this_tow = tow;
   survey_tow = tow;


   jd_utc = jd_gps = jdate(year,month,day) + jtime(hours,minutes,seconds,raw_frac);
   if(elapsed_time_set == 0) {
      jd_elapsed = jd_utc;
      elapsed_time_set = 1;
   }

   if(jd_utc == last_jd_utc) ++stuck_clock;
   else stuck_clock = 0;
   last_jd_utc = jd_utc;

   if(last_kbd_jd == 0.0) last_kbd_jd = jd_utc;

   calc_msg_ofs();

   if(no_poll) show_version_header();

   primary_misc();

   if(stuck_clock > 5) ;  // clock has stopped, avoid continuous screen dumps
   else if(leap_time && leap_dump) {  // do screen dump if leap-second seen
      refresh_page();
      leap_dumped = 1;
      if(!have_leap_info) have_leap_info = 99; // show the "Leap: captured" status
      dump_screen(0, 0, "leap_sec");
   }

   pt_exit:
   // every time we see the 8F.AB (or a time code) message, 
   // ... we request a different minor status message from the receiver
   request_misc_msg();  
   if(PALISADE) {  // these don't output secondary timing message (or primary timing for that matter)
      secondary_timing(0);
   }
   else if((ACU_GG || ACU_360 || ACUTIME) && (have_sec_timing == 0)) {
      secondary_timing(0);
   }
   return;
}


DATA_SIZE last_xt;
DATA_SIZE x_temp;

int last_ma;


void do_pps_adev(double val)
{
   // perform adev calc on a receiver PPS value

   if(pps_adevs_cleared) ; // skip the first point after clearing adevs
   else if(pps_adev_period > 0.0) {  // using receiver data
     if(++pps_adev_time >= pps_adev_period) {   // add this data point to adev data queues  aaaahhhh assumes 1Hz
        add_pps_adev_point(val, 0);
        pps_adev_time = 0.0;
     }
   }
   pps_adevs_cleared = 0;
}

void do_osc_adev(double val)
{
   // perform adev calc on a receiver OSC value

   if(osc_adevs_cleared) ; // skip the first point after clearing adevs
   else if(osc_adev_period > 0.0) {  // using receiver data
     if(++osc_adev_time >= osc_adev_period) {   // add this data point to adev data queues  aaaahhhh assumes 1Hz
        add_osc_adev_point(val, 0);
        osc_adev_time = 0.0;
     }
   }
   osc_adevs_cleared = 0;
}


#define UCCM_PPS_ADEV_SCALE    3.590 // scales receiver TINT adevs to match hardware derived values
#define UCCMP_PPS_ADEV_SCALE   3.112 // 4.275   //  4.270
#define SAMSUNG_PPS_ADEV_SCALE 1.355 // 3.000

double last_rftg_phase;

void add_rcvr_adev_point(int why)
{
   // NEW_RCVR

   // add receiver derived pps/osc values to adev queues
   if(jitter_adev) return;  // adev queues in use measuring message timing
    
   if(TICC_USED) {    // ADEV data comes from external time interval counter
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == BRANDY_RCVR) {
      do_pps_adev(pps_offset);
   }
   else if(rcvr_type == PRS_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == RFTG_RCVR) {
///   if(have_pps_offset && last_rftg_phase) do_pps_adev(pps_offset-last_rftg_phase);  
///   last_rftg_phase = pps_offset;
      do_pps_adev(pps_offset);
   }
   else if(rcvr_type == SCPI_RCVR) {  // TINT adevs
      if(have_pps_offset) do_pps_adev(pps_offset/100.00);  
//    if(have_osc_offset) do_osc_adev(osc_offset);  // makes no sense to ADEV
   }
   else if(rcvr_type == UCCM_RCVR) {  // TINT adevs
      if(have_pps_offset) {
         if(scpi_type == UCCMP_TYPE) {
            do_pps_adev((pps_offset/100.00)*UCCMP_PPS_ADEV_SCALE);
         }
         else if(scpi_type == SAMSUNG_TYPE) {
            do_pps_adev((pps_offset/100.00)*SAMSUNG_PPS_ADEV_SCALE);
         }
         else {
            do_pps_adev((pps_offset/100.00)*UCCM_PPS_ADEV_SCALE);
         }
      }

      if(0 && have_osc_offset) {  // UCCM DIAG:LOOP? adevs
         do_osc_adev(osc_offset);  // we don't know what this value actually is, so dont ADEV_STUFF it
      }
   }
   else if(0) {  // adadad
   }
   else if(rcvr_type == GPSD_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == NVS_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
   }
   else if(rcvr_type == SIRF_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset / 100.0);
      if(have_osc_offset) do_osc_adev(osc_offset / 100.0);
   }
   else if(rcvr_type == UBX_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(have_pps_offset) do_pps_adev(pps_offset);
      if(have_osc_offset) do_osc_adev(osc_offset);
   }
}


int vis_table [32+1+1];
int vis_sat_count;
void build_vis_table()
{
int prn;
int i, j;

   // Build a list of sat PRNs with the tracked sats at the start.
   // This is used to speed up getting ephermeris data from tracked sats first.

   for(prn=1; prn<=32; prn++) {  // init the table
      vis_table[prn] = prn;
   }

   i = 1;
   vis_sat_count = 0;
   for(prn=1; prn<=32; prn++) {
      if(sat[prn].tracking) {
         j =  vis_table[prn];
         vis_table[prn] = vis_table[i];
         vis_table[i] = j;

         ++vis_sat_count;
         ++i;
      }
   }

   if(0 && log_file) {
      --i;
      fprintf(log_file, "#vis %d:", i);
      for(prn=1; prn<=32; prn++) {
         fprintf(log_file, " %02X", vis_table[prn]);
         if(prn == i) fprintf(log_file, " - ");
      }
      fprintf(log_file, "\n");
   }
}

void poll_raw_data()
{
int i;
static int vis_seq = 0;

   // ask for raw observation data

   if(rcvr_type != TSIP_RCVR) return;
   if(raw_msg_rate == 0) return;

   build_vis_table();   // get list of visible sats
   if(vis_sat_count) {  // poll for a different visible sat ephemeris once a second
      request_system_data(6, vis_table[vis_seq+1]);
      request_eph_status(vis_table[vis_seq+1]);
      if(++vis_seq > 32) vis_seq = 0;
      if(vis_seq > vis_sat_count) vis_seq = 0;
   }

   if((0 && ACU_360)) {  // poll for sats raw data individually  rnx
      for(i=1; i<=vis_sat_count; i++) {  
         if(vis_table[i]) {
            request_last_raw(vis_table[i]);
         }
      }
   }
   else {  // get all sats raw data
      request_last_raw(0x00);
   }
}


void show_scaled_lla()
{
   // start scaled lla mode (if enabled) once valid lat/lon info received
   if(NO_SATS) return;

   if(1 && (lat && lon) && (have_valid_lla == 0)) {  // we now have valid lat/lon
      new_queue(RESET_ALL_QUEUES, 6466); // clear the queues so autoscale_lla does not crash
      have_valid_lla = 1;
      min_q_lat = max_q_lat = lat*RAD_TO_DEG;
      min_q_lon = max_q_lon = lon*RAD_TO_DEG;
      if(autoscale_lla) {
         change_lla_scale();
         rebuild_lla_plot(0);
         need_redraw = 4344;
      }
   }
}

void secondary_timing(int get_tsip)
{
u08 spare1, spare2;
u32 dac_value;
u08 spare3[8];
int i;
int color;
u08 spare_data;
u08 survey_err;
double jit;
DATA_SIZE val;
DATA_SIZE x_dac;
double x_pps;
double x_osc;
double x_lat;
double x_lon;
double x_alt;
long   x_val;
int seq_err;

   // process the secondary timing message from the receiver (if any) and
   // validate the various receiver data values.  For TSIP devices, this routine
   // gets the secondary timing message from the device.
   if(get_tsip) log_packet_id("Packet 0x8F.AC (Secondary timing)");

   ++timing_seen;

   if(tsip_type == STARLOC_TYPE) {   // this turd can send secondary timing packets
      seq_err = this_pri_tow-(last_pri_tow+1);
      if(seq_err < (-1000)) seq_err += (7*24*60*60);  // week wrap
      if(seq_err == (-2)) return;  // skipped time stamp
      if(skip_starloc_time) return;  // without a preceeding primary timing packet
      skip_starloc_time = 1;
   }

   color = 0;

   if(get_tsip) {
      rcvr_mode = tsip_byte();
      discipline_mode = tsip_byte();
      if(SV6_FAMILY || ACUTIME || ACU_GG || ACU_360 || PALISADE) discipline_mode = DIS_MODE_NORMAL;
      survey_progress = tsip_byte();
      have_progress = 1;
      holdover = tsip_dword();
      critical_alarms = tsip_word();
      last_ma = minor_alarms;
      minor_alarms = tsip_word();
//if(last_ma != minor_alarms) sprintf(debug_text, "ma:%04X  last_ma:%04X", minor_alarms, last_ma); // rrrrr
      gps_status = tsip_byte();
      discipline = tsip_byte();
      spare1 = tsip_byte();
      spare2 = tsip_byte();
      x_pps = (double) tsip_single();
      x_osc = (double) tsip_single();
      x_val = tsip_dword();
      x_dac = tsip_single();
      if(res_t || ACU_GG || ACU_360 || ACUTIME) {
         have_sawtooth = 1;
         if(x_dac < 200e-9) x_dac *= 1.0E9;  // !!!! old firmware outputs sawtooth in seconds, convert to nsec
      }
      else have_dac = 1;
//      last_temp_val = temperature;
      last_xt = x_temp;
      x_temp = tsip_single();
      if(x_temp) have_temperature = 100;

      if(last_xt == 0.0F) last_xt = x_temp;
//      if(last_temp_val == 0.0F) last_temp_val = temperature;
      x_lat = tsip_double();
      x_lon = tsip_double();
      x_alt = tsip_double();

      pps_quant = tsip_single();  // res_t
      if(res_t || ACU_GG || ACU_360 || ACUTIME) x_dac = pps_quant;

      spare_data = 0;  // flag set if any non-zero spare data fields 
      for(i=0; i<4; i++) {
         spare3[i] = tsip_byte();  // ACUTIME spare3[0] -> 0=NO PPS GEN  1=PPS generated
         if(spare3[i]) ++spare_data;
      }

      check_tsip_end(1);

      if(!have_critical_alarms) need_redraw = 7701;

      have_antenna = 1;
      have_osc_age = 1;
      have_osc_offset = 1;
      have_pps_offset = 1;
      have_rcvr_pps = 1;
      have_rcvr_osc = 1;
      have_saved_posn = 1;
      have_tracking = 1;
      have_leap_info = 1;
      have_op_mode = 1;
      have_almanac = 1;
      have_critical_alarms = 1;
      have_gps_status = 1;
      have_sec_timing = 1;

      poll_raw_data();
//adadad    do_pps_adev(x_pps / 100.0);
//adadad    do_osc_adev(x_osc / 100.0);

      if(just_read) return;
      if(tsip_error) return;
   }
   else {
poll_raw_data();
      x_pps = pps_offset;
      x_osc = osc_offset;
      x_dac = dac_voltage;
      x_temp = temperature;
      last_xt = x_temp;
      x_val = 0;
   }

   pps_offset = x_pps;
   osc_offset = x_osc;
   dac_value = x_val;
   dac_voltage = x_dac;

if((jitter_adev == 0) && (TICC_USED == 0) && (pause_data == 0)) {
   add_rcvr_adev_point(0);
}

   last_temp_val = temperature;
// temperature = x_temp;
if(undo_fw_temp_filter && (luxor == 0) && (rcvr_type != UCCM_RCVR)) {
   temperature = (SENSOR_TC*x_temp) - ((SENSOR_TC-1.0F)*last_xt);  // unaverage the firmware reported temperature
   if((temperature < -100.0) || (temperature > 100.0F)) temperature = x_temp;  // filter problem
}
else if(have_temperature) {
   temperature = x_temp;
}

   if(last_temp_val == 0.0F) last_temp_val = temperature;
   if(get_tsip) {
      lat = x_lat;
      lon = x_lon;
      alt = x_alt;
   }

   if(plot[TEMP].plot_center == NEED_CENTER) plot[TEMP].plot_center = scale_temp((double) temperature);
   if(enviro_mode()) {
      if(plot[PRESSURE].plot_center == NEED_CENTER) plot[PRESSURE].plot_center = scale_pressure((double) pressure);
   }
   if(plot[BATTV].plot_center  == NEED_CENTER) plot[BATTV].plot_center  = dac_voltage;
   if(luxor && (plot[TC2].plot_center == NEED_CENTER)) plot[TC2].plot_center = scale_temp((double) luxor_tc2);
   if(luxor && (plot[LUX1].plot_center == NEED_CENTER)) plot[LUX1].plot_center = (float) (pps_offset * lux_scale);
   if(luxor && (plot[LUX2].plot_center == NEED_CENTER)) plot[LUX2].plot_center = (float) (pps_offset * lum_scale);

   if(survey_progress == 100) surveying = 0;
   if(doing_survey != last_survey) {  // self survey changed
      if(trimble_save) ;
      else if(precision_survey) ;
      else need_redraw = 2010;
   }
   last_survey = doing_survey;

   #ifdef PRECISE_STUFF
      precise_check();
   #endif

   if(crude_temp) {   // simulate the crude temperature sensor for temp ctrl pid testing
      val = temperature - (DATA_SIZE) (int) temperature;
      val -= 0.75;
      if((val >= 0.02) || (val < (-0.02))) {  // allow some noise around the switch point
         temperature = ((DATA_SIZE) (int) temperature) + (DATA_SIZE) 0.75;
      }
   }

   if(tsip_error) {  // don't pollute log with potentially bad data
      pps_offset = last_pps_offset;
      osc_offset = last_osc_offset;
      dac_voltage = last_dac_voltage;
      temperature = last_temp_val;
   }
   else {  // filter out bogus values
      if(TIMING_RCVR) ;
      else if(rcvr_type == THERMO_RCVR) ;
      else if(rcvr_type == TICC_RCVR) ;
      else if((ticc_type == LARS_TICC) && TICC_USED) ;
      else if(rcvr_type == UCCM_RCVR) ;  // kkkkkk
      else if(res_t == 0) {
         #ifdef __386__
            if(ABS(dac_voltage) <= 1.0E-4F) dac_voltage = 0.0F;
            if(ABS(temperature) <= 1.0E-4F) temperature = 0.0F;
         #endif

         if(luxor == 0) {
            if(dac_voltage == 0.0F) dac_voltage = last_dac_voltage;
            if(temperature == 0.0F) temperature = last_temp_val;
////        if(pps_offset == 0.0F)  pps_offset = last_pps_offset;
////        if(osc_offset == 0.0F)  osc_offset = last_osc_offset;
            if(DAC_PCT) {
               if((dac_voltage < (-100.0F)) || (dac_voltage > 100.0F)) dac_voltage = last_dac_voltage;
            }
            else if(rcvr_type == RFTG_RCVR) {
               if((dac_voltage < (-20.0F)) || (dac_voltage > 20.0F)) dac_voltage = last_dac_voltage;
            }
            else if((dac_voltage < (-10.0F)) || (dac_voltage > 10.0F)) dac_voltage = last_dac_voltage;
            if((temperature < (-55.0F)) || (temperature > 100.0F)) temperature = last_temp_val;
         }
      }

      have_rcvr_mode = 1;

      #ifdef PRECISE_STUFF
         update_precise_survey();
         if(rcvr_mode != last_rcvr_mode) plot_lla_axes(20);
         last_rcvr_mode = rcvr_mode;
      #endif
   }

   if(saw_ntpx && (initial_voltage == 0.0) && ((user_set_osc_param & PARAM_INITV) == 0x00)) {
      initial_voltage = dac_voltage;  // set initial dac voltage to the current dac value
      have_initv = 1;
   }

   if(have_time && (have_osc == 0)) {  // initialize the value to the current PPS offset
      have_osc = 1;
      osc_integral = (((double) pps_offset) * 1.0E-9);
   }
   osc_integral += (osc_offset * 1.0E-9);


   filter_spikes();    // filter out false temperature sensor spikes
   #ifdef TEMP_CONTROL
      control_temp();
   #else
      temp_dir = ' ';
   #endif

   #ifdef OSC_CONTROL
      control_osc();
   #endif

   survey_err = 0;
   if((rcvr_type == UCCM_RCVR) && (scpi_type == SAMSUNG_TYPE)) ;
   else if(survey_progress > 100) {
      survey_progress = 100;
      survey_err = 1;
   }

#ifdef ADEV_STUFF
   if(jitter_adev) {  // measuring message timing adevs
      jit = (this_time_msec-last_time_msec);   // rrrrr
      do_pps_adev(msg_ofs * 1.0E6);
      do_osc_adev(jit*1.0E6);
   }
#endif // ADEV_STUFF

   if((tsip_type == STARLOC_TYPE) && (pt_hh == st_hh) && (pt_min == st_min) && (pt_sec == st_sec)) {
      // ignore duplicate time stamp
   }
   else {
      if(reading_log == 0) {
         time_check(0, (DATA_SIZE) 1.0, year,month,day, hours,minutes,seconds,raw_frac);  // check for skips in the time
      }
      if(++log_file_time >= log_interval) {
         if(doing_log_dump == 0) write_log_readings(log_file, -1L);
         log_file_time = 0;
      }

      if(rinex_file && have_info) {
         write_rinex_header(rinex_file);
         write_rinex_obs(rinex_file);
      }
   }
   st_hh = pt_hh;
   st_min = pt_min;
   st_sec = pt_sec;

   if(sim_eof) tsip_error = survey_err = 0;
   if(tsip_error) return;
   if(survey_err) return;

   last_pps_offset = pps_offset;
   last_osc_offset = osc_offset;
   last_dac_voltage = dac_voltage;

   last_temperature = temperature;
   last_tc0 = tc0;
   last_tc1 = tc1;
   last_tc2 = tc2;

   last_adc1 = adc1;
   last_adc2 = adc2;
   last_adc3 = adc3;
   last_adc4 = adc4;

   last_humidity = humidity;
   last_pressure = pressure;

   // round these to multiples of the graph scale factor
   last_temperature *= plot[TEMP].ref_scale;
   last_temperature = (long) ((last_temperature / plot[TEMP].scale_factor)) * plot[TEMP].scale_factor;
   last_temperature /= plot[TEMP].ref_scale;

   if(0) {
      last_tc1 *= plot[TEMP1].ref_scale;
      last_tc1 = (long) ((last_tc1 / plot[TEMP1].scale_factor)) * plot[TEMP1].scale_factor;
      last_tc1 /= plot[TEMP1].ref_scale;

      last_tc2 *= plot[TEMP2].ref_scale;
      last_tc2 = (long) ((last_tc2 / plot[TEMP2].scale_factor)) * plot[TEMP2].scale_factor;
      last_tc2 /= plot[TEMP2].ref_scale;
   }

   last_dac_voltage *= plot[DAC].ref_scale; 
   last_dac_voltage = (long) ((last_dac_voltage / plot[DAC].scale_factor)) * plot[DAC].scale_factor;
   last_dac_voltage /= plot[DAC].ref_scale; 

   if(have_alarms == 0) {
      have_alarms = 1;
      last_critical = critical_alarms;
      last_minor = minor_alarms;
   }

#ifdef ADEV_STUFF
   if(pause_data == 0) {  // redraw adev curves and tables every 10 seconds
      update_adev_display(ATYPE, 0);  
   }
#endif // ADEV_STUFF

   show_version_header();    // show the receiver id info
   show_log_state();         // show the logging mode
   show_param_values(0);     // update alarm and data value displays

   write_log_changes();      // write important state changes to log file

   if((last_utc_ofs == 0) && have_utc_ofs) {  // we just got the UTC offset
      last_utc_ofs = have_utc_ofs;            
      if(rcvr_type == TICC_RCVR);
      else if(log_loaded == 0) clear_all_data();   // assume previous data was bogus, clear it
   }

   update_plot_data();       // add latest info to the plot queue and update the screen
   show_scaled_lla();
   show_plot_stats();

//sprintf(debug_text2, "dtl:%d  ppstrend:%d  ttype:%d", dynamic_trend_line, plot[PPS].show_trend, title_type);
   if(dynamic_trend_line) {  // update trend line info plot title dynamically
      show_trend_info(selected_plot);
   }

   track_object();  // output sun, moon, sat position to TRACK_PORT (if enabled)

   if(ticc_sim_file) {  // get aux TICC data from a simulation file  //lfs //LARS_TICC
      if(fgets(out, sizeof out, ticc_sim_file) != NULL) {
         char *s;
         s = strchr(out, 0x0D);
         if(s) *s = 0;
         s = strchr(out, 0x0A);
         if(s) *s = 0;
         strcpy((char *) ticc_buf, out);
         ticc_wptr = strlen((char *) ticc_buf);
         decode_ticc_msg(TICC_PORT);
         packet_end = 1;
         ticc_sim_eof = 0;
      }
      else ticc_sim_eof = 1;
   }
}


void get_ae_packet()
{
u08 subcode;      // packet subcode
u16 zero;         // ???
u08 leds;         // led status
u08 hold;         // holdover state
u08 pll;          // pll state
u08 dis;          // disciplining mode
u08 flash;        // firmware code
u08 b1,b2;        // ???
u08 log_count;    // number of events in the log
u16 op_status;    // operation status
u16 hw_status;    // hardware status
float pps_val;    // related to pps error (in ns)
float osc_val;    // related to osc error (in ppb)
int i;
unsigned char buf[32];


   log_packet_id("Packet 0x8F.AE (Nortel packet)");

   // Unknown packet sent by Nortel receiver.  Also mentioned as being
   // sent by the Palisade,  but in a different format.

// for(i=0; i<9+8; i++) tsip_byte();
   subcode = tsip_byte();
   if(subcode == 0x01) {
      zero  = tsip_word();
      leds  = tsip_byte();
      ffom  = tsip_byte();
      have_ffom = 1;
      tfom  = tsip_byte();
      have_tfom = 1;
      hold  = tsip_byte();

      if(try_ntpx == 0) {
         pll   = tsip_byte();
         dis   = tsip_byte();
         flash = tsip_byte();

         b1 = tsip_byte();    // 0
         b2 = tsip_byte();    // 1
         log_count = tsip_byte();  // error count
         op_status = tsip_word(); 
         hw_status = tsip_word(); 

         pps_val = tsip_single();  // PPS val (ns)
         osc_val = tsip_single();  // OSC val (ppb)
      }
//    sprintf(plot_title, "led:%02X  ffom:%02X tfom:%02X  ho:%02X  pll:%02X  dis:%02X  flash:%02X  b:%02X,%02X  log:%02X  op:%04X hw:%04X  %12g %12g", 
//      leds, ffom,tfom,  hold,pll,dis,flash, b1,b2, log_count, op_status,hw_status, pps_val,osc_val);
   }
   else if(1) {
//    plot_title[0] = 0;
      for(i=0; i<9+8+8; i++) {
         buf[i] = tsip_byte();
//       sprintf(out, "%02X ", (unsigned) buf[i]);
//       strcat(plot_title, out);
      }
   }

   check_tsip_end(1);
   if(STARLOC) ;
   else if(try_ntpx && (tsip_error == 0) && (zero == 0x0001)) {
      saw_ntpx = 1;
      strcpy(unit_name, "Nortel NTPX"); 
      saw_gpsdo = 3;
      if(user_set_temp_filter == 0) undo_fw_temp_filter = 0;
   }

   if(STARLOC) ;
   else if(tsip_error && (zero == 0x0001)) { // error seen, maybe it's an NTPX gpsdo?
      try_ntpx ^= 1;
      if(try_ntpx == 0) {
         saw_ntpx = 0;
         saw_gpsdo = 0;
      }
   }
//sprintf(plot_title, "ntpx: %d  zero:%04X  saw_ntpx=%d  notel=%d  oscp=%04X", 
//try_ntpx, zero, saw_ntpx, saw_nortel, have_osc_params);
}


void get_tsip_config()
{
u08 rcvr_mode;
u08 rsvd1;
u08 rsvd2;
u08 rsvd3;
u08 rsvd4[32]; 
u08 sat_types;
u08 i, last;
float el_val;
float amu_val;

   log_packet_id("Packet 0xBB (Receiver config)");

   subcode = tsip_byte();       // 0
   rcvr_mode = tsip_byte();     // 1
   rsvd1 = tsip_byte();         // 2
   dynamics_code = tsip_byte(); // 3
   rsvd2 = tsip_byte();         // 4
   el_val = tsip_single();      // 5
   amu_val = tsip_single();     // 9
   pdop_mask = tsip_single();   // 13
   have_pdop_mask |= 0x01;
   pdop_switch = tsip_single(); // 17
   have_pdop_mask |= 0x02;
   rsvd3 = tsip_byte();         // 21  (DGPS age)
   foliage_mode = tsip_byte();  // 22 saw_icm: anti-jam mode

   // byte 23: low power mode
   // byte 24: clock hold mode
   // byte 25: measurement rate
   // byte 26: fix rate
   // byte 27: sat type mask for OD clock mode saw_icm
   //          0x01 GPS
   //          0x02 GLONASS
   //          0x08 Beidou
   //          0x10 Galileo
   //          0x20 QZSS 
   last = 40;
   if(ACU_GG) last = 43;  // !!!!! should be 40, but this causes a packet read error!
   else if(ACU_360) last = 40;
   else if(ACUTIME && (acu_type == '1')) last = 43;  // !!!! 40 for newer models?
   else if(PALISADE) last = 44;

   for(i=23; i<last; i++) {   
      rsvd4[i-23] = tsip_byte();
      if((i == 27) && (saw_icm || (res_t == RES_T_360) || ACU_GG || ACU_360)) { // saw_icm: byte 28 = OD clock mode sat type bit mask
         sat_types = rsvd4[i-23];
         if(sat_types == 0) ;
         else if(sat_types == 0xFF) ;
         else {
            gnss_mask = 0;
            if(sat_types & 0x01) gnss_mask |= GPS;
            if(sat_types & 0x02) gnss_mask |= GLONASS;
            if(sat_types & 0x08) gnss_mask |= BEIDOU;
            if(sat_types & 0x10) gnss_mask |= GALILEO;
            if(sat_types & 0x20) gnss_mask |= QZSS;
            if(gnss_mask == 0) {
               gnss_mask = MIXED;
               have_gnss_mask = 0;
            }
            else have_gnss_mask = 4;
         }
      }
   }

   check_tsip_end(1);

   // stupid filtering required for STARLOC II devices
   el_val = (float) (int) ((el_val*RAD_TO_DEG) + 0.50F);
   if(0 && STARLOC) ;
   else if((el_val >= 0.0) && (el_val <= 90.0)) {
      el_mask = el_val;
      have_el_mask = 1;
   }

   if(0 && STARLOC) ;
   else if((amu_val >= 0.0) && (amu_val < 60.0)) {
      amu_mask = amu_val;
      have_amu = 1;
   }
   if(tsip_error) return;
}


//
//
//  Luxor LED / Power analyzer stuff
//
//

// unit_status bit definitions
#define RESET_BIT      0x80000000L
#define CAL_MODE_BIT   0x40000000L
#define ZEROING_BIT    0x20000000L
#define WDT_BIT        0x10000000L
#define RUN_TIMEOUT    0x08000000L
#define CONFIG_ERR     0x04000000L
#define CAL_CRC_ERR    0x02000000L
#define COM_ERR_BIT    0x01000000L

#define AUXV_HVC_BIT   0x00800000L
#define AUXV_LVC_BIT   0x00400000L
#define LOAD_WATTS_BIT 0x00200000L
#define BATT_WATTS_BIT 0x00100000L

#define LUX2_OVFL_BIT  0x00080000L
#define LUX2_CHIP_BIT  0x00040000L
#define LUX1_OVFL_BIT  0x00020000L
#define LUX1_CHIP_BIT  0x00010000L

#define TEMP2_BAD_BIT  0x00008000L
#define TEMP2_OVT_BIT  0x00004000L
#define TEMP2_MASK     0xFFFFCFFFL
#define TEMP2_IR       0x00001000L
#define TEMP2_TC       0x00002000L
#define TEMP2_AT       0x00003000L

#define TEMP1_BAD_BIT  0x00000800L
#define TEMP1_OVT_BIT  0x00000400L
#define TEMP1_MASK     0xFFFFFCFFL
#define TEMP1_IR       0x00000100L
#define TEMP1_TC       0x00000200L
#define TEMP1_AT       0x00000300L

#define LOAD_HVC_BIT   0x00000080L
#define LOAD_LVC_BIT   0x00000040L
#define LOAD_OVC_BIT   0x00000020L
#define CFG_CRC_ERR    0x00000010L

#define BATT_HVC_BIT   0x00000008L
#define BATT_LVC_BIT   0x00000004L
#define BATT_OVC_BIT   0x00000002L
#define BATTERY_ON     0x00000001L

#define FAULT_BITS    (BATT_OVC_BIT | BATT_LVC_BIT | BATT_HVC_BIT | BATT_WATTS_BIT | LOAD_OVC_BIT | LOAD_HVC_BIT | LOAD_LVC_BIT | LOAD_WATTS_BIT | AUXV_HVC_BIT | AUXV_LVC_BIT | TEMP1_OVT_BIT | TEMP1_BAD_BIT | TEMP2_OVT_BIT | TEMP2_BAD_BIT | WDT_BIT | COM_ERR_BIT | RUN_TIMEOUT | CONFIG_ERR | CAL_CRC_ERR | CFG_CRC_ERR)


u08 luxor_fault()
{
int row, col;
int color;

   if(1 && (unit_status & RESET_BIT)) {
      have_time = 0;
      reset_alarm();
      sound_alarm = 0;
//    fault_seen = 0;
   }

   if((unit_status & FAULT_BITS) == 0) {
      fault_seen = 0;
      if(unit_status & RESET_BIT) ;
      else if(unit_status & CAL_MODE_BIT) ;
      else if(unit_status & ZEROING_BIT) ;
      else if(prot_menu || show_prots) ;
      else {
         return 0;
      }
   }
   else if((unit_status & FAULT_BITS) && (fault_seen == 0)) {
      if(unit_status & RESET_BIT) ;
      else if(unit_status & ZEROING_BIT) ;
      else {
         fault_seen = 1;
         if((unit_status & FAULT_BITS) == COM_ERR_BIT) ;
         else if((unit_status & FAULT_BITS) == WDT_BIT) ;
         else if((unit_status & FAULT_BITS) == (WDT_BIT | COM_ERR_BIT)) ;
         else if(have_time) {
            sound_alarm |= ALARM_LUXOR;
            enable_alarm();
         }
      }
   }

   erase_watch();
   row = (aclock_y - ACLOCK_SIZE/2 + (TEXT_HEIGHT-1)) / TEXT_HEIGHT;
   col = (aclock_x - ACLOCK_SIZE/2 + (TEXT_WIDTH-1)) / TEXT_WIDTH;
   if(aclock_y < PLOT_ROW) {
      col -= 5;
      if(row) --row;
   }

   if(prot_menu || show_prots) {
      if(unit_status & FAULT_BITS) color = RED;
      else                         color = WHITE;
      vidstr(row++, col, color, "Protections:");

      if(unit_status & BATT_LVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "Batt LVC: %8.3f V", batt_lvc);
      vidstr(row++, col, color, out);

      if(unit_status & BATT_HVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "Batt HVC: %8.3f V", batt_hvc);
      vidstr(row++, col, color, out);

      if(unit_status & BATT_OVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "Batt OVC: %8.3f A", batt_ovc);
      vidstr(row++, col, color, out);

      if(unit_status & BATT_WATTS_BIT) color = RED;
      else                             color = WHITE;
      sprintf(out, "Batt OVW: %8.3f W", batt_watts);
      vidstr(row++, col, color, out);

      if(unit_status & LOAD_LVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "LED LVC:  %8.3f V", load_lvc);
      vidstr(row++, col, color, out);

      if(unit_status & LOAD_HVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "LED HVC:  %8.3f V", load_hvc);
      vidstr(row++, col, color, out);

      if(unit_status & LOAD_OVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "LED OVC:  %8.3f A", load_ovc);
      vidstr(row++, col, color, out);

      if(unit_status & LOAD_WATTS_BIT) color = RED;
      else                             color = WHITE;
      sprintf(out, "LED OVW:  %8.3f W", load_watts);
      vidstr(row++, col, color, out);

      if(unit_status & AUXV_LVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "AUXV LVC: %8.3f V", auxv_lvc);
      vidstr(row++, col, color, out);

      if(unit_status & AUXV_HVC_BIT) color = RED;
      else                           color = WHITE;
      sprintf(out, "AUXV HVC: %8.3f V", auxv_hvc);
      vidstr(row++, col, color, out);


      if(unit_status & TEMP1_OVT_BIT) color = RED;
      else                            color = WHITE;
      sprintf(out, "TEMP1:    %8.3f%c%c", tc1_ovt, DEGREES, DEG_SCALE);
      vidstr(row++, col, color, out);

      if(unit_status & TEMP2_OVT_BIT) color = RED;
      else                            color = WHITE;
      sprintf(out, "TEMP2:    %8.3f%c%c", tc2_ovt, DEGREES, DEG_SCALE);
      vidstr(row++, col, color, out);

      if(unit_status & WDT_BIT) color = RED;
      else                      color = WHITE;
      sprintf(out, "Timeout:  %8.3f S", msg_timeout);
      vidstr(row++, col, color, out);
   }
   else {
      vidstr(row++, col, RED, "Abnormal status:");
      if(unit_status & RESET_BIT)      vidstr(row++, col, RED, "Unit reset"); 
      if(unit_status & CAL_MODE_BIT)   vidstr(row++, col, RED, "Cal mode"); 
      if(unit_status & CAL_CRC_ERR)    vidstr(row++, col, RED, "Cal memory bad"); 
      if(unit_status & CFG_CRC_ERR)    vidstr(row++, col, RED, "Config memory bad"); 
      if(unit_status & CONFIG_ERR)     vidstr(row++, col, RED, "Config changed"); 
      if(unit_status & ZEROING_BIT) {
         vidstr(row++, col, RED, "Zeroing sensors"); 
      }
      else {
         if(unit_status & BATT_OVC_BIT)   vidstr(row++, col, RED, "Battery over current");
         if(unit_status & BATT_WATTS_BIT) vidstr(row++, col, RED, "Battery over watts");
         if(unit_status & LOAD_OVC_BIT)   vidstr(row++, col, RED, "LED over current");
         if(unit_status & LOAD_WATTS_BIT) vidstr(row++, col, RED, "LED over watts");
      }
      if(unit_status & BATT_LVC_BIT)   vidstr(row++, col, RED, "Battery low voltage");
      if(unit_status & BATT_HVC_BIT)   vidstr(row++, col, RED, "Battery high voltage");
      if(unit_status & LOAD_LVC_BIT)   vidstr(row++, col, RED, "LED low voltage");
      if(unit_status & LOAD_HVC_BIT)   vidstr(row++, col, RED, "LED high voltage");
      if(unit_status & AUXV_LVC_BIT)   vidstr(row++, col, RED, "AUXV low voltage");
      if(unit_status & AUXV_HVC_BIT)   vidstr(row++, col, RED, "AUXV high voltage");
      if(unit_status & TEMP1_OVT_BIT)  vidstr(row++, col, RED, "Temp1 over-temp");
      if(unit_status & TEMP2_OVT_BIT)  vidstr(row++, col, RED, "Temp2 over-temp");
      if(unit_status & TEMP1_BAD_BIT)  vidstr(row++, col, RED, "Temp1 sensor fault");
      if(unit_status & TEMP2_BAD_BIT)  vidstr(row++, col, RED, "Temp2 sensor fault");
      if(unit_status & LUX1_OVFL_BIT)  vidstr(row++, col, RED, "Lux overflow");
      if(unit_status & LUX2_OVFL_BIT)  vidstr(row++, col, RED, "Lumens overflow");
      if(unit_status & COM_ERR_BIT)    vidstr(row++, col, RED, "Serial data error");
      if(unit_status & WDT_BIT)        vidstr(row++, col, RED, "Message timeout");
      if(unit_status & RUN_TIMEOUT)    vidstr(row++, col, RED, "Timer shutdown");
   }

   return 1;
}

struct CCT_TABLE {
   float ratio;
   float k;
} cctt[] = {
   { 0.000F, 200000.0F},
   { 0.440F, 63675.0F},     // 390 nm UV !!!!!
   { 0.823F, 20000.0F}, // dummy
   { 0.858F, 15000.0F}, // Chinese 3W
   { 0.894F, 13000.0F}, // Chinese 3W
   { 1.013F, 10000.0F}, // Chinese 3W
   { 1.156F, 8000.0F},  // Chinese 3W
   { 1.360F, 6500.0F},  // XML T6 UF2100
   { 1.550F, 5700.0F},  // luminus
   { 1.770F, 5200.0F},  // Bridgelux C8000
   { 1.890F, 4950.0F},  // SkyRayKing NW on high
   { 2.295F, 4250.0F},  // Nichia 219
   { 2.482F, 4000.0F},  // Philips capsule
   { 3.023F, 3350.0F},  // Bridgelux
   { 3.367F, 3050.0F},  // LSG MR16l
   { 3.458F, 3000.0F},  // philips/lsg/syl PAR20/Syl PAR16
   { 3.752F, 2850.0F},  // Bridgelux W0804
   { 4.077F, 2700.0F},  // LSG PAR30  SYL PAR16
   { 4.500F, 2500.0F}   // dummy value !!!!!
};

#define NUM_CCT (sizeof(cctt) / sizeof(struct CCT_TABLE))

DATA_SIZE cie_x, cie_y, cie_z;
DATA_SIZE cie_sum;

void calc_cie(DATA_SIZE red_uw, DATA_SIZE green_uw,  DATA_SIZE blue_uw)
{
   if(tcs_color) {  // TCS3414
      cie_x = ((DATA_SIZE) -0.14282*red_uw) + ((DATA_SIZE) 1.54924*green_uw) + ((DATA_SIZE) -0.95641*blue_uw); // TCS3414
      cie_y = ((DATA_SIZE) -0.32466*red_uw) + ((DATA_SIZE) 1.57837*green_uw) + ((DATA_SIZE) -0.73191*blue_uw);
      cie_z = ((DATA_SIZE) -0.68202*red_uw) + ((DATA_SIZE) 0.77073*green_uw) + ((DATA_SIZE) +0.56332*blue_uw);
   }
   else {           // TCS3210
      cie_x = ((DATA_SIZE) 0.4287*red_uw) + ((DATA_SIZE) 0.4489*green_uw)  + ((DATA_SIZE) 0.0493*blue_uw);
      cie_y = ((DATA_SIZE) 0.1450*red_uw) + ((DATA_SIZE) 0.9623*green_uw)  + ((DATA_SIZE) -0.1167*blue_uw);
      cie_z = ((DATA_SIZE) 0.0539*red_uw) + ((DATA_SIZE) -0.4059*green_uw) + ((DATA_SIZE) 1.4191*blue_uw);
   }
   cie_sum = cie_x + cie_y + cie_z;
}

DATA_SIZE calc_cct(int type, int undo_scale, double red, double green, double blue)
{
int i;
DATA_SIZE val;
DATA_SIZE dif;
DATA_SIZE pct;
DATA_SIZE red_uw, green_uw, blue_uw;
DATA_SIZE ccx, ccy, ccz;
DATA_SIZE n;
DATA_SIZE cct;

   if(undo_scale) {        // red, green and blue came from get_plot_q() values
      if(show_color_uw) {  // we need to undo the scale factor that was applied to those values 
         red *= RED_SENS;     // blue
         green *= GREEN_SENS; // green
         blue *= BLUE_SENS;   // red
      }
      else if(show_color_pct) {
         // !!!!!!! we cant properly undo those values
         red_uw = (DATA_SIZE) (red * (red + green + blue));
         green_uw = (DATA_SIZE) (green * (red + green + blue));
         blue_uw = (DATA_SIZE) (blue * (red + green + blue));

         red = red_uw;
         green = green_uw;
         blue = blue_uw;
      }
   }
if(0 && cct_dbg) sprintf(plot_title, "ty=%d r=%f g=%f b=%f", type, red, green, blue);

   if(type == 0) {
      if(blue == 0.0) return 0.0;
      val = (DATA_SIZE) ((red / blue) * cct_cal);
val = rb_m * val + rb_b;

      for(i=0; i<(int) NUM_CCT; i++) {
         if(val < cctt[i].ratio) {
            if(i == 0) return 99999.999F;

            dif = cctt[i].ratio - cctt[i-1].ratio;
            if(dif == 0.0F) return 0.0F;
            pct = (val - cctt[i-1].ratio) / dif;

            dif = cctt[i].k - cctt[i-1].k;
// sprintf(plot_title, "red=%f  rob=%f  val=%f  hz=%f  i=%d  pct=%f  dif=%f", red, r_over_b, val, red_hz/blue_hz, i, pct, dif);
            dif *= pct;
            return cctt[i-1].k + dif;
         }
      }
   }
   else {
      red_uw = (DATA_SIZE) red / RED_SENS;
      green_uw = (DATA_SIZE) green / GREEN_SENS;
      blue_uw = (DATA_SIZE) blue /  BLUE_SENS;

      calc_cie(red_uw, green_uw, blue_uw);
      if(cie_sum) {
         ccx = cie_x / cie_sum;
         ccy = cie_y / cie_sum;
         ccz = cie_z / cie_sum;
         if(type == 1) {
            n = (ccx - 0.3320F) / (ccy - 0.1858F);
            cct = (-449.0F*n*n*n) + (3525.0F*n*n) - (6823.3F*n) + 5520.33F;
            if((cct < 0.0F) || (cct > 100000.0F)) cct = 0.0F;
            cct /= cct1_cal;  // apply bogus correction factor
            return cct;
         }
         else if(type == 2) {
            n = (ccx - 0.3366F) / (ccy - 0.1735F);
            cct = (DATA_SIZE) ((-949.86315F) + 6253.80338F*exp(-n/0.91259F) + 28.70599F*exp(-n/0.20039) + 0.00004F*exp(-n/0.07125F));
            if((cct < 0.0F) || (cct > 100000.0F)) cct = 0.0F;
            cct /= cct2_cal;  // apply bogus correction factor
            return cct;
         }
      }
      else return 0.0;
   }

   return 1.0;
}


#define HH 6.626068E-34
#define CC 299792458.0
#define KK 1.3806503E-23

double plank(double t, double y)
{
double f;

// This routine used Plank's equation to calculate the energy at wavelength
// y (in namometers) of a black body at temperature t (in degrees K)

   y *= 1.0E-9;     // convert wavelenth to meters
   f = (2.0*PI*HH*CC*CC) /
       ((y*y*y*y*y) * (exp((HH*CC) / (KK*y*t)) - 1.0));
   f /= 1.0E6;      // normalize to standard units
//printf("T=%f  y=%g  f=%g\n", t,y,f);
   return f;

}


DATA_SIZE calc_cri(DATA_SIZE cct)
{
double bb_r,bb_g,bb_b,d,sum;  // black body values
double R,G,B;                 // sensor values
double y;
double err;

   d = 0.0;

   R = red_uw;
   G = green_uw;
   B = blue_uw;
   sum = R + G + B;
   if(sum == 0.0) return 0.0;

   R /= sum;
   G /= sum;
   B /= sum;

   // calculate the black body energy emitted over the color sensor bands
   if(cri_flag) {
      bb_r = plank(cct, 621.0);  // 640
      bb_g = plank(cct, 500.0);  // 524
      bb_b = plank(cct, 490.0);  // 470
   }
   else if(1) {
      bb_b  = plank(cct, 420.0) * 0.30;
      bb_b += plank(cct, 430.0) * 0.40;
      bb_b += plank(cct, 440.0) * 0.42;
      bb_b += plank(cct, 450.0) * 0.45;
      bb_b += plank(cct, 460.0) * 0.48;
      bb_b += plank(cct, 470.0) * 0.46;
      bb_b += plank(cct, 480.0) * 0.44;
      bb_b += plank(cct, 490.0) * 0.40;
      bb_b += plank(cct, 500.0) * 0.35;
      bb_b += plank(cct, 510.0) * 0.30;
      bb_b += plank(cct, 520.0) * 0.25;
      bb_b += plank(cct, 530.0) * 0.15;
      bb_b += plank(cct, 540.0) * 0.14;
      bb_b += plank(cct, 550.0) * 0.13;
      bb_b += plank(cct, 560.0) * 0.08;
      bb_b /= 15.0;

      bb_g  = plank(cct, 420.0) * 0.05;
      bb_g += plank(cct, 420.0) * 0.06;
      bb_g += plank(cct, 440.0) * 0.07;
      bb_g += plank(cct, 450.0) * 0.08;
      bb_g += plank(cct, 460.0) * 0.10;
      bb_g += plank(cct, 470.0) * 0.18;
      bb_g += plank(cct, 480.0) * 0.20;
      bb_g += plank(cct, 490.0) * 0.23;
      bb_g += plank(cct, 500.0) * 0.28;
      bb_g += plank(cct, 510.0) * 0.32;
      bb_g += plank(cct, 520.0) * 0.38;
      bb_g += plank(cct, 530.0) * 0.50;
      bb_g += plank(cct, 540.0) * 0.55;
      bb_g += plank(cct, 550.0) * 0.54;
      bb_g += plank(cct, 560.0) * 0.50;
      bb_g += plank(cct, 570.0) * 0.40;
      bb_g += plank(cct, 580.0) * 0.39;
      bb_g += plank(cct, 590.0) * 0.20;
      bb_g += plank(cct, 600.0) * 0.15;
      bb_g += plank(cct, 610.0) * 0.06;
      bb_g /= 20.0;

      bb_r  = plank(cct, 510.0) * 0.03;
      bb_r += plank(cct, 520.0) * 0.05;
      bb_r += plank(cct, 530.0) * 0.08;
      bb_r += plank(cct, 540.0) * 0.10;
      bb_r += plank(cct, 550.0) * 0.17;
      bb_r += plank(cct, 560.0) * 0.17;
      bb_r += plank(cct, 570.0) * 0.20;
      bb_r += plank(cct, 580.0) * 0.40;
      bb_r += plank(cct, 590.0) * 0.50;
      bb_r += plank(cct, 600.0) * 0.60;
      bb_r += plank(cct, 610.0) * 0.65;
      bb_r += plank(cct, 620.0) * 0.70;
      bb_r += plank(cct, 630.0) * 0.73;
      bb_r += plank(cct, 640.0) * 0.80;
      bb_r += plank(cct, 650.0) * 0.82;
      bb_r += plank(cct, 660.0) * 0.85;
      bb_r += plank(cct, 670.0) * 0.85;
      bb_r += plank(cct, 680.0) * 0.90;
      bb_r += plank(cct, 690.0) * 0.93;
      bb_r += plank(cct, 700.0) * 0.95;
      bb_r /= 20.0;    
   }
   else {
      bb_r = bb_g = bb_b = 0.0;
      for(y=400.0; y<=520.0; y+=10.0) {
         bb_b += plank(cct, y);
         d += 1.0;
      }
      bb_b /= d;

      for(y=480.0; y<=600.0; y+=10.0) {
         bb_g += plank(cct, y);
         d += 1.0;
      }
      bb_g /= d;

      for(y=550.0; y<=770.0; y+=10.0) {
         bb_r += plank(cct, y);
         d += 1.0;
      }
      bb_r /= d;
   }
   sum = bb_r + bb_g + bb_b;  // normalize black body energy to 0 .. 1
   bb_r /= sum;
   bb_g /= sum;
   bb_b /= sum;


   err = sqrt((((R-bb_r)*(R-bb_r)) + ((G-bb_g)*(G-bb_g)) + ((B-bb_b)*(B-bb_b)))/3.0);
   err = (1.0-err) * (1.0-err);

   return (DATA_SIZE) (err*100.0);
}


#define SAT_COLOR_HZ 700000.0F      // color sensor saturation threshold
#define MAX_COLOR_HZ 500000.0F      // color sensor saturation warning threshold
#define MIN_COLOR_HZ 100.0F         // color sensor too low threshold
#define RED_OVFL   0x01
#define GREEN_OVFL 0x02
#define BLUE_OVFL  0x04
#define WHITE_OVFL 0x08
#define RED_LOW    0x10
#define GREEN_LOW  0x20
#define BLUE_LOW   0x40
#define WHITE_LOW  0x80
#define RED_SAT    0x100
#define GREEN_SAT  0x200
#define BLUE_SAT   0x400
#define WHITE_SAT  0x800

u08 last_cal_mode;


void measure_ir()
{
   // this routine measures the battery internal resistance by checking
   // how the battery voltage changes when loaded and unloaded

   if(calc_ir >= IR_TIME) {        // turn on load
      set_batt_pwm(0xFFFF);
      --calc_ir;
      sprintf(plot_title, "Calculating battery internal resistance: %2d", calc_ir);
   }
   else if(calc_ir == 3) {   // get loaded readings
      ir_v = batt_v;
      ir_i = batt_i;
      --calc_ir;
      set_batt_pwm(0);
      sprintf(plot_title, "Calculating battery internal resistance: %2d", calc_ir);
   }
   else if(calc_ir) {
      --calc_ir;
      if(calc_ir) {     // get unloaded readings
         sprintf(plot_title, "Calculating battery internal resistance: %2d", calc_ir);
      }
      else {
         ir_v = fabs(batt_v-ir_v);
         if(ir_i) {
            ir_v /= ir_i;
            sprintf(plot_title, "Battery internal resistance: %.2f milliohms at %.3f amps", ir_v*1000.0F, ir_i);
         }
         else {
            sprintf(plot_title, "No load detected on the battery");
         }
      }
   }
}



#define TERM_TIME 60  // seconds
int term_timer;       // times amount of time that the charge current is less than the shutoff threshold


void end_sweep()
{
   cc_mode = 0;
   sweep_stop = 0.0F;
   sweep_val = 0.0F;
   cc_state = 0;
   if(update_stop) {
      pause_data = 1;
      view_all(1);
      need_redraw = 2011;
   }
   update_stop = 0;
}

void constant_load()
{
DATA_SIZE delta;
u16 pwm;

   if(cc_mode == 0) return;
   if(cc_state < 5) ++cc_state;
   if(sweep_rate <= 0) {
      sweep_rate = sweep_tick = 1;
   }

   if(cc_state == 1) {  // starting up
      if(cc_mode == PWM_SWEEP) {
         cc_pwm = sweep_val = sweep_start;
         goto charged;
      }
      else if((cc_mode == CC_LIPO) && (led_v < unsafe_v)) {  // potentially unsafe cell - don't charge
         goto stop_charge;
      }
      term_timer = TERM_TIME;
      if(sweep_stop) cc_pwm = 0.0;
      else           cc_pwm = PWM_STEP;
   }
   else if(cc_mode == PWM_SWEEP) {   // sweeping PWM value between limits
      if(sweep_start > sweep_end) {  // down sweep
         if(--sweep_tick <= 0) {
            sweep_tick = sweep_rate;
            sweep_val -= PWM_STEP;
            if(sweep_val < 0.0) end_sweep();
         }
         if(sweep_val < sweep_end) {
            end_sweep();
         }
      }
      else {                         // up sweep;
         if(--sweep_tick <= 0) {
            sweep_tick = sweep_rate;
            sweep_val += PWM_STEP;
            if(sweep_val > 1.0) end_sweep();
         }
         if(sweep_val > sweep_end) {
            end_sweep();
         }
      }
      cc_pwm = sweep_val;
      goto charged;
   }
   else {
      if((cc_mode == CC_LIPO) && (led_v > (lipo_volts-0.05))) {  // constant V mode
//       if(led_v > (lipo_volts+0.05)) goto stop_charge;
         if(led_v > (lipo_volts+0.10)) goto stop_charge;
         if(led_i < (cc_val/20.0)) {  // constant I mode - charge done at charge_rate/20
            if(--term_timer < 0) {
               stop_charge:
               end_sweep();
               cc_pwm = 0.0;
               goto charged;
            }
         }
         else term_timer = TERM_TIME;

         if(led_i < cc_val) {
            if((led_v > lipo_volts) && cc_pwm) {
               cc_pwm -= PWM_STEP;
               if(cc_pwm < PWM_STEP) cc_pwm = PWM_STEP;
            }
            goto charged;
         }
      }

      if((cc_mode == CC_VOLTS) && (led_v > 0.050)) {  // must have at least 50mv load voltage
         if(sweep_stop) {
            if(led_v > sweep_stop) {
               end_sweep();
               cc_pwm = 0.0;
            }
            else if(--sweep_tick <= 0) {
               sweep_tick = sweep_rate;
               cc_pwm += PWM_STEP;
               if(cc_pwm > 1.0) {
                  end_sweep();
                  cc_pwm = 0.0;
               }
            }
         }
         else {
            delta = (cc_val - led_v);
            delta /= led_v;
            if(delta < 0.0) delta *= (DATA_SIZE) 0.50;
            else            delta *= (DATA_SIZE) 0.20;
            cc_pwm += (delta * cc_pwm);
         }
      }
      else if((cc_mode == CC_WATTS) && (led_w > 0.050)) {  // must have at least 50mw load power
         if(sweep_stop) {
            if(led_w > sweep_stop) {
               end_sweep();
               cc_pwm = 0.0;
            }
            else if(--sweep_tick <= 0) {
               sweep_tick = sweep_rate;
               cc_pwm += PWM_STEP;
               if(cc_pwm > 1.0) {
                  end_sweep();
                  cc_pwm = 0.0;
               }
            }
         }
         else {
            delta = (cc_val - led_w);
            delta /= led_w;
            if(delta < 0.0) delta *= (DATA_SIZE) 0.25;  // power is a squared function, reduce gain
            else            delta *= (DATA_SIZE) 0.04;
            cc_pwm += (delta * cc_pwm);
         }
      }
      else if((cc_mode > 1) && (led_i > 0.050)) {  // must have at least 50mA load current
         if(sweep_stop) {
            if(led_i > sweep_stop) {
               end_sweep();
               cc_pwm = 0.0;
            }
            else if(--sweep_tick <= 0) {
               sweep_tick = sweep_rate;
               cc_pwm += PWM_STEP;
               if(cc_pwm > 1.0) {
                  end_sweep();
                  cc_pwm = 0.0;
               }
            }
         }
         else {
            delta = (cc_val - led_i);
            delta /= led_i;
            if(delta < 0.0) delta *= (DATA_SIZE) 0.50;
            else            delta *= (DATA_SIZE) 0.20;
            cc_pwm += (delta * cc_pwm);
         }
      }
      else {
         if(sweep_stop) {
            if(--sweep_tick <= 0) {
               sweep_tick = sweep_rate;
               cc_pwm += PWM_STEP;
               if(cc_pwm > 1.0) {
                  end_sweep();
                  cc_pwm = 0.0;
               }
            }
         }
         else {
            cc_pwm += PWM_STEP;
         }
      }
   }

   charged:
   if(cc_pwm > 1.0)        cc_pwm = 1.0;
   else if(cc_pwm <= 0.0F) cc_pwm = 0.0;

   pwm = (u16) (cc_pwm * 65535.0);
   set_batt_pwm(pwm);

   if(cc_mode == CC_LIPO) {
      sprintf(plot_title, " LiPo Charge %.3fA to %.3fV: led_i=%.3fA  pwm=%f %04X %04X", cc_val,lipo_volts, led_i, cc_pwm,pwm,pwm>>6);
   }
   else if(cc_mode == CC_AMPS) {
      sprintf(plot_title, " CC Load %.3fA: led_i=%.3fA  pwm=%f %04X %04X", cc_val, led_i, cc_pwm,pwm,pwm>>6);
   }
   else if(cc_mode == CC_VOLTS) {
      sprintf(plot_title, " CV Load %.3fV: led_v=%.3fV  pwm=%f %04X %04X", cc_val, led_v, cc_pwm,pwm,pwm>>6);
   }
   else if(cc_mode == CC_WATTS) {
      sprintf(plot_title, " CW Load %.3fW: led_v=%.3fV  led_i=%.3fA  led_w=%.3fW  pwm=%f %04X %04X", cc_val, led_v, led_i, led_w, cc_pwm,pwm,pwm>>6);
   }
   else if(cc_mode == PWM_SWEEP) {
      sprintf(plot_title, " PWM sweep from %.3f to %.3f:  pwm=%f %04X %04X", sweep_start, sweep_end, cc_pwm,pwm,pwm>>6);
   }
}


u32 last_unit_status;

float ldbg1, ldbg2, ldbg3, ldbg4;


void request_luxor_ver()
{
   if(luxor == 0) return;
   if(no_poll) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x00);
   send_tsip_end();
}

void get_luxor_packet()
{
u08 subcode;    // packet subcode
double val;
int i;
unsigned char buf[32];
int batt_volts, led_volts;
int batt_amps, led_amps;
int row;
int col;
int color;
int color_ovfl;
DATA_SIZE color_sum;
DATA_SIZE ccx, ccy, ccz;
DATA_SIZE cct1, cct2, cct3, cct4;

   // Luxor power/light analyzer
   subcode = tsip_byte();
   if(subcode == 0x00) {        // get version info
      luxor_hw_ver = tsip_byte();
      luxor_hw_rev = tsip_byte();
      luxor_sn_prefix = sn_prefix = tsip_byte();
      luxor_serial_num = serial_num = tsip_word();

      batt_volts = tsip_word();
      batt_amps = (int) (s16) tsip_word();
      led_volts = tsip_word();
      led_amps = (int) (s16) tsip_word();
      check_tsip_end(1);

      have_info |= ALL_ID_INFO;

      if(text_mode && first_key) return;
      if(zoom_screen) return;

      if(cal_mode) color = RED;
      else         color = WHITE;

      sprintf(
         out, "BAT:%3dV  %c%dA", 
         batt_volts, (batt_amps<0)?PLUS_MINUS:'+', (batt_amps<0)?0-batt_amps:batt_amps
      );
      vidstr(VER_ROW+1, VER_COL, color, out);
      sprintf(
         out, "LED:%3dV  %c%dA", 
         led_volts,  (led_amps<0)?PLUS_MINUS:'+',  (led_amps<0)?0-led_amps:led_amps
      );
      vidstr(VER_ROW+2, VER_COL, color, out);
      sprintf(out, "Ver: %d.%02d", luxor_hw_ver,luxor_hw_rev);
      vidstr(VER_ROW+3, VER_COL, color, out);

      show_version_header();
//    show_serial_info();
show_log_state();
   }
   else if(subcode == 0x01) {   // get readings
      if(0 && (luxor == 0)) {
         luxor = 10;
         rcvr_type = LUXOR_RCVR;
         tsip_type = LUXOR_TYPE;
         config_rcvr_type(1);
         need_msg_init = 2003;
//       reset_luxor_wdt(0x01);
//       config_luxor_plots();
         config_screen(201);
         request_luxor_ver();
         set_luxor_time();
      }
      ++tow;
      time_color = DST_TIME_COLOR;

      unit_status = tsip_dword();
      batt_pwm = tsip_word();

      pri_frac = raw_frac = 0.0;
      pri_seconds = seconds = tsip_byte();
      pri_minutes = minutes = tsip_byte();
      pri_hours = hours = tsip_byte();
      pri_day = day = tsip_byte();
      pri_month = month = tsip_byte();
      pri_year = year = tsip_byte() + 2000;

      tow = fake_tow(jd_utc) % (7L*24L*60L*60L);
      faked_tow = 4;
//    this_tow = tow;

      batt_v = dac_voltage = tsip_single();
      have_dac = 1;
      batt_i = tsip_single(); 

      led_pos = tsip_single(); 
      led_neg = tsip_single(); 
      led_v = led_pos - led_neg;
      led_i = tsip_single(); 
      adc2 = tsip_single();

      luxor_tc1 = temperature = tsip_single(); 
      luxor_tc2 = tsip_single(); 
      have_temperature2 = 2;
      have_temperature = 101;

      pwm_hz = tsip_single();

      lux1 = tsip_single(); 
      lux1_time = tsip_byte();

      lux2 = tsip_single(); 
      lux2_time = tsip_byte();

      red_hz = tsip_single();
      blue_hz = tsip_single();
      white_hz = tsip_single();
      green_hz = tsip_single();
      r_over_b = tsip_single();

      cal_mode = tsip_byte();
      ldbg1 = tsip_single();
      ldbg2 = tsip_single();
      ldbg3 = tsip_single();
      ldbg4 = tsip_single();

      check_tsip_end(1);


      if(show_debug_info) {
         sprintf(plot_title, "dbg1=%f dbg2=%f dbg3=%f dbg4=%f", ldbg1,ldbg2,ldbg3,ldbg4);
      }

      reset_luxor_wdt(0);

      if(unit_status != last_unit_status) {  // make sure fault display gets erased/redrawn
         last_unit_status = unit_status;
         need_redraw = 2012;
      }

      if(unit_status & FAULT_BITS) {
         end_sweep();
      }
      if(calc_ir) {     // battery internal resistance
         measure_ir();
      }
      constant_load();

      if(unit_status & RESET_BIT) {
         set_luxor_time();
         request_luxor_ver();
      }
      else if(cal_mode != last_cal_mode) request_luxor_ver();
      last_cal_mode = cal_mode;


      color_ovfl = 0;
      if(red_hz > SAT_COLOR_HZ)        color_ovfl |= RED_SAT;
      else if(red_hz > MAX_COLOR_HZ)   color_ovfl |= RED_OVFL;
      else if(red_hz < MIN_COLOR_HZ)   color_ovfl |= RED_LOW;

      if(green_hz > SAT_COLOR_HZ)      color_ovfl |= GREEN_SAT;
      else if(green_hz > MAX_COLOR_HZ) color_ovfl |= GREEN_OVFL;
      else if(green_hz < MIN_COLOR_HZ) color_ovfl |= GREEN_LOW;

      if(blue_hz > SAT_COLOR_HZ)       color_ovfl |= BLUE_SAT;
      else if(blue_hz > MAX_COLOR_HZ)  color_ovfl |= BLUE_OVFL;
      else if(blue_hz < MIN_COLOR_HZ)  color_ovfl |= BLUE_LOW;

      if(white_hz > SAT_COLOR_HZ)      color_ovfl |= WHITE_SAT;
      else if(white_hz > MAX_COLOR_HZ) color_ovfl |= WHITE_OVFL;
      else if(white_hz < MIN_COLOR_HZ) color_ovfl |= WHITE_LOW;

      cct  = calc_cct(0, 0, (double) red_hz, (double) green_hz, (double) blue_hz);
      cct1 = calc_cct(1, 0, (double) red_hz, (double) green_hz, (double) blue_hz);
      cct2 = calc_cct(2, 0, (double) red_hz, (double) green_hz, (double) blue_hz);

      cct3 = (cct + cct1 + cct2) / 3.0F;
      cct4 = sqrt((cct*cct + cct1*cct1 + cct2*cct2) / 3.0F);
cct3 = cct4;

      red_uw = red_hz / RED_SENS;
      green_uw = green_hz / GREEN_SENS;
      blue_uw = blue_hz / BLUE_SENS;
      white_uw = white_hz / WHITE_SENS;
if(alt_lux1) lux1 = green_uw * alt_lux1;

      calc_cie(red_uw, green_uw, blue_uw);

      if(cie_sum) {
         ccx = cie_x / cie_sum;
         ccy = cie_y / cie_sum;
         ccz = cie_z / cie_sum;
      }
      else {
         ccx = ccy = ccz = 0.0F;
         cct = cct1 = cct2 = 0.0F;
      }


      pps_offset = (double) lux1; 
      have_pps_offset = 2;
      have_rcvr_pps = 2;
      osc_offset = (double) batt_i; 
      have_osc_offset = 2;
      have_rcvr_osc = 2;

      update_gps_screen(5556);

      batt_w = (batt_v*batt_i);
      led_w = (led_v*led_i);

      if(text_mode && first_key) return;
      if(zoom_screen) return;

      if(1 && (SCREEN_HEIGHT > SHORT_SCREEN)) row = 1;
      else                                    row = 0;
      col = 30;

      if(cal_mode) unit_status |= CAL_MODE_BIT;
      sprintf(out, "Status: %08lX", (unsigned long) unit_status);
      if(unit_status & FAULT_BITS)      color = RED;
      else if(unit_status & BATTERY_ON) color = WHITE;
      else                              color = YELLOW;
      vidstr(row++, col, color, out);
      ++row;


      color_sum = (red_uw + green_uw + blue_uw) / 100.0F;
      if(color_sum == 0.0F) {
         sprintf(out, "Red:    none       ");
         vidstr(row++, col, GREY, out);
         sprintf(out, "Green:  none       ");
         vidstr(row++, col, GREY, out);
         sprintf(out, "Blue:   none       ");
         vidstr(row++, col, GREY, out);
         sprintf(out, "White:  none       ");
         vidstr(row++, col, GREY, out);
      }
      else if(show_color_hz) {
         sprintf(out, "Red:    %8.0f Hz", red_hz);
         if(color_ovfl & RED_OVFL)     color = YELLOW;
         else if(color_ovfl & RED_SAT) color = RED;
         else if(color_ovfl & RED_LOW) color = BLUE;
         else                          color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Green:  %8.0f Hz", green_hz);
         if(color_ovfl & GREEN_OVFL)     color = YELLOW;
         else if(color_ovfl & GREEN_SAT) color = RED;
         else if(color_ovfl & GREEN_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Blue:   %8.0f Hz", blue_hz);
         if(color_ovfl & BLUE_OVFL)     color = YELLOW;
         else if(color_ovfl & BLUE_SAT) color = RED;
         else if(color_ovfl & BLUE_LOW) color = BLUE;
         else                           color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "White:  %8.0f Hz", white_hz);
         if(color_ovfl & WHITE_OVFL)     color = YELLOW;
         else if(color_ovfl & WHITE_SAT) color = RED;
         else if(color_ovfl & WHITE_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);
      }
      else if(show_color_pct) {
         sprintf(out, "Red:    %8.3f %%", red_uw/color_sum);
         if(color_ovfl & RED_OVFL)     color = YELLOW;
         else if(color_ovfl & RED_SAT) color = RED; 
         else if(color_ovfl & RED_LOW) color = BLUE;
         else                          color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Green:  %8.3f %%", green_uw/color_sum);
         if(color_ovfl & GREEN_OVFL)     color = YELLOW;
         else if(color_ovfl & GREEN_SAT) color = RED;
         else if(color_ovfl & GREEN_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Blue:   %8.3f %%", blue_uw/color_sum);
         if(color_ovfl & BLUE_OVFL)     color = YELLOW;
         else if(color_ovfl & BLUE_SAT) color = RED;
         else if(color_ovfl & BLUE_LOW) color = BLUE;
         else                           color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "White:  %8.3f %%", white_uw/color_sum);
         if(color_ovfl & WHITE_OVFL)     color = YELLOW;
         else if(color_ovfl & WHITE_SAT) color = RED;
         else if(color_ovfl & WHITE_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);
      }
      else if(show_color_uw) {
         sprintf(out, "Red:   %9.3f uW/cm^2", red_hz/RED_SENS);
         if(color_ovfl & RED_OVFL)     color = YELLOW;
         else if(color_ovfl & RED_SAT) color = RED;
         else if(color_ovfl & RED_LOW) color = BLUE;
         else                          color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Green: %9.3f uW/cm^2", green_hz/GREEN_SENS);
         if(color_ovfl & GREEN_OVFL)     color = YELLOW;
         else if(color_ovfl & GREEN_SAT) color = RED;
         else if(color_ovfl & GREEN_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "Blue:  %9.3f uW/cm^2", blue_hz/BLUE_SENS);
         if(color_ovfl & BLUE_OVFL)     color = YELLOW;
         else if(color_ovfl & BLUE_SAT) color = RED;
         else if(color_ovfl & BLUE_LOW) color = BLUE;
         else                           color = WHITE;
         vidstr(row++, col, color, out);

         sprintf(out, "White: %9.3f uW/cm^2", white_hz/WHITE_SENS);
         if(color_ovfl & WHITE_OVFL)     color = YELLOW;
         else if(color_ovfl & WHITE_SAT) color = RED;
         else if(color_ovfl & WHITE_LOW) color = BLUE;
         else                            color = WHITE;
         vidstr(row++, col, color, out);
      }

      if(color_sum == 0.0F)                        color = GREY;
      else if(color_ovfl & (RED_SAT | BLUE_SAT))   color = RED;
      else if(color_ovfl & (RED_OVFL | BLUE_OVFL)) color = YELLOW;
      else if(color_ovfl & (RED_LOW | BLUE_LOW))   color = BLUE;
      else                                         color = WHITE;
      if(1) sprintf(out, "R/B:   %9.3f   ", r_over_b);
//    if(blue_hz) sprintf(out, "R/B:   %9.3f   ", red_hz/blue_hz);
      else        sprintf(out, "R/B:               ");
      vidstr(row++, col, color, out);
      sprintf(out, "CCT:   %9.3f %cK  ", cct, DEGREES);
      vidstr(row++, col, color, out);

      ++row;
      if(color_sum == 0.0F)                                     color = GREY;
      else if(color_ovfl & (RED_SAT | GREEN_SAT | BLUE_SAT))    color = RED;
      else if(color_ovfl & (RED_OVFL | GREEN_OVFL | BLUE_OVFL)) color = YELLOW;
      else if(color_ovfl & (RED_LOW | GREEN_LOW | BLUE_LOW))    color = BLUE;
      else                                                      color = WHITE;
//    sprintf(out, "ciex: %.4f  ", cie_x);
//    vidstr(row++, col, color, out); 
//    sprintf(out, "ciey: %.4f  ", cie_y);
//    vidstr(row++, col, color, out); 
//    sprintf(out, "ciez: %.4f  ", cie_z);
//    vidstr(row++, col, color, out); 
      sprintf(out, "ciex: %.4f  ", ccx);
      vidstr(row++, col, color, out); 
      sprintf(out, "ciey: %.4f  ", ccy);
      vidstr(row++, col, color, out); 
      sprintf(out, "ciez: %.4f  ", ccz);
      vidstr(row++, col, color, out); 
      ++row;

      sprintf(out, "cct1: %.3f %cK  ", cct1, DEGREES);
      vidstr(row++, col, color, out); 
      sprintf(out, "cct2: %.3f %cK  ", cct2, DEGREES);
      vidstr(row++, col, color, out); 
      sprintf(out, "cct3: %.3f %cK  ", cct3, DEGREES);
      vidstr(row++, col, color, out); 
//    sprintf(out, "cct4: %.3f %cK  ", cct4, DEGREES);
//    vidstr(row++, col, color, out); 
      sprintf(out, "bogoCRI:%6.2f  ", calc_cri(cct));
      vidstr(row++, col, color, out); 


      col = 0;
      if(1 && (SCREEN_HEIGHT > SHORT_SCREEN)) row = 1;
      else                                    row = 0;

      if(unit_status & (BATT_HVC_BIT | BATT_LVC_BIT)) color = RED;
//    else if((batt_v > 0.003F) && (batt_v < 0.300F)) color = BLUE;
      else if(unit_status & BATTERY_ON)               color = WHITE;
      else                                            color = YELLOW;
      sprintf(out, "Batt V: %8.3f V", batt_v);
      vidstr(row++, col, color, out);

      if(unit_status & BATT_OVC_BIT)    color = RED;
      else if(unit_status & BATTERY_ON) color = WHITE;
      else                              color = YELLOW;
      sprintf(out, "Batt I: %8.3f A", batt_i);
      vidstr(row++, col, color, out);

      if(unit_status & BATTERY_ON) {
         if(batt_pwm != 0xFFFF) color = GREY;
         else                   color = WHITE;
      }
      else color = YELLOW;
      sprintf(out, "Batt W: %8.3f W", batt_w);
      vidstr(row++, col, color, out);


      if(plot[AUXV].show_plot) {
         if(unit_status & AUXV_HVC_BIT)      color = RED;
         else if(unit_status & AUXV_LVC_BIT) color = RED;
         else                                color = WHITE;
         sprintf(out, "Aux V:  %8.3f V", adc2);
         vidstr(row++, col, color, out);
      }
      else if(SCREEN_HEIGHT >= SHORT_SCREEN) ++row;

      if(unit_status & (LOAD_HVC_BIT | LOAD_LVC_BIT))   color = RED;
//    else if((led_pos > 0.003F) && (led_pos < 0.300F)) color = BLUE;
//    else if((led_neg > 0.003F) && (led_neg < 0.300F)) color = BLUE;
      else if(unit_status & BATTERY_ON)                 color = WHITE;
      else                                              color = YELLOW;
      sprintf(out, "Led +:  %8.3f V", led_pos);
      vidstr(row++, col, color, out);
      sprintf(out, "Led -:  %8.3f V", led_neg);
      vidstr(row++, col, color, out);
      sprintf(out, "Led Vf: %8.3f V", fabs(led_v));
      vidstr(row++, col, color, out);

      if(unit_status & LOAD_OVC_BIT)    color = RED;
      else if(unit_status & BATTERY_ON) color = WHITE;
      else                              color = YELLOW;
      sprintf(out, "Led I:  %8.3f A", led_i);
      vidstr(row++, col, color, out);

      sprintf(out, "Led W:  %8.3f W", led_w);
      if(unit_status & BATTERY_ON) color = WHITE;
      else                         color = YELLOW;
      vidstr(row++, col, color, out);

      sprintf(out, "Eff:             ");
      if(batt_w) {
         val = fabs(led_w/batt_w*100.0);  // !!!!! fabs?
         if(batt_pwm != 0xFFFF) color = GREY;
         if(val < 120.0) sprintf(out, "Eff:    %8.3f %%", val);
         else            sprintf(out, "Eff:         ??? %%");
      }
      vidstr(row++, col, color, out);


      if(SCREEN_HEIGHT >= SHORT_SCREEN) ++row;
      if((unit_status & (TEMP1_IR | TEMP1_TC | TEMP1_AT)) == 0) {   // no chip seen
         color = GREY;
         sprintf(out, "Temp1:      NONE    ");
      }
      else {                            // thermocouple chip installed
         if(unit_status & TEMP1_OVT_BIT)      color = RED;     // over temp
         else if(unit_status & TEMP1_BAD_BIT) color = YELLOW;  // no thermocouple seen
         else                                 color = WHITE;
         sprintf(out, "Temp1:  %s", fmt_temp((double) tc1));
      }
      vidstr(row++, col, color, out);


      if((unit_status & (TEMP2_IR | TEMP2_TC | TEMP2_AT)) == 0) {   // no chip seen
         color = GREY;
         sprintf(out, "Temp2:      NONE    ");
      }
      else {
         if(unit_status & TEMP2_OVT_BIT)      color = RED;     // over temp
         else if(unit_status & TEMP2_BAD_BIT) color = YELLOW;  // no thermocouple seen
         else                                 color = WHITE;
         sprintf(out, "Temp2:  %s", fmt_temp((double) luxor_tc2));
      }
      vidstr(row++, col, color, out);




      if(SCREEN_HEIGHT >= SHORT_SCREEN) ++row;
      if(unit_status & LUX1_CHIP_BIT) {
//val = ((white_hz/243.56F) + ((red_hz+green_hz+blue_hz)/229.8F)) * (1.10F/2.0F);
         if(show_fc) sprintf(out, "Lux:    %8.3f fc  ", lux1*lux_scale);
         else        sprintf(out, "Lux:    %8.3f lux ", lux1*lux_scale);
         if(unit_status & LUX1_OVFL_BIT) color = RED;   
         else                            color = WHITE;
      }
      else {
         color = GREY;
         sprintf(out, "Lux:        NONE");
      }
      vidstr(row++, col, color, out);

      if(unit_status & LUX2_CHIP_BIT) {
         if(show_cp) sprintf(out, "Lum:    %8.3f cp  ", lux2*lum_scale);
         else        sprintf(out, "Lum:    %8.3f lum ", lux2*lum_scale);
         if(unit_status & LUX2_OVFL_BIT) color = RED;   
         else                            color = WHITE;
      }
      else {
         color = GREY;
         sprintf(out, "Lum:        NONE");
      }
      vidstr(row++, col, color, out);

      color = WHITE;
      sprintf(out, "PWM:    %8.3f Hz  ", pwm_hz);
      vidstr(row++, col, color, out);
   }
   else if(subcode == 0x07) {
      get_luxor_config();
   }
   else if(subcode == 0x10) {
      get_luxor_cal();
   }
   else if(1) {
      plot_title[0] = 0;
      for(i=0; i<9+8+8; i++) {
         buf[i] = tsip_byte();
//       sprintf(out, "%02X ", (unsigned) buf[i]);
//       strcat(plot_title, out);
      }
      check_tsip_end(1);
   }
   else {
      check_tsip_end(1);
   }
}

void set_luxor_time()
{
   if(luxor == 0) return;

   get_clock_time();   // in UTC

   send_tsip_start(LUXOR_ID); 
   send_byte(0x02);
   send_byte((u08) clk_seconds);
   send_byte((u08) clk_minutes);
   send_byte((u08) clk_hours);
   send_byte((u08) clk_day);
   send_byte((u08) clk_month);
   send_byte((u08) (clk_year%100));
   send_tsip_end();

   luxor_time_set = 1;
}

void set_luxor_sens(u08 lux1, u08 lux2)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x03);
   send_byte(lux1);
   send_byte(lux2);
   send_tsip_end();
}

void set_batt_pwm(u16 pwm)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x06);
   send_word(pwm);
   send_tsip_end();

   if(pwm == 0) {    // cancel alarm timers
      alarm_time = alarm_date = 0;
      egg_timer = 0;
      repeat_egg = 0;
   }
}


void set_pwm_step()
{
   if(batt_pwm_res == 8) PWM_STEP = (256.0F / 65536.0F);
   else if(batt_pwm_res == 9) PWM_STEP = (128.0F / 65536.0F);
   else { 
      PWM_STEP = (64.0F / 65536.0F);
      batt_pwm_res = 10;
   }
}

void set_luxor_config()
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x07);
   send_single((float) batt_lvc);
   send_single((float) batt_hvc);
   send_single((float) batt_ovc);
   send_single((float) batt_watts);
   send_single((float) load_lvc);
   send_single((float) load_hvc);
   send_single((float) load_ovc);
   send_single((float) load_watts);
   send_single((float) auxv_lvc);
   send_single((float) auxv_hvc);
   send_single((float) tc1_ovt);
   send_single((float) tc2_ovt);
   send_single((float) msg_timeout);

   send_single((float) lux1_time);
   send_single((float) lux2_time);
   send_single((float) emis1);
   send_single((float) emis2);

   send_byte(batt_pwm_res);
   send_tsip_end();

   set_pwm_step();

   Sleep(500);   // !!!!!! allow time for message to be processed
}

void get_luxor_config()
{
   if(luxor == 0) return;

   batt_lvc = tsip_single();
   batt_hvc = tsip_single(); 
   batt_ovc = tsip_single(); 
   batt_watts = tsip_single();
   load_lvc = tsip_single(); 
   load_hvc = tsip_single(); 
   load_ovc = tsip_single(); 
   load_watts = tsip_single();
   auxv_lvc = tsip_single(); 
   auxv_hvc = tsip_single(); 
   tc1_ovt = tsip_single(); 
   tc2_ovt = tsip_single(); 
   msg_timeout = tsip_single();

   lux1_time = (u08) tsip_single();
   lux2_time = (u08) tsip_single();
   emis1 = tsip_single(); 
   emis2 = tsip_single(); 

   batt_pwm_res = tsip_byte();
   set_pwm_step();
   check_tsip_end(1);
}

void set_luxor_cal()
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x11);
   send_single((float) vref_m);
   send_single((float) vref_b);
   send_single((float) temp1_m);
   send_single((float) temp1_b);
   send_single((float) temp2_m);
   send_single((float) temp2_b);
   send_single((float) vcal_m);
   send_single((float) vcal_b);
   send_single((float) batti_m);
   send_single((float) batti_b);
   send_single((float) ledi_m);
   send_single((float) ledi_b);
   send_single((float) lux1_m);
   send_single((float) lux1_b);
   send_single((float) lux2_m);
   send_single((float) lux2_b);
   send_single((float) adc2_m);
   send_single((float) adc2_b);
   send_single((float) rb_m);
   send_single((float) rb_b);
   send_tsip_end();

   Sleep(500);   // !!!!!! allow time for message to be processed
}

void get_luxor_cal()
{
   if(luxor == 0) return;

   vref_m = tsip_single();
   vref_b = tsip_single();
   temp1_m = tsip_single();
   temp1_b = tsip_single();
   temp2_m = tsip_single();
   temp2_b = tsip_single();
   vcal_m = tsip_single();
   vcal_b = tsip_single();
   batti_m = tsip_single();
   batti_b = tsip_single();
   ledi_m = tsip_single();
   ledi_b = tsip_single();
   lux1_m = tsip_single();
   lux1_b = tsip_single();
   lux2_m = tsip_single();
   lux2_b = tsip_single();
   adc2_m = tsip_single();
   adc2_b = tsip_single();
   rb_m = tsip_single();
   rb_b = tsip_single();

   check_tsip_end(1);
}


void set_luxor_runtime(u32 seconds)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x0A);
   send_dword(seconds);
   send_tsip_end();
}

void set_luxor_delay(u16 msecs)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x0B);
   send_word(msecs);
   send_tsip_end();
}


#define CLICK_TIME 500


void set_driver_mode()
{
int i, j;
int len;
int count;
float vals[128];
float val;

   // This routine sets the LED driver mode by pulsing the battery on and off.
   // It is also used to switch the battery on, off, or PWM it.

   end_sweep();
   count = 0;
   i = 0;
   len = strlen(edit_buffer);

   while(i < len) {   // get a list of numbers on the line
      for(j=i; j<len; j++) {   // find next number field
         if(edit_buffer[j] == 0) goto no_num;
         if(edit_buffer[j] == 0x0A) goto no_num;
         if(edit_buffer[j] == 0x0D) goto no_num;
         if(edit_buffer[j] == '.') goto got_num;
         if(isdigit(edit_buffer[j])) goto got_num;
         if(edit_buffer[j] == '*') {  // '*' is a double 100 msec pulse
            if(count >= 125) break;
            vals[count++] = 100;     // off
            vals[count++] = 100;     // on
            vals[count++] = 100;     // off
            vals[count++] = 100;     // on
         }
      }
      break;

      got_num:
      i = j;
      val = 0;
      val = (float) atof(&edit_buffer[i]);
      vals[count] = val;
      ++count;
      if(count >= 128) break;

      while(i < len) {  // skip over number
         ++i;
         if(edit_buffer[i] == 0) goto no_num;
         if(edit_buffer[i] == 0x0A) goto no_num;
         if(edit_buffer[i] == 0x0D) goto no_num;
         if(edit_buffer[i] == '.') continue;
         if(edit_buffer[i] < '0') break;
         if(edit_buffer[i] > '9') break;
         if(edit_buffer[i] == '*') break;
      }
   }

   no_num:
   if(count == 0) {  // no numbers on the line, toggle battery state
      if(batt_pwm) {
         set_batt_pwm(0);
      }
      else {
update_check();
         set_batt_pwm(65535);
      }
//    set_luxor_delay(CLICK_TIME);
      Sleep(CLICK_TIME);
   }
   else if((count == 1) && (vals[0] <= 1.0)) {  // single number
      if(vals[0] == 0.0F) {
         set_batt_pwm(0);
      }
      else {
update_check();
         if(vals[0] == 1.0F) set_batt_pwm(65535);
         else set_batt_pwm((u16) (val*65536.0F));
      }
   }
   else {  // pulse the battery
      for(i=0; i<count; i++) {
         if(i & 1) {  // an ON time
            set_batt_pwm(65535);
         }
         else {           // an OFF time
            set_batt_pwm(0);
         }
//       set_luxor_delay((u16) vals[i]);
         Sleep((DWORD) vals[i]);
         set_batt_pwm(65535);
      }
   }
}

void set_emissivity(DATA_SIZE em1, DATA_SIZE em2)
{
   if(luxor) {
      send_tsip_start(LUXOR_ID); 
      send_byte(0x04);
      send_single((float) em1);
      send_single((float) em2);
      send_tsip_end();
   }
   else if((rcvr_type == THERMO_RCVR) && (enviro_type == LFS_ENVIRO) && (enviro_sensors & ENV_EMIS)) {
      sprintf(out, "PEMIS%d\r", (int) (em1*100.0));
      send_enviro_cmd(out, RCVR_PORT);
   }
}


void set_cal_mode(u08 cal_mode)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x05);
   send_byte(cal_mode);
   send_tsip_end();
}

void reset_luxor_wdt(u08 flag)
{
   if(luxor == 0) return;

   send_tsip_start(LUXOR_ID); 
   send_byte(0x09);
   send_byte(flag);
   send_tsip_end();
}

//
//
//  TSIP receiver message dispatcher
//
//


void request_misc_msg()
{
   // This routine requests various minor status messages
   // It requests a different message each time it is called.

   if(first_request) {
////  request_rcvr_info(200);
      first_request = 0;
      saw_version = 0;
      req_num = 0;
   }

   if(POLLED_RCVR) { // these receivers have their own message polling routines
      return;
   }

   ++req_num;
   if     (req_num ==  1) request_version();
   else if(req_num ==  2) request_rcvr_config(2); 
   else if(req_num ==  3) request_timing_mode();
   else if(req_num ==  4) request_pps_mode();
   else if(req_num ==  5) request_pps_info();
   else if(req_num ==  6) request_survey_params();
   else if(req_num ==  7) request_sat_list();
   else if(req_num ==  8) {
      if(log_db == 0) request_sig_levels();
   }
   else if(req_num ==  9) request_sat_health(); 
   else if(req_num == 10) request_datum(); 
   else if(req_num == 11) request_utc_info();  // this message can hose up some res_t receivers
   else if(req_num == 12) request_filter_config();    // tsip only
else if(SV6_FAMILY && !ACU_GG && !ACU_360 && !ACUTIME && !PALISADE) req_num = 0;
else if(ACE3) req_num = 0;
else if(PALISADE) req_num = 0;
//   else if((rcvr_type == TSIP_RCVR) && !SV6 && !ACE3 && !PALISADE) {
   else if(rcvr_type == TSIP_RCVR) {
      if     (req_num == 13) request_all_dis_params();   // tsip only
      else if(req_num == 14) request_eeprom_status();    // tsip only
      else if(req_num == 15) request_dac_voltage();      // tsip only
      else if(req_num == 16) request_sat_status(0x00);   // tsip only
      else if(req_num == 17) request_alm_health();       // tsip only
      else if(req_num == 18) request_io_options();       // tsip only
      else if(req_num == 19) request_packet_mask();      // tsip only
      else if(req_num == 20) request_last_posn();        // tsip only
//    else if(saw_version == 0) {   // no response to version message requests
//    else if((com[RCVR_PORT].user_set_baud == 0) && ((have_info & VERSION_INFO) == 0) || ((have_info & PRODN_PARAMS) == 0) && ((have_info & MANUF_PARAMS) == 0)) {   // no response to version message requests
      else if(detect_rcvr_type && (com[RCVR_PORT].user_set_baud == 0) && ((saw_version == 0) || (saw_version == 0x0C))) {   // no response to version message requests
//sprintf(plot_title, "rnum:%d  saw_v:%d  new parity:%d", req_num, saw_version, com[RCVR_PORT].parity);
BEEP(503);
         com[RCVR_PORT].parity = (com[RCVR_PORT].parity+1) % 3;   // try different parity
         init_com(RCVR_PORT, 106);
         need_redraw = 2013; // ggggg
         req_num = 0;
      }
      else req_num = 0;
   }
   else req_num = 0;

   #ifdef SAT_TRAILS
      // here we try to get position info for untracked sats,  but tbolts
      // don't seem to want to give up the goods on untracked sats... but
      // we ask anyway
      if(++status_prn > 32) status_prn = 1; // !!!! max_sat_check
      request_sat_status(status_prn);
   #endif
}

void get_timing_msg()
{
   subcode = tsip_byte();

   if     (subcode == 0x0B) get_comp_time();
   else if(subcode == 0x14) get_unknown_msg(0x8F00 | subcode);  // * current datum values
   else if(subcode == 0x15) get_datums();
   else if(subcode == 0x20) get_sv6_fix();
   else if(subcode == 0x26) get_unknown_msg(0x8F00 | subcode);  // * eeprom write acknowledge
   else if(subcode == 0x41) get_manuf_params();
   else if(subcode == 0x42) get_prodn_params();
   else if(subcode == 0x45) get_segment_info();                 // EEPROM segemnt info
   else if(subcode == 0x4A) get_pps_settings();
   else if(subcode == 0x4B) get_unknown_msg(0x8F00 | subcode);  // * programming the survey limit
   else if(subcode == 0x4D) get_unknown_msg(0x8F00 | subcode);  // * automatic packet output mask
   else if(subcode == 0x4E) get_pps_mode();
   else if(subcode == 0xA0) get_dac_values();
   else if(subcode == 0xA1) get_osc_sense();

   else if(subcode == 0xA2) get_timing_mode();
   else if(subcode == 0xA5) get_packet_mask();
   else if(subcode == 0xA7) get_sat_solutions();   // not on ThunderBolt-E
   else if(subcode == 0xA8) get_discipline_params();
   else if(subcode == 0xA9) get_survey_params();
   else if(subcode == 0xAB) primary_timing(1);
   else if(subcode == 0xAC) secondary_timing(1);
   else if(subcode == 0xAD) get_unknown_msg(0x8F00 | subcode);  // * primary UTC time
   else if(subcode == 0xAE) get_ae_packet();
   else                     get_unknown_msg(0x8F00 | subcode);
}


void get_unknown_msg(u16 msg_id)
{
   if(msg_id == 0x13) {
      msg_id = get_next_tsip();
      if(log_comments && (log_stream & LOG_HEX_STREAM) && log_file) {
         fprintf(log_file, "#!! Message rejected: %02X\n      ", msg_id);
         if(log_flush_mode) fflush(log_file);
         kol = (-1);
      }
   }
   else {
      if(log_comments && (log_stream & LOG_HEX_STREAM) && log_file) {
         fprintf(log_file, "#!! Unknown message: id %02X:\n      ", msg_id);
         if(log_flush_mode) fflush(log_file);
         kol = (-1);
      }
   }

   tsip_rptr = tsip_wptr = 0;  // flush the tsip buffer
}


void wakeup_nortel()
{
int row, col;
unsigned c;

   // try to wake up the Nortel NTGS/NTPX/NTBW units

   if(sim_file) return;
   try_nortel = 0;
   saw_nortel = 0;
   if(PALISADE) return;
   if(SV6_FAMILY) return;
   if(nortel != 1) return;  

   try_nortel = 0xFF;
   wakeup_tsip_msg = 0;
   waking = 1;

   col = 0;
   row = 1;
   while(wakeup_tsip_msg == 0) {
      vidstr(row,col, RED, "*");
      refresh_page();
      ++col;

      SetDtrLine(RCVR_PORT, 1);
      if(NO_SCPI_BREAK && (rcvr_type == SCPI_RCVR)) ; 
      else SendBreak(RCVR_PORT);

      request_sig_levels();           // 0x27
      request_rcvr_health();          // 0x26
      request_sat_list();             // 0x24
      request_sat_status(0x00);       // 0x3C
      request_gps_time();             // 0x21
      request_io_options();           // 0x35
//    request_hw_ver();               // 1C 03
//    request_unk_ver();              // 1C 02
      request_version();              // 1F
      request_rcvr_config(4);         // BB 00
      request_filter_config();        // 70
      set_health_config(0x03, 0x00);  // 39 03 00
      request_c2();                   // C2
      request_7A_00();                // 7A 00
      request_datum();                // 8E 15
      Sleep(500);

      if(1 && com[RCVR_PORT].process_com) {
         loopy:
         abort_wakeup();
         if(SERIAL_DATA_AVAILABLE(RCVR_PORT)) {
            while(SERIAL_DATA_AVAILABLE(RCVR_PORT)) {
               c = get_com_char();
               while(c == DLE) {
                  if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
                     Sleep(100);
                  }
                  if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
                     goto loopy;
                  }
                  c = get_com_char();
                  if(c == ETX) goto etx_seen;
                  abort_wakeup();
               }
               abort_wakeup();
            }
            Sleep(100);
            goto loopy;
         }
         abort_wakeup();
         continue;
      }

      etx_seen:
      get_pending_gps(2);
      abort_wakeup();
   }

   waking = 0;
// set_pps_mode(RATE_1PPS);  // 1pps mode
// request_pps_mode();
}

void new_packet(int redraw)
{
   ++packet_count;
   if(packet_count == 1L) {
      if(redraw) need_redraw = 3333;  // get rid of any "no serial..." message
   }

   if(timing_seen == 2) { // reset queues when second time message seen
      new_queue(RESET_ALL_QUEUES, 100);
      timing_seen = 3;
   }

   // NEW_RCVR
   if(need_queue_reset) {  // data has just started comming in... reset queues when importand plots have data
      if(rcvr_type == RFTG_RCVR) {  // reset queues after first few packets have arrived
         if(have_dac && have_temperature && have_pps_offset) { // all plots now have data
            new_queue(RESET_ALL_QUEUES, 222);
            need_queue_reset = 0;
         }
      }
   }
}


void start_msg_decode(int redraw)
{
   // prepare to decode a receiver message

   msg_fault = 0x00;
   tsip_rptr = 0;
   ticc_rptr = 0;
   enviro_rptr = 0;

   first_msg = 0;
   last_msg = msg_id;
   ++wakeup_tsip_msg; // we have seen a message
   tsip_error = 0;    // this flag gets set if we see something wrong in a message
   early_end = 0;
   new_packet(redraw);

   flush_debug();
}


u32 tsip_packets;

void decode_tsip_message()
{
   flush_debug();

   msg_fault = 0x00;
   tsip_rptr = 0;
   msg_id = get_next_tsip();

   subcode = 0x00;
   first_msg = 0;
   last_msg = msg_id;
   ++wakeup_tsip_msg; // we have seen a TSIP message
   tsip_error = 0;    // this flag gets set if we see something wrong in a message
   early_end = 0;
   new_packet(0);

   ++tsip_packets;
   if(tsip_packets == 100) {
      if((have_temperature == 0) && (user_set_temp_plot == 0)) {  // no temperature readings to plot
         plot[TEMP].show_plot = 0;
      }
   }

   msg_id &= 0xFF;
   if     (msg_id == 0x13) get_unknown_msg(0x13);
   else if(msg_id == 0x1C) get_ebolt_version();
   else if(msg_id == 0x40) get_almanac_data();     // almanac data page
   else if(msg_id == 0x41) get_gps_time();         // ntpx, RES 360. SV6 family
   else if(msg_id == 0x42) get_single_ecef_fix();
   else if(msg_id == 0x43) get_velocity_fix();
   else if(msg_id == 0x44) get_sv6_sat_list();
   else if(msg_id == 0x45) get_version_info();
   else if(msg_id == 0x46) get_ebolt_health1();
   else if(msg_id == 0x47) get_sig_levels();
   else if(msg_id == 0x48) get_system_msg();       // GPS system message (get with packet 0x28)
   else if(msg_id == 0x49) get_alm_health();
   else if(msg_id == 0x4A) get_single_lla_fix(); 
   else if(msg_id == 0x4B) get_ebolt_health2();
   else if(msg_id == 0x4C) get_sv6_config(); 
   else if(msg_id == 0x4D) get_sv6_osc_offset(); 
   else if(msg_id == 0x4E) get_set_time_response(); //response to set GPS time (packet 0x2E)
   else if(msg_id == 0x4F) get_sv6_utc_info(); 
   else if(msg_id == 0x54) get_clock_bias();
   else if(msg_id == 0x55) get_io_options();
   else if(msg_id == 0x56) get_enu_velocity_fix();
   else if(msg_id == 0x57) get_last_fix_info();
   else if(msg_id == 0x58) get_packet_58();
   else if(msg_id == 0x59) get_sat_health();
   else if(msg_id == 0x5A) get_raw_data();
   else if(msg_id == 0x5B) get_eph_status();
   else if(msg_id == 0x5C) get_sat_tracking(0x5C);
   else if(msg_id == 0x5D) get_sat_tracking(0x5D); // res 360 receiver
   else if(msg_id == 0x5E) get_fix_status();       // additional fix status
   else if(msg_id == 0x5F) get_eeprom_status();
   else if(msg_id == 0x6C) get_sat_list(1);        // res 360 receiver
   else if(msg_id == 0x6D) get_sat_list(0);
   else if(msg_id == 0x70) get_filter_config();
   else if(msg_id == 0x72) get_posn_filter();
   else if(msg_id == 0x74) get_alt_filter();
   else if(msg_id == 0x75) get_high8_mode();
   else if(msg_id == 0x76) get_high6_mode();
   else if(msg_id == 0x78) get_diff_age();
   else if(msg_id == 0x82) get_diff_mode();
   else if(msg_id == 0x83) get_ecef_fix();
   else if(msg_id == 0x84) get_lla_fix();
   else if(msg_id == 0x8F) get_timing_msg();
   else if(msg_id == 0xBB) get_tsip_config();
   else if(msg_id == LUXOR_ID) get_luxor_packet();
   else                        get_unknown_msg(msg_id);

   if(com[RCVR_PORT].com_error) {    // we had a com timeout so were skipping serial reads
      com[RCVR_PORT].com_error = 0;  // we can stop searching since data is now comming in
   }

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_tsip_message()
{
u08 c;

   // this routine buffers up an incoming TSIP message and then parses it
   // when it is complete.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }


   if(tsip_sync == 0) {         // syncing to start of message, search for a DLE
      if(c == DLE) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) {    // DLE had been seen, now checking next byte
      if(c == DLE) {            // DLE DLE is a 0x10 data byte
         goto rst_msg;
      }
      else if(c == ETX) {       // DLE ETX is end-of-message
         goto rst_msg;          // ... should never happen here
      }
      else {                    // DLE xx is message start
         tsip_sync = 2;         // ... so accumulate the message
         if(tsip_wptr < MAX_TSIP) {
            tsip_buf[tsip_wptr++] = c;
         }
         else {                 // buffer overlow
            tsip_error |= OVFL_ERROR;
            goto rst_msg;
         }
      }
   }
   else if(tsip_sync == 2) {    // buffer up the message
      if(c == DLE) tsip_sync = 3;
      else if(tsip_wptr < MAX_TSIP) {
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
////     goto rst_msg;
      }
   }
   else if(tsip_sync == 3) {   // last char was a DLE
      if(c == ETX) {           // DLE ETX is end-of-message
         decode_tsip_message(); // so process the buffered message
         packet_end = 1;

         rst_msg:
         tsip_wptr = 0;
         tsip_sync = 0;
      }
      else {                   // DLE DLE is a DLE data byte and DLE xx is message ID
         if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
            tsip_buf[tsip_wptr++] = c;
         }
         else {
            tsip_error |= OVFL_ERROR;
////        goto rst_msg;
         }
         tsip_sync = 2;
      }
   }
   else {     // should never happen
      goto rst_msg;
   }
}


//
//
//
//   RT17 receiver stuff  (like NetRS RT17 format messages)
//
//
//

u08 rt17_buf[MAX_TSIP];  // used to build complete data record from consecutive packets
int rt17_wptr;

void flush_rt17_cmd()
{
int i;

   // flush any un-processed commands
if(debug_file) fprintf(debug_file, "flush rt17\n");
   for(i=0; i<=256; i++) send_byte(0); // toots - rt17 fix needed
}

void send_rt17_start(int msg, int len)
{
// flush_rt17_cmd();   // toots - RT17 fix needed
if(debug_file) fprintf(debug_file, "send rt17: %02x  len:%d\n", msg, len);

   send_byte(0x02);
   rt17_tx_cksum = 0;

   send_byte(0x00);   // status
   send_byte(msg);    // msg type
   send_byte(len);    // header len
}

void send_rt17_end()
{
if(debug_file) fprintf(debug_file, "cksum: %02x\n", rt17_tx_cksum);
   send_byte(rt17_tx_cksum & 0xFF);
   send_byte(0x03);
}


void parse_rt17_posn(int rif)
{
int flags;
int count;
int i;
double clock;
double freq;

   log_packet_id("Position");

   lat = tsip_double() * PI;
   lon = tsip_double() * PI;
   alt = tsip_double();
   clock = tsip_double();  // clock offset (meters)
   freq = tsip_double();   // freq offset (from 1536*1.023MHz)
   pdop = (float) tsip_double();
   have_dops |= PDOP;
   tsip_double();   // lat rate
   tsip_double();   // lon rate
   tsip_double();   // alt rate
   tsip_dword();    // time tag (msecs)
   flags = tsip_byte();
   count = tsip_byte();

   if(     (flags & 0x07) == 0x00) rcvr_mode = RCVR_MODE_SINGLE;
   else if((flags & 0x07) == 0x01) rcvr_mode = RCVR_MODE_2D;
   else if((flags & 0x07) == 0x02) rcvr_mode = RCVR_MODE_2DCLK;
   else if((flags & 0x07) == 0x03) rcvr_mode = RCVR_MODE_2D_3D;
   else if((flags & 0x07) == 0x04) rcvr_mode = RCVR_MODE_3D;
   else if((flags & 0x07) == 0x05) rcvr_mode = RCVR_MODE_DGPS;  // RTK/SBAS
   else                            rcvr_mode = RCVR_MODE_UNKNOWN; 

   for(i=0; i<count; i++) {  // channel numbers
      tsip_byte();
   }
   for(i=0; i<count; i++) {  // prn numbers
      tsip_byte();
   }

clock = (clock / (LIGHTSPEED*1000.0)); // convert meters to secs
clock *= 1.0E9;  // nsecs
pps_offset = clock;
have_pps_offset = 17;
osc_offset = freq;
have_osc_offset = 17;
}


void parse_rt17_event()
{
int source;
int port;
int tag;
double time;

   log_packet_id("Event");
   source = tsip_byte();
   port = tsip_byte();
   tag = tsip_word();
   time = tsip_double();  // msecs in GPS week
}



void rt17_concise(int rif)
{
int prn;
int flags1, flags2;
int az, el;
double snr;
double l2_snr;
double prange;
double phase;
double doppler;
int lli;

   // parse concise format realtime observation info

   prn = tsip_byte();
   flags1 = tsip_byte();
   flags2 = tsip_byte();
   el = (int) (s08) tsip_byte();
   az = (int) (s16) tsip_word();

   snr = 0.0;
   prange = 0.0;
   phase = 0.0;
   doppler = 0.0;
   lli = 0;

   if(flags1 & 0x40) {  // L1 data
      snr = (double) (u08) tsip_byte();      // snr
      snr /= 4.0;
      prange = tsip_double();   // pseudorange
      phase = tsip_double();    // phase
      doppler = (double) tsip_single();  // doppler

      if((prn >= 1) && (prn <= 32)) {
         sat[prn].level_msg = 1;
         sat[prn].sig_level = (float) snr;
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);

         phase = 0.0-phase;
         sat[prn].code_phase = phase;
         if(phase) {
            have_phase |= rinex_gnss(prn);
         }

         sat[prn].range = prange;
         if(prange) {
            have_range |= rinex_gnss(prn);
         }

         sat[prn].doppler = doppler;
         if(doppler) {
            have_doppler |= rinex_gnss(prn);
         }

         lli = 0;
         if(prange && (flags1 & 0x02)) lli |= CYCLE_SLIP;
         sat[prn].ca_lli = lli;
      }
sprintf(out, " -prn:%02d l1: snr:%f  phase:%f  range:%f  doppler:%f  flags1:%02X  flags2:%02X  lli:%02X", prn, snr, phase, prange, doppler, flags1,flags2, lli);
if(debug_file) fprintf(debug_file, "%s\n", out);
   }

   l2_snr = 0.0;
   prange = 0.0;
   phase = 0.0;
   doppler = 0.0;

   if(flags1 & 0x01) {  // L2 data
      l2_snr = (double) (u08) tsip_byte();      // snr
      l2_snr /= 4.0;
      phase = tsip_double();    // phase
      prange = (double) tsip_single();   // pseudorange

      if((prn >= 1) && (prn <= 32)) {
         sat[prn].l2_sig_level = (float) l2_snr;
         sat[prn].l2_level_msg = 17;
         have_l2_snr |= rinex_gnss(prn);

         if(flags1 & 0x10) phase = 0.0-phase;
         else phase = 0.0;

         if(flags1 & 0x20) prange = sat[prn].range + prange;
         else {
            prange = 0.0;
            phase = 0.0-sqrt(fabs(phase));
         }

         sat[prn].l2_code_phase = phase;
         if(phase) {
            have_l2_phase |= rinex_gnss(prn);
         }

         sat[prn].l2_range = prange;
         if(prange) {
            have_l2_range |= rinex_gnss(prn);
         }

         lli = 0;
         if(prange && (flags1 & 0x04)) lli |= CYCLE_SLIP;
         if(prange && (flags2 & 0x04)) lli |= P_TRACK;  // tracking encrypted code
         sat[prn].l2_lli = lli;
      }
sprintf(out, " -prn:%02d l2: snr:%f  phase:%f  range:%f  doppler:%f  flags1:%02X  flags2:%02X  lli:%02X", prn, l2_snr, phase, prange, doppler, flags1,flags2, lli);
if(debug_file) fprintf(debug_file, "%s\n", out);
   }

   if(rif & 0x02) {  // expanded format
      tsip_byte();    // iode
      tsip_byte();    // L1 slip counter
      tsip_byte();    // L2 slip counter
   }

   if((prn >= 1) && (prn <= 32)) {
      set_sat_azel(prn, (float) az, (float) el);
      if(snr > 0) sat[prn].tracking = prn;
      else        sat[prn].tracking = (-1);
      have_sat_azel = 17;
   }

   return;
}

void rt17_expanded(int rif)
{
int prn;
int flags1, flags2;
int flag_status;
int az, el;
double snr;
double l2_snr;
double prange;
double phase;
double doppler;
int lli;

   // parse expanded format realtine observation info

   prn = tsip_byte();
   flags1 = tsip_byte();
   flags2 = tsip_byte();
   flag_status = tsip_byte();
   el = (int) (s16) tsip_word();
   az = (int) (s16) tsip_word();

   snr = 0.0;
   prange = 0.0;
   phase = 0.0;
   doppler = 0.0;
   lli = 0;

   if(flags1 & 0x40) {  // L1 data
      snr = tsip_double();      // snr
      prange = tsip_double();   // pseudorange
      phase = tsip_double();    // phase
      doppler = tsip_double();  // doppler
      tsip_double();  // rsvd

      if((prn >= 1) && (prn <= 32)) {
         sat[prn].level_msg = 1;
         sat[prn].sig_level = (float) snr;
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);

         phase = 0.0-phase;
         sat[prn].code_phase = phase;
         if(phase) {
            have_phase |= rinex_gnss(prn);
         }

         sat[prn].range = prange;
         if(prange) {
            have_range |= rinex_gnss(prn);
         }

         sat[prn].doppler = doppler;
         if(doppler) {
            have_doppler |= rinex_gnss(prn);
         }

         lli = 0;
         if(prange && (flags1 & 0x02)) lli |= CYCLE_SLIP;
         sat[prn].ca_lli = lli;
      }
sprintf(out, "  prn:%02d l1: snr:%f  phase:%f  range:%f  doppler:%f  flags1:%02X  flags2:%02X  lli:%02X", prn, snr, phase, prange, doppler, flags1,flags2, lli);
if(debug_file) fprintf(debug_file, "%s\n", out);
   }

   l2_snr = 0.0;
   prange = 0.0;
   phase = 0.0;
   doppler = 0.0;

   if(flags1 & 0x01) {  // L2 data
      l2_snr = tsip_double();  // snr
      phase = tsip_double();   // phase
      prange = tsip_double();  // pseudorange

      if((prn >= 1) && (prn <= 32)) {
         sat[prn].l2_sig_level = (float) l2_snr;
         sat[prn].l2_level_msg = 17;
         have_l2_snr |= rinex_gnss(prn);

         if(flags1 & 0x10) phase = 0.0-phase;
         else phase = 0.0;

         if(flags1 & 0x20) prange = sat[prn].range + prange;
         else {
            prange = 0.0;
            phase = 0.0-sqrt(fabs(phase));
         }

         sat[prn].l2_code_phase = phase;
         if(phase) {
            have_l2_phase |= rinex_gnss(prn);
         }

         sat[prn].l2_range = prange;
         if(prange) {
            have_l2_range |= rinex_gnss(prn);
         }

         lli = 0;
         if(prange && (flags1 & 0x04)) lli |= CYCLE_SLIP;
         if(prange && (flags2 & 0x04)) lli |= P_TRACK;  // tracking encrypted code
         sat[prn].l2_lli = lli;
      }
   }

   if(rif & 0x02) {  // expanded format
      tsip_byte();    // iode
      tsip_byte();    // L1 slip counter
      tsip_byte();    // L2 slip counter
      tsip_byte();    // rsvd
      doppler = tsip_double();  // L2 doppler
      if((prn >= 1) && (prn <= 32)) {
         sat[prn].l2_doppler = doppler;
         if(doppler) {
            have_l2_doppler |= rinex_gnss(prn);
         }
      }
   }

   if((prn >= 1) && (prn <= 32)) {
      set_sat_azel(prn, (float) az, (float) el);
      if(snr > 0) sat[prn].tracking = prn;
      else        sat[prn].tracking = (-1);
      have_sat_azel = 17;
   }

sprintf(out, "  prn:%02d l2: snr:%f  phase:%f  range:%f  doppler:%f  flags1:%02X  flags2:%02X  lli:%02X", prn, l2_snr, phase, prange, doppler, flags1,flags2, lli);
if(debug_file) fprintf(debug_file, "%s\n", out);

   return;
}

void parse_rt17_realtime(int rif)
{
double xtow;
double clock;
int sats;
double jd, jd0;
static double last_jd0 = 0.0;

   // parse the rt17 realtime observations data message.
   // This message drives the screen update
   //
   // Claification on the use of the L2 carrier phase and pseudorange fields
   // came from the RTKLIB rt17.c file.

   log_packet_id("Realtime GPS data");
   level_type = "dBc";

   xtow = tsip_double();
   clock = tsip_double();
   sats = tsip_byte();
//sprintf(debug_text, "tow:%.6f  clk:%.6f  sum:%.6f", xtow,clock,xtow+clock);

   if(add_clk_ofs) {  // add receiver clock offset to the GPS time code
      xtow += clock;
   }

   get_clock_time();   // toots - so we can calc the gps week number
   jd0 = clk_jd + jtime(0,0,utc_offset,0.0);  // we are in UTC time, convert to GPS time
   jd0 -= GPS_EPOCH;

   if(1 && (jd0 < last_jd0)) {  // ignore backwards time skips
      last_jd0 = 0.0;
      return;
   }
   last_jd0 = jd0;

   tow = pri_tow = this_tow = survey_tow = (int) ((xtow+500.0)/1000.0);  
   have_tow = 17;

   gps_week = (int) (jd0 / 7.0);
   if(have_week == 0) need_redraw = 2054;
   have_week = 17;

   if(raw_msg_rate) {  // receiver always outputs RAW data at 1 Hz
      if((tow % raw_msg_rate) != 0) goto do_screen;  // drop unwanted messages
   }

   obs_tow = xtow / 1000.0;
   jd_obs = GPS_EPOCH + ((double) gps_week * 7.0) + jtime(0,0,0,obs_tow);

if(debug_file) {
   gregorian(0, jd_obs);
   fprintf(debug_file, "jd_obs gps: %04d/%02d/%02d %02d:%02d:%02d   rif:%02X  sats:%d\n", g_year,g_month,g_day, g_hours,g_minutes,g_seconds, rif,sats);
}

   reset_sat_tracking();
   while(sats--) {
      if(rif & 0x01) {  // concise format (has no L2 doppler)
         rt17_concise(rif);
      }
      else {  // expanded format (has L2 doppler... but NetRS always sends 0!, so why bother)
         rt17_expanded(rif);
      }
   }


   // update the screen
   do_screen:
   jd = xtow / 1000.0;
   jd /= (24.0*60.0*60.0);
   jd += jdate(1999,8,22);
   jd += (((double) gps_week-1024.0) * 7.0);

   set_gregorian_time(jd);   // set time variables

   if(timing_mode == TMODE_UTC) {  // we want UTC time - convert gps time to utc
      gps_to_utc();
   }

   update_gps_screen(1717);
}


void parse_rt17_raw5()
{
   // undocumented packet
   log_packet_id("Unknown RAW5");
}

void parse_rt17_raw6()
{
   // This packet is actually RT27 which is undocumented
   log_packet_id("Realtime GNSS data");
}

void parse_rt17_enh_posn()
{
   // this is a RT27 packet
   log_packet_id("Enhanced position");
}


void parse_rt17_svdata(int msg)
{
int subcode;

   // satellite data
   subcode = tsip_byte();
   sprintf(out, "SVDATA 0x%02X:%02X", msg, subcode);
   log_packet_id(out);
}


void parse_rt17_rawdata(int msg)
{
int subcode;
int page;
int reply;
int flags;

   subcode = tsip_byte();
   page = tsip_byte();
   reply = tsip_byte();
   flags = tsip_byte();

   if     (subcode == 0x00) parse_rt17_realtime(flags);
   else if(subcode == 0x01) parse_rt17_posn(flags);
   else if(subcode == 0x02) parse_rt17_event();
   else if(subcode == 0x05) parse_rt17_raw5();
   else if(subcode == 0x06) parse_rt17_raw6();
   else if(subcode == 0x07) parse_rt17_enh_posn();
   else {
      sprintf(out, "RAWDATA 0x%02X:%02X", msg, subcode);
      log_packet_id(out);
   }
}

void parse_rt17_gsof(int msg)
{
int reply;
int page;
int pages;

int subcode;
int len;

   reply = tsip_byte();
   page = tsip_byte();
   pages = tsip_byte();

   while(tsip_rptr < tsip_wptr) {  // parse the GSOF messages
      subcode = tsip_byte();
      len = tsip_byte();
      sprintf(out, "GSOF msg 0x%02X:%d", subcode, len);
      log_packet_id(out);
      // decode GSOF packets here
while(len--) tsip_byte();  // toots - skip payload bytes for now
break;
   }
}


void decode_rt17_msg(int msg, int status)
{
int page;
int pages;
int reply;
int i;
static int last_reply = (-2);
static int last_page = 0;

   // parse and decode the RT17 message

   start_msg_decode(1);

   have_critical_alarms = 17;
   if(status & 0x02) critical_alarms |= CRIT_PWR;
   else              critical_alarms &= (~CRIT_PWR);

   if(msg == 0x40) {  // GSOF data
      reply = rt17_buf[0];
      page = rt17_buf[1];
      pages = rt17_buf[2];
   }
   else if(msg == 0x57) {  // RAWDATA
      // rt17_buf[0] = message type subcode
      page = rt17_buf[1];
      reply = rt17_buf[2];

      pages = page & 0x0F;
      page  = (page >> 4) & 0x0F;
   }
   else {  // other messages
      for(i=0; i<tsip_wptr; i++) {  // copy RT17 buffer to tsip buffer
         if(i < MAX_TSIP) tsip_buf[i] = rt17_buf[i];
      }

      // !!!!parse message here
      if(msg == 0x55) parse_rt17_svdata(msg);
else if(debug_file) fprintf(debug_file, "Misc msg type %02X skipped.\n", msg);

      rt17_wptr = 0;
      last_reply = (-1);
      last_page = 0;
      return;
   }

if(0 && debug_file) {
   fprintf(debug_file, "copy page %d of %d   reply:%d  last_reply:%d  len:%d\n", page, pages, reply,last_reply, rt17_wptr);
}
   // merge multi-page packet data into one buffer (tsip_buf)
   if(page != (last_page + 1)) {  // page sequence error
if(debug_file) fprintf(debug_file, "page seq error: last:%d  this:%d\n", last_page, page);
      last_page = 0;
      return;
   }

   last_page = page;
   if(page == 1) {  // first page of data, copy all data
      last_reply = reply;
      for(i=0; i<tsip_wptr; i++) {
         if(rt17_wptr < MAX_TSIP) tsip_buf[rt17_wptr++] = rt17_buf[i];
      }
   }
   else if(reply != last_reply) {  // message sequence error
if(debug_file) fprintf(debug_file, "reply seq error: last:%d  this:%d\n", last_reply, reply);
   }
   else if(msg == 0x40) {  // copy only message data from following pages to tsip_buf
      for(i=3; i<tsip_wptr; i++) {  // skip subcode, reply, page, pages
         if(rt17_wptr < MAX_TSIP) tsip_buf[rt17_wptr++] = rt17_buf[i];
      }
   }
   else if(msg == 0x57) {  // copy only message data from following pages to tsip_buf
      for(i=4; i<tsip_wptr; i++) {  // skip subcode, page, reply, flags
         if(rt17_wptr < MAX_TSIP) tsip_buf[rt17_wptr++] = rt17_buf[i];
      }
   }
if(0 && debug_file) fprintf(debug_file, "Page:%02X  tsip_wptr:%d  rt17_wptr:%d\n", page, tsip_wptr, rt17_wptr);

   if(page != pages) {  // more pages follow for this message
      return;
   }
   last_page = 0;

   tsip_wptr = rt17_wptr;  // parse merged page buffer

   if(msg == 0x40) {  // GSOF
      parse_rt17_gsof(msg);
   }
   else if(msg == 0x57) {  // RAWDATA
      parse_rt17_rawdata(msg);
   }

   rt17_wptr = 0;
   last_reply = (-1);
}



void get_rt17_message()
{
u08 c;
static int status;
static int msg;
static int len, xlen;

   // This routine buffers up an incoming RT17 message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_rt17_msg()
   // Some RT17 messages are spread out over several packets.  decode_rt17_msg()
   // re-assembles them into one large packet for parsing.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == 0x02) {
         tsip_sync = 1;
         get_sync_time();
      }
      else if(c == 0x06) {  // ack
if(debug_file) fprintf(debug_file, "ack\n");
      }
      else if(c == 0x15) {  // nak
if(debug_file) fprintf(debug_file, "nak\n");
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      rt17_vfy_cksum = 0;  // the calculated message checksum
      rt17_msg_cksum = 0;  // the checksum in the message
      return;
   } 
   else if(tsip_sync == 1) { // STX has been seen, get status byte
      status = c;
      rt17_vfy_cksum += c;
      tsip_sync = 2;
   }
   else if(tsip_sync == 2) {  // msg type byte
      msg = c;
      rt17_vfy_cksum += c;
      tsip_sync = 3;
   }
   else if(tsip_sync == 3) {  // msg len
      len = xlen = c;
      rt17_vfy_cksum += c;
      tsip_sync = 4;
      if(len == 0) {      // null message
         tsip_sync = 5;
      }
   }
   else if(tsip_sync == 4) {  // message data
      rt17_vfy_cksum += c;
      rt17_buf[tsip_wptr++] = c;
      --len;
      if(len == 0) tsip_sync = 5;
   }
   else if(tsip_sync == 5) {  // checksum
      rt17_msg_cksum = c;
      tsip_sync = 6;
   }
   else if(tsip_sync == 6) {  // end of message
sprintf(out, "msg:%02X:%02X:%02X  status:%02X  len:%02x  etx:%02X  chk:%02X  vfy:%02X", 
msg,rt17_buf[0],rt17_buf[1],  status, xlen, c, rt17_msg_cksum&0xFF, rt17_vfy_cksum&0xFF);
if(debug_file) fprintf(debug_file, "%s\n", out);
      if(c != 0x03) goto rst_msg;  // ETX was expected

      rt17_msg_cksum &= 0xFF;
      rt17_vfy_cksum &= 0xFF;
      if(rt17_vfy_cksum != rt17_msg_cksum) goto rst_msg;  // checksums dont match

      decode_rt17_msg(msg, status);  // message checksum matches, process the message
      packet_end = 1;

      tsip_wptr = 0;     // prepare for next message
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      rt17_wptr = 0;
      rt17_vfy_cksum = rt17_msg_cksum = 0; // init received message checksum
   }
}


//
//
//   NMEA receiver stuff
//
//

#define NMEA_ZDA 1     // messages that can provide NMEA time/date
#define NMEA_RMC 2
#define NMEA_GGA 3
#define NMEA_GNS 4

#define TIME_FILTER  1 // set to non-zero to prioritze possible date/time sources
                       // set to 0 to get date/time from all NMEA messages


int last_was_gsv;


int is_numeric(char *field)
{
unsigned i;

   // returns true if field starts with + - . or digit

   if(field[0] == 0) return 0;

   for(i=0; i<strlen(field); i++) {  // skip leading whitespace
      if(field[i] == ' ') ;
      else if(field[i] == '\t') ;
      else {  // first non-whitespace seen
         if(field[i] == '+') return 1;
         if(field[i] == '-') return 2;
         if(field[i] == '.') return 3;
         if((field[i] >= '0') && (field[i] <= '9')) return 4;
         if((field[i] == '.') && (field[i+1] >= '0') && (field[i+1] <= '9')) return 5;
         break;
      }
   }

   return 0;  // field is not a number
}


int get_msg_field()
{
char c;
unsigned i;
int quote;

   // extract the next comma (or other separator char) separated field from a
   // message (this routine is also used by several different receiver types 
   // besides NMEA)

   msg_field[0] = 0;
   if(nmea_msg[msg_col] == 0) return 0;  // at end-of-message

   i = 0;
   quote = 0;
   while(msg_col < (int)sizeof(nmea_msg)) {   // get next field from the nmea message
      c = nmea_msg[msg_col];
      if((c == '"') && (rcvr_type == CS_RCVR)) {  // quoted strings allowed
         ++msg_col;
         if(quote) quote = 0;
         else      quote = 1;
      }
      else if((c == '"') && (rcvr_type == SA35_RCVR)) {  // quoted strings allowed
         ++msg_col;
         if(quote) quote = 0;
         else      quote = 1;
      }
      else if(c == 0) {  // reached end-of-message
         break;
      }
      else if(quote) {  // quoted string
         goto add_char;
      }
      else if((c == ',') && (rcvr_type != TICC_RCVR)) { // end of comma delimted field
         ++msg_col;   // HP interval counters have commas in their numbers
         break;
      }
      else if((rpn_mode > 0) && (c == ' ')) {
         ++msg_col;
         if(i) break;
      }
      else if((rcvr_type == BRANDY_RCVR) && (c == ' ')) {    // skip leading spaces, end field on a space 
         ++msg_col;
         if(i) break;
         break;
      }
      else if((rcvr_type == STAR_RCVR) && (c == '=')) {
         ++msg_col;
         break;
      }
      else if((rcvr_type == TICC_RCVR) && (c == ' ')) {  // skip leading spaces, end field on a space
         ++msg_col;
         if(i) break;
      }
      else if((rcvr_type == TICC_RCVR) && (c == '\t')) {  // skip leading spaces, end field on a space
         ++msg_col;
         if(i) break;
      }
      else if((rcvr_type == TRUE_RCVR) && (c == ' ')) {    // skip leading spaces, end field on a space 
         ++msg_col;
         if(i) break;
         break;
      }
      else if((rcvr_type == TSERVE_RCVR) && (c == ':')) {    // skip leading spaces, end field on a ':'
         ++msg_col;
         if(i) break;
         break;
      }
      else if(0 && (rcvr_type == Z12_RCVR) && (c == ':')) {    // skip leading spaces, end field on a ':'
         ++msg_col;
         if(i) break;
         break;
      }
      else {        // add char to extracted field
         add_char:
         if(i < (sizeof(msg_field) - 1)) {
            msg_field[i++] = c;
            msg_field[i] = 0;
            ++msg_col;
         }
      }
   }

   return msg_field[0];
}


void parse_gpgsa(int system)
{
int mode_flag;
int fix_status;
int prn;
int i;

   if((system & system_mask) == 0) return;

   last_was_gsv = 0;
   if(get_msg_field()) mode_flag = msg_field[0];

   if(get_msg_field()) {
      if(0 && (rcvr_type == BRANDY_RCVR)) ;  // we get rvcr_mode from the Brandywine ",A" message
      else if(rcvr_type == ESIP_RCVR) ;  // we get rvcr_mode from the CRY message
      else {
         fix_status = atoi(msg_field);
         i = rcvr_mode;
         if(fix_status == 1) {
            rcvr_mode = RCVR_MODE_NO_SATS;  
            if((rcvr_type == FURUNO_RCVR) && have_furuno_fix_mode) {
               if((furuno_fix_mode == 2) || (furuno_fix_mode == 4)) {  // !!!! fix mode 4?
                  rcvr_mode = RCVR_MODE_HOLD;
               }
            }
         }
         else if(fix_status == 2) rcvr_mode = RCVR_MODE_2D;
         else if(fix_status == 3) rcvr_mode = RCVR_MODE_3D;
         else                     rcvr_mode = RCVR_MODE_UNKNOWN;
         have_tracking = 1;

         minor_alarms &= (~MINOR_NO_TRACK);
         if(rcvr_mode == RCVR_MODE_NO_SATS) { 
            if(rcvr_type == BRANDY_RCVR) rcvr_mode = i;  // Brandywine GPSDO sends fix_mode == 1 in position hold mode?
            else minor_alarms |= MINOR_NO_TRACK;
         }
         have_rcvr_mode = 2;
      }
   }

   for(i=1; i<=12; i++) {   // list of sats being tracked
      if(get_msg_field()) {
         prn = atoi(msg_field);
         if((prn >= 1) && (prn <= MAX_PRN)) { 
            sat[prn].tracking = prn;
            sat[prn].level_msg = 2;
            have_snr |= rinex_gnss(prn);
         }
      }
   }

// have_dops = 0;
   if(get_msg_field()) {
      pdop = (float) atof(msg_field);
      have_dops |= PDOP;
   }
   if(get_msg_field()) {
      hdop = (float) atof(msg_field);
      have_dops |= HDOP;
   }
   if(get_msg_field()) {
      vdop = (float) atof(msg_field);
      have_dops |= VDOP;
   }
}

void parse_gpgsv(int system)
{
int num_sents;
int sent_num;
int sat_count;
int prn;
int az, el;
int snr;
int i;

   if((system & system_mask) == 0) return;

   if(get_msg_field()) {
      num_sents = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {
      sent_num = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {
      sat_count = atoi(msg_field);
      have_count = 1;
   }

//   if(sent_num == 1) {  // reset sat tracking info 
   if(last_was_gsv == 0) {  // reset sat tracking info 
      reset_sat_tracking();
   }

   last_was_gsv = 1;

   for(i=0; i<4; i++) {
      if(get_msg_field()) prn = atoi(msg_field);
      else continue;

      if(get_msg_field()) el = atoi(msg_field);
      else continue;

      if(get_msg_field()) az = atoi(msg_field);
      else continue;

      if(get_msg_field()) snr = atoi(msg_field);
      else {
         snr = (0);
//       continue;
      }

      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].level_msg = 1;
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].sig_level = (float) snr;
         have_snr |= rinex_gnss(prn);
         if(snr > 0) sat[prn].tracking = prn;
         else        sat[prn].tracking = (-1);
         have_sat_azel = 2;

         record_sig_levels(prn);
      }
   }

   if(sent_num == num_sents) {
      level_type = "SNR";
      if((rcvr_type == BRANDY_RCVR) && (have_gpgsv == 0)) {
         new_queue(RESET_ALL_QUEUES, 1504);
      }
      have_gpgsv = system;
   }

   config_sat_count(sat_count);
}

void get_nmea_lat()
{
double deg;

   if(get_msg_field()) {
      deg = atof(msg_field);
      lat = (double) (int) (deg / 100.0);
      deg = deg - (lat * 100.0);
      deg /= 60.0;
      lat += deg;
      lat *= (PI / 180.0);
   }

   if(get_msg_field()) {
      if(msg_field[0] == 'S') lat = 0.0 - lat;
   }
}

void get_nmea_lon()
{
double deg;

   if(get_msg_field()) {
      deg = atof(msg_field);
      lon = (double) (int) (deg / 100.0);
      deg = deg - (lon * 100.0);
      deg /= 60.0;
      lon += deg;
      lon *= (PI / 180.0);
   }

   if(get_msg_field()) {
      if(msg_field[0] == 'W') lon = 0.0 - lon;
   }
}

void get_nmea_alt()
{
   if(get_msg_field()) {  //altitude
      alt = atoi(msg_field);
      get_msg_field();    // meters or feet
      if(msg_field[0] == 'F') alt = alt * FEET_PER_METER;
   }
   else get_msg_field();  // meters or feet
}

void get_nmea_time()
{
double ftime;
int time;

   // get a time field from a NMEA message

   if(rcvr_type == BRANDY_RCVR) {  // we use the brandywine time and date message
      get_msg_field();
   }
   else if(get_msg_field()) {  // time
      ftime = atof(msg_field);  // time field can be floating point
      time = (int) ftime;
      pri_hours = hours = (time / 10000);
      pri_minutes = minutes = ((time / 100) % 100);
      pri_seconds = seconds = ((time / 1) % 100);
      pri_frac = raw_frac = ftime - (double) time;
//vvvv   time_flags |= TFLAGS_UTC;  // UTC based time
      if(timing_mode == TMODE_GPS) {  // convert utc time to gps time
         utc_to_gps();
      }
      time_flags &= (~TFLAGS_INVALID);
   }
   else if(1) { // empty time field, use system clock and flag as invalid time
      get_clock_time();
      hours = pri_hours = clk_hours;
      minutes = pri_minutes = clk_minutes;
      seconds = pri_seconds = clk_seconds;
      pri_frac = raw_frac = clk_frac;
      time_flags |= (~TFLAGS_INVALID);
   }
}

void get_nmea_date()
{
int date;

   // get a date field from a NMEA message

   if(rcvr_type == BRANDY_RCVR) {  // we use the brandywine time and date message
      get_msg_field();
   }
   else if(get_msg_field()) {
      date = atoi(msg_field);
      have_nmea_date = 0x07;     // we have day/month/year

      pri_day = day = (date / 10000);
      pri_month = month = ((date / 100) % 100);
      pri_year = ((date / 1) % 100);
      if(pri_year > TRUNC_YEAR) pri_year += 1900;
      else                      pri_year += 2000;
      year = pri_year;
   }
}


void check_nmea_date()
{
   // fake a date from the system clock if none seen from the GPS
   if(rcvr_type == BRANDY_RCVR) return;

   if(have_nmea_date != 0x07) {  // SV6_TYPE - has no date messages, use the system clock
      get_clock_time();
      year = pri_year = clk_year;
      month = pri_month = clk_month;
      day = pri_day = clk_day;
   }
}


void parse_gpgll(int system)
{
double old_lat, old_lon,old_alt;

   old_lat = lat;
   old_lon = lon;
   old_alt = alt;

   get_nmea_lat();
   get_nmea_lon();
   get_nmea_alt();

   if(get_msg_field()) {  // status: A=valid  V=invalid
      if(msg_field[0] == 'V') {
         lat = old_lat;
         lon = old_lon;
         alt = old_alt;
      }
   }
   if(get_msg_field()) {  // mode: A=autonomus  D=differential  N=invalid
      if(msg_field[0] == 'N') {
         lat = old_lat;
         lon = old_lon;
         alt = old_alt;
      }
   }
}


void parse_gpvtg(int system)
{
   // !!!!! parse this
}


void parse_gpgns(int system)
{
double old_lat, old_lon, old_alt;
int old_hours;
int old_minutes;
int old_seconds;
int old_year;
int old_month;
int old_day;
double old_frac;

int old_pri_hours;
int old_pri_minutes;
int old_pri_seconds;
int old_pri_year;
int old_pri_month;
int old_pri_day;
double old_pri_frac;
unsigned i, aok;

   have_gpgns = system;
   last_was_gsv = 0;

   old_lat = lat;
   old_lon = lon;
   old_alt = alt;

   old_pri_hours = pri_hours;
   old_pri_minutes = pri_minutes;
   old_pri_seconds = pri_seconds;
   old_pri_year = pri_year;
   old_pri_month = pri_month;
   old_pri_day = pri_day;
   old_pri_frac = pri_frac;

   old_hours = hours;
   old_minutes = minutes;
   old_seconds = seconds;
   old_year = year;
   old_month = month;
   old_day = day;
   old_frac = raw_frac;

   if     (TIME_FILTER && have_gpzda) get_msg_field();
   else if(TIME_FILTER && have_gprmc) get_msg_field(); 
   else if(TIME_FILTER && have_gpgga) get_msg_field(); 
   else                               get_nmea_time();

   get_nmea_lat();
   get_nmea_lon();

   if(get_msg_field()) {  // mode
      aok = 0;
      for(i=0; i<strlen(msg_field); i++) {
         if(msg_field[i] != 'N') ++aok;
      }

      if(aok == 0) {  // invalid fix for all systems
         reject:
         lat = old_lat;
         lon = old_lon;
         alt = old_alt;

         pri_hours = old_pri_hours;   
         pri_minutes = old_pri_minutes; 
         pri_seconds = old_pri_seconds; 
         pri_year = old_pri_year;    
         pri_month = old_pri_month;   
         pri_day = old_pri_day;     
         pri_frac = old_pri_frac;    

         hours = old_hours;   
         minutes = old_minutes; 
         seconds = old_seconds; 
         year = old_year;    
         month = old_month;   
         day = old_day;     
         raw_frac = old_frac;
         return;
      }
   }
   else goto reject;

   if(get_msg_field()) {  // sat count
      sat_count = atoi(msg_field);
      have_count = 2;
   }

   get_msg_field();  // HDOP

   if(get_msg_field()) {
      alt = atoi(msg_field);
   }

   if(get_msg_field()) {  // geoid height separation in meters
   }
   if(get_msg_field()) {  // DGPS age
   }
   if(get_msg_field()) {  // DGPS ref station id
   }

   if(get_msg_field()) {  // nav status - non-standard, Furuno sends this
      // S=safe
      // C=caution
      // U=unsafe
      // V=valid
   }

   config_sat_count(sat_count);

   check_nmea_date();

   // priority of date/time is ZDA, RMC, GGA, GNS
   if     (TIME_FILTER && have_gpzda) ;
   else if(TIME_FILTER && have_gprmc) ;
   else if(TIME_FILTER && have_gpgga) ;
   else drive_nmea_screen(system, NMEA_GNS);
}


void parse_gprmc(int system)
{
   if((system & system_mask) == 0) return;

   last_was_gsv = 0;
   have_gprmc = system;

   if(TIME_FILTER && have_gpzda) get_msg_field();
   else                          get_nmea_time();

   get_msg_field();  // active flag A=good  V=invalid fix

   if(msg_field[0] == 'A') {
      get_nmea_lat();
      get_nmea_lon();

      if(get_msg_field()) {  // speed (km/hr)
         speed = atof(msg_field) * 0.514444;
         have_speed = 4;
      }
      if(get_msg_field()) {  // course angle
         heading = atof(msg_field);
         have_heading = 4;
      }

      if(rcvr_type == BRANDY_RCVR) return;  // Brandywine gets date/time from a different message

      if(TIME_FILTER && have_gpzda && (have_nmea_date == 0x07)) get_msg_field();
      else get_nmea_date();
   }

   check_nmea_date();

   if(TIME_FILTER && have_gpzda) ;
   else drive_nmea_screen(system, NMEA_RMC);
}


void parse_gpgga(int system)
{
int fix;

   if((system & system_mask) == 0) return;

   last_was_gsv = 0;
   if((rcvr_type == BRANDY_RCVR) && (have_gpgga = 0)) {
      new_queue(RESET_ALL_QUEUES, 1504);
   }
   have_gpgga = system;

   if     (TIME_FILTER && have_gpzda) get_msg_field();
   else if(TIME_FILTER && have_gprmc) get_msg_field();
   else                               get_nmea_time();  // was get_msg_field();

   get_nmea_lat();
   get_nmea_lon();

   get_msg_field();  // fix status   zzzzz - verify fix is good
   if(msg_field[0]) fix = atoi(msg_field);
   else             fix = 0;

   if(get_msg_field()) { // sat count
      sat_count = atoi(msg_field);
      have_count = 3;
   }

   if(get_msg_field()) { // hdop
      hdop = (float) atof(msg_field);
      have_dops |= HDOP;
   }

   get_nmea_alt();

   get_msg_field();  // geiod height
   get_msg_field();  // dgps time
   get_msg_field();  // dgps station

   config_sat_count(sat_count);

   check_nmea_date();

   if     (TIME_FILTER && have_gpzda) ;
   else if(TIME_FILTER && have_gprmc) ;
   else if(rcvr_type == BRANDY_RCVR) {
      return;  // Brandywine gets date/time from a different message
   }
   else drive_nmea_screen(system, NMEA_GGA);
}

void parse_gpzda(int system)
{
int tz_hours;
int tz_minutes;
double tz_adjust;
double jd;


   if((rcvr_type == Z12_RCVR) && ZDA_TIME) {
      get_norcvr_message();
      return;
   }

   if((system & system_mask) == 0) return;

   have_gpzda = system;

   tz_hours = 0;      // time zone adjustment
   tz_minutes = 0;
   tz_adjust = 0.0;

   last_was_gsv = 0;

   // Note: OSX45xx corrupts the ZDA message if the receiver has rollover issues
   get_nmea_time();
   if(get_msg_field()) {
      pri_day = day = atoi(msg_field);
      if((pri_day < 1) || (pri_day > 31)) ;
      else have_nmea_date |= 0x01;
   }
   if(get_msg_field()) {
      pri_month = month = atoi(msg_field);
      if((pri_month < 1) || (pri_month > 12)) ;
      else have_nmea_date |= 0x02;
   }
   if(get_msg_field()) {
      pri_year = year = atoi(msg_field);
      if((pri_year < ROLLOVER_YEAR) || (pri_year > (ROLLOVER_YEAR+50)));  // piss3 bogus year, use sys clock
      else have_nmea_date |= 0x04;
   }

   check_nmea_date();

   if(get_msg_field()) {  // time zone hours
      tz_hours = atoi(msg_field);
      if(get_msg_field()) {  // time zone minutes
         tz_minutes = atoi(msg_field);
         if((tz_hours < 0) && (tz_minutes > 0)) tz_minutes = 0 - tz_minutes;
      }
      // !!!!!! we should adjust receiver time for time zone if not UTC
      tz_adjust = jtime(tz_hours,tz_minutes,0,0.0);
      if(tz_adjust) {
         jd = jdate(pri_year,pri_month,pri_day) + jtime(pri_hours,pri_minutes,pri_seconds,pri_frac);   
         jd -= tz_adjust;

         set_gregorian_time(jd);
      }
   }

   drive_nmea_screen(system, NMEA_ZDA);
}


void config_jackson()
{
   // proprietary Jackson Labs STATUS message seen... config for Jack Labs LTE-Lite 

   if(lte_lite) return;  // we are already congigured

   lte_lite = 1;
   have_info |= ALL_ID_INFO;

if(1 || (rcvr_type != VENUS_RCVR)) {
   rcvr_type = VENUS_RCVR;
   nmea_type = VENUS_NMEA;
   lte_lite = 1;
   config_rcvr_type(0);
   need_msg_init = 2005;
   lte_lite = 1;
}

   plot[DAC].plot_id = "DAC";    // setup plots
   plot[DAC].units = "%";
   plot[DAC].scale_factor = 1.0;
   plot[DAC].ref_scale = 1.0;
   if(user_set_dac_plot == 0) plot[DAC].show_plot = 1;

   plot[OSC].units = " ns";
   plot[OSC].ref_scale = 1.0F;
   ppt_string = " ns";
   ppb_string = " ns";
   if(user_set_osc_float == 0) plot[OSC].float_center = 1;
   if(user_set_osc_plot == 0) plot[OSC].show_plot = 1;

   if(user_set_pps_plot == 0) plot[PPS].show_plot = 1;
   if(user_set_pps_float == 0) plot[PPS].float_center = 1;

// if(user_set_dac_float == 0) plot[DAC].float_center = 1;
   new_queue(RESET_ALL_QUEUES, 135);  // flush old data
   need_redraw = 6386;
}

void parse_pjlts(int system)
{
int i;

   // Jackson labs LTE Lite STATUS message

   config_jackson();

   if(get_msg_field()) {  // filtered UTC offset in ns
      pps_offset = (OFS_SIZE) (atof(msg_field) / 1.0);
      have_pps_offset = 59;
   }

   if(get_msg_field()) {  // raw UTC offset in ns
   }

   if(get_msg_field()) {  // captured PPS pulses
   }

   if(get_msg_field()) {  // lock status
      i = atoi(msg_field);
      if     (i == 0) discipline_mode = DIS_MODE_WARMUP;
      else if(i == 1) discipline_mode = DIS_MODE_AUTO_HOLD;
      else if(i == 2) discipline_mode = DIS_MODE_LEARNING;
      else if(i == 5) discipline_mode = DIS_MODE_SOFT_HOLD;
      else if(i == 6) discipline_mode = DIS_MODE_NORMAL;
      else            discipline_mode = DIS_MODE_UNKNOWN;
   }

   if(get_msg_field()) {  // EFC voltage
   }

   if(get_msg_field()) {  // EFC %
      dac_voltage = (DATA_SIZE) atof(msg_field);
      have_dac = 77;
   }

   if(get_msg_field()) {  // freq accuracy
      osc_offset = (OFS_SIZE) (atof(msg_field) * 1.0E9);
      have_osc_offset = 59;
   }

   if(get_msg_field()) {  // holdover seconds
      holdover = (u32) atoi(msg_field);
   }

   if(get_msg_field()) {  // tracked sats
      if(have_sawtooth == 0) {
         sat_count = jackson_sat_count = atoi(msg_field);
         have_count = 333;
      }
   }

   if(get_msg_field()) {  // health status
      i = atohex(msg_field);

      if(i & 0x03) critical_alarms |= CRIT_OCXO;
      else         critical_alarms &= (~CRIT_OCXO);
      have_critical_alarms = 86;

      if(i & 0x04) minor_alarms |= MINOR_JL_PHASE;
      else         minor_alarms &= (~MINOR_JL_PHASE);

      if(i & 0x08) minor_alarms |= MINOR_JL_RUNTIME;
      else         minor_alarms &= (~MINOR_JL_RUNTIME);

      if(i & 0x10) minor_alarms |= MINOR_JL_HOLD;
      else         minor_alarms &= (~MINOR_JL_HOLD);

      if(i & 0x20) minor_alarms |= MINOR_JL_FREQ;
      else         minor_alarms &= (~MINOR_JL_FREQ);

      if(i & 0xC0) minor_alarms |= (MINOR_OSC_AGE);
      else         minor_alarms &= (~MINOR_OSC_AGE);
      have_osc_age = 86;

      if(i & 0x200) minor_alarms |= MINOR_JL_CHANGE;
      else          minor_alarms &= (~MINOR_JL_CHANGE);
   }

   if(lte_lite == 1) {  // device is only sending $PJLTS message
      get_norcvr_message();  // drive screen uodate
   }
}


void config_venus_timing()
{
   if((saw_timing_msg == 0) || (have_sawtooth == 0)) {
      if(rcvr_type != VENUS_RCVR) {
         rcvr_type = VENUS_RCVR;
         config_rcvr_type(0);
         need_msg_init = 2004;
      }
      else {
         config_rcvr_plots();
         config_msg_ofs();
      }

      plot[ONE].show_plot = 0;
      plot[TWO].show_plot = 0;
      plot[THREE].show_plot = 0;
      plot[SIX].show_plot = 0;
      if(user_set_dac_plot == 0) plot[DAC].show_plot = 1;
   }
}

void parse_venus_sawtooth()
{
int mode;
int survey_len;
float sawtooth;
float sdev1;
float sdev2;

  have_venus_timing |= 0x01;
  config_venus_timing();
  saw_timing_msg |= 0x08;

  if(get_msg_field()) {
     mode = atoi(msg_field);

     if(mode == 0) { // PVT mode
        minor_alarms &= (~MINOR_SURVEY);
        venus_hold_mode = 0;
        rcvr_mode = RCVR_MODE_3D;
     }
     else if(mode == 1) {  // surveying
        minor_alarms |= (MINOR_SURVEY);
        venus_hold_mode = 0;
        rcvr_mode = RCVR_MODE_SURVEY;
     }
     else if(mode == 2) {  // position hold
        minor_alarms &= (~MINOR_SURVEY);
        venus_hold_mode = 1;
        rcvr_mode = RCVR_MODE_HOLD;
     }
  }

  if(get_msg_field()) {
     survey_len = atoi(msg_field);
  }

  if(get_msg_field()) {
     sawtooth = (float) atof(msg_field);
     have_sawtooth = 1;

     if(lte_lite) ;   // we show dac voltage instead of sawtooth
     else {
        dac_voltage = sawtooth;
     }
  }

  if(get_msg_field()) {
     sdev1 = (float) atof(msg_field);
  }

  if(get_msg_field()) {
     sdev2 = (float) atof(msg_field);
  }
}

void parse_psti(int system)
{
int id;

   // handle the Venus proprietary NMEA messages
   // !!!!!! should we set rcvr_type to VENUS_RCVR?

   nmea_type = VENUS_NMEA;
   if((system & system_mask) == 0) return;

   if(get_msg_field()) {
      id = atoi(msg_field);

      if(id == 0) {  // sawtooth correction
         parse_venus_sawtooth();
      }
   }

   return;
}


void parse_pgrmf(int system)
{
int i;
int fix_status;

   // handle the Garmin PGRMF GPS system data NMEA message
return;  // !!!!! disabled until it can be tested

   nmea_type = GARMIN_NMEA;
   if((system & system_mask) == 0) return;

   if(get_msg_field()) {  // 1 - GPS week
      gps_week = atoi(msg_field);
      faked_tow = 0;
      if(have_week == 0) need_redraw = 3354;
      have_week = 199;
   }

   if(get_msg_field()) {  // 2 - GPS TOW
      pri_tow = atoi(msg_field);
      tow = pri_tow;  
      this_tow = tow;
      survey_tow = tow;

      if(have_tow == 0) need_redraw = 3029;
      have_tow = 55;
   }

   get_nmea_date();    // 3 - date: ddmmyy
   get_nmea_time();    // 4 - time: hhmmss

   if(get_msg_field()) {  // 5 - leap second count
      i = atoi(msg_field);
      if(!user_set_utc_ofs) utc_offset = i;
      check_utc_ofs(33);
   }

   get_nmea_lat();         // 6 and 7
   get_nmea_lon();         // 8 and 9


   if(get_msg_field()) {  // 10 - mode - M)anual  A)automatic
   }

   if(get_msg_field()) {  // 11 - fix type: 0=none  1=2D  2=3D
      if(1) {  // !!!! do we want to get this from GPGSA
         fix_status = atoi(msg_field);
         if     (fix_status == 0) rcvr_mode = RCVR_MODE_NO_SATS;  
         else if(fix_status == 1) rcvr_mode = RCVR_MODE_2D;  
         else if(fix_status == 2) rcvr_mode = RCVR_MODE_3D;
         else                     rcvr_mode = RCVR_MODE_UNKNOWN;
         have_tracking = 1;
         if(rcvr_mode == RCVR_MODE_NO_SATS) minor_alarms |= MINOR_NO_TRACK;
         else                               minor_alarms &= (~MINOR_NO_TRACK);
         have_rcvr_mode = 2;
      }
   }

   if(get_msg_field()) {  // 12 - speed (km/hr)
      speed = atof(msg_field) * 0.514444;  // meters per second
      have_speed = 20;
   }

   if(get_msg_field()) {  // 13 - heading 0..359
      heading = atof(msg_field);
      have_heading = 20;
   }

   if(get_msg_field()) {  // 14 - PDOP
      pdop = (float) atof(msg_field);
      have_dops |= PDOP;
   }

   if(get_msg_field()) {  // 15 - TDOP
      tdop = (float) atof(msg_field);
      have_dops |= TDOP;
   }
}


void parse_pgrmt(int system)
{
   // handle the Garmin PGRMT sensor status NMEA message
return;  // !!!!! disabled until it can be tested

   nmea_type = GARMIN_NMEA;
   if((system & system_mask) == 0) return;

   critical_alarms = 0x0000;
   minor_alarms = 0x0000;
   have_critical_alarms = 555;

   if(get_msg_field()) {  // 1 - receiver id
   }

   if(get_msg_field()) {  // 2 - ROM check
      if(strchr(msg_field, 'F')) critical_alarms |= CRIT_ROM;
   }

   if(get_msg_field()) {  // 3 - Rcvr check
   }

   if(get_msg_field()) {  // 4 - BBRAM check
      if(strchr(msg_field, 'L')) minor_alarms |= MINOR_EEPROM;
      have_eeprom = 555;
   }

   if(get_msg_field()) {  // 5 - RTC check
      if(strchr(msg_field, 'L')) critical_alarms |= CRIT_OCXO;
   }

   if(get_msg_field()) {  // 6 - OSC check
      if(strchr(msg_field, 'F')) minor_alarms |= MINOR_OSC_AGE;
      have_osc_age = 555;
   }

   if(get_msg_field()) {  // 7 - data collection
   }

   if(get_msg_field()) {  // 8 - temperature
      temperature = (float) atof(msg_field);
      have_temperature = 102;
   }

   if(get_msg_field()) {  // 9 - config data OK
      if(strchr(msg_field, 'L')) minor_alarms |= MINOR_EEPROM;
      have_eeprom = 555;
   }
}


//
//
//   Furuno receiver stuff
//
//

float ura_to_dist(int prn, int acc)
{
   // convert GPS system URA code to distance in meters
   if(prn < 1) return (-1.0F);
   if(prn > MAX_PRN) return (-1.0F);

   if(rinex_gnss(prn) & (GPS | SBAS)) {  // field is a GPS URA code
      if     (acc == 0)  return 2.4F;
      else if(acc == 1)  return 3.4F;
      else if(acc == 2)  return 4.85F;
      else if(acc == 3)  return 6.85F;
      else if(acc == 4)  return 9.65F;
      else if(acc == 5)  return 13.65F;
      else if(acc == 6)  return 24.00F;
      else if(acc == 7)  return 48.00F;
      else if(acc == 8)  return 96.00F;
      else if(acc == 9)  return 192.00F;
      else if(acc == 10) return 384.00F;
      else if(acc == 11) return 768.00F;
   }
   else if(rinex_gnss(prn) & GLONASS) {  // Ft word
      if     (acc == 0)  return 1.0F;
      else if(acc == 1)  return 2.0F;
      else if(acc == 2)  return 2.50F;
      else if(acc == 3)  return 4.00F;
      else if(acc == 4)  return 5.00F;
      else if(acc == 5)  return 7.00F;
      else if(acc == 6)  return 10.00F;
      else if(acc == 7)  return 12.00F;
      else if(acc == 8)  return 14.00F;
      else if(acc == 9)  return 16.00F;
      else if(acc == 10) return 32.00F;
      else if(acc == 11) return 64.00F;
      else if(acc == 12) return 128.00F;
      else if(acc == 13) return 256.00F;
      else if(acc == 14) return 512.00F;
   }

   return (-1.00F);
}


void parse_gpacc()
{
int prn;
int acc;
char c[2];

   if(get_msg_field()) {
      for(prn=1; prn<=32; prn++) {
         c[0] = msg_field[prn-1];
         c[1] = 0;
         if(c[0] == 0) break;

         if(c[0] == 'X') acc = (-1);
         else            acc = atohex(c);
         sat[prn].sv_accuracy = ura_to_dist(prn, acc);

         if(have_accu == 0) need_redraw = 2344;
         have_accu = 1;
      }
   }
}


void parse_gpanc()
{
int i;
char c;

   get_msg_field();  // eat the almanac time string

   if(get_msg_field()) {
      reset_sat_health();
      for(i=0; i<32; i++) {
         c = msg_field[i];
         if(c == 0) break;
         else if(c == '0') sat[i+1].health_flag = 0;  // no sat
         else if(c == '1') sat[i+1].health_flag = 1;  // unhealthy
         else if(c == '2') sat[i+1].health_flag = 2;  // good
      }
   }
   else return;
}


void parse_gpgpt()
{
int val;
int i;

   if(get_msg_field()) {  // gps time valid
      val = atoi(msg_field);
      if(val) time_flags &= (~TFLAGS_INVALID);
      else    time_flags |= (TFLAGS_INVALID);
   }

   if(get_msg_field()) {  // gps week
      gps_week = atoi(msg_field);
      faked_tow = 0;
      have_week = 1;
   }

   if(get_msg_field()) {  // GPS TOW
      pri_tow = atoi(msg_field);
      tow = pri_tow;  
      this_tow = tow;
      survey_tow = tow;

      if(have_tow == 0) need_redraw = 3029;
      have_tow = 55;
   }

   if(get_msg_field()) {  // leap second count
      i = atoi(msg_field);
      time_flags |= TFLAGS_NO_UTC_OFS;
      if(i) {
         time_flags &= (~TFLAGS_NO_UTC_OFS);
         if(!user_set_utc_ofs) utc_offset = i;
         check_utc_ofs(334);
      }
   }
}


void parse_gpmge()
{
int i;
int prn;

   // get prohibited SBAS sats bitmask (answer from gpmgq query)

   for(i=0; i<32; i++) {
      prn = i+120;
      sat[prn].disabled = 0;
   }

   if(get_msg_field()) {  // gps week
      excluded_sbas = (u32) atohex(msg_field);
      for(i=0; i<32; i++) {
         prn = i+120;
         if(excluded_sbas & (1 << i)) sat[prn].disabled = 1;
      }
   }
   else return;
}


void parse_gppri()
{
int i;
char c;

   // position fix of sats - from PFEC,GPprq

   if(get_msg_field()) {
     for(i=0; i<32; i++) {
        c = msg_field[i];
        if(c == 0) break;
        // !!!! do something with the data: '1'=no fix  '2'=GPS only   3=DGPS+RTCM  4=DGPS+SBAS
     }
   }
   else return;
}


void parse_gppsp()
{
int sbas_sat;

   // get forced SBAS sat number (answer to GPpsq)

   if(get_msg_field()) {
      sbas_sat = atoi(msg_field);
   }
   else return;
}


void parse_gprrm()
{
int traim_offset;

   // traim status

   traim_alarm = traim_status = traim_deleted = traim_offset = 0;

   if(get_msg_field()) {
      traim_alarm = atoi(msg_field);
   }

   if(get_msg_field()) {
      traim_status = atoi(msg_field);
   }

   if(get_msg_field()) {
      traim_deleted = atoi(msg_field);
   }

   get_msg_field();  // reserved
   get_msg_field();  // reserved
   get_msg_field();  // reserved
   get_msg_field();  // reserved

   if(get_msg_field()) {
      traim_offset = atoi(msg_field);
   }
}


void parse_gprsd()
{
int furuno_traim;
int pps_mode;

   // pps/traim config

   if(get_msg_field()) {
      traim_mode = atoi(msg_field);
      have_traim = 1;
   }

   if(get_msg_field()) {
      furuno_traim = atoi(msg_field);
   }

   if(get_msg_field()) {
      pps_mode = atoi(msg_field);
      if(pps_mode) pps_enabled = 1;
      else         pps_enabled = 0;
      have_pps_enable = 1;
   }
}


void parse_gpssd()
{
double hold_alt;
int almanac;
int prn;
int count;
int flag;
u32 val;

   while(get_msg_field()) {
      if(msg_field[0] == 'A') {  // almanac flag
         almanac = atoi(&msg_field[1]);
      }
      else if(msg_field[0] == 'D') {  // PDOP threshold value
         pdop_mask = (float) atof(&msg_field[1]);
         have_pdop_mask |= 0x01;
      }
      else if(msg_field[0] == 'G') {  // datum
         datum = atoi(&msg_field[1]);
         have_datum = 1;
      }
      else if(msg_field[0] == 'H') {  // 2D position hold altitude
         hold_alt = atof(&msg_field[1]);
      }
      else if(msg_field[0] == 'M') {  // elevation mask angle
         el_mask = (float) atof(&msg_field[1]);
         have_el_mask = 1;
      }
      else if(msg_field[0] == 'S') {  // signal mask value
         amu_mask = (float) atof(&msg_field[1]);
         have_amu = 1;
      }
      else if(msg_field[0] == 't') {  // cable delay in nanoseconds
         cable_delay = atof(&msg_field[1]);
         cable_delay /= 1.0E9;
         have_cable_delay = 1;
      }
      else if(msg_field[0] == 'U') {  // excluded sats
         val = atohex(&msg_field[1]);
         count = 0;

         for(prn=1; prn<=32; prn++) {
            if(val & (1 << (prn-1))) ++count;
         }

         single_sat_prn = 0;
         have_single_prn = 1;
         if(count == 31) {  // all but 1 sat excluded
            for(prn=1; prn <= 32; prn++) {
               flag = (val & (1 << (prn-1)));
               if(flag == 0) {
                  single_sat_prn = prn; 
                  have_single_prn = 1;
                  break;
               }
            }
         }

         val = (~val);
         sats_enabled = val;
         update_disable_list(sats_enabled);
      }
      else if(msg_field[0] == 'W') {  // smoothing index
         smoothing_code = atoi(&msg_field[1]);
      }
      else if(msg_field[0] == 'X') {  // dynamic index
         dynamics_code = atoi(&msg_field[1]);
      }
      else if(msg_field[0] == 'Z') {  // fix mode
         furuno_fix_mode = atoi(&msg_field[1]);
         have_furuno_fix_mode = 1;
      }
   }
}


void parse_gpstd()
{
int fix_type;

   // position fix methond

   if(get_msg_field()) { 
      fix_type = atoi(msg_field);
   }
   else return;
}


void parse_gptmd()
{
   minor_alarms &= (~MINOR_SURVEY);
   survey_secs = 0;
   survey_length = 0;

   if(get_msg_field()) {   // samples remaining
      if(msg_field[0]) {
         survey_secs = atoi(msg_field);
         if(survey_secs) minor_alarms |= MINOR_SURVEY;
         survey_length = survey_secs;
      }
   }
   else return;
}


void parse_gptps()
{
int yy,mm,dd;
int hrs,mins,secs;
int pend, leap_flag;
int i, val;

   get_msg_field();  // 2: eat the date/time

   if(get_msg_field()) {  // 3: time standard
      val = atoi(msg_field);
      if(val == 1) { // RTC time
      }
      else if(val == 2) {  // GPS time
         time_flags &= (~TFLAGS_UTC);
         have_timing_mode = 1;
         have_rcvr_tmode = 1;
      }
      else if(val == 3) {  // UTC time
         time_flags |= TFLAGS_UTC;
         have_timing_mode = 1;
         have_rcvr_tmode = 1;
      }
   }

   get_msg_field();  // 4: eat PPS status
   get_msg_field();  // 5: eat the fix mode

   leap_flag = 0;
   yy = mm = dd = 0;
   hrs = mins = secs = 0;
   if(get_msg_field()) {  // 6: pending leapsecond date/time
      if(atoi(msg_field)) {
         sscanf(msg_field, "%2d%2d%2d%2d%2d%2d", &yy,&mm,&dd, &hrs,&mins,&secs);
         yy += 2000;
         leap_flag = 1;
      }
   }

   minor_alarms &= (~MINOR_LEAP_PEND);
   if(get_msg_field()) {  // 7: leapsecond adjustment (-1, 00, +1)
      pend = atoi(msg_field);  // leap second +/- 1
//sprintf(debug_text, "leap dir:%s  pend:%d", msg_field, pend);
      if(pend && leap_flag) {
         minor_alarms |= MINOR_LEAP_PEND;
         jd_leap = jdate(yy,mm, dd) + jtime(hrs,mins,secs,-1.0);  // -1 since says 2017/1/1
         have_jd_leap = 88;
         calc_jd_leap(88);
      }
      have_leap_info = 54;
   }

   if(get_msg_field()) {  // 8: leap second count
      i = atoi(msg_field);
      time_flags |= TFLAGS_NO_UTC_OFS;
      if(i) {
         time_flags &= (~TFLAGS_NO_UTC_OFS);
         if(!user_set_utc_ofs) utc_offset = i;
         check_utc_ofs(334);
      }
   }

   if(get_msg_field()) {  // 9: UTC parameter date/time
   }

   if(get_msg_field()) {  // 10: gps week
      gps_week = atoi(msg_field);
      faked_tow = 0;
      have_week = 1;
   }

   if(get_msg_field()) {  // 11: GPS TOW
      pri_tow = atoi(msg_field);
      tow = pri_tow;  
      this_tow = tow;
      survey_tow = tow;

      if(have_tow == 0) need_redraw = 3029;
      have_tow = 55;
   }
}


void parse_gptst()
{
int status;
double id;
int t1,t2;

   // test results
   t1 = t2 = status = 0;
   id = 0;

   if(get_msg_field()) {
      status = atoi(msg_field);
      if(status == 0) need_redraw = 8527;
   }

   if(get_msg_field()) {
      id = atof(msg_field);
      furuno_pgm = (int) (id / 100.0);
      furuno_ver = (int) fmod(id, 100.0);
      have_info |= ALL_ID_INFO;
   }

   if(get_msg_field()) {
      t1 = atoi(msg_field);
   }

   if(get_msg_field()) {
      t2 = atoi(msg_field);

      critical_alarms = 0;
      have_critical_alarms = 1;
      have_antenna = 1;

      if(t2 & 0x01) {  // ROM error
         critical_alarms |= CRIT_ROM;
      }

      if(t2 & 0x02) {  // RAM error
         critical_alarms |= CRIT_RAM;
      }

      if(t2 & 0x04) {  // antenna error
         minor_alarms |= MINOR_ANT_NO_PWR;
      }
      else {
         minor_alarms &= (~MINOR_ANT_NO_PWR);
      }

      if(t2 & 0x08) {  // backup param error
         critical_alarms |= CRIT_RTC;
      }
   }

   if(status == 0) {
      send_furuno_cmd("GPtrq,1");  // finish self test
   }
}

void parse_gpwas()
{
int setting;
int state;

   // SBAS position fix params (answer from gpwaq)

   if(get_msg_field()) {
      setting = atoi(&msg_field[1]);
   }
   else return;

   if(get_msg_field()) {
      state = atohex(&msg_field[1]);
   }
   else return;
//sprintf(debug_text, "waq setting:%d  state:%d", setting,state);
}


void parse_gpwav()
{
int geo_sat;
int i;
int prn;
int el;
int az;
int snr;

   // SBAS sat info - from GPint,wav00
   for(i=120; i<140; i++) {
      sat[i].level_msg = (0);
   }

   if(get_msg_field()) {
      geo_sat = atoi(msg_field);
   }
   else return;

   for(i=0; i<geo_sat; i++) {
      if(get_msg_field()) {
         prn = atoi(msg_field);
      }
      else break;

      if(get_msg_field()) {
         el = atoi(msg_field);
      }
      else break;

      if(get_msg_field()) {
         az = atoi(msg_field);
      } 
      else break;

      if(get_msg_field()) {
         snr = atoi(msg_field);
      }
      else break;

      if((prn >= 1) && (prn <= MAX_PRN)) {
         sat[prn].level_msg = 111;
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].sig_level = (float) snr;
         have_snr |= rinex_gnss(prn);
         if(snr > 0) sat[prn].tracking = prn;
         else        sat[prn].tracking = (-1);
         have_sat_azel = 2;

         record_sig_levels(prn);
      }
   }
}


void parse_gpast()
{
}

void parse_gpisd()
{
}

void parse_gpdie()
{
}

void parse_gptlp()
{
}

void parse_gpgac()
{
}

void parse_gp_unkn()
{
}

void parse_pfec()
{

   // Furuno proprietary messages

   if(get_msg_field()) {  // get the message identifier string
      if(strstr(msg_field, "GPssd")) ;  // message has lower case data
      else strupr(msg_field);
   }
   else return;

   if     (strstr(msg_field, "GPACC")) parse_gpacc();   // satellie accuracy
   else if(strstr(msg_field, "GPANC")) parse_gpanc();   // satellite health
   else if(strstr(msg_field, "GPAST")) parse_gpast();   // * posn,alt/speed/etc - we get from NMEA sentences
   else if(strstr(msg_field, "GPTST")) parse_gptst();   // test results
   else if(strstr(msg_field, "GPssd")) parse_gpssd();   // GPset data
   else if(strstr(msg_field, "GPISD")) parse_gpisd();   // * sentence output rates - we don't need this
   else if(strstr(msg_field, "GPDIE")) parse_gpdie();   // * DGPS status - we don't need this
   else if(strstr(msg_field, "GPTLP")) parse_gptlp();   // * leapseoncd info - we get this from gptps
   else if(strstr(msg_field, "GPTPS")) parse_gptps();   // time info
   else if(strstr(msg_field, "GPGPT")) parse_gpgpt();   // GPS time info
   else if(strstr(msg_field, "GPRRM")) parse_gprrm();   // traim info
   else if(strstr(msg_field, "GPRSD")) parse_gprsd();   // traim config  - gprrq
   else if(strstr(msg_field, "GPTMD")) parse_gptmd();   // survey status - gptmq
   else if(strstr(msg_field, "GPWAV")) parse_gpwav();   // SBAS sat info *
   else if(strstr(msg_field, "GPSTD")) parse_gpstd();   // position fix method  - gpstq
   else if(strstr(msg_field, "GPWAS")) parse_gpwas();   // SBAS posion fix params - gpwaq
   else if(strstr(msg_field, "GPMGE")) parse_gpmge();   // excluded SBAS sats - gpmgq 
   else if(strstr(msg_field, "GPPSP")) parse_gppsp();   // forced SBAS sat - gppsq
   else if(strstr(msg_field, "GPPRI")) parse_gppri();   // satellie position fix status - gpprq
   else if(strstr(msg_field, "GPGAC")) parse_gpgac();   // * SBAS sat almanac status gpgap - gpgaq
   else parse_gp_unkn();                                // * unknown message
}



//
//
//  ESIP receiver stuff (Furuno)
//
//

void parse_crw()
{
int i;
int tls, fls;
int pps;
int yy;
int mm;
int dd;

   // leapsecond info

   if(get_msg_field()) {  // eat the TPS1
   }

   i = 0;
   fls = tls = 0;

   get_fixed_field(4);
   yy = atoi(msg_field);
   get_fixed_field(2);
   mm = atoi(msg_field);
   get_fixed_field(2);
   dd = atoi(msg_field);
   if(get_msg_field()) {  // hour/min/sec
   }

   if(get_msg_field()) {  // time validity
      i = atoi(msg_field);
      time_flags &= (~(TFLAGS_USER_TIME | TFLAGS_GNSS_MASK | TFLAGS_UTC | TFLAGS_INVALID | TFLAGS_RTC));
      if     (i == 0) time_flags |= TFLAGS_RTC;  // time from rtc chip
      else if(i == 1) ;  // GPS time
      else if(i == 2) time_flags |= TFLAGS_UTC;
//    else if(i == 3) time_flags |= TFLAGS_GLONASS;
      else            time_flags |= TFLAGS_INVALID;
   }

   get_fixed_field(4);
   yy = atoi(msg_field);
   get_fixed_field(2);
   mm = atoi(msg_field);
   get_fixed_field(2);
   dd = atoi(msg_field);
   if(get_msg_field()) {  // hour/min/sec - should be 000000
   }

   if(get_msg_field()) {  // utc offset
      tls = atoi(msg_field);
      if(tls) {
         if(!user_set_utc_ofs) utc_offset = tls;
         check_utc_ofs(33);
      }
   }

   if(get_msg_field()) {  // future utc offset
      fls = atoi(msg_field);
   }

   minor_alarms &= (~MINOR_LEAP_PEND);
   if(yy && mm && dd && fls && tls && (fls != tls)) {
      minor_alarms |= MINOR_LEAP_PEND;
      jd_leap = jdate(yy,mm,dd) + jtime(0,0,0,-1.0);  // -1 since says 2017/1/1
      have_jd_leap = 87;
      calc_jd_leap(87);
   }
   have_leap_info = 87;

   if(get_msg_field()) {  // pps source
      pps = atoi(msg_field);
      esip_time_source = pps;
      if(0) {
         time_flags &= (~(TFLAGS_USER_TIME | TFLAGS_GNSS_MASK | TFLAGS_UTC | TFLAGS_INVALID | TFLAGS_RTC));
         if     (pps == 0) time_flags |= TFLAGS_USER_TIME;  // time from rtc chip
         else if(pps == 1) ;  // GPS time
         else if(pps == 2) time_flags |= TFLAGS_UTC;
         else if(pps == 3) time_flags |= TFLAGS_GLONASS;
         else              time_flags |= TFLAGS_INVALID;
      }
   }
}

void parse_perdack()
{
int flag;

   // command acknowledgement

   flag = 256;
   if(get_msg_field()) {  // command being acked
   }

   if(get_msg_field()) {  // ack(0..255) / nak(-1)
      flag = atoi(msg_field);
   }

   if(get_msg_field()) {  // first param of command
   }
}

void parse_crx()
{
int i;

   if(get_msg_field()) {  // eat the TPS2
   }

   if(get_msg_field()) {  // PPS status
      i = atoi(msg_field);
      if(i) pps_enabled = 1;
      else  pps_enabled = 0;
      have_pps_enable = 87;
   }

   if(get_msg_field()) {  // PPS mode
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // PPS period
      i = atoi(msg_field);
      if(i == 1) {
         pps_rate = RATE_PP2S;
         have_pps_rate = 87;
      }
      else if(i == 0) {
         pps_rate = RATE_1PPS;
         have_pps_rate = 87;
      }
   }

   if(get_msg_field()) {  // PPS pulse width (msecs)
      esip_pps_width  = atoi(msg_field);
      have_pps_duty = 87;
   }

   if(get_msg_field()) {  // cable delay
      cable_delay = atof(msg_field);
      cable_delay /= 1.0E9;
      have_cable_delay = 87;
   }

   if(get_msg_field()) {  // PPS polaity
      i = atoi(msg_field);
      pps_polarity = i;
      have_pps_polarity = 87;
   }

   if(get_msg_field()) {  // pps_type
      i = atoi(msg_field);
      esip_pps_type = i;
      have_esip_pps_type = 87;
   }

   if(get_msg_field()) {  // pps accuracy (ns)
      i = atoi(msg_field);
      pps_offset = ((OFS_SIZE) i);
      have_pps_offset = 87;
   }

   if(get_msg_field()) {  // sawtooth
      dac_voltage = (float) atof(msg_field);
      have_sawtooth = 87;
   }

   if(get_msg_field()) {  // accuracy theshold
      i = atoi(msg_field);
      if(0 && (i >= 5) && (i <= 9999)) {
         pps_threshold = (float) atoi(msg_field);
         have_pps_threshold = 87;
      }
   }
}

void parse_cry()
{
int i;

   get_msg_field();  // eat the TPS3

   if(get_msg_field()) {  // pos mode
      i = atoi(msg_field);
      minor_alarms &= (~MINOR_SURVEY);
      if(i == 0) {
         rcvr_mode = RCVR_MODE_3D;
      }
      else if((i == 1) || (i == 2)) {
         rcvr_mode = RCVR_MODE_SURVEY;
         minor_alarms |= MINOR_SURVEY;
      }
      else if(i == 3) {
         rcvr_mode = RCVR_MODE_HOLD;
      }
      else {
         rcvr_mode = RCVR_MODE_UNKNOWN;
      }
      have_rcvr_mode = 87;
   }

   if(get_msg_field()) {  // sigma
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // sigma thresh
      i = atoi(msg_field);
   }

   i = 0;
   if(get_msg_field()) {  // survey samples taken so far
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // survey time in minutes
      survey_secs = atoi(msg_field) - i;
      if(survey_secs < 0) survey_secs = 0;
   }

   if(get_msg_field()) {  // traim solution
      traim_alarm = atoi(msg_field);
traim_mode = 1;
      have_traim = 87;
   }

   if(get_msg_field()) {  // traim status
      traim_status = atoi(msg_field);
   }

   if(get_msg_field()) {  // removed sat count
      traim_deleted = atoi(msg_field);
   }

   if(get_msg_field()) {  // reserved
      i = atohex(msg_field);
   }

}

void parse_crz()
{
int i;

   get_msg_field();  // eat the TPS4

   if(get_msg_field()) {  // freq mode
      i = atoi(msg_field);
      esip_status = i;
      have_esip_status = 87;
   }

   if(get_msg_field()) {  // freq status
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // gclk accuracy
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // delay between legacy and gclk PPS
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // amount of change of phase delay
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // duration of lock (secs)
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // holdover duration
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // reserved
      i = atohex(msg_field);
   }

   if(get_msg_field()) {  // id tag
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // reserved
      i = atohex(msg_field);
   }

   if(get_msg_field()) {  // reserved
      i = atoi(msg_field);
   }

}


void parse_crm()
{
int i;
int prn;
static int tow = 0;
double val;

   prn = 0;
   if(get_msg_field()) {  // tow
      tow = atoi(msg_field);
      if(raw_msg_rate) {  // receiver always outputs RAW data at 1 Hz
         if((tow % raw_msg_rate) != 0) return;  // drop unwanted messages
      }
      else return;

      if(0) {
         pri_tow = i;
         this_tow = i;
         survey_tow = i;

         if(have_tow == 0) need_redraw = 3087;
         have_tow = 87;
      }
   }

   if(get_msg_field()) {  // sentence number
      i = atoi(msg_field);
      if(i == 1) {
         obs_tow = tow;
         jd_obs = GPS_EPOCH + ((double) gps_week * 7.0) + jtime(0,0,0,tow);
      }
   }

   if(get_msg_field()) {  // max sentences
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // gps system
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // prn
      prn = atoi(msg_field);
      if(prn < 0) prn = 0;
      else if(prn > MAX_PRN) prn = 0;
   }

   if(get_msg_field()) {  // reserved
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // snr - we get this from NMEA messages
      i = atoi(msg_field);
   }

   if(get_msg_field()) {  // accumulated doppler range
      val = atof(msg_field);
      val /= (64.0);  // meters
      sat[prn].accum_range = val;
      have_accum_range = 87;
   }

   // Note: the GT87 can output "stuck" doppler and pseudorange values
   //       for sats that are supposed to be actively tracked.  We filter
   //       stuck values out when writinf RINEX file.
   if(get_msg_field()) {  // doppler freq
      val = atof(msg_field);  // meters/sec, scaled
      val /= (-4096.0);  // meters/sec
      val *= 1575.42E6 / (LIGHTSPEED*1000.0);   // !!!!!! need GLONASS freq
      sat[prn].doppler = val;
      if(val) {
         have_doppler |= rinex_gnss(prn);
      }
   }

   if(get_msg_field()) {  // pseudorange
      val = atof(msg_field);  // meters, scaled
      val /= (64.0);  // meters
      sat[prn].range = val;
      if(val) {
         have_range |= rinex_gnss(prn);
      }
   }

   sat[prn].ca_lli = 0;
   sat[prn].l1_lli = 0;
   sat[prn].l2_lli = 0;
}

void parse_crn()
{
int i;
int system;
int prn;
int frame[MAX_PRN+1][10];

   // GPS navigation subframe

   system = (-1);
   prn = 0;

   if(get_msg_field()) {
      system = atoi(msg_field);
      if(system != 1) return;  // system 1 is GPS
   }

   if(get_msg_field()) {
      prn = atoi(msg_field);
      if(prn <= 0) return;
      if(prn >= MAX_PRN) return;
   }

   for(i=0; i<10; i++) {
      if(get_fixed_field(6)) {
         if(msg_field[0] == '-') frame[prn][i] = 0;
         else frame[prn][i] = atohex(msg_field);
      }
   }
}


void esip_disable(int prn, int count, u32 mask)
{
int i;

   // flag excluded sats

   for(i=0; i<count; i++) {
      if(mask & (1U << i)) sat[prn].disabled = 1;
      else                 sat[prn].disabled = 0;
      ++prn;
   }
}

void parse_perdapi()
{
int i;
int gnss;
float val;
u32 mask;

   gnss = 0;
   get_msg_field();
   if(strstr(msg_field, "FIXMASK")) {  // snr and elevation mask
      get_msg_field(); // eat the "USER"


      if(get_msg_field()) {  // el mask
         val = (float) atof(msg_field);
         el_mask = val;
         have_el_mask = 87;
      }
      get_msg_field();

      if(get_msg_field()) {  // snr mask
         val = (float) atof(msg_field);
         amu_mask = val;
         have_amu = 87;
      }
      get_msg_field();

      for(i=1; i<256; i++) {
         sat[i].disabled = 0;
      }

      if(get_msg_field()) {  // excluded GPS sats
         mask = atohex(msg_field);
         esip_deleted_gps = mask;
         esip_disable(1, 32, mask);
      }
      if(get_msg_field()) {  // excluded Glonass
         mask = atohex(msg_field);
         esip_deleted_glonass = mask;
         esip_disable(65, 28, mask);
      }
      if(get_msg_field()) {  // excluded Galileo
         mask = atohex(msg_field);
         esip_deleted_galileo = mask;
//       esip_disable(211, 20, mask);  // !!!!!! what starting PRN to use?  Ublox uses 211..246
      }
      if(get_msg_field()) {  // excluded QZSS
         mask = atohex(msg_field);
         esip_deleted_qzss = mask;
         esip_disable(93, 7, mask);
      }
      if(get_msg_field()) {  // excluded SBAS
         mask = atohex(msg_field);
         esip_deleted_sbas = mask;
         esip_disable(33, 19, mask);
      }
      have_esip_fixmask = 87;
   }
   else if(strstr(msg_field, "FREQ")) {  // GCLK settings
      if(get_msg_field()) {    // GCLK enabled
         i = atoi(msg_field);
      }

      if(get_msg_field()) {  // GCLK freq
         pps2_freq = atof(msg_field);
         have_pps_freq |= 0x02;
      }

      if(get_msg_field()) {  // GCLK duty
         pps2_duty = atof(msg_field) / 100.0;
         have_pps_duty |= 0x02;
      }
//sprintf(debug_text, "GCLK enbl:%d  freq:%g  duty:%g", i, pps2_freq,pps2_duty);

      if(get_msg_field()) {  // offset in ns
         i = atoi(msg_field);
      }
   }
   else if(strstr(msg_field, "GNSS")) {  // GNSS systems in use
      get_msg_field(); // eat the talker id

      if(get_msg_field()) {  // gps
         i = atoi(msg_field);
         if(i) gnss |= GPS;
      }

      if(get_msg_field()) {  // glonass
         i = atoi(msg_field);
         if(i) gnss |= GLONASS;
      }

      if(get_msg_field()) {  // galileo
         i = atoi(msg_field);
         if(i) gnss |= GALILEO;
      }

      if(get_msg_field()) {  // QZSS
         i = atoi(msg_field);
         if(i) gnss |= QZSS;
      }

      if(get_msg_field()) {  // SBAS
         i = atoi(msg_field);
         if(i) gnss |= SBAS;
      }

      gnss_mask = gnss;
      have_gnss_mask = 87;
   }
   else if(strstr(msg_field, "RESTART")) {  // receiver restart command
   }
   else if(strstr(msg_field, "TIMEZONE")) {  // receiver timezone setting
   }
}

void parse_perdsys()
{
   get_msg_field();
   if(strstr(msg_field, "VERSION")) {  
      if(get_msg_field()) {
         msg_field[32] = 0;
         strcpy(esip_device, msg_field);
      }
      if(get_msg_field()) {
         msg_field[32] = 0;
         strcpy(esip_version, msg_field);
      }
      if(get_msg_field()) {
         msg_field[32] = 0;
         strcpy(esip_query, msg_field);
      }
      if(get_msg_field()) {
         msg_field[32] = 0;
         strcpy(esip_model, msg_field);
         if(strstr(esip_model, "GT8736")) furuno_type = 8736;
         else if(strstr(esip_model, "GT87")) furuno_type = 87;
         else furuno_type = 0;
      }
      have_info |= ALL_ID_INFO;
   }
   else if(strstr(msg_field, "GPIO")) {  // gpio0 .. gpio8
      if(get_msg_field()) { 
         minor_alarms &= (~MINOR_ANT_NO_PWR);
         // !!!!!! this decode does NOT match the G87 docs !!!!!
         if(furuno_type == 8736) {  // GT8736
            if     ((msg_field[0] == 'H') && (msg_field[2] == 'L')) minor_alarms |= MINOR_ANT_SHORT;  // short
            else if((msg_field[0] == 'H') && (msg_field[2] == 'H')) minor_alarms |= MINOR_ANT_OPEN;   // open
            else if((msg_field[0] == 'L') && (msg_field[2] == 'H')) ;  // normal
            else if((msg_field[0] == 'L') && (msg_field[2] == 'L')) minor_alarms |= MINOR_ANT_NO_PWR; // unkn
         }
         else {  // GT87
            if     ((msg_field[0] == 'L') && (msg_field[2] == 'H')) minor_alarms |= MINOR_ANT_SHORT;  // short
            else if((msg_field[0] == 'H') && (msg_field[2] == 'H')) minor_alarms |= MINOR_ANT_OPEN;   // open
            else if((msg_field[0] == 'H') && (msg_field[2] == 'L')) ;  // normal
            else if((msg_field[0] == 'L') && (msg_field[2] == 'L')) minor_alarms |= MINOR_ANT_NO_PWR; // unkn
         }
         have_antenna = 87;
//sprintf(debug_text, "GPIO:%s", msg_field);
      }
   }
}


//
//
//   Ashtech Z12 receiver stuff
//
//


int in_mpc;

void get_z12_message()
{
u08 c;
static int bin_len = 0;
static int z12_bin_len = 0;
static int bin_msg = 0;
static unsigned bin_sum = 0;
static unsigned odd=0, even=0, ck=0;
static unsigned msg_sum = 0;
static unsigned dben_low, dben_high;
static int mpc_msg = 0;

   // This routine buffers up an incoming NMEA message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()


   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
if(in_mpc == 0) {
   get_norcvr_message();
   reset_com_timer(RCVR_PORT);
}
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(bin_len) {
      if(bin_len == (-2)) {  // DBEN payload length
         dben_low = c;
         ++bin_len;
      }
      else if(bin_len == (-1)) {
         dben_high = c;
         bin_len = (dben_high << 8) | dben_low;
         bin_sum = 0;
      }
      else if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;

         nmea_vfy_cksum ^= c;       // XOR cksum on MPC message

         if(bin_len & 1) odd = c;   // 16-bit sum on other messages
         else            even = c;

         if(bin_len <= 2) {
            if(bin_len == 1) {
               msg_sum = (even * 256) + odd;
            }
         }
         else if(bin_len & 1) {
            ck = ((unsigned) odd);
            ck += (((unsigned) even) << 8);
            bin_sum += ck;
            bin_sum &= 0xFFFF;
         }
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
      ++bin_msg;
      --bin_len;
      if(bin_len <= 0) goto bin_end;
   }
   else if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == '$') {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      bin_len = 0;
//    z12_bin_len = 0;
      bin_msg = 0;
      bin_sum = 0;
      msg_sum = 0;
      nmea_vfy_cksum = 0;  // the calculated message checksum
      nmea_msg_cksum = 0;  // the checksum in the message
      return;
   }
   else if(tsip_sync == 1) { // '$' has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A)) goto nmea_end;  // message has no checksum

      if(c == '*') tsip_sync = 2;  // message checksum follows
      else if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         nmea_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
         if(tsip_wptr == 10) {  // see if Z12 binary data follows
            mpc_msg = 0;
            if     (strstr((char *) tsip_buf, "PBN,")) bin_len = 56;
            else if(strstr((char *) tsip_buf, "ALM,")) bin_len = 70;
            else if(strstr((char *) tsip_buf, "SNV,")) bin_len = 132;
            else if(strstr((char *) tsip_buf, "EPB,")) bin_len = 122;
            else if(strstr((char *) tsip_buf, "RPC,")) bin_len = (-2);  // !!!! has variable sized messages, we ignore this
            else if(strstr((char *) tsip_buf, "MPC,")) {
               bin_len = 95;  // !!!! was 97
               nmea_vfy_cksum = 0x00;
               mpc_msg = 1;
            }
            z12_bin_len = bin_len;
         }
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 2) {  // getting message checksum chars
      if((c == 0x0D) || (c == 0x0A)) goto nmea_end;

      if     ((c >= '0') && (c <= '9')) nmea_msg_cksum = (nmea_msg_cksum << 4) | (c-'0');
      else if((c >= 'A') && (c <= 'F')) nmea_msg_cksum = (nmea_msg_cksum << 4) | ((c-'A')+10);
      else goto rst_msg;
   }
   else if(tsip_sync == 3) {  // end of message
      nmea_end:
if(debug_file) fprintf(debug_file, "At nmea end:(%s)\n", tsip_buf);
      if((tsip_sync == 2) && (nmea_vfy_cksum != nmea_msg_cksum)) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }

      bin_end:
      if(bin_msg) {
         if(mpc_msg && (nmea_vfy_cksum == 0)) decode_nmea_msg();
         else if(msg_sum == bin_sum) decode_nmea_msg();
         else if(debug_file) {
            sprintf(out, "Message checksum error: nmea:%02X  msg:%04X vfy:%04X", nmea_vfy_cksum, msg_sum,bin_sum);
            fprintf(debug_file, "%s\n", out);
in_mpc = 0;
//strcpy(debug_text, out);
         }
      }
      else {
         decode_nmea_msg();      // message checksum matches, process the message
      }
      packet_end = 1;

      if(debug_file) {
         if(bin_msg) {
            tsip_buf[10] = 0;
            fprintf(debug_file, "RCVD Z12:%-11.11s (binary len:%d)  bin_sum:%04X  msg_sum:%04X\n", tsip_buf,z12_bin_len, bin_sum, msg_sum);
         }
         else {
            fprintf(debug_file, "RCVD Z12:%s  (ascii len:%d)\n", tsip_buf, z12_bin_len);
         }
         if(tsip_buf[0] == 'G') ;
         else if(tsip_buf[0] == 'P') ;
         else {
            fprintf(debug_file, "BAD MSG %d: msglen:%d  wptr:%d len:%d\n", bin_msg, z12_bin_len, tsip_wptr, bin_len);
         }
      }

      tsip_wptr = 0;     // prepare for next message
      tsip_sync = 0;
      bin_len = 0;
//    z12_bin_len = 0;
      bin_msg = 0;
      bin_sum = 0;
      msg_sum = 0;
      venus_nmea = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      bin_len = 0;
//    z12_bin_len = 0;
      bin_msg = 0;
      bin_sum = 0;
      msg_sum = 0;
      nmea_vfy_cksum = nmea_msg_cksum = 0; // init received message checksum
      venus_nmea = 0;
   }
}


void parse_z12_mpc()
{
int prn;
int az, el;
int snr,l1_snr,l2_snr;
int warn_ca,warn_l1,warn_l2;
double prange;
double phase;
static int last_msg = 0;
double val;

   // binary format message
   log_packet_id("z12_mpc");

if(debug_file && show_debug_info) {
   fprintf(debug_file, "decoding MPC: rptr:%d wptr:%d\n", tsip_rptr, tsip_wptr);
}

in_mpc = 1;
   tsip_rptr = 10;

   tsip_word();      // sequence tag

   if(last_msg == 0) {
      reset_sat_tracking();
   }
   last_msg = tsip_byte();

   prn = tsip_byte();
   if(prn < 0) prn = 0;
   else if(prn > MAX_PRN) prn = 0;
   sat[prn].tracking = 1;

   el = tsip_byte();
   az = tsip_byte() * 2;
   set_sat_azel(prn, (float) az, (float) el);

   tsip_byte();  // channel

   // start of C/A code raw measuement data
   warn_ca = tsip_byte();  // warn flag
   sat[prn].ca_lli = warn_ca;
   tsip_byte();  // good bad flag
   tsip_byte();  // space

   snr = tsip_byte();
   level_type = "dBc";
   sat[prn].sig_level = ((float) snr) / (float) Z12_SNR_SCALE;
   sat[prn].level_msg = 0x12;
   have_snr |= rinex_gnss(prn);
   record_sig_levels(prn);

   tsip_byte();  // spare

   phase = tsip_double();
   sat[prn].code_phase = phase;
   if(phase) {
      have_phase |= rinex_gnss(prn);
   }

   prange = tsip_double();
   prange *= (LIGHTSPEED*1000.0);
if(debug_file && show_debug_info) {
   if((prange > 1.0E9) || (prange < 0.0)) fprintf(debug_file, "range err:%f  jd_obs:%.9f\n", prange, jd_obs);
}
   sat[prn].range = prange;
   if(prange) {
      have_range |= rinex_gnss(prn);
   }

   val = ((double) (int) tsip_dword()) / 10000.0;
   sat[prn].doppler = val;
   if(val) {
      have_doppler |= rinex_gnss(prn);
   }

   tsip_dword();  // smoothing


   // start of L1 code raw measuement data
   warn_l1 = tsip_byte();  // warn flag
   sat[prn].l1_lli = warn_l1 ^ Z_LOSS;
   tsip_byte();  // good bad flag
   tsip_byte();  // space

   l1_snr = tsip_byte();
   have_l1_snr |= rinex_gnss(prn);
   sat[prn].l1_sig_level = ((float) l1_snr) / (float) Z12_SNR_SCALE;
   sat[prn].l1_level_msg |= rinex_gnss(prn);

   tsip_byte();  // spare

   phase = tsip_double();
   sat[prn].l1_code_phase = phase;
   if(phase) {
      have_l1_phase |= rinex_gnss(prn);
   }

   prange = tsip_double();
   prange *= (LIGHTSPEED*1000.0);
if(debug_file && show_debug_info) {
   if((prange > 1.0E9) || (prange < 0.0)) fprintf(debug_file, "range1 err:%f  jd_obs:%.9f\n", prange, jd_obs);
}
   sat[prn].l1_range = prange;
   if(prange) {
      have_l1_range |= rinex_gnss(prn);
   }

   val = ((double) (int) tsip_dword()) / 10000.0;
   sat[prn].l1_doppler = val;
   if(val) {
      have_l1_doppler |= rinex_gnss(prn);
   }

   tsip_dword();  // smoothing


   // start of L2 code raw measuement data
   warn_l2 = tsip_byte();  // warn flag
   sat[prn].l2_lli = warn_l2 ^ Z_LOSS;
   tsip_byte();  // good bad flag
   tsip_byte();  // space

   l2_snr = tsip_byte();
   sat[prn].l2_sig_level = ((float) l2_snr) / (float) Z12_SNR_SCALE;
   sat[prn].l2_level_msg = 0x12;
   have_l2_snr |= rinex_gnss(prn);
if(debug_file && show_debug_info) fprintf(debug_file, "PRN:%d  SNR L1:%f L2:%f\n", prn, sat[prn].l1_sig_level, sat[prn].l2_sig_level);

   tsip_byte();  // spare

   phase = tsip_double();
   sat[prn].l2_code_phase = phase;
   if(phase) {
      have_l2_phase |= rinex_gnss(prn);
   }

   prange = tsip_double();
   prange *= (LIGHTSPEED*1000.0);
if(debug_file && show_debug_info) {
   if((prange > 1.0E9) || (prange < 0.0)) fprintf(debug_file, "range2 err:%f  jd_obs:%.9f\n", prange, jd_obs);
}
   sat[prn].l2_range = prange;
   if(prange) {
      have_l2_range |= rinex_gnss(prn);
   }

   val = ((double) (int) tsip_dword()) / 10000.0;
   sat[prn].l2_doppler = val;
   if(val) {
      have_l2_doppler |= rinex_gnss(prn);
   }

   tsip_dword();  // smoothing

if(debug_file && show_debug_info) {
   fprintf(debug_file, "CA%02d: phase:%-14f range:%-14f  dop:%-14f\n", prn,sat[prn].code_phase, sat[prn].range, sat[prn].doppler);
   fprintf(debug_file, "L1%02d: phase:%-14f range:%-14f  dop:%-14f\n", prn,sat[prn].l1_code_phase, sat[prn].l1_range, sat[prn].l1_doppler);
   fprintf(debug_file, "L2%02d: phase:%-14f range:%-14f  dop:%-14f\n", prn,sat[prn].l2_code_phase, sat[prn].l2_range, sat[prn].l2_doppler);
   fprintf(debug_file, "WARN    CA:%02X  L1:%02X  L2:%02X\n", warn_ca,warn_l1,warn_l2);
   fprintf(debug_file, "az:%d  el:%d  ca_snr:%d  l1_snr:%d  l2_snr:%d\n", az,el,snr,l1_snr,l2_snr);
}

// poll_z12_time(0);
}

void parse_z12_pbn()
{
double tow;
double jd;
double x,y,z;
float clk_ofs;
float drift;
int week;
int leaps;

   log_packet_id("z12_pbn");

   tsip_rptr = 10;

   tow = (double) tsip_dword() / 1000.0;

   jd = jd_gps - GPS_EPOCH;
   week = (int) (jd / 7.0);
   obs_tow = tow;
   jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,tow);


   jd = (jd_gps - jd_zda);
   jd *= (24.0*60.0*60.0);
   leaps = (int) (jd);
   if((leaps >= 18) && (leaps <= 32) && (have_utc_ofs == 0)) {
      if(!user_set_utc_ofs) utc_offset = leaps;
      check_utc_ofs(112);
   }

   z12_site[0] = tsip_byte();  // site name
   z12_site[1] = tsip_byte();
   z12_site[2] = tsip_byte();
   z12_site[3] = tsip_byte();
   z12_site[4] = 0;
   strcpy(rinex_site, z12_site);
   if(1 && strstr(marker_name, DEFAULT_NAME)) {
      strcpy(marker_name, z12_site);
   }

   x = tsip_double();  // ecef coords
   y = tsip_double();
   z = tsip_double();
   ecef_to_lla(x,y,z);
if(debug_file && show_debug_info) {
fprintf(debug_file, "PBN: tow %f  jd_obs:%f  ecef:%f %f %f  lat:%f lon:%f  alt:%f\n", tow, jd_obs, x,y,x, elat*180.0/PI,elon*180.0/PI,ealt);
}

   if(x && y && z) {
      lat = elat;
      lon = elon;
      alt = ealt;
   }

   clk_ofs = tsip_single();

   tsip_single();  // ecef velocity
   tsip_single();
   tsip_single();

   drift = tsip_single();

   pdop = (DATA_SIZE) (((double) tsip_word()) / 100.0);
   have_dops |= PDOP;

in_mpc = 0;
poll_z12_time(1);
}

void parse_z12_rid()
{
   // Z12 receiver ID
   log_packet_id("z12_rid");

   if(get_msg_field()) {  // type
      msg_field[32] = 0;
      strcpy(z12_type, msg_field);
   }

   if(get_msg_field()) {  // channel options
      msg_field[32] = 0;
      strcpy(z12_chan_opt, msg_field);
   }

   if(get_msg_field()) {  // nav version
      msg_field[32] = 0;
      strcpy(z12_nav_ver, msg_field);
   }

   if(get_msg_field()) {  // rsvd
      msg_field[32] = 0;
      strcpy(z12_rsvd, msg_field);
   }

   if(get_msg_field()) {  // chan version
      msg_field[32] = 0;
      strcpy(z12_chan_ver, msg_field);
   }

   if(jd_obs) {  // prevents writing RINEX file until raw readings are available
      if(rinex_file) {
         if(have_utc_ofs) {  // dont start writing until utc info available
            have_info |= ALL_ID_INFO;
         }
      }
      else if(log_file && (log_fmt == RINEX)) {  // writing .obs file
         if(have_utc_ofs) {  // dont start writing until utc info available
            have_info |= ALL_ID_INFO;
         }
      }
      else {
         have_info |= ALL_ID_INFO;
      }
   }

   if(ZDA_TIME == 0) get_norcvr_message();
}

void parse_z12_alm()
{
   log_packet_id("z12_alm");
}

void parse_z12_snv()
{
   log_packet_id("z12_snv");
}

void parse_z12_epb()
{
   log_packet_id("z12_epb");
}

void parse_z12_rpc()
{
   log_packet_id("z12_rpc");
}

void parse_z12_pos()
{
   log_packet_id("z12_pos");
}


void parse_z12_pps()
{
double period;
double ofs;

   // PPS output control
   log_packet_id("z12_pps");

   if(get_msg_field()) {  // period (0.5 .. 59.5 secs)
      period = atof(msg_field);
      if     (period == 1.0) pps_rate = RATE_1PPS;
      else if(period == 2.0) pps_rate = RATE_PP2S;
      else                   pps_rate = RATE_USER;

      if(period == 0.0) pps_enabled = 0;
      else              pps_enabled = 1;

      have_pps_rate = 12;
   }

   if(get_msg_field()) {  // offset (in msecs)
      ofs = atof(msg_field);
      pps1_delay = ofs;
      have_pps_delay |= 0x01;
   }

   get_msg_field();  // PPS enabled on port A
   get_msg_field();  // PPS enabled on port B 
   get_msg_field();  // PPS enabled on port C 
   get_msg_field();  // PPS enabled on port D 

   have_z12_pps = 12;
}

void parse_z12_ext()
{
double freq;
int mode;
int lock;

   // External freq control
   log_packet_id("z12_ext");

   if(get_msg_field()) {  // freq
      freq = atof(msg_field);
   }

   if(get_msg_field()) {  // switch mode
      mode = atoi(msg_field);
   }

   if(get_msg_field()) {  // locked
      lock = atoi(msg_field);  // 'L' or 'U'
   }

   have_z12_ext = 12;
}


void parse_pashr()
{
   if(get_msg_field() == 0) return;
if(debug_file) fprintf(debug_file, "Parsing Z12: %s\n", msg_field);

   if     (strstr(msg_field, "PBN")) parse_z12_pbn();  // binary messages
   else if(strstr(msg_field, "ALM")) parse_z12_alm();
   else if(strstr(msg_field, "EPB")) parse_z12_epb();
   else if(strstr(msg_field, "MPC")) parse_z12_mpc();
   else if(strstr(msg_field, "RPC")) parse_z12_rpc();
   else if(strstr(msg_field, "SNV")) parse_z12_snv();

   else if(strstr(msg_field, "RID")) parse_z12_rid();
   else if(strstr(msg_field, "POS")) parse_z12_pos();
   else if(strstr(msg_field, "EXT")) parse_z12_ext();
   else if(strstr(msg_field, "PPS")) parse_z12_pps();
}


#define MAX_FAKE_COUNT 10  // the max number of consecutive time stamps we can fake
int fake_count;


void update_gps_screen(int why)
{
double jd0;

   // this routine handles the primary_timing() function for non-TSIP receivers
   // It drives the main screen update cycle

   // once a Venus receiver has NMEA messages enabled, it stops sending the
   // NAV message, so we need to fake the tow and gps week numbers from the
   // NMEA date/time
//if(debug_file) fprintf(debug_file, "ugs(%d)  msg:%d  line:%d\n", why, star_msg, star_line);

   if(TOW_AND_WEEK) {  // synthesize the GPS week and time-of-week
      tow = fake_tow(jd_utc);
      if(timing_mode != TMODE_GPS) tow += utc_offset;
      tow %= (7L*24L*60L*60L);
      this_tow = survey_tow = pri_tow = tow;
      have_tow = 999;

      jd0 = jd_utc;
      if(timing_mode != TMODE_GPS) jd0 += jtime(0,0,utc_offset,0.0);  // we are in UTC time, convert to GPS time

      jd0 -= GPS_EPOCH;
      gps_week = (int) (jd0 / 7.0);
      if(have_week == 0) need_redraw = 2054;
      have_week = 999;
      faked_tow = 1;
//sprintf(plot_title, "fake week:%d  jd0:%f  tmode:%d  ofs:%d", gps_week,jd0, timing_mode, utc_offset);
   }
   else if(!have_tow) {
      tow = this_tow = survey_tow = pri_tow = fake_tow(jd_utc) % (7L*24L*60L*60L);
      faked_tow = 2;
   }
   else faked_tow = 0;

   if(RCVR_SENDS_ID) ;
   else { // force log header dump
      have_info |= ALL_ID_INFO;
   }

   primary_timing(0);     // show time and lla info
   secondary_timing(0);   // validate receiver time, etc values and update screen
}


void drive_nmea_screen(int system, int why)
{
static int last_hours = 0;
static int last_minutes = 0;
static int last_seconds = 0;
static int last_month = 0;
static int last_day = 0;
static int last_year = 0;
static double last_frac;
static int last_why;

   // update the screen for NMEA receivers and polled receivers that can
   // send multiple time messages per second.  This routine filters out
   // duplicated time stamps
   if(lte_lite == 1) lte_lite = 2;     // LTE Lite with both NMEA and STATUS messages


   if     (hours != last_hours) ;      // filter out duplicate time stamps since
   else if(minutes != last_minutes) ;  // ... NMEA sends the time in several 
   else if(seconds != last_seconds) ;  // ... different messages and different
   else if(month != last_month) ;      // ... receivers send different sets
   else if(day != last_day) ;          // ... of messages that may have the
   else if(year != last_year) ;        // ... same time stamps.
   else if((nav_rate != 1.0) && (last_frac != raw_frac)) ;
   else return;

   last_hours = hours;
   last_minutes = minutes;
   last_seconds = seconds;
   last_month = month;
   last_day = day;
   last_year = year;
   last_frac = raw_frac;

   update_gps_screen(system);
   last_why = why;

   if(rcvr_type == BRANDY_RCVR) {
      if(pri_seconds == SCPI_STATUS_SECOND) {
         queue_brandy_cmd("l", BRANDY_SATINFO_MSG);
      }
      else {
         queue_polled_cmd("f", BRANDY_FREQ_MSG);  // request freq controller info
      }
   }

}



void decode_nmea_msg()
{
char c;
int i;
static int row = 0;

   venus_nmea = 0;
   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   if(debug_file && (rcvr_type == ESIP_RCVR)) {
      fprintf(debug_file, "Rcvd eSIP:%s\n", nmea_msg);
   }
   if(debug_file && (rcvr_type == FURUNO_RCVR)) {
      fprintf(debug_file, "Rcvd furuno:%s\n", nmea_msg);
   }


   msg_col = 0;     // index of next char to get from nmea buffer
   get_msg_field(); // get the NMEA message type 

   if     (!strcmp(msg_field, "GPGSV")) parse_gpgsv(GPS);
   else if(!strcmp(msg_field, "BDGSV")) parse_gpgsv(BEIDOU);
   else if(!strcmp(msg_field, "GBGSV")) parse_gpgsv(BEIDOU);
   else if(!strcmp(msg_field, "GLGSV")) parse_gpgsv(GLONASS);
   else if(!strcmp(msg_field, "GAGSV")) parse_gpgsv(GALILEO);
   else if(!strcmp(msg_field, "GNGSV")) parse_gpgsv(MIXED);

   else if(!strcmp(msg_field, "GPGSA")) parse_gpgsa(GPS);
   else if(!strcmp(msg_field, "BDGSA")) parse_gpgsa(BEIDOU);
   else if(!strcmp(msg_field, "GBGSA")) parse_gpgsa(BEIDOU);
   else if(!strcmp(msg_field, "GLGSA")) parse_gpgsa(GLONASS);
   else if(!strcmp(msg_field, "GAGSA")) parse_gpgsa(GALILEO);
   else if(!strcmp(msg_field, "GNGSA")) parse_gpgsa(MIXED);

   else if(!strcmp(msg_field, "GPGGA")) parse_gpgga(GPS);
   else if(!strcmp(msg_field, "BDGGA")) parse_gpgga(BEIDOU);
   else if(!strcmp(msg_field, "GBGGA")) parse_gpgga(BEIDOU);
   else if(!strcmp(msg_field, "GLGGA")) parse_gpgga(GLONASS);
   else if(!strcmp(msg_field, "GAGGA")) parse_gpgga(GALILEO);
   else if(!strcmp(msg_field, "GNGGA")) parse_gpgga(MIXED);

   else if(!strcmp(msg_field, "GPRMC")) parse_gprmc(GPS);
   else if(!strcmp(msg_field, "BDRCM")) parse_gprmc(BEIDOU);
   else if(!strcmp(msg_field, "GBRMC")) parse_gprmc(BEIDOU);
   else if(!strcmp(msg_field, "GLRMC")) parse_gprmc(GLONASS);
   else if(!strcmp(msg_field, "GARMC")) parse_gprmc(GALILEO);
   else if(!strcmp(msg_field, "GNRMC")) parse_gprmc(MIXED);

   else if(!strcmp(msg_field, "GPZDA")) parse_gpzda(GPS);
   else if(!strcmp(msg_field, "BDZDA")) parse_gpzda(BEIDOU);
   else if(!strcmp(msg_field, "GBZDA")) parse_gpzda(BEIDOU);
   else if(!strcmp(msg_field, "GLZDA")) parse_gpzda(GLONASS);
   else if(!strcmp(msg_field, "GAZDA")) parse_gpzda(GALILEO);
   else if(!strcmp(msg_field, "GNZDA")) parse_gpzda(MIXED);

   else if(!strcmp(msg_field, "GPGNS")) parse_gpgns(GPS);
   else if(!strcmp(msg_field, "BDGNS")) parse_gpgns(BEIDOU);
   else if(!strcmp(msg_field, "GBGNS")) parse_gpgns(BEIDOU);
   else if(!strcmp(msg_field, "GLGNS")) parse_gpgns(GLONASS);
   else if(!strcmp(msg_field, "GAGNS")) parse_gpgns(GALILEO);
   else if(!strcmp(msg_field, "GNGNS")) parse_gpgns(MIXED);

// else if(!strcmp(msg_field, "GPGLL")) parse_gpgll(GPS);
// else if(!strcmp(msg_field, "BDGLL")) parse_gpgll(BEIDOU);
// else if(!strcmp(msg_field, "GBGLL")) parse_gpgll(BEIDOU);
// else if(!strcmp(msg_field, "GLGLL")) parse_gpgll(GLONASS);
// else if(!strcmp(msg_field, "GAGLL")) parse_gpgll(GALILEO);
// else if(!strcmp(msg_field, "GNGLL")) parse_gpgll(MIXED);

// else if(!strcmp(msg_field, "GPVTG")) parse_gpvtg(GPS);
// else if(!strcmp(msg_field, "BDVTG")) parse_gpvtg(BEIDOU);
// else if(!strcmp(msg_field, "GBVTG")) parse_gpvtg(BEIDOU);
// else if(!strcmp(msg_field, "GLVTG")) parse_gpvtg(GLONASS);
// else if(!strcmp(msg_field, "GAVTG")) parse_gpvtg(GALILEO);
// else if(!strcmp(msg_field, "GNVTG")) parse_gpvtg(MIXED);

   else if(!strcmp(msg_field, "PASHR"))  parse_pashr();       // Ashtech Z12 messages

   else if(!strcmp(msg_field, "PERDCRW"))  parse_crw();       // Furuno esip messages
   else if(!strcmp(msg_field, "PERDCRX"))  parse_crx();
   else if(!strcmp(msg_field, "PERDCRY"))  parse_cry();
   else if(!strcmp(msg_field, "PERDCRZ"))  parse_crz();
   else if(!strcmp(msg_field, "PERDCRM"))  parse_crm();
   else if(!strcmp(msg_field, "PERDCRN"))  parse_crn();
   else if(!strcmp(msg_field, "PERDACK"))  parse_perdack();
   else if(!strcmp(msg_field, "PERDAPI"))  parse_perdapi();
   else if(!strcmp(msg_field, "PERDSYS"))  parse_perdsys();

   else if(!strcmp(msg_field, "PFEC"))  parse_pfec();         // Furuno messages

   else if(!strcmp(msg_field, "PGRMT")) parse_pgrmt(MIXED);   // Garmin GPS sensor status
   else if(!strcmp(msg_field, "PGRMF")) parse_pgrmf(MIXED);   // Garmin GPS system data
   else if(!strcmp(msg_field, "PSTI"))  parse_psti(MIXED);
   else if(!strcmp(msg_field, "PJLTS")) parse_pjlts(MIXED);

   else {
      last_was_gsv = 0;
      parse_gp_unkn();
   }


   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
   return;
}


void get_nmea_message()
{
u08 c;

   // This routine buffers up an incoming NMEA message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == '$') {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      nmea_vfy_cksum = 0;  // the calculated message checksum
      nmea_msg_cksum = 0;  // the checksum in the message
      return;
   }
   else if(tsip_sync == 1) { // '$' has been seen, now build the message
//if((c == 0x0D) || (c == 0x0A)) goto nmea_end;
      if(c == 0x0D) return;
      if(c == 0x0A) goto nmea_end;

      if(c == '*') tsip_sync = 2;  // message checksum follows
      else if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         nmea_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 2) {  // getting message checksum chars
//if((c == 0x0D) || (c == 0x0A)) goto nmea_end;
      if(c == 0x0D) return;
      if(c == 0x0A) goto nmea_end;

      if     ((c >= '0') && (c <= '9')) nmea_msg_cksum = (nmea_msg_cksum << 4) | (c-'0');
      else if((c >= 'A') && (c <= 'F')) nmea_msg_cksum = (nmea_msg_cksum << 4) | ((c-'A')+10);
      else goto rst_msg;
   }
   else if(tsip_sync == 3) {  // end of message
      nmea_end:
      if((tsip_sync == 2) && (nmea_vfy_cksum != nmea_msg_cksum)) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }

      if(rcvr_type == ZYFER_RCVR)     decode_zyfer_message(); // message checksum matches, process the message
      else if(rcvr_type == TRUE_RCVR) decode_true_message();
      else                            decode_nmea_msg();      // message checksum matches, process the message
      packet_end = 1;

      tsip_wptr = 0;     // prepare for next message
      tsip_sync = 0;
      venus_nmea = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      nmea_vfy_cksum = nmea_msg_cksum = 0; // init received message checksum
      venus_nmea = 0;
   }
}


//
//
//   Novatel SuperStar II receiver stuff
//
//

void send_ss_start(int id, int len)
{
   ss_tx_cksum = 0;
   len -= 4;   // 4 bytes of header

   send_byte(0x01);    // SOH
   send_byte(id);      // if bit 0x80 set on message requests, send continuosly
   send_byte(id^0xFF);
   send_byte(len);
}

void send_ss_end()
{
s16 sum;

   sum = ss_tx_cksum;
   send_byte(sum % 256);
   send_byte(sum / 256);
}

void send_ss_string(char *s)
{
unsigned j;

   if(s == 0) return;
   for(j=0; j<strlen(s); j++) send_byte(s[j]);
}

void request_ss_msg(int id)
{
   // if (id & 0x80) send message continuously, else send once
   send_ss_start(id, 4);
   send_ss_end();
}

void parse_ss_unkn(int id, char *s)
{
   if(s == 0) s = "";

   sprintf(out, "Packet id %d ignored: (%s)", id,s);
   log_packet_id(s);
}

void parse_ss_nav()
{
double secs;
int nav_mode;
int sv_count;
int sys_mode;
int et;       // power on hours
int rsvd;     // reserverd
int hrs;

   log_packet_id("Nav data");

   hrs = tsip_byte();
   pri_hours = hours = hrs & 0x1F;
   pri_minutes = minutes = tsip_byte();
   secs = tsip_double();
   pri_seconds = seconds = (int) secs;
   pri_frac = raw_frac = (secs - (double) pri_seconds);

   pri_day = day = tsip_byte();
   pri_month = month = tsip_byte();
   pri_year = year = tsip_word();

   lat = tsip_double();
   lon = tsip_double();
   alt = tsip_single();

   speed = tsip_single();
   have_speed = 1;
   heading = tsip_single() * 180.0 / PI;
   have_heading = 1;

   tsip_single();  // north vel
   tsip_single();  // east vel
   tsip_single();  // vertical vel
   tsip_single();  // hfom
   tsip_single();  // vfom

   hdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 10.0;
   vdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 10.0;
   have_dops |= (HDOP | VDOP);

   nav_mode = tsip_byte();
   sv_count = tsip_byte();
   sys_mode = tsip_byte();
   et = tsip_byte();       // power on hours
   rsvd = tsip_byte();     // reserverd

   sat_count = sv_count & 0x0F;

   datum = sv_count & 0x0F;
   datum |= (sys_mode & 0x30);
   datum |= ((sys_mode & 0x80) >> 1);
   have_datum = 1;

   update_gps_screen(8589);  // update screen 
}

void parse_ss_raw()
{
   log_packet_id("Raw measurement data");
}

void parse_ss_config()
{
int ss_config;
int ss_antenna;

   log_packet_id("Receiver config");

   ss_config = tsip_byte() & 0x0F;

   nav_rate = (DATA_SIZE) (tsip_byte() & 0x03);
   if     (nav_rate == 0) nav_rate = 1;
   else if(nav_rate == 1) nav_rate = 2;
   else if(nav_rate == 2) nav_rate = 5;
   else                   nav_rate = 1;  // unknown rate

   ss_antenna = tsip_byte() & 0x03;  // antenna type (0=auto  1=active  2=passive)

   tsip_byte();  // rsvd
   tsip_word();  // max speed
   tsip_byte();  // max acceleration (bits 0..5)
   tsip_byte();  // statistical threshold
   tsip_byte();  // dead reconning threshold

   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
   tsip_byte();  // rsvd
}

void parse_ss_sats()
{
int count;
int prn;
int status;
int i, j;
float el;
float az;
int snr;

   log_packet_id("Satellite info");
   count = tsip_byte() & 0x0F;
   reset_sat_tracking();

   while(count--) {
      status = tsip_byte();
      prn = (status & 0x1F) + 1;
      i = tsip_byte();
      el = (float) (char) i;
      i = tsip_byte();
      j = tsip_byte();
      if(j & 1) i += 128;
      az = (float) i;
      j = (j >> 1) & 0x7F;
      if(j) prn = (87 + j);

      snr = tsip_byte();  // snr

      status = (status >> 5) & 0x03;
      if(status == 3) sat[prn].tracking = 1;
      else if(status == 1) sat[prn].tracking = (-1);

      sat[prn].level_msg = 222;
      set_sat_azel(prn, az,el);
      sat[prn].sig_level = (float) snr;
      have_snr |= rinex_gnss(prn);
      have_sat_azel = 2;

      record_sig_levels(prn);
      level_type = "dBc";
   }
}

void get_ss_string(char *s, int len)
{
int i;

   for(i=0; i<len; i++) {
      if(s) {
         s[i] = tsip_byte();
         s[i+1] = 0;
      }
      else tsip_byte();
   }
}

void parse_ss_id()
{
   log_packet_id("Version info");

   get_ss_string(ss_sw_pn, 14);
   get_ss_string(ss_model, 14);
   get_ss_string(ss_model_cksum, 4);
   get_ss_string(ss_boot_pn, 14);
   get_ss_string(ss_rsvd, 22);
   get_ss_string(ss_psn, 13);
   get_ss_string(ss_rsvd2, 4);
   ss_boot_cksum = tsip_word();
   ss_op_cksum = tsip_word();
   ss_type = tsip_byte();

   have_info |= ALL_ID_INFO;
}

void parse_ss_status()
{
int sys_flag;
int nav_flag;

   log_packet_id("Receiver status");

   sys_flag = tsip_byte(); // system mode
   tsip_byte();
   tsip_word();            // almanac week

   gps_week = tsip_word(); // gps week
   have_week = 333;

   ss_deleted_gps = tsip_dword();       // GPS sat disable bitmask
   sats_enabled = (~ss_deleted_gps);
   update_disable_list(sats_enabled);

   tsip_byte();        // rsvd

   ss_deleted_sbas = tsip_dword();      // !!!! needs work SBAS sat disabled bitmask

   tsip_byte();        // min idle time
   tsip_byte();        // idle time

   el_mask = ((float) tsip_word()) / 100.0F;

   tsip_byte();        // discretes

   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd

   // sys_flag 0: self test
   // sys_flag 1: initializing
   // sys_flag 2: acquisition
   // sys_flag 3: navigation
   // sys_flag 4: fault

   // nav_flag 0: init required
   // nav_flag 1: initialized
   // nav_flag 2: nav 3d
   // nav_flag 3: nav 2d
   // nav_flag 4: differential 3d
   // nav_flag 5: differential 2d
   // nav_flag 6: dead reconing
   // nav_flag 7: reserved
   // nav_flag 8: base station
   nav_flag = tsip_byte(); // nav mode

   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd
   tsip_byte();        // rsvd

   tsip_word();        // differential word count
   tsip_word();        // parity error count
}

void parse_ss_health()
{
int prn;
int i;

   log_packet_id("Satellie health");

   reset_sat_health();
   for(prn=1; prn<=32; prn+=4) {
      i = tsip_byte();
      if(i & 0x03) sat[prn+0].health_flag = 1;
      if(i & 0x0C) sat[prn+1].health_flag = 1;
      if(i & 0x30) sat[prn+2].health_flag = 1;
      if(i & 0xC0) sat[prn+3].health_flag = 1;
   }
}

void parse_ss_test()
{
int flag6;
int flag10;
int flag11;
int flag12;
int flag13;
int flag14;
int flag15;
int flag16;
int flag17;
int flag18;
int i;

   log_packet_id("Self test results");

   tsip_byte();            // initiated vs power-up test

   critical_alarms = 0;
   minor_alarms &= (~MINOR_EEPROM);

   flag6 = tsip_byte();    // hardware
   if((flag6 & 0x01) == 0) critical_alarms |= CRIT_RAM;
   if((flag6 & 0x02) == 0) critical_alarms |= CRIT_ROM;
   if((flag6 & 0x04) == 0) minor_alarms |= MINOR_EEPROM;
   if((flag6 & 0x20) == 0) critical_alarms |= CRIT_FPGA;     // uart
   if((flag6 & 0x10) == 0) critical_alarms |= CRIT_RTC;
   if((flag6 & 0x20) == 0) critical_alarms |= CRIT_FPGA;

   tsip_byte();            // rsvd
   tsip_byte();            // rsvd
   tsip_byte();            // rsvd

   flag10 = tsip_byte();   // checksums
   if((flag10 & 0x01)) critical_alarms |= CRIT_ROM;  // boot cksum
   if((flag10 & 0x02)) critical_alarms |= CRIT_ROM;  // operation cksum
   if((flag10 & 0x1C)) critical_alarms |= CRIT_ROM;  // flash error code
   if((flag10 & 0x80)) critical_alarms |= CRIT_ROM;  // flash size

   flag11 = tsip_byte();   // 
   if(flag11 & 0x01) minor_alarms |= MINOR_EEPROM;
   if(flag11 & 0x02) critical_alarms |= CRIT_RAM;

   flag12 = tsip_byte();   // com1
   flag13 = tsip_byte();   // com2

   flag14 = tsip_byte();   // 
   if(flag14 & 0x01) critical_alarms |= CRIT_FPGA;
   if(flag14 & 0x06) critical_alarms |= CRIT_RTC;
   if(flag14 & 0x08) critical_alarms |= CRIT_RAM;

   flag15 = tsip_byte();   // RF
   if(flag15 & 0x3F) critical_alarms |= CRIT_GPS;

   flag16 = tsip_byte();   // correlator1
   if(flag16 & 0xFF) critical_alarms |= CRIT_GPS;
   flag17 = tsip_byte();   // correlator2
   if(flag17 & 0xFF) critical_alarms |= CRIT_GPS;
   flag18 = tsip_byte();   // correlator3
   if(flag18 & 0xFF) critical_alarms |= CRIT_GPS;

   for(i=19; i<=40; i++) { // rsvd
      tsip_byte();
   }
}

void parse_ss_utc()
{
int wn_lsf;
int dn;
int valid;

   log_packet_id("UTC and ionosphere data");

   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_dword();
   tsip_dword();
   tsip_byte();
   tsip_byte();
   tsip_byte();

   wn_lsf = tsip_byte();   // !!!! we need a 16 bit value here
   dn = tsip_byte();
   tsip_byte();
   valid = tsip_byte();

   tsip_dword();  // reserved
   tsip_dword();
   tsip_dword();
   tsip_dword();

   if(0 && valid) {
      calc_leap_days(wn_lsf, dn, 765);
   }
}

void parse_ss_timing()
{
int i;

   log_packet_id("Timing status");

   cable_delay = ((double) tsip_dword()) * 1.0E9;
   have_cable_delay = 333;

   pps1_delay = ((double) tsip_dword()) * 1.0E9;
   have_pps_delay |= 0x01;

   ss_pps_width = ((double) tsip_dword()) * 100.0;  // in ns (100 ns granularity)
   have_pps_duty = 1;

   tsip_byte();  // number of observations
   el_mask = ((float) tsip_word()) / 100.0F;

   tsip_byte();  // leap second change (-1, 0, 1)
   i = tsip_byte();
   if(i) {
      if(!user_set_utc_ofs) utc_offset = i;
      check_utc_ofs(33);
   }

   pps_offset = (DATA_SIZE) tsip_double();  // bias
   have_pps_offset = 333;
   osc_offset = (DATA_SIZE) tsip_double();  // drift
   have_osc_offset = 333;

   tsip_byte();    // date of PPS
   tsip_byte();  
   tsip_word();  

   tsip_byte();    // time of PPS
   tsip_byte();
   tsip_double();

   tsip_dword();   // pps residual in ns

   tsip_byte();    // timing operation mode, etc
   tsip_dword();   // TFOM clock bias in ns
   tsip_byte();    // rsvd
   ss_intrinsic_delay = tsip_word();    // intrinsic delay
}

void parse_ss_link()
{
   log_packet_id("Link overflow");
}

void parse_ss_ack()
{
   log_packet_id("Message acknowledge");
}


void decode_ss_msg()
{
u08 id;
u08 cid;
u08 len;

   // process the received Novatel SuperStar II message
   start_msg_decode(1);

   id = tsip_byte();
   cid = tsip_byte();
   len = tsip_byte();

   if     (id == 6)   parse_ss_unkn(id,  "Channel assignments 0..5");   // current channel assignment (0..5)
   else if(id == 7)   parse_ss_unkn(id,  "Channel assignments 6..12");   // current channel assignment (6..12)
   else if(id == 20)  parse_ss_nav();     // nav data
   else if(id == 21)  parse_ss_unkn(id,  "ECEF nav data");  // nav data ECEF
   else if(id == 22)  parse_ss_unkn(id,  "Ephemeris data");  // ephemeris data
   else if(id == 23)  parse_ss_raw();     // raw measurement data
   else if(id == 30)  parse_ss_config();  // receiver config
   else if(id == 33)  parse_ss_sats();    // sat visibility and status
   else if(id == 43)  parse_ss_unkn(id,  "DGPS config");  // DGPS config
   else if(id == 45)  parse_ss_id();      // hw/sw id info
   else if(id == 47)  parse_ss_unkn(id,  "Base station data");  // base station data
   else if(id == 48)  parse_ss_unkn(id,  "Differential status");  // differential status
   else if(id == 49)  parse_ss_status(); // receiver status
   else if(id == 50)  parse_ss_health(); // sat health
   else if(id == 51)  parse_ss_test();   // self test results
   else if(id == 65)  parse_ss_unkn(id,  "RTCM data");  // RTCM data message
   else if(id == 67)  parse_ss_unkn(id,  "SBAS data");  // SBAS data
   else if(id == 68)  parse_ss_unkn(id,  "SBAS status");  // SBAS status
   else if(id == 75)  parse_ss_utc()   ; // ionosphere and UTC time data
   else if(id == 76)  parse_ss_unkn(id,  "Almanac data");  // almanac data
   else if(id == 78)  parse_ss_unkn(id,  "Almanac status");  // almanac status
   else if(id == 113) parse_ss_timing(); // timing status
   else if(id == 125) parse_ss_link()  ; // link overflow
   else if(id == 126) parse_ss_ack();    // message acknowledge
   else               parse_ss_unkn(id,  "Unknown message");

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_ss_message()
{
u08 c;
static u08 id;
static u08 cid;
static int msg_len;

   // This routine buffers up an incoming Novatel message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_ss_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a SOH
      if(c == 0x01) {      // SOH seen
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      ss_vfy_cksum = 0;  // the calculated message checksum
      ss_msg_cksum = 0;  // the checksum in the message
      id = 0;
      cid = 0;
      msg_len = 0;
      return;
   }
   else if(tsip_sync == 1) { // SOH has been seen, get message id
      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         ss_vfy_cksum += c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
      id = c;
      ++tsip_sync;
   }
   else if(tsip_sync == 2) { // message id inverted
      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         ss_vfy_cksum += c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
      cid = c ^ 0xFF;
//BEEP(5555);  // piss3
//sprintf(out, "id:%02X(%d)  c:%02X  cinv:%02x    ", id,id, c, cid);
//DEBUGSTR(out);
//refresh_page();
      if(id != cid) goto rst_msg;
      ++tsip_sync;
   }
   else if(tsip_sync == 3) { // message len
      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         ss_vfy_cksum += c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
      msg_len = c;
      ++tsip_sync;
      if(msg_len == 0) ++tsip_sync;
   }
   else if(tsip_sync == 4) { // message body
      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         ss_vfy_cksum += c;
         tsip_buf[tsip_wptr++] = c;
      }
      --msg_len;
      if(msg_len <= 0) ++tsip_sync;
   }
   else if(tsip_sync == 5) {  // low byte of checksum
      ss_msg_cksum = c;
      ++tsip_sync;
   }
   else if(tsip_sync == 6) {  // high byte of checksum
      ss_msg_cksum += ((int) c) * 256;
      if(ss_msg_cksum == ss_vfy_cksum) decode_ss_msg();
      packet_end = 1;
      tsip_sync = 0;
      tsip_wptr = 0;
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      nmea_vfy_cksum = nmea_msg_cksum = 0; // init received message checksum
      venus_nmea = 0;
   }
}


//
//
//   RFTG receiver stuff
//
//

void parse_rftg_runtime()
{
unsigned gps_time;

   log_packet_id("Packet 0x20 (runtime)");

   gps_time = tsip_dword();
   rftg_elapsed = (unsigned) tsip_dword();
}

void parse_rftg_21()
{
   log_packet_id("Packet 0x21 (unknown)");

   tsip_byte();  // 0x00
   tsip_byte();  // 01=OK 02=when not tracking
   tsip_byte();  // 0x74  0x16 when normal
   tsip_byte();  // 0x00
   tsip_byte();  // 40=antenna open
   tsip_byte();  // 0x15=ok 0x06=ok 0x01=ok 00=no signal
}

void parse_rftg_phase()
{
   log_packet_id("Packet 0x22 (phase)");

   rftg_phase_err = (double) tsip_single();     // phase err ns
   rftg_phase_ref = (double) tsip_single();     // ref ns
   rftg_avg_phase = (double) tsip_single();     // avg phase?
   rftg_delta_ape_10m = (double) tsip_single(); // 10 min delta ape

   pps_offset = (OFS_SIZE) (double) rftg_avg_phase * 1.0E9;  // average phase
   have_pps_offset = 1;
//sprintf(debug_text, "phase: %g %g %g %g", v1,v2,v3,v4);
}


void parse_rftg_voltages()
{
double ctrl;
int b1,b2,b3,b4;

   log_packet_id("Packet 0x23 (voltages)");

   ctrl = ((double) (u16) tsip_word()) / 3276.8;  // counter?
   b1 = tsip_byte(); 
   b2 = tsip_byte(); 
   b3 = tsip_byte(); 
   b4 = tsip_byte(); 

   // these two are only sent by the XO unit
   if(rftg_unit != 0) {
      rftg_adc = ((double) (u16) tsip_word()) / 3276.8;  // counter?
      rftg_dac_5min = ((double) (u16) tsip_word()) / 3276.8;  // counter?
   }

   dac_voltage = (DATA_SIZE) ctrl;
   have_dac = 1;
   temperature = (DATA_SIZE) (((double)b1 * 1.5024) - 273.0);
   have_temperature = 103;

   if(rftg_unit == 0) {
      ant_v1 = ((double) b2) / 15.44571833;  // lamp V
      ant_v2 = ((double) b3) / 15.44571833;  // xtal V
      plot[SIX].units = "--";       // meaningless number for Rb unit
      plot[SIX].plot_id = "---";
      plot[SEVEN].plot_id = "LampV";
      plot[EIGHT].plot_id = "OcxoV";
   }
   else {
      ant_v1 = ((double) b2) / 50.0486431;   // fault1 V
      ant_v2 = ((double) b3) / 50.0486431;   // fault2 V
      plot[SIX].units = "mA";
      plot[SIX].plot_id = "AntI";
      plot[SEVEN].plot_id = "AntV1";
      plot[EIGHT].plot_id = "AntV2";
   }
   ant_ma = (ant_v2 - ant_v1) * 100.0;  // antenna current

   rftg_oscv = ((double) b4) / 7.121011923;
   have_ant_v1 = have_ant_v2 = have_ant_ma = 1;

//sprintf(debug_text3, "rftg23: %.5f %d->%.5f %d->%.5f %d->%.5f %d->%.5f  adc:%.5f  dac5:%.5f", ctrl, b1,temperature, b2,ant_v1, b3,ant_v2, b4,rftg_oscv, rftg_adc,rftg_dac_5min);
}

void parse_rftg_correction()
{
unsigned v2, v4;

   log_packet_id("Packet 0x24 (time/freq corrections)");

   rftg_time_corr = (double) tsip_single();             // time correction
   v2 = (unsigned) tsip_dword();   // age counter

   rftg_freq_corr = (double) tsip_single();             // freq correction
   v4 = (unsigned) tsip_dword();   // age counter

// sprintf(plot_title, "rftg24: %g %d %g %g", rftg_time_corr,v2,rftg_freq_corr,v4);
}


void parse_rftg_sigs()
{
int i;
int num_vis;
int num_tracked;
int prn;
float az;
int tracked;
int snr;
int chan;

   // satellite status
   log_packet_id("Packet 0x25 (satellite signals)");

   reset_sat_tracking();
   level_type = "SNR";

   num_vis = tsip_byte();
   num_tracked = tsip_byte();

   for(i=0; i<6; i++) {
      prn = tsip_byte();
      tracked = tsip_byte(); // 08=tracked   0=not tracked
      snr = tsip_byte();
      chan = tsip_byte();    // channel status: A2=tracked and used  01=not tracked
      if((prn >= 1) && (prn <= 32)) {
         az = (float) (prn*10);   // fake the az/el so sat sig levels show in the sat map
         set_sat_azel(prn, az, 20.0F);

         sat[prn].sig_level = (float) snr;
         sat[prn].level_msg = 0x25;
         have_snr |= rinex_gnss(prn);
         if(tracked & 0x08) {
            sat[prn].tracking = prn;
         }
         record_sig_levels(prn);
      }
   }

   tsip_byte();
}

void parse_rftg_posn()
{
int i;
double v1,v2,v3;

   // rcvr posn
   log_packet_id("Packet 0x26 (position)");

   for(i=0; i<5; i++) {  // 5 sets of values RCVR, AVG. NVM0, NVM1, NVM2
       v1 = (double) (s32) tsip_dword();
       v2 = (double) (s32) tsip_dword();
       v3 = (double) (s32) tsip_dword();
       if(i == 0) {
          lat = (v1 / 3600000.0) * PI / 180.0;
          lon = (v2 / 3600000.0) * PI / 180.0;
          alt = (v3 / 100.0);
          have_rftg_lla = 1;
       }
   }
}

void parse_rftg_additional_status()
{
int fw;

   log_packet_id("Packet 0x27 (additional status)");

   fw = tsip_word();  // fw version

   tsip_byte();  //
   tsip_byte();  //
   tsip_byte();  //
// maybe valid float seen here
   tsip_byte();  //
   tsip_byte();  //
// valid float seen here
   tsip_byte();  //
   tsip_byte();  //
   tsip_byte();  //
   tsip_byte();  //
   tsip_byte();  //

   rftg_sensitivity = (double) tsip_single(); // sensitivity
   rftg_pll_port = tsip_byte();   // pll status port
   rftg_pld_port = tsip_byte();   // pld status port
   tsip_byte();  //

// sprintf(debug_text, "adds:%g  pll:%02x pld:%02x", rftg_sensitivity, rftg_pll_port,rftg_pld_port);
}

void parse_rftg_28()
{
   log_packet_id("Packet 0x28 (unknown)");
}


void parse_rftg_corr_history()
{
   // !!!!!!! do something?
   log_packet_id("Packet 0x29 (correction history)");
}


void parse_rftg_cable()
{
float val;

   // cable delay in feet
   log_packet_id("Packet 0x55 (cable delay)");

   val = tsip_single();
   cable_delay = (double) val;  // cable delay in feet
   cable_delay = cable_delay / 1.0E9;
   cable_delay /= VELOCITY_FACTOR;  // cable delay in nanoseconds
   have_cable_delay = 1;
//sprintf(debug_text3, "rftg55: %f  %f", val, cable_delay);
}


void parse_rftg_errlog()
{
   // !!!!! we need to decode this
   log_packet_id("Packet 0x57 (error log)");
}


void parse_rftg_traim()
{
   // !!!!! we need to decode this
   log_packet_id("Packet 0x63 (traim status)");

   tsip_byte();  // message rate
   tsip_byte();  // alarm limit us (?)
   tsip_byte();  // status (0x0D)
   tsip_byte();  // 
   tsip_byte();  // 
   tsip_byte();  // 
}


void parse_rftg_warmup()
{
   log_packet_id("Packet 0x82 (warmup time)");

   rftg_warmup_time = tsip_word();
}


void parse_rftg_delta_ape()
{
   log_packet_id("Packet 0x85 (delta ape)");

   rftg_delta_ape = (double) tsip_single();
}


void parse_rftg_const_ape()
{
   log_packet_id("Packet 0x86 (constant ape)");

   rftg_const_ape = (double) tsip_single();
}


void parse_rftg_ape2()
{
   log_packet_id("Packet 0x88 (ape2)");

   rftg_ape2 = (double) tsip_single();
}

void parse_rftg_ape()
{
   log_packet_id("Packet 0x89 (ape)");

   rftg_ape = (double) tsip_single();
}


void parse_rftg_delta_temp()
{
   log_packet_id("Packet 0x90 (delta temperature)");

   rftg_delta_temp = (double) tsip_single();
}


void parse_rftg_hw_ver()
{
   log_packet_id("Packet 0x91 (hardware version)");

   rftg_hw = (int) tsip_byte();
   have_info |= VERSION_INFO;
}


void parse_rftg_avg_sample()
{
   log_packet_id("Packet 0x92 (average sample)");
   rftg_avg_sample = (int) tsip_byte();
}


void parse_rftg_corr_sched()
{
   log_packet_id("Packet 0x94 (correction schedule)");

   rftg_corr_sched = tsip_word();
}


void parse_rftg_unknown(int pkt)
{
   sprintf(out, "Packet 0x%02X (UNKNOWN PACKET)", pkt);
   log_packet_id(out);

//sprintf(debug_text2, "saw unkn msg %02X", msg_id);
}



void set_rftg_fix_mode(int mode)
{
   // (mode == 0) -> fix mode
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x31);
   send_byte(mode);
   send_rftg_end();
}

void set_rftg_cable(double delay)
{
   if(read_only) return;

   delay *= 1.0E9;
   delay *= VELOCITY_FACTOR;  // assumed velocity factor

   start_rftg_request(1);

   send_rftg_start(0x35);
   send_byte(1);   // 1=set?
   send_single((float) delay);
   send_rftg_end();
   set_rftg_normal();
}

void set_rftg_lla(S32 slat, S32 slon, S32 salt)
{
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x32);
   send_dword(slat);
   send_dword(slon);
   send_dword(salt);
   send_rftg_end();
}

void set_rftg_traim(int mode)
{
   // (mode == 1) -> enable  (0 == disable)
   // note: this does not seem to change anything!!!!!
   if(read_only) return;

   start_rftg_request2(0);

   if(mode == 0) mode = 2;  // disable

   send_rftg_start(0x64);
   send_byte(mode);
   send_rftg_end();
}

void set_rftg_advance(float val)
{
   // advance pps (in microseconds)
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x30);
   send_byte(1);    // advance
   send_single(val);
   send_rftg_end();
}

void set_rftg_delay(float val)
{
   // delay pps (in microseconds)
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x30);
   send_byte(2);    // delay
   send_single(val);
   send_rftg_end();
}

void set_rftg_offset(double val)
{
   // pps offset - in nanoseconds
   if(read_only) return;

   val = (val / 1000.0);   // convert nanoseconds to microseconds
   if(val >= 0.0) set_rftg_advance((float) val);
   else           set_rftg_delay((float) (0.0-val));
}

void rftg_clear_errlog()
{
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x37);  // clear error history from eeprom
   send_byte(1); 
   send_rftg_end();

   set_rftg_normal();
}

void rftg_enable_cpu()
{
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x30);
   send_byte(4); 
   send_dword(0);
   send_rftg_end();

   set_rftg_normal();
}

void rftg_disable_cpu()
{
   if(read_only) return;

   start_rftg_request2(0);

   send_rftg_start(0x30);
   send_byte(5); 
   send_dword(0);
   send_rftg_end();

   set_rftg_normal();
}


void parse_rftg_time()
{
int i;
char c;
double jd;

   log_packet_id("RFTG time code");

   start_msg_decode(1);
   jd = 0.0;

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   msg_col = 0;     // index of next char to get from nmea buffer
   if(get_fixed_field(1)) {    // 0=ref0  1=ref1
      rftg_unit = atohex(msg_field);
      have_rftg_unit = 1;
      if((rftg_unit != 0) && (user_set_sat_plot == 0)) {  // enable sat plot unless user set it
         plot[SAT_PLOT].show_plot = 1;
      }
   }
   if(get_fixed_field(1)) {    // 0=active 1=inactive
      i = atohex(msg_field);
      if(i) minor_alarms |= MINOR_INACTIVE;
      else  minor_alarms &= (~MINOR_INACTIVE);
   }
   if(get_fixed_field(1)) {    // not used
      i = atohex(msg_field);
   }
   if(get_fixed_field(1)) {    // mode
      i = atohex(msg_field);
      if     (i == 0) discipline_mode = DIS_MODE_WARMUP;
      else if(i == 1) discipline_mode = DIS_MODE_NORMAL;
      else if(i == 2) discipline_mode = DIS_MODE_AUTO_HOLD;
      else if(i == 3) discipline_mode = DIS_MODE_FAILED;
      else if(i == 4) discipline_mode = DIS_MODE_UNKNOWN;
   }

   if(get_fixed_field(1)) {   // alarm char 1
      i = atohex(msg_field);
      if(i & 0x03) pps_enabled = 0;
      else         pps_enabled = 1;
      have_pps_enable = 1;

      if(i & 0x04) minor_alarms |= MINOR_ANT_NO_PWR;
      else         minor_alarms &= (~MINOR_ANT_NO_PWR);
      have_antenna = 1;

      if(i & 0x08) minor_alarms |= MINOR_WARMUP;   // warmup fail
      else         minor_alarms &= (~MINOR_WARMUP); // warmup ok
   }

   have_critical_alarms = 1;
   critical_alarms &= (~CRIT_OCXO);
   if(get_fixed_field(1)) {   // alarm char 2
      i = atohex(msg_field);
      if(i & 0x01) critical_alarms |= CRIT_OCXO;
      if(i & 0x02) critical_alarms |= CRIT_ROM;     // GPS ROM
      else         critical_alarms &= (~CRIT_ROM);
      if(i & 0x04) critical_alarms |= CRIT_RAM;     // GPS RAM
      else         critical_alarms &= (~CRIT_RAM);  
      if(i & 0x08) critical_alarms |= CRIT_OCXO;
   }

   if(get_fixed_field(1)) {   // alarm char 3
      i = atohex(msg_field);
      have_critical_alarms = 1;
      if(i & 0x01) critical_alarms |= MINOR_HOLDOVER;          
      else         critical_alarms &= (~MINOR_HOLDOVER);          
      if(i & 0x04) minor_alarms    |= MINOR_DISCIPLINE;   
      else         minor_alarms    &= (~MINOR_DISCIPLINE);
      if(i & 0x0A) critical_alarms |= CRIT_FPGA;          // temperature
      else         critical_alarms &= (~CRIT_FPGA);
   }

   if(get_fixed_field(1)) {   // alarm char 4
      i = atohex(msg_field);
      if(i & 0x01) critical_alarms |= CRIT_GPS;
      else         critical_alarms &= (~CRIT_GPS);
      if(i & 0x0A) minor_alarms    |= MINOR_OSC_CTRL;
      else         minor_alarms    &= (~MINOR_OSC_CTRL);
   }

   if(get_fixed_field(2)) {   // time in current mode
   }

   if(get_fixed_field(8)) {  // gps time
      time_flags &= (~TFLAGS_INVALID);
      jd = (double) atohex(msg_field);
      if(jd == 0.0) {  // no time, show system clock
         time_flags |= TFLAGS_INVALID;
         get_clock_time();
         jd = clk_jd - GPS_EPOCH;
         jd *= (24.0*60.0*60.0);
      }
   }

   if(get_fixed_field(4)) {   // firmware ID
      msg_field[4] = 0;
      strcpy(rftg_fw, msg_field);
      have_info |= (MANUF_PARAMS | PRODN_PARAMS);
   }

// sprintf(out, "%s -> unit %d  status:%04X  alarm:%06X  time:%.0f  mfg:%s", 
// nmea_msg, unit, status, alarm, jd, msg_field);

   jd /= (24.0*60.0*60.0);
   jd += GPS_EPOCH;

   set_gregorian_time(jd);
   if(time_flags & TFLAGS_UTC) {
      gps_to_utc();
   }

   update_gps_screen(4387);
   request_rftg_voltages();   // ask for group of status messages every second
}

void decode_rftg_message()
{ 
   flush_debug();

   msg_fault = 0x00;
   tsip_rptr = 0;
   msg_id = get_next_tsip();

   subcode = 0x00;
   first_msg = 0;
   last_msg = msg_id;
   ++wakeup_tsip_msg; // we have seen a TSIP message
   tsip_error = 0;    // this flag gets set if we see something wrong in a message
   early_end = 0;
   new_packet(0);

   msg_id &= 0xFF;
   if     (msg_id == 0x20) parse_rftg_runtime();
   else if(msg_id == 0x21) parse_rftg_21();
   else if(msg_id == 0x22) parse_rftg_phase();
   else if(msg_id == 0x23) parse_rftg_voltages();
   else if(msg_id == 0x24) parse_rftg_correction();
   else if(msg_id == 0x25) parse_rftg_sigs();
   else if(msg_id == 0x26) parse_rftg_posn();
   else if(msg_id == 0x27) parse_rftg_additional_status();
   else if(msg_id == 0x28) parse_rftg_28();
   else if(msg_id == 0x29) parse_rftg_corr_history();
   else if(msg_id == 0x55) parse_rftg_cable();
   else if(msg_id == 0x57) parse_rftg_errlog();
   else if(msg_id == 0x63) parse_rftg_traim();
   else if(msg_id == 0x82) parse_rftg_warmup();
   else if(msg_id == 0x85) parse_rftg_delta_ape();  
   else if(msg_id == 0x86) parse_rftg_const_ape();  
   else if(msg_id == 0x88) parse_rftg_ape2();  
   else if(msg_id == 0x89) parse_rftg_ape();  
   else if(msg_id == 0x90) parse_rftg_delta_temp();
   else if(msg_id == 0x91) parse_rftg_hw_ver();
   else if(msg_id == 0x92) parse_rftg_avg_sample();
   else if(msg_id == 0x94) parse_rftg_corr_sched();
   else                    parse_rftg_unknown(msg_id);

   saw_rcvr_msg = 1;
}


void get_rftg_message()
{
u08 c;
int i;
static int colon = 0;
char s[3];  // used to calculate message cksum

   // this routine buffers up an incoming TSIP message and then parses it
   // when it is complete.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {         // syncing to start of message, search for a DLE
      if(c == DLE) {
         tsip_sync = 1;
         get_sync_time();
         colon = 0;
      }
      else if(c == ':') {
         tsip_sync = 1;
         get_sync_time();
         colon = 1;
      }

      nmea_vfy_cksum = 0;
      nmea_msg_cksum = 0;
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) {    // DLE had been seen, now checking next byte
      if(c == DLE) {            // DLE DLE is a 0x10 data byte
         goto rst_msg;
      }
      else if(c == ETX) {       // DLE ETX is end-of-message
         goto rst_msg;          // ... should never happen here
      }
      else if(colon) {
         if((c == '0') || (c == '1')) {
            goto get_msg;
         }
         else goto rst_msg;
      }
      else {                    // DLE xx is message start
         get_msg:
         tsip_sync = 2;         // ... so accumulate the message
         if(tsip_wptr < (MAX_TSIP-1)) {
            tsip_buf[tsip_wptr++] = c;
            tsip_buf[tsip_wptr] = 0;
         }
         else {                 // buffer overlow
            tsip_error |= OVFL_ERROR;
            goto rst_msg;
         }
      }
   }
   else if(tsip_sync == 2) {    // buffer up the message
      if(colon && (c == 0x0D)) {
         tsip_sync = 3;
         if(tsip_wptr < (MAX_TSIP-1)) {
            tsip_buf[tsip_wptr++] = 0;
            tsip_buf[tsip_wptr] = 0;
         }
         else {
            goto rst_msg;
         }
      }
      else if(c == DLE) {
         tsip_sync = 3;
      }
      else if(tsip_wptr < (MAX_TSIP-1)) {
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 3) {   // last char was a DLE
      if(colon) {
         nmea_vfy_cksum = 0;
         for(i=0; i<22; i+=2) {
            s[0] = tsip_buf[i];
            s[1] = tsip_buf[i+1];
            s[2] = 0;
            nmea_vfy_cksum += atohex(s);
         }
         nmea_vfy_cksum &= 0xFF;

         i = atohex((char *) &tsip_buf[22]) & 0xFF;
         if(nmea_vfy_cksum == i) {
            parse_rftg_time();
         }
         goto rst_msg;
      }
      else if(c == ETX) {           // DLE ETX is end-of-message
         decode_rftg_message(); // so process the buffered message
         packet_end = 1;

         rst_msg:
         tsip_wptr = 0;
         tsip_sync = 0;
      }
      else {                   // DLE DLE is a DLE data byte and DLE xx is message ID
         if(tsip_wptr < (MAX_TSIP-1)) {  // so add it to the message buffer
            tsip_buf[tsip_wptr++] = c;
            tsip_buf[tsip_wptr] = 0;
         }
         else {
            tsip_error |= OVFL_ERROR;
            goto rst_msg;
         }
         tsip_sync = 2;
      }
   }
   else {     // should never happen
      goto rst_msg;
   }
}




//
//
//   Brandywine receiver stuff
//
//

int brandy_msg_id = 0;

void send_brandy_char(u08 c)
{
   sendout(RCVR_PORT, c, EOM);
nmea_tx_cksum ^= c;
////   if(sim_file == 0) Sleep(5);
   // !!!! wo we need to eat echoed chars?
}


void send_brandy_start()
{
   send_brandy_char('$');
   nmea_tx_cksum = 0;
}

void send_brandy_string(char *s, int comma)
{
int i, j;

   if(s == 0) return;

   j = strlen(s);
   for(i=0; i<j; i++) send_brandy_char((u08) s[i]);

   if(comma) send_brandy_char((u08) ',');
}

void send_brandy_end(int do_cksum)
{
char cksum[10];

   sprintf(cksum, "%02X", (nmea_tx_cksum & 0xFF));

   if(do_cksum) {
      send_brandy_char('*');
      send_brandy_char(cksum[0]);
      send_brandy_char(cksum[1]);
   }
   send_brandy_char(0x0D);
   send_brandy_char(0x0A);

   if(sim_file == 0) Sleep(50);
}

void send_brandy_cmd(char *s)
{
   if(s == 0) return;
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend brandy start: %s\n", s);
   }

   send_brandy_start();
   send_brandy_string(s, 0);
//send_brandy_end(0);
//return;
   if(strchr(s, '*')) send_brandy_end(0);
   else               send_brandy_end(1);
}

void parse_brandy_t()
{
double val;
char c1,c2;
int status;

   log_packet_id("time");

   if(use_a_time) return;

   if(get_msg_field()) {  // time
      c1 = c2 = 0;
      sscanf(msg_field, "%d%c%d%c%lf", &pri_hours,&c1,&pri_minutes,&c2,&val);
      if(c1 != ':') return;
      if(c2 != ':') return;

      hours = pri_hours;
      minutes = pri_minutes;
      seconds = pri_seconds = (int) val;
      pri_frac = val - (double) pri_seconds;
//pri_frac = 0.0;  // prevent time code sequence errors
   }

   if(get_msg_field()) {  // date
      c1 = c2 = 0;
      sscanf(msg_field, "%d%c%d%c%d", &pri_day,&c1,&pri_month,&c2,&pri_year);
      if(c1 != '/') return;
      if(c2 != '/') return;
      if(pri_year < 80) pri_year += 2000;
      else              pri_year += 1900;
      month = pri_month;
      day = pri_day;
      year = pri_year;
   }

   if(timing_mode == TMODE_GPS) {  // convert utc time to gps time
      utc_to_gps();
   }

   get_msg_field();  // day of year
   get_msg_field();  // day of week

   if(get_msg_field()) {  // status  (hex number)
      status = atohex(msg_field);
      time_flags &= (~TFLAGS_INVALID);
      if(status & 0x08) {  // time ok
         time_flags &= (~TFLAGS_INVALID);
      }
      else { // time bad
//!!!!!! time_flags |= (TFLAGS_INVALID);
      }
   }

   drive_nmea_screen(GPS, 8089);  // aaattt update screen 
}


void parse_brandy_a()
{
char c;
int val;

   // version and time info
   log_packet_id("version and time");

   if(get_msg_field()) {  // fw version (handled in version message)
   }

   if(get_msg_field()) {  // time - we get this from the "t" message
      if(use_a_time) {
         sscanf(msg_field, "%d%c%d%c%d", &pri_hours,&c,&pri_minutes,&c,&pri_seconds);
         hours = pri_hours;
         minutes = pri_minutes;
         seconds = pri_seconds;
      }
   }

   if(get_msg_field()) {  // date - we get this from the "t" message
      if(use_a_time) {
         sscanf(msg_field, "%d%c%d%c%d", &pri_day,&c,&pri_month,&c,&pri_year);
         if(pri_year < 80) pri_year += 2000;
         else              pri_year += 1900;
         month = pri_month;
         day = pri_day;
         year = pri_year;
      }
   }
//sprintf(debug_text, "%02d:%02d:%02d  %04d/%02d/%02d", hours,minutes,seconds, year,month,day);

   if(timing_mode == TMODE_GPS) {  // convert utc time to gps time
      if(use_a_time) utc_to_gps();
   }

   if(get_msg_field()) {  // status  (hex number)
      val = atohex(msg_field);
//sprintf(debug_text2, "status:%04X", val);
      time_flags &= (~TFLAGS_INVALID);
      if(val & 0x08) {  // time ok
         time_flags &= (~TFLAGS_INVALID);
      }
      else { // time bad
//!!!!!! time_flags |= (TFLAGS_INVALID);
      }

      if(val & 0x04) {  // GPS unlocked
      }
      else {  // GPS locked
      }
   }

   if(get_msg_field()) {  // position averaging count
      if(isdigit(msg_field[0])) {
         survey_progress = atoi(msg_field);
         have_progress = 2;
      }
   }

   if(get_msg_field()) {  // position averaging mode
      c = msg_field[0];
      minor_alarms &= (~MINOR_SURVEY);
      if(c == '0') {  // not averaging
         rcvr_mode = RCVR_MODE_3D;
         have_rcvr_mode = 22;
      }
      else if(c == '1') {  // averaging
         rcvr_mode = RCVR_MODE_SURVEY;
         minor_alarms |= MINOR_SURVEY;
         have_rcvr_mode = 22;
      }
      else if(c == '2') {  // position hold mode
         rcvr_mode = RCVR_MODE_HOLD;
         have_rcvr_mode = 22;
      }
   }

   if(get_msg_field()) {  // output status (hex number)
      val = atohex(msg_field);
      if(val & 0x0080) {  // pll unlocked  !!!!!
         ffom = 2;
      }
      else ffom = 0;
      have_ffom = 33;
   }

   if(get_msg_field()) {  // control status (hex number)
      val = atohex(msg_field);
      if(val & 0x0010) minor_alarms |= MINOR_OSC_AGE;
      else             minor_alarms &= (~MINOR_OSC_AGE);
      have_osc_age = 556;

      if(val & 0x0040) minor_alarms |= MINOR_NO_TRACK;
      else             minor_alarms &= (~MINOR_NO_TRACK);
      have_tracking = 1;

      if(val & 0x0008) critical_alarms |= (CRIT_OCXO);
      else             critical_alarms &= (~CRIT_OCXO);

      if(val & 0x0080) critical_alarms |= (CRIT_FPGA);
      else             critical_alarms &= (~CRIT_FPGA);
      have_critical_alarms = 77;

      if(val & 0x0002) discipline_mode = DIS_MODE_WARMUP;
      else             discipline_mode = DIS_MODE_NORMAL;
   }

   if(use_a_time)  {
      drive_nmea_screen(GPS, 8877);
   }
}


void parse_brandy_c()
{

   // pulse output
   log_packet_id("pulse output");

   if(get_msg_field()) {  // pulse time should be UXXXXXX or P1000 for 1PPS
      strupr(msg_field);
      if(msg_field[0] == 'P') brandy_pps_rate = atoi(&msg_field[1]);
      else if(strstr(msg_field, "UXXXXXX")) brandy_pps_rate = 1000;
      else brandy_pps_rate = 0;
      have_brandy_rate = 1;
   }

   if(get_msg_field()) {  // pulse width in msecs
      brandy_pps_width = atoi(msg_field);
      if(brandy_pps_width < 0) pps_polarity = 1;
      else                     pps_polarity = 0;
      have_pps_polarity = 22;
      have_brandy_width = 1;
   }
}


void parse_brandy_e()
{
   // code output
   log_packet_id("code output");

   if(get_msg_field()) {  // time code 1 type
      brandy_code1 = msg_field[0];
      have_brandy_code |= 0x01;
   }

   if(get_msg_field()) {  // pulse output type
      brandy_code2 = msg_field[0];
      if     (brandy_code2 == '0') { pps_enabled = 0; have_pps_enable = 30; }
      else if(brandy_code2 == '1') { pps_enabled = 0; have_pps_enable = 31; } 
      else if(brandy_code2 == '2') { pps_enabled = 1; have_pps_enable = 31; } 
      else if(brandy_code2 == '3') { pps_enabled = 1; have_pps_enable = 32; } 
      have_brandy_code |= 0x02;
   }

   if(get_msg_field()) {  // TXD1 code type (not used)
      brandy_code3 = msg_field[0];
      have_brandy_code |= 0x04;
   }

   if(get_msg_field()) {  // TXD2 code type (not used)
      brandy_code4 = msg_field[0];
      have_brandy_code |= 0x08;
   }
}



void parse_brandy_f()
{

   // frequency controller info

   log_packet_id("freq controller");

   if(get_msg_field()) {  // 2 -
      inst_phase = atof(msg_field);
      pps_offset = inst_phase;
      have_pps_offset = 456;
   }

   if(get_msg_field()) {  // 3 - documentation says this should be item 4!
      if(msg_field[0] == '%') { // value out of range
         avg_phase = atof(&msg_field[1]);
      }
      else {
         avg_phase = atof(msg_field);
      }
   }

   if(get_msg_field()) {  // 4 - always 0 on GPS-4  - documentation says this should be item 3!  
      phase_control_val = atof(msg_field);
   }

   if(get_msg_field()) {  // 5 -
      freq_control_val = atof(msg_field);
      dac_voltage = (DATA_SIZE) ((freq_control_val / 32767.0) * 100.0);
      have_dac = 44;
   }

   if(get_msg_field()) {  // 6 - last freq correction
      last_freq_corr = atof(msg_field);
      osc_offset = (last_freq_corr * 1.0E12);
      have_osc_offset = 44;
   }

   if(get_msg_field()) {  // 7 - frequency trend
      freq_trend = atof(msg_field);
   }

   if(get_msg_field()) {  // 8 - date of last correction
      msg_field[32] = 0;
      strcpy(last_correction, msg_field);
   }

   if(get_msg_field()) {  // 9 - temperature (not valid on GPS-4)
      temperature = (DATA_SIZE) atof(msg_field);
//    have_temperature = 1;  // temp reading not valid
   }

   if(get_msg_field()) {  // 10 -
      phase_status = atohex(msg_field);
      if(phase_status & 0xF8) minor_alarms |= MINOR_PLL;
      else                    minor_alarms &= (~MINOR_PLL);
      have_pll = 1;
   }

   if(get_msg_field()) {  // 11 -
      pll_constraint = atohex(msg_field);

      if(pll_constraint & 0x0C) time_flags |= TFLAGS_INVALID;
      else                      time_flags &= (~TFLAGS_INVALID);

      if(pll_constraint & 0x01) minor_alarms |= MINOR_OSC_CTRL;
      else                      minor_alarms &= (~MINOR_OSC_CTRL);

   }

   if(get_msg_field()) {  // 12 - osc type
      msg_field[16] = 0;
      strcpy(brandy_osc, msg_field);
      have_info |= (MANUF_PARAMS);
   }
}


void parse_brandy_j()
{
double jd;
int pend;
int i;
int yy,mon,dd;
int hh,mm,ss;

   // leapsecond info
   log_packet_id("leapsecond info");

   yy = mon = dd = 0;
   hh = mm = ss = 0;
   if(get_fixed_field(2)) {
      yy = atoi(msg_field);
      if(yy < 80) yy += 2000;
      else        yy += 1900;
   }
   if(get_fixed_field(2)) mon = atoi(msg_field);
   if(get_fixed_field(2)) dd = atoi(msg_field);
   if(get_fixed_field(2)) hh = atoi(msg_field);
   if(get_fixed_field(2)) mm = atoi(msg_field);
   if(get_fixed_field(2)) ss = atoi(msg_field);
   get_fixed_field(1);  // eat the comma
//sprintf(debug_text3, "leap: %04d/%02d/%02d  %02d:%02d:%02d (%s)", yy,mon,dd, hh,mm,ss, msg_field);

   if(get_msg_field()) {
      pend = atoi(msg_field);  // leap second +/- 1
//sprintf(debug_text, "leap dir:%s  pend:%d", msg_field, pend);
      minor_alarms &= (~MINOR_LEAP_PEND);
      if(pend) {
         minor_alarms |= MINOR_LEAP_PEND;
         if(yy || mon || dd || hh || mm || ss) {
           jd = jdate(yy, mon, dd);  // -1 since moto says 2017/1/1
           jd_leap = jd + jtime(hh,mm,ss,-1.0);
           have_jd_leap = 8;
           calc_jd_leap(8);
         }
      }
      have_leap_info = 54;
   }

   if(get_msg_field()) {  // leap second count
      i = atoi(msg_field);
      if(i) {
         if(!user_set_utc_ofs) utc_offset = i;
         check_utc_ofs(33);
      }
   }
}


void parse_brandy_n()
{
   // receiver fw version
   log_packet_id("firmware");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(brandy_fw, msg_field);
   }
   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(brandy_engine, msg_field);
   }
   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(brandy_test, msg_field);
   }

   have_info |= (VERSION_INFO | PRODN_PARAMS);
}


void parse_brandy_o()
{
   // time zone
   log_packet_id("time zone");
}


void parse_brandy_z()
{
   // reset receiver
   log_packet_id("receiver reset");
}


void parse_prccg()
{
int cmd;

   // Brandywine query responses
   // queries D, H, L, P, S produce NMEA messages

   if(get_msg_field() == 0) return;

   cmd = toupper(msg_field[0]);

   if     (cmd == 'A') parse_brandy_a();
   else if(cmd == 'C') parse_brandy_c();
   else if(cmd == 'E') parse_brandy_e();
   else if(cmd == 'F') parse_brandy_f();
   else if(cmd == 'J') parse_brandy_j();
   else if(cmd == 'N') parse_brandy_n();
   else if(cmd == 'O') parse_brandy_o();
   else if(cmd == 'Z') parse_brandy_z();
}


void poll_next_brandy()
{
int test;

   // request an item from a BRANDY teceiver.  Requests are alternated between
   // a time message and some receiver parameter.  The parameter requests
   // alternate between one of the important parameters and then the lesser
   // important ones.


   test = 1;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else if(polled_msg_id == BRANDY_TIME_MSG) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
      }
      if(polled_req < 0) polled_req = 0;

      if(0 && ((polled_seq % 3) == 0)) ;
      else if(1 && (polled_seq % 20)) {  // rate limit messages due to low baud rate
        if(use_a_time)  send_polled_cmd("a", BRANDY_TIME_MSG);  // request "a" time
        else            send_polled_cmd("t", BRANDY_TIME_MSG);  // request "t" time
      }
      else {
         if     (polled_req == 0)  send_polled_cmd("a", BRANDY_VERSION_MSG);
         else if(polled_req == 1)  send_polled_cmd("c", BRANDY_PULSE_MSG);
         else if(polled_req == 2)  send_polled_cmd("e", BRANDY_CODE_MSG);
         else if(polled_req == 3)  send_polled_cmd("h", BRANDY_HEALTH_MSG);   //long
         else if(polled_req == 4)  send_polled_cmd("j", BRANDY_LEAP_MSG);
         else if(polled_req == 5)  send_polled_cmd("p", BRANDY_POSN_MSG);     //long
         else if(polled_req == 6)  send_polled_cmd("n", BRANDY_FW_MSG);
         else if(polled_req == 7)  send_polled_cmd("d", BRANDY_DOP_MSG);      //long
         else if(polled_req == 8)  send_polled_cmd("s", BRANDY_INFO_MSG);
//       else if(polled_req == 9)  send_polled_cmd("f", BRANDY_FREQ_MSG);     //long
//       else if(polled_req == 10) send_polled_cmd("o", BRANDY_ZONE_MSG);

         ++polled_req;
         if(polled_req > 8)  {
            polled_req = 0;
            ++all_polled;
         }
      }

      ++polled_seq;
   }
   else {
      if(use_a_time)  send_polled_cmd("a", BRANDY_TIME_MSG);  // request "a" time
      else            send_polled_cmd("t", BRANDY_TIME_MSG);  // request "t" time
   }
}


void decode_brandy_msg()
{
char c;
int i;
static int row = 0;

   venus_nmea = 0;
   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

//if(debug_file) fprintf(debug_file, "decode brandy: %s\n", nmea_msg);
//if(raw_file) fprintf(raw_file, "decode brandy: %s\n", nmea_msg);

   msg_col = 0;     // index of next char to get from nmea buffer
   if(isdigit(nmea_msg[0])) {
      parse_brandy_t();
      last_was_gsv = 0;
   }
   else if(nmea_msg[0] == '?') {  // error code
      last_was_gsv = 0;
   }
   else {
      get_msg_field(); // get the NMEA message type 
      if     (!strcmp(msg_field, "GPGSV")) {
         parse_gpgsv(GPS);
      }
      else if(!strcmp(msg_field, "GPGSA")) parse_gpgsa(GPS);
      else if(!strcmp(msg_field, "GPGGA")) parse_gpgga(GPS);
      else if(!strcmp(msg_field, "GPRMC")) parse_gprmc(GPS);
      else if(!strcmp(msg_field, "PRCCG")) parse_prccg();
      else if(!strcmp(msg_field, "PFEC"))  parse_pfec();
      else last_was_gsv = 0;
   }

   poll_next_brandy();

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
   return;
}

void get_brandy_message()
{
u08 c;
static int nmea_fmt = 0;

   // This routine buffers up an incoming Brandywine message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if((c == '$') || (c == '?') || isdigit(c)) {  // t-cmd and error messages also
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      nmea_vfy_cksum = 0;  // the calculated message checksum
      nmea_msg_cksum = 0;  // the checksum in the message
      nmea_fmt = 0;
      if(isdigit(c)) goto tcode;     // time code message
      else if(c == '?') goto tcode;  // error message
      nmea_fmt = 1;
      return;
   }
   else if(tsip_sync == 1) { // '$' has been seen, now build the message
      tcode:
      if((c == 0x0D) || (c == 0x0A)) goto nmea_end;  // message has no checksum

      if(c == '*') tsip_sync = 2;  // message checksum follows
      else if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         nmea_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 2) {  // getting message checksum chars
      if((c == 0x0D) || (c == 0x0A)) goto nmea_end;

      if     ((c >= '0') && (c <= '9')) nmea_msg_cksum = (nmea_msg_cksum << 4) | (c-'0');
      else if((c >= 'A') && (c <= 'F')) nmea_msg_cksum = (nmea_msg_cksum << 4) | ((c-'A')+10);
      else goto rst_msg;
   }
   else if(tsip_sync == 3) {  // end of message
      nmea_end:
      if(nmea_fmt == 0) ;  // t-cmd or error message
      else if(strstr((char *) &tsip_buf[0], "PRCCG,A")) ;  // rcvr sends wrong checksum!
      else if(nmea_fmt && (tsip_sync == 2) && (nmea_vfy_cksum != nmea_msg_cksum)) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }

      decode_brandy_msg(); // message checksum matches, process the message
      packet_end = 1;
      tsip_wptr = 0;       // prepare for next message
      tsip_sync = 0;
      venus_nmea = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      nmea_vfy_cksum = nmea_msg_cksum = 0; // init received message checksum
      venus_nmea = 0;
   }
}



//
//
//   Spectratime SRO100 receiver stuff  (Rubidium oscillator)
//
//

void poll_next_sro()
{
int test;

   // request an item from a SRO100 rubidium.  Requests are alternated between
   // a time message and some device parameter.  The parameter requests are 
   // alternated between one of three important parameters and then the lesser
   // important ones.

   test = 0;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else if(1) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
      }
      else {  // poll standard messages 
      if(polled_req < 0) polled_req = 0;

         if(0 && prs_poll_tick) {
            if(prs_poll_tick == 1) {       // get FC value every two seconds
               send_polled_cmd("FC?", PRS_FC_MSG);
               ++prs_poll_tick;
            }
            else if(prs_poll_tick == 2) {  // get TT value every two seconds
               send_polled_cmd("TT?", PRS_TT_MSG);
               ++prs_poll_tick;
            }
            else {  // get case temperature value every two seconds
               send_polled_cmd("AD10?", PRS_AD10_MSG);
               prs_poll_tick = 0;
            }
         }
         else {
            if     (polled_req == 0)   send_polled_cmd("M",         SRO_M_MSG); 
            else if(polled_req == 1)   send_polled_cmd("ID",        SRO_ID_MSG); 
            else if(polled_req == 2)   send_polled_cmd("SN",        SRO_SN_MSG); 
            else if(polled_req == 3)   send_polled_cmd("ST",        SRO_ST_MSG); 
            else if(polled_req == 4)   send_polled_cmd("TR?",       SRO_TR_MSG); 
            else if(polled_req == 5)   send_polled_cmd("SY?",       SRO_SY_MSG); 
            else if(polled_req == 6)   send_polled_cmd("DE???????", SRO_DE_MSG); 
            else if(polled_req == 7)   send_polled_cmd("PW???????", SRO_PW_MSG); 
            else if(polled_req == 8)   send_polled_cmd("FC??????",  SRO_FC_MSG); 
            else if(polled_req == 9)   send_polled_cmd("FS?",       SRO_FS_MSG); 
            else if(polled_req == 10)  send_polled_cmd("TW???",     SRO_TW_MSG); 
            else if(polled_req == 11)  send_polled_cmd("AW???",     SRO_AW_MSG); 
            else if(polled_req == 12)  send_polled_cmd("TC??????",  SRO_TC_MSG); 
            else if(polled_req == 13)  send_polled_cmd("CO????",    SRO_CO_MSG); 
            else if(polled_req == 14)  send_polled_cmd("VS",        SRO_VS_MSG); 
            else if(polled_req == 15)  send_polled_cmd("VT",        SRO_VT_MSG); 
            else if(polled_req == 16)  send_polled_cmd("RA????",    SRO_RA_MSG); 
            else if(polled_req == 17)  send_polled_cmd("GF?????",   SRO_GF_MSG); 
            else if(polled_req == 18)  send_polled_cmd("R4F",       SRO_R4F_MSG); 
            else if(polled_req == 19)  send_polled_cmd("R48",       SRO_R48_MSG); 
            else if(polled_req == 20)  send_polled_cmd("R49",       SRO_R49_MSG); 

            else if(polled_req == 21)  send_polled_cmd("R14",       SRO_R14_MSG); 
            else if(polled_req == 22)  send_polled_cmd("R15",       SRO_R15_MSG); 
            else if(polled_req == 23)  send_polled_cmd("R05",       SRO_R05_MSG); 
            else if(polled_req == 24)  send_polled_cmd("R06",       SRO_R06_MSG); 
            else if(polled_req == 25)  send_polled_cmd("L05",       SRO_L05_MSG); 
            else if(polled_req == 26)  send_polled_cmd("L06",       SRO_L06_MSG); 

            if(++polled_req > 22) {
               polled_req = 0;
               ++all_polled;
               if(all_polled == 1) {  // reset the queues the first time through
                  new_queue(RESET_ALL_QUEUES, 4598);
               }
            }
         }
         ++polled_seq;
      }
   }
}

int valid_sro_status()
{
int hh;
int gg;
int ff;
int ee;
int dd;
int cc;
int bb;
int aa;
int i;

   // return true if nmea_msg scans 8 hex values

   i = sscanf(nmea_msg, "%x %x %x %x %x %x %x %x", &hh,&gg,&ff,&ee,&dd,&cc,&bb,&aa);
   if(i != 8) {  // expected 8 values.  Loss of message sync?
      return 0;
   }

   return 1;
}

void parse_sro_m()
{
int hh;   // efc input
int gg;   // reserved
int ff;   // Rb signal peak voltage
int ee;   // photocell voltage
int dd;   // varactor voltage
int cc;   // heater current
int bb;   // cell current
int aa;   // not used
int i;

   log_packet_id("readings");
   i = sscanf(nmea_msg, "%x %x %x %x %x %x %x %x", &hh,&gg,&ff,&ee,&dd,&cc,&bb,&aa);
   if(i != 8) {  // expected 8 values.  Loss of message sync?
      restart_prs_polling();
      return;
   }

   sro_hh = ((double) hh) / 255.0 * 5.0;
   sro_gg = (double) gg;
   sro_ff = ((double) ff) / 255.0 * 5.0;
   sro_ee = ((double) (255-ee)) / 255.0 * 5.0;
   sro_dd = ((double) dd) / 255.0 * 5.0;
   sro_cc = ((double) (255-cc)) / 255.0 * 100.0;
   sro_bb = ((double) (255-bb)) / 255.0 * 100.0;
   sro_aa = (double) aa;
}

void parse_sro_id()
{
   log_packet_id("id info");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   nmea_msg[21] = 0;
   strcpy(sro_id, nmea_msg);
   if(all_polled) have_info |= (VERSION_INFO | PRODN_PARAMS);
}

void parse_sro_sn()
{
   log_packet_id("serial number");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   nmea_msg[18] = 0;
   strcpy(sro_sn, nmea_msg);
   if(all_polled) have_info |= (MANUF_PARAMS | PRODN_PARAMS);
}

void parse_sro_st()
{
   log_packet_id("status");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_status= atoi(nmea_msg);
   discipline_mode = DIS_MODE_NORMAL;
   if     (sro_status == 0) discipline_mode = DIS_MODE_WARMUP;
   else if(sro_status == 1) discipline_mode = DIS_MODE_LEARNING;
   else if(sro_status == 9) discipline_mode = DIS_MODE_FAILED;
}

void parse_sro_tr()
{
   log_packet_id("tr value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_tr = atoi(nmea_msg);
}

void parse_sro_sy()
{
   log_packet_id("sy value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_sy = atoi(nmea_msg);
}

void parse_sro_de()
{
   log_packet_id("de value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_de = atoi(nmea_msg);
}

void parse_sro_pw()
{
   log_packet_id("pps enable");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_pw = atoi(nmea_msg);
   if(sro_pw) pps_enabled = 1;
   else       pps_enabled = 0;
}

void parse_sro_fc()
{
   log_packet_id("freq control value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_fc = atoi(nmea_msg);
   osc_offset = ((double)sro_fc)*SRO_DDS_STEP*1.0E12/1000.0;
   have_osc_offset = 77;
}

void parse_sro_fs()
{
   log_packet_id("fs value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_fs = atoi(nmea_msg);
}

void parse_sro_tw()
{
   log_packet_id("tw value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_tw = atoi(nmea_msg);
}

void parse_sro_aw()
{
   log_packet_id("aw value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_aw = atoi(nmea_msg);
}

void parse_sro_tc()
{
   log_packet_id("time constant");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_tc = atoi(nmea_msg);
   time_constant = (DATA_SIZE) sro_tc;
   have_osc_params |= PARAM_TC;
}

void parse_sro_co()
{
   log_packet_id("co value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_co = atoi(nmea_msg);
}

void parse_sro_vt()
{
   log_packet_id("vt value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_vt = atoi(nmea_msg);
}

void parse_sro_vs()
{
   log_packet_id("pps offset");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_vs = atof(nmea_msg);
   pps_offset = sro_vs;
   have_pps_offset = 77;
}

void parse_sro_ra()
{
   log_packet_id("ra value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_ra = atoi(nmea_msg);
}

void parse_sro_gf()
{
   log_packet_id("gofast value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_gf = atoi(nmea_msg);
}


void parse_sro_l05()
{
   log_packet_id("fc high byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_l05 = atohex(nmea_msg);
}

void parse_sro_l06()
{
int i;

   log_packet_id("fc low byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_l06 = atohex(nmea_msg);
   i = (sro_l05 * 256) + sro_l06;
   if(sro_l05 & 0x80) i = 32767-i;
   sro_poweron_fc = SRO_DDS_STEP * (double) i;
//sprintf(debug_text2, "pwronr_fc:%g %g  l05:%02X  l06:%02x", (double)sro_poweron_fc*SRO_DDS_STEP, sro_poweron_fc, sro_l05,sro_l06);
}

void parse_sro_r05()
{
   log_packet_id("user fc high byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r05 = atohex(nmea_msg);
}

void parse_sro_r06()
{
int i;

   log_packet_id("user fc low byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r06 = atohex(nmea_msg);
   i = (sro_r05 * 256) + sro_r06;
   if(sro_r05 & 0x80) i = 32767-i;
   sro_user_fc = SRO_DDS_STEP * (double) i;
//sprintf(debug_text2, "user_fc:%g %g  r14:%02X  r15:%02x", (double)sro_user_fc*SRO_DDS_STEP, sro_user_fc, sro_r05,sro_r06);
}

void parse_sro_r14()
{
   log_packet_id("freq limit high byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r14 = atohex(nmea_msg);
}

void parse_sro_r15()
{
int i;

   log_packet_id("freq limit low byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r15 = atohex(nmea_msg);
   i = (sro_r14 * 256) + sro_r15;
   if(sro_r14 & 0x80) i = 32767-i;
   sro_freq_lim = SRO_DDS_STEP * (double) i;
//sprintf(debug_text, "freq lim:%g  r14:%02X  r15:%02x", sro_freq_lim, sro_r14,sro_r15);
}

void parse_sro_r48()
{
   log_packet_id("countdown high byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r48 = atohex(nmea_msg);
}

void parse_sro_r49()
{
int i;

   log_packet_id("countdown low byte");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r49 = atohex(nmea_msg);

   i = (sro_r48 * 256) + sro_r49;
   sro_countdown = i;
}

void parse_sro_r4F()
{
   log_packet_id("4F value");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   sro_r4F = atohex(nmea_msg);
}

void parse_sro_td()
{
   log_packet_id("time");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
}

void parse_sro_dt()
{
   log_packet_id("date");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
}

void parse_sro_raquik()
{
   log_packet_id("raquick");
   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
}

void sro_eeprom()
{
   // do warning beep for commands that write eeprom

   BEEP(504);
}


void set_sro_tc(int secs)
{
   if(read_only) return;

   if(secs < 0) secs = 0;
   if(secs > 999999) secs = 999999;
   sprintf(out, "TC%06d", secs);
   queue_sro_cmd(out, SRO_TC_MSG);
   sro_eeprom();
}

void set_sro_sy(int mode)
{
   if(read_only) return;

   if(mode < 0) mode = 0;
   if(mode > 3) mode = 1;
   sprintf(out, "SY%d", mode);
   queue_sro_cmd(out, SRO_SY_MSG);
   sro_eeprom();
}

void set_sro_tr(int mode)
{
   if(read_only) return;

   if(mode < 0) mode = 0;
   if(mode > 3) mode = 1;
   sprintf(out, "TR%d", mode);
   queue_sro_cmd(out, SRO_TR_MSG);
   sro_eeprom();
}

void set_sro_fs(int mode)
{
   if(read_only) return;

   if(mode < 0) mode = 0;
   if(mode > 3) mode = 1;
   sprintf(out, "FS%d", mode);
   queue_sro_cmd(out, SRO_FS_MSG);
   queue_sro_cmd("L05", SRO_L05_MSG); 
   queue_sro_cmd("L06", SRO_L06_MSG); 
   sro_eeprom();
}

void set_sro_gf(int secs)
{
   if(read_only) return;

   if(secs < 0) secs = 0;
   if(secs > 65535) secs = 65535;
   sprintf(out, "GF%05d", secs);
   queue_sro_cmd(out, SRO_GF_MSG);
   sro_eeprom();
}

void set_sro_width(double usecs)
{
int val;

   if(read_only) return;

   if(usecs < 0.0) usecs = 0.0 - usecs;
   usecs *= 1000.0;
   usecs += (SRO_TICK / 2.0);
   val = (int) (usecs / SRO_TICK);
   if(val > 7499999) val = 7499999;
   sprintf(out, "PW%07d", val);
   queue_sro_cmd(out, SRO_PW_MSG);
   sro_eeprom();
}

void set_sro_delay(double nsecs)
{
int val;

   if(read_only) return;

   if(nsecs < 0.0) nsecs = 0.0 - nsecs;
   nsecs += (SRO_TICK / 2.0);
   val = (int) (nsecs / SRO_TICK);
   if(val > 255) val = 255;
   sprintf(out, "DE%07d", val);
   queue_sro_cmd(out, SRO_DE_MSG);
   sro_eeprom();
}

void set_sro_raw(double nsecs)
{
int val;

   if(read_only) return;

   val = (int) (nsecs / SRO_TICK);
   if(val > 127) val = 127;
   if(val < -128) val = -128;
   if(val < 0) sprintf(out, "RA%04d", val);
   else        sprintf(out, "RA+%03d", val);
   queue_sro_cmd(out, SRO_RA_MSG);
   sro_eeprom();
}

void set_sro_co(double nsecs)
{
int val;

   if(read_only) return;

   val = (int) (nsecs);
   if(val > 127) val = 127;
   if(val < -128) val = -128;
   if(val < 0) sprintf(out, "CO%04d", val);
   else        sprintf(out, "CO+%03d", val);
   queue_sro_cmd(out, SRO_CO_MSG);
   sro_eeprom();
}

void set_sro_fc(double ppb)
{
int val;

   if(read_only) return;

   val = (int) ((ppb*1.0E-12) / SRO_DDS_STEP);
   if(val > 32767) val = 32767;
   if(val < -32768) val = -32768;
   if(val < 0) sprintf(out, "FC%06d", val);
   else        sprintf(out, "FC+%05d", val);
   queue_sro_cmd(out, SRO_FC_MSG);
   queue_sro_cmd("L05", SRO_L05_MSG); 
   queue_sro_cmd("L06", SRO_L06_MSG); 
   sro_eeprom();
}

void set_sro_alarm_window(double nsecs)
{
int val;

   if(read_only) return;

   if(nsecs < 0.0) nsecs = 0.0 - nsecs;
   nsecs += (SRO_TICK / 2.0);
   val = (int) (nsecs / SRO_TICK);
   if(val > 7499999) val = 7499999;
   sprintf(out, "AW%03d", val);
   queue_sro_cmd(out, SRO_AW_MSG);
   sro_eeprom();
}

void set_sro_track_window(double nsecs)
{
int val;

   if(read_only) return;

   if(nsecs < 0.0) nsecs = 0.0 - nsecs;
   nsecs += (SRO_TICK / 2.0);
   val = (int) (nsecs / SRO_TICK);
   if(val > 255) val = 255;
   sprintf(out, "TW%03d", val);
   queue_sro_cmd(out, SRO_TW_MSG);
   sro_eeprom();
}

void set_sro_clock()
{

   if(read_only) return;

   sprintf(out, "DT%04d-%02d-%02d", pri_year,pri_month,pri_day);
   queue_sro_cmd(out, SRO_DT_MSG);

   sprintf(out, "TD%02d:%02d:%02d", pri_hours,pri_minutes,pri_seconds);
   queue_sro_cmd(out, SRO_TD_MSG);
   sro_eeprom();
}


void decode_sro_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }
   msg_col = 0;     // index of next char to get from nmea buffer

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %d:[%s]\n", polled_msg_id, nmea_msg);
//sprintf(debug_text, "Decode msg %d:[%s]", polled_msg_id, nmea_msg);


   sro_msg_id = polled_msg_id;
   if     (strstr(nmea_msg,  "TNTSRO")) parse_sro_id();
   else if(strstr(nmea_msg,  "RESET")) sro_msg_id = 0;
   else if(strstr(nmea_msg,  "TNT")) sro_msg_id = 0;
   else if(strstr(nmea_msg,  "?")) {
      sro_msg_id = 0;
   }

   else if(sro_msg_id == SRO_M_MSG)      parse_sro_m();
   else if(sro_msg_id == SRO_ID_MSG)     parse_sro_id();
   else if(sro_msg_id == SRO_SN_MSG)     parse_sro_sn();
   else if(sro_msg_id == SRO_ST_MSG)     parse_sro_st();
   else if(sro_msg_id == SRO_TR_MSG)     parse_sro_tr();
   else if(sro_msg_id == SRO_SY_MSG)     parse_sro_sy();
   else if(sro_msg_id == SRO_DE_MSG)     parse_sro_de();
   else if(sro_msg_id == SRO_PW_MSG)     parse_sro_pw();
   else if(sro_msg_id == SRO_FC_MSG)     parse_sro_fc();
   else if(sro_msg_id == SRO_FS_MSG)     parse_sro_fs();
   else if(sro_msg_id == SRO_TW_MSG)     parse_sro_tw();
   else if(sro_msg_id == SRO_AW_MSG)     parse_sro_aw();
   else if(sro_msg_id == SRO_TC_MSG)     parse_sro_tc();
   else if(sro_msg_id == SRO_VS_MSG)     parse_sro_vs();
   else if(sro_msg_id == SRO_VT_MSG)     parse_sro_vt();
   else if(sro_msg_id == SRO_GF_MSG)     parse_sro_gf();
   else if(sro_msg_id == SRO_RA_MSG)     parse_sro_ra();

   else if(sro_msg_id == SRO_L05_MSG)    parse_sro_l05();
   else if(sro_msg_id == SRO_L06_MSG)    parse_sro_l06();
   else if(sro_msg_id == SRO_R05_MSG)    parse_sro_r05();
   else if(sro_msg_id == SRO_R06_MSG)    parse_sro_r06();
   else if(sro_msg_id == SRO_R14_MSG)    parse_sro_r14();
   else if(sro_msg_id == SRO_R15_MSG)    parse_sro_r15();
   else if(sro_msg_id == SRO_R48_MSG)    parse_sro_r48();
   else if(sro_msg_id == SRO_R49_MSG)    parse_sro_r49();
   else if(sro_msg_id == SRO_R4F_MSG)    parse_sro_r4F();

   else if(sro_msg_id == SRO_TD_MSG)     parse_sro_td();
   else if(sro_msg_id == SRO_DT_MSG)     parse_sro_dt();
   else if(sro_msg_id == SRO_RAQUIK_MSG) parse_sro_raquik();

   else if(sro_msg_id == SCPI_USER_MSG)     parse_scpi_user();
   else if(sro_msg_id == (0-SCPI_USER_MSG)) parse_scpi_user();

   i = get_norcvr_message();   // returns true if seconds just ticked
///   if(SLOW_PRS_POLL && (seconds & 0x01));  // enable this to trigger high priority message polls every seoncd
                                              // ... but this slows polling loop cycle to around 1 minute
///   else if(i && (prs_poll_tick == 0)) prs_poll_tick = 1;  // trigger high priority message polls
   poll_next_sro();

   sro_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
}



//
//
//   Symmetricom SA35 receiver stuff (rubidium)
//
//

void parse_sa35_telem()
{
   log_packet_id("telemetry");
   have_sa35_telem = 35;

   if(get_msg_field()) {  // BITE (0=locked  1=unlocked)
      sa35_unlock = atoi(msg_field);
      if(sa35_unlock) discipline_mode = DIS_MODE_UNLOCK;
      else            discipline_mode = DIS_MODE_NORMAL;
   }

   if(get_msg_field()) {  // firmware
      msg_field[32] = 0;
      strcpy(sa35_fw, msg_field);
   }

   if(get_msg_field()) {  // serial number
      msg_field[32] = 0;
      strcpy(sa35_id, msg_field);
      strcpy(sa35_sn, &msg_field[6]);
      msg_field[6] = 0;

      strcpy(sa35_model, &msg_field[4]);
      msg_field[4] = 0;

      strcpy(sa35_date, &msg_field[0]);
      have_info |= ALL_ID_INFO;
   }

   if(get_msg_field()) { // TEC control (millidegrees C)
      sa35_tec = atof(msg_field) / 1000.0;
   }

   if(get_msg_field()) { // rf control  (0.1 mV)
      sa35_rf = atof(msg_field) / 10000.0;
   }

   if(get_msg_field()) { // DDS freq center current (0.01 Hz)
      sa35_center_freq = atof(msg_field) / 0.01;
   }

   if(get_msg_field()) { // cell heater current (mA)
      sa35_heater = atof(msg_field);
   }

   if(get_msg_field()) { // dc signal (mV)
      sa35_dc = atof(msg_field) / 1000.0;
   }

   if(get_msg_field()) { // temperature (millidegrees C)
      temperature = (DATA_SIZE) (atof(msg_field) / 1000.0);
      have_temperature = 35;
   }

   if(get_msg_field()) { // digital tuning (0.01 Hz)
      sa35_tune = atof(msg_field) / 0.01;
   }

   if(get_msg_field()) { // EFC enable
      sa35_efc_enable = atoi(msg_field);
   }

   if(get_msg_field()) { // EFC voltage (mV)
      sa35_efc = atof(msg_field) / 1000.0;
      dac_voltage = (DATA_SIZE) sa35_efc;
      have_dac = 35;
   }

   if(get_msg_field()) { // digital tuning (1E-15)
      sa35_dds = atof(msg_field) * 1.0E-15;
   }
}

void set_sa35_freq(double freq)
{
double val;

   // !!!!! placeholder

   if(read_only) return;

   if(freq > 2.00E-8) freq = 2.00E-8;
   if(freq < -2.00E-8) freq = -2.00E-8;

   val = freq / 1.0E-15;
   sprintf(out, "<FG%d>", (int) val);
   queue_sa35_cmd(out, SA35_DDS_CMD);

   BEEP(505);  // signal EEPROM write  piss3
}

void set_sa35_efc(int mode)
{
   if(mode == 0) queue_sa35_cmd("<NX0>", SA35_EFC_CMD);  // disable
   else          queue_sa35_cmd("<NX0>", SA35_EFC_CMD);  // enable
}


void poll_next_sa35()
{
int test;

   // !!!!! placeholder
   test = 0;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
      if(no_response_msg) {  // last message sends no response
         no_response_msg = 0;
         send_polled_cmd("^", SA35_TELEM_CMD); 
      }
   }
   else if(1) { // request next misc message every time
      send_polled_cmd("^", SA35_TELEM_CMD);
   }
}

void decode_sa35_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }
   msg_col = 0;     // index of next char to get from nmea buffer

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %d:[%s]\n", polled_msg_id, nmea_msg);
//sprintf(debug_text, "Decode msg %d:[%s]", polled_msg_id, nmea_msg);


   sa35_msg_id = polled_msg_id;

   // !!!!! decode here

   i = get_norcvr_message();   // returns true if seconds just ticked
   poll_next_sa35();

   sa35_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
}


//
//
//   Spectratimee LPFRS receiver stuff (rubidium)
//
//


void parse_lpfrs_m()
{
int hh;   // photocell voltage
int gg;   // Rb signal peak voltage
int ff;   // reserved
int ee;   // varactor voltage
int dd;   // EFC input voltage
int cc;   // lamp current
int bb;   // cell current
int aa;   // 90 MHz agc voltage
int i;

   log_packet_id("paramters");

   i = sscanf(nmea_msg, "%x %x %x %x %x %x %x %x", &hh,&gg,&ff,&ee,&dd,&cc,&bb,&aa);
   if(i != 8) {  // expected 8 values.  Loss of message sync?
      restart_prs_polling();
      return;
   }

   lpfrs_hh = ((double) (255-hh)) / 255.0 * 5.0;
   lpfrs_gg = ((double) gg) / 255.0 * 5.0;
   lpfrs_ff = ((double) ff);
   lpfrs_ee = ((double) ee) / 255.0 * 5.0;
   lpfrs_dd = ((double) dd) / 255.0 * 5.0;
   lpfrs_cc = ((double) (255-cc)) / 255.0 * 500.0;  // ma
   lpfrs_bb = ((double) (255-bb)) / 255.0 * 500.0;  // ma
   lpfrs_aa = ((double) gg) / 255.0 * 5.0;
}

void parse_lpfrs_id()
{
   log_packet_id("id info");

   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   nmea_msg[14] = 0;
   strcpy(lpfrs_id, nmea_msg);

   nmea_msg[36] = 0;
   strcpy(lpfrs_fw, &nmea_msg[16]);

   nmea_msg[57] = 0;
   strcpy(lpfrs_ck, &nmea_msg[37]);

   if(lpfrs_id[0] && lpfrs_fw[0] && lpfrs_ck[0]) have_info |= (ALL_ID_INFO);
}

void parse_lpfrs_c_read()
{
   log_packet_id("coarse tune word");

   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
   lpfrs_c_rval = atohex(nmea_msg);
   lpfrs_c_rval &= 0xFF;
}

void parse_lpfrs_f_read()
{
int i, j;

   log_packet_id("fine tune word");

   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }

   lpfrs_f_rval = atohex(nmea_msg);
   lpfrs_f_rval &= 0xFF;

   if(lpfrs_c_rval & 0x80) i = lpfrs_c_rval - 256;
   else                    i = lpfrs_c_rval;

   if(lpfrs_f_rval & 0x80) j = lpfrs_f_rval - 256;
   else                    j = lpfrs_f_rval;

   lpfrs_freq = 1.0E-9 * (double) i;
   lpfrs_freq += (1.0E-11 * (double) j);

   osc_offset = lpfrs_freq * 1.0E9;
   have_osc_offset = 78;
//sprintf(debug_text, "fread i:%d j:%d freq:%g ofs:%g", i,j,lpfrs_freq,osc_offset);
}

void parse_lpfrs_c_write()
{
   log_packet_id("coarse tune write");

   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
}

void parse_lpfrs_f_write()
{
   log_packet_id("fine tune write");

   if(valid_sro_status()) {
      restart_prs_polling();
      return;
   }
}

void set_lpfrs_freq(double freq)
{
int high, low;
double val;

   if(read_only) return;

   if(freq > 1.27E-7) freq = 1.27E-7;
   if(freq < -1.28E-7) freq = -1.28E-7;

   high = (int) (freq / 1.0E-9);
   val = freq - ((double) high * 1.0E-9);
   low = (int) (val / 1.0E-11);

   sprintf(out, "C%02X", high & 0xFF);
   queue_lpfrs_cmd(out, LPFRS_C_WRITE_MSG);
   sprintf(out, "F%02X", low & 0xFF);
   queue_lpfrs_cmd(out, LPFRS_F_WRITE_MSG);

   BEEP(505);  // signal EEPROM write
//sprintf(debug_text2, "set freq %g:  val:%g  high:%d low:%d", freq,val,high,low);
}


void poll_next_lpfrs()
{
int test;

   // request an item from a LPFRS rubidium.  Requests are alternated between
   // a time message and some device parameter.  The parameter requests are 
   // alternated between one of three important parameters and then the lesser
   // important ones.

   test = 0;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
      if(no_response_msg) {  // last message sends no response
         no_response_msg = 0;
         send_polled_cmd("M", LPFRS_M_MSG); 
      }
   }
   else if(1) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
         if(no_response_msg) {  // last message sends no response
            no_response_msg = 0;
            send_polled_cmd("M", LPFRS_M_MSG); 
         }
      }
      else {  // poll standard messages 
      if(polled_req < 0) polled_req = 0;
         if     (polled_req == 0) send_polled_cmd("M",   LPFRS_M_MSG); 
         else if(polled_req == 1) send_polled_cmd("L06", LPFRS_C_READ_MSG); 
         else if(polled_req == 2) send_polled_cmd("L0A", LPFRS_F_READ_MSG); 
//       else if(polled_req == 3) send_polled_cmd("V",   LPFRS_ID_MSG);  // takes too long a time to send

         if(++polled_req > 2) {
            polled_req = 0;
            ++all_polled;
            if(all_polled == 1) {  // reset the queues the first time through
               new_queue(RESET_ALL_QUEUES, 4598);
            }
         }

         if(no_response_msg) {  // last message sends no response
            no_response_msg = 0;
            send_polled_cmd("M", LPFRS_M_MSG); 
         }
         ++polled_seq;
      }
   }
}

void decode_lpfrs_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }
   msg_col = 0;     // index of next char to get from nmea buffer

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %d:[%s]\n", polled_msg_id, nmea_msg);
//sprintf(debug_text, "Decode msg %d:[%s]", polled_msg_id, nmea_msg);


   lpfrs_msg_id = polled_msg_id;
   if     (strstr(nmea_msg,  "TNT")) parse_lpfrs_id();
   else if(strstr(nmea_msg,  "RESET")) sro_msg_id = 0;
   else if(strstr(nmea_msg,  "TNT")) sro_msg_id = 0;
   else if(strstr(nmea_msg,  "?")) {
      lpfrs_msg_id = 0;
   }

   else if(lpfrs_msg_id == LPFRS_M_MSG)       parse_lpfrs_m();
   else if(lpfrs_msg_id == LPFRS_ID_MSG)      parse_lpfrs_id();
   else if(lpfrs_msg_id == LPFRS_C_READ_MSG)  parse_lpfrs_c_read();
   else if(lpfrs_msg_id == LPFRS_F_READ_MSG)  parse_lpfrs_f_read();
   else if(lpfrs_msg_id == LPFRS_C_WRITE_MSG) parse_lpfrs_c_write();
   else if(lpfrs_msg_id == LPFRS_F_WRITE_MSG) parse_lpfrs_f_write();

   else if(lpfrs_msg_id == SCPI_USER_MSG)     parse_scpi_user();
   else if(lpfrs_msg_id == (0-SCPI_USER_MSG)) parse_scpi_user();

   i = get_norcvr_message();   // returns true if seconds just ticked
///   if(SLOW_PRS_POLL && (seconds & 0x01));  // enable this to trigger high priority message polls every seoncd
                                              // ... but this slows polling loop cycle to around 1 minute
///   else if(i && (prs_poll_tick == 0)) prs_poll_tick = 1;  // trigger high priority message polls
   poll_next_lpfrs();

   lpfrs_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
}


//
//
//   SRS PRS-10 receiver stuff
//
//
                         // 0=request high priority messages every second (all messages polled in 55 seconds)

void poll_next_prs()
{
int test;

   // request an item from a PRS10 rubidium.  Requests are alternated between
   // a time message and some device parameter.  The parameter requests are 
   // alternated between one of three important parameters and then the lesser
   // important ones.

   test = 0;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else if(1) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
      }
      else {  // poll standard messages 
      if(polled_req < 0) polled_req = 0;

         if(0 && ((polled_seq % 8) == 0)) {       // get FC value every two seconds
            send_polled_cmd("FC?", PRS_FC_MSG);
         }
         else if(0 && ((polled_seq % 8) == 1)) {  // get TT value every two seconds
            send_polled_cmd("TT?", PRS_TT_MSG);
         }
         else if(0 && ((polled_seq % 8) == 2)) {  // get case temperature value every two seconds
            send_polled_cmd("AD10?", PRS_AD10_MSG);
         }
         else if(1 && prs_poll_tick) {
            if(prs_poll_tick == 1) {       // get FC value every two seconds
               send_polled_cmd("FC?", PRS_FC_MSG);
               ++prs_poll_tick;
            }
            else if(prs_poll_tick == 2) {  // get TT value every two seconds
               send_polled_cmd("TT?", PRS_TT_MSG);
               ++prs_poll_tick;
            }
            else {  // get case temperature value every two seconds
               send_polled_cmd("AD10?", PRS_AD10_MSG);
               prs_poll_tick = 0;
            }
         }
         else {
            // 52 message cycle repeats every 12 seconds -> 4.33 messages per second with PRS_SLEEP == 0
            // 52 message cycle repeats every 13 seconds -> 4.00 messages per second with PRS_SLEEP == 100

            if     (polled_req == 0)  send_polled_cmd("ID?",   PRS_ID_MSG);  // we get serial number from here, not from SN?
            else if(polled_req == 1)  send_polled_cmd("EP?",   PRS_EP_MSG);  // enable power
            else if(polled_req == 2)  send_polled_cmd("VB?",   PRS_VB_MSG);
            else if(polled_req == 3)  send_polled_cmd("ST?",   PRS_ST_MSG);
            else if(polled_req == 4)  send_polled_cmd("LM?",   PRS_LM_MSG);
            else if(polled_req == 5)  send_polled_cmd("LO?",   PRS_LO_MSG);
            else if(polled_req == 6)  send_polled_cmd("FC?",   PRS_FC_MSG);
            else if(polled_req == 7)  send_polled_cmd("DS?",   PRS_DS_MSG);
            else if(polled_req == 8)  send_polled_cmd("SF?",   PRS_SF_MSG);
            else if(polled_req == 9)  send_polled_cmd("SS?",   PRS_SS_MSG);
            else if(polled_req == 10) send_polled_cmd("GA?",   PRS_GA_MSG);
            else if(polled_req == 11) send_polled_cmd("PH?",   PRS_PH_MSG);
            else if(polled_req == 12) send_polled_cmd("SP?",   PRS_SP_MSG);
            else if(polled_req == 13) send_polled_cmd("MS?",   PRS_MS_MSG);
            else if(polled_req == 14) send_polled_cmd("MO?",   PRS_MO_MSG);
            else if(polled_req == 15) send_polled_cmd("MR?",   PRS_MR_MSG);
            else if(polled_req == 16) send_polled_cmd("FC!?",  PRS_FC2_MSG);  // was TT?
            else if(polled_req == 17) send_polled_cmd("TS?",   PRS_TS_MSG);
            else if(polled_req == 18) send_polled_cmd("TO?",   PRS_TO_MSG);
            else if(polled_req == 19) send_polled_cmd("PL?",   PRS_PL_MSG);
            else if(polled_req == 20) send_polled_cmd("PT?",   PRS_PT_MSG);
            else if(polled_req == 21) send_polled_cmd("PF?",   PRS_PF_MSG);
            else if(polled_req == 22) send_polled_cmd("PI?",   PRS_PI_MSG);

            else if(polled_req == 23) send_polled_cmd("SD0?",  PRS_SD0_MSG);
            else if(polled_req == 24) send_polled_cmd("SD1?",  PRS_SD1_MSG);
            else if(polled_req == 25) send_polled_cmd("SD2?",  PRS_SD2_MSG);
            else if(polled_req == 26) send_polled_cmd("SD3?",  PRS_SD3_MSG);
            else if(polled_req == 27) send_polled_cmd("SD4?",  PRS_SD4_MSG);
            else if(polled_req == 28) send_polled_cmd("SD5?",  PRS_SD5_MSG);
            else if(polled_req == 29) send_polled_cmd("SD6?",  PRS_SD6_MSG);
            else if(polled_req == 30) send_polled_cmd("SD7?",  PRS_SD7_MSG);

            else if(polled_req == 31) send_polled_cmd("AD0?",  PRS_AD0_MSG);
            else if(polled_req == 32) send_polled_cmd("AD1?",  PRS_AD1_MSG);
            else if(polled_req == 33) send_polled_cmd("AD2?",  PRS_AD2_MSG);
            else if(polled_req == 34) send_polled_cmd("AD3?",  PRS_AD3_MSG);
            else if(polled_req == 35) send_polled_cmd("AD4?",  PRS_AD4_MSG);
            else if(polled_req == 36) send_polled_cmd("AD5?",  PRS_AD5_MSG);
            else if(polled_req == 37) send_polled_cmd("AD6?",  PRS_AD6_MSG);
            else if(polled_req == 38) send_polled_cmd("AD7?",  PRS_AD7_MSG);
            else if(polled_req == 39) send_polled_cmd("AD8?",  PRS_AD8_MSG);
            else if(polled_req == 40) send_polled_cmd("AD9?",  PRS_AD9_MSG);
            else if(polled_req == 41) send_polled_cmd("AD10?", PRS_AD10_MSG);  // case temp
            else if(polled_req == 42) send_polled_cmd("AD11?", PRS_AD11_MSG);
            else if(polled_req == 43) send_polled_cmd("AD12?", PRS_AD12_MSG);
            else if(polled_req == 44) send_polled_cmd("AD13?", PRS_AD13_MSG);
            else if(polled_req == 45) send_polled_cmd("AD14?", PRS_AD14_MSG);
            else if(polled_req == 46) send_polled_cmd("AD15?", PRS_AD15_MSG);
            else if(polled_req == 47) send_polled_cmd("AD16?", PRS_AD16_MSG);
            else if(polled_req == 48) send_polled_cmd("AD17?", PRS_AD17_MSG);
            else if(polled_req == 49) send_polled_cmd("AD18?", PRS_AD18_MSG);
            else if(polled_req == 50) send_polled_cmd("AD19?", PRS_AD19_MSG);

            else if(polled_req == 51) send_polled_cmd("PS?",   PRS_PS_MSG);

            if(++polled_req > 51) {
               polled_req = 0;
               ++all_polled;
               if(all_polled == 1) {  // reset the queues the first time through
                  new_queue(RESET_ALL_QUEUES, 4598);
               }
            }
         }
         ++polled_seq;
      }
   }
}




void parse_prs_xx()
{
   // null messages
}

void parse_prs_id()
{
char *s;
   
   log_packet_id("");
   log_packet_id("id info");
   prs_fw[0] = 0;
   prs_sn[0] = 0;

   s = strstr(nmea_msg, "_SN_");
   if(s == 0) return;

   *s = 0;
   strcpy(prs_fw, nmea_msg);

   if(s[1]) strcpy(prs_sn, s+1);
   if(all_polled) have_info |= ALL_ID_INFO;
}

void parse_prs_st()
{
int i;

   // status
   log_packet_id("status");

   for(i=0; i<6; i++) {
      if(get_msg_field()) {
         prs_st[i] = atoi(msg_field);
         have_prs_st |= (1 << i);

         if(prs_st[0] & 0x0F) critical_alarms |= CRIT_PWR;
         else                 critical_alarms &= (~CRIT_PWR);

         if(prs_st[3] & 0x0C) critical_alarms |= CRIT_OCXO;
         else                 critical_alarms &= (~CRIT_OCXO);

         if(prs_st[5] & 0x06) critical_alarms |= CRIT_FPGA;  // bad interrupt or watchdog
         else                 critical_alarms &= (~CRIT_FPGA);
//       have_critical_alarms = 1;

         if(prs_st[5] & 0x18) minor_alarms |= MINOR_EEPROM;
         else                 minor_alarms &= (~MINOR_EEPROM);
         have_eeprom = 1;
      }
      else ++bad_prs_val;
   }
}

void parse_prs_lm()
{
   // lock mode
   log_packet_id("lock mode");

   if(get_msg_field()) {
      prs_lm = atoi(msg_field);
      have_prs_lm = 1;
      if(prs_lm & 0x0C) pps_enabled = 0;
      else pps_enabled = 1;
      have_pps_enable = 1;

      if(prs_lm == 3) pps_polarity = 1;
      else            pps_polarity = 0;
   }
   else ++bad_prs_val;
}

void parse_prs_lo()
{
   // lock loop enable
   log_packet_id("loop lock enable");

   if(get_msg_field()) {
      prs_lo = atoi(msg_field);

      if     (prs_lo == 0) discipline_mode = DIS_MODE_DISABLED; // DIS_MODE_MANUAL_HOLD;
      else if(prs_lo == 1) discipline_mode = DIS_MODE_NORMAL;
      else                 discipline_mode = DIS_MODE_UNKNOWN;
      have_prs_lo = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_ep()
{
   // enable power
   log_packet_id("enable power");

   if(get_msg_field()) {
      prs_ep = atoi(msg_field);
      have_prs_ep = 1;
   }
   else ++bad_prs_val;
}

double prs_fc_ref;

void parse_prs_fc()
{
double val;

   // frequecny control 
   log_packet_id("frequency control");

   if(get_msg_field()) {
      prs_fc1 = atoi(msg_field);
      have_prs_fc |= 0x01;
   }
   else ++bad_prs_val;

   if(get_msg_field()) {
      prs_fc2 = atoi(msg_field);
      have_prs_fc |= 0x02;
   }
   else ++bad_prs_val;

   val = (double) (prs_fc1 - 2048) * 1000.0;
   val += (double) (prs_fc2 - 2048); // freq DAC control word
   val *= 1.5;
   prs_fc_ppt = (val * 1.0E-12);
   val /= 1000.0;      // convert to ppt
   osc_offset = (val - prs_fc_ref);  // remove reference value to get current steering change
//sprintf(debug_text3, "fc:%d %d -> %g %g   (%g .. %g)  %g", prs_fc1,prs_fc2, 
//val, osc_offset, plot[OSC].min_disp_val,plot[OSC].max_disp_val,(plot[OSC].max_disp_val-plot[OSC].min_disp_val)*1.0E6);
   have_osc_offset = 32;
}

void parse_prs_fc2()
{
int life;
double val;

   // frequency control eeprom settings
   log_packet_id("frequency control eeprom");

   if(get_msg_field()) {  // power cycles
      prs_pwr_cycles = atoi(msg_field);
      have_prs_fc2 |= 0x01;
   }
   else ++bad_prs_val;

   if(get_msg_field()) {
      prs_fc_writes = atoi(msg_field);
      have_prs_fc2 |= 0x02;

      life = prs_fc_writes;  // updated around twice a day (manual says daily)
      if(prs_fc_writes > prs_pwr_cycles) life -= prs_pwr_cycles;
      scpi_life = (life * 12);  // updated around twice a day (manual says daily)
      have_lifetime = 1;
   }
   else ++bad_prs_val;

   if(get_msg_field()) {
      prs_ee_fc1 = atoi(msg_field);
   }
   else ++bad_prs_val;

   if(get_msg_field()) {
      prs_ee_fc2 = atoi(msg_field);
   }
   else ++bad_prs_val;

   val = (double) (prs_ee_fc1 - 2048) * 1000.0;
   val += (double) (prs_ee_fc2 - 2048); // DAC reference setting
   val *= 1.5;
   prs_ee_fc_ppt = (val * 1.0E-12);
   val /= 1000.0;
   prs_fc_ref = val;
}

void parse_prs_ds()
{
   // detected signals 
   log_packet_id("detected signals");

   if(get_msg_field()) {
      prs_ds1 = atoi(msg_field);
      have_prs_ds |= 0x01;
   }
   else ++bad_prs_val;

   if(get_msg_field()) {
      prs_ds2 = atoi(msg_field);
      have_prs_ds |= 0x02;
   }
   else ++bad_prs_val;
}

void parse_prs_sf()
{
   // set frequency
   log_packet_id("set frequency");

   if(get_msg_field()) {
      prs_sf = atoi(msg_field);
      have_prs_sf = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_ss()
{
   // set slope
   log_packet_id("set slope");

   if(get_msg_field()) {
      prs_ss = atoi(msg_field);
      have_prs_ss = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_ga()
{
   // gain
   log_packet_id("gain");

   if(get_msg_field()) {
      prs_ga = atoi(msg_field);
      have_prs_ga = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_ph()
{
   // phase
   log_packet_id("phase");

   if(get_msg_field()) {
      prs_ph = atoi(msg_field);
      have_prs_ph = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_sp()
{
int i;

   // set parameters
   log_packet_id("set parameters");

   for(i=0; i<3; i++) {
      if(get_msg_field()) {
         prs_sp[i] = atoi(msg_field);
         have_prs_sp |= (1 << i);
      }
      else ++bad_prs_val;
   }
}

void parse_prs_ms()
{
   // magnetic switching
   log_packet_id("magnetic switching");

   if(get_msg_field()) {
      prs_ms = atoi(msg_field);
      have_prs_ms = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_mo()
{
   // magnetic offset
   log_packet_id("magnetic offset");

   if(get_msg_field()) {
      prs_mo = atoi(msg_field);
      have_prs_mo = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_mr()
{
   // magnetic read
   log_packet_id("magnetic read");

   if(get_msg_field()) {
      prs_mr = atoi(msg_field);
      have_prs_mr = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_tt()
{
   // time tag
   log_packet_id("time tag");

   if(get_msg_field()) {
      prs_tt = atoi(msg_field);
      have_prs_tt = 1;
      if(prs_tt >= 0) {
         if(prs_tt >= 500000000) pps_offset = (OFS_SIZE) (prs_tt - 1000000000);
         else                    pps_offset = (OFS_SIZE) prs_tt;
         have_pps_offset = 1;
      }
   }
   else ++bad_prs_val;
}

void parse_prs_ts()
{
   // time slope
   log_packet_id("time slope");

   if(get_msg_field()) {
      prs_ts = atoi(msg_field);
      have_prs_ts = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_to()
{
   // time offset
   log_packet_id("time offset");

   if(get_msg_field()) {
      prs_to = atoi(msg_field);
      have_prs_to = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_ps()
{
   // pulse slope
   log_packet_id("pulse slope");

   if(get_msg_field()) {
      prs_ps = atoi(msg_field);
      have_prs_ps = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_pl()
{
   // phase lock
   log_packet_id("phase lock");

   if(get_msg_field()) {
      prs_pl = atoi(msg_field);
      have_prs_pl = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_pt()
{
   // phase lock time constant
   log_packet_id("PLL time constant");

   if(get_msg_field()) {
      prs_pt = atoi(msg_field);
      have_prs_pt = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_pf()
{
   // phase lock freq stability
   log_packet_id("PLL freq stability");

   if(get_msg_field()) {
      prs_pf = atoi(msg_field);
      have_prs_pf = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_pi()
{
   // phase lock integrator
   log_packet_id("PLL integrator");

   if(get_msg_field()) {
      prs_pi = atoi(msg_field);
      have_prs_pi = 1;
   }
   else ++bad_prs_val;
}

void parse_prs_sd(int i)
{
   // dac data
   log_packet_id("dac data");

   if(i < 0) return;
   if(i > 7) return;

   if(get_msg_field()) {
      prs_sd[i] = atoi(msg_field);
      have_prs_sd |= (1 << i);
   }
   else ++bad_prs_val;
}

void parse_prs_ad(int i)
{
double val;

   // analog data
   log_packet_id("analog data");

   if(i < 0) return;
   if(i > 19) return;

   if(get_msg_field()) {
      if(!strchr(msg_field, '.')) ++bad_prs_val;

      val = atof(msg_field);
      if     (i == 1) val *= 10.0;    // scale readings to actual values
      else if(i == 2) val *= 10.0;
      else if(i == 3) val *= 10.0;
      else if(i == 4) val *= 10.0;
      else if(i == 9) val *= 4.0;
      else if(i == 10) val *= 100.0;
      else if(i == 16) val *= 4.0;
      else if(i == 17) val *= 4.0;
      else if(i == 18) val *= 4.0;

      prs_ad[i] = val;
      have_prs_ad |= (1 << i);

      if((i == 1) || (i == 2)) {  // average of power readings
         prs_ad_pwr = ((prs_ad[1]+prs_ad[2])/2.0);  
      }
      else if(i == 10) {  // case temperature
         temperature = (DATA_SIZE) prs_ad[i];
         have_temperature = 104;
      }
      else if((i == 11) || (i == 12) || (i == 13)) { // average of thermistor readings
         prs_ad_therm = ((prs_ad[11]+prs_ad[12]+prs_ad[13])/3.0);  
      }
   }
   else ++bad_prs_val;
}

void parse_prs_vb()
{
   // verbose mode
   log_packet_id("verbose mode");

   if(get_msg_field()) {
      prs_vb = atoi(msg_field);
      have_prs_vb = 1;
   }
   else ++bad_prs_val;
}


void set_prs_ep(int val)
{
   if(read_only) return;

   sprintf(out, "EP%d", val);
   queue_prs_cmd(out, PRS_EP_MSG);
   queue_prs_cmd("EP?", PRS_EP_MSG);
}

void set_prs_ga(int val)
{
   if(read_only) return;

   sprintf(out, "GA%d", val);
   queue_prs_cmd(out, PRS_GA_MSG);
   queue_prs_cmd("GA?", PRS_GA_MSG);
}

void set_prs_mo(int val)
{
   if(read_only) return;

   sprintf(out, "MO%d", val);
   queue_prs_cmd(out, PRS_MO_MSG);
   queue_prs_cmd("MO?", PRS_MO_MSG);
}

void set_prs_ms(int val)
{
   if(read_only) return;

   sprintf(out, "MS%d", val);
   queue_prs_cmd(out, PRS_MS_MSG);
   queue_prs_cmd("MS?", PRS_MS_MSG);
}

void set_prs_pf(int val)
{
   if(read_only) return;

   sprintf(out, "PF%d", val);
   queue_prs_cmd(out, PRS_PF_MSG);
   queue_prs_cmd("PF?", PRS_PF_MSG);
}

void set_prs_pi(int val)
{
   if(read_only) return;

   sprintf(out, "PI%d", val);
   queue_prs_cmd(out, PRS_PI_MSG);
   queue_prs_cmd("PI?", PRS_PI_MSG);
}

void set_prs_pp(int val)
{
   if(read_only) return;

   sprintf(out, "PP%d", val);
   queue_prs_cmd(out, PRS_PP_MSG);
// queue_prs_cmd("PT?", PRS_PP_MSG);  // !!! no way to read this back
}

void set_prs_pt(int val)
{
   if(read_only) return;

   sprintf(out, "PT%d", val);
   queue_prs_cmd(out, PRS_PT_MSG);
   queue_prs_cmd("PT?", PRS_PT_MSG);
}

void set_prs_sf(int val)
{
   if(read_only) return;

   sprintf(out, "SF%d", val);
   queue_prs_cmd(out, PRS_SF_MSG);
   queue_prs_cmd("SF?", PRS_SF_MSG);
}

void set_prs_sp(int r, int n, int a)
{
   if(read_only) return;

   sprintf(out, "SP%d,%d,%d", r,n,a);
   queue_prs_cmd(out, PRS_SP_MSG);
   queue_prs_cmd("SP?", PRS_SP_MSG);
}

void set_prs_to(int val)
{
   if(read_only) return;

   sprintf(out, "TO%d", val);
   queue_prs_cmd(out, PRS_TO_MSG);
   queue_prs_cmd("TO?", PRS_TO_MSG);
   queue_prs_cmd("TT?", PRS_TT_MSG);
}



void restart_prs_polling()
{
    polled_req = 0;                  // reset message queues, etc
    drain_port(RCVR_PORT);
    polled_q_in = polled_q_out = 0;
    polled_q_entries = 0;
    polled_msg_id = 0;
    scpi_msg_id = 0;
    prs_msg_id = 0;
    x72_msg_id = 0;
    sa35_msg_id = 0;
    sro_msg_id = 0;
    lpfrs_msg_id = 0;
    rcvr_reset = 0;
    tsip_sync = 0;
    tsip_wptr = 0;
    tsip_rptr = 0;
    did_init1 = 0;
}

void decode_prs_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }
   msg_col = 0;     // index of next char to get from nmea buffer

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %d:[%s]\n", polled_msg_id, nmea_msg);
//sprintf(debug_text, "Decode msg %d:[%s]", polled_msg_id, nmea_msg);


   prs_msg_id = polled_msg_id;
   if     (strstr(nmea_msg,  "OK")) ;
   else if(strstr(nmea_msg,  "BAD")) ;
   else if(strstr(nmea_msg,  "ERROR")) ;
   else if(!strcmp(nmea_msg, "PRS_10")) {  // response message to a reset
      if(debug_file) fprintf(debug_file, "Device reset!");
      BEEP(506);

      restart_prs_polling();

      queue_prs_cmd("VB1", PRS_VB_MSG);  // turn on verbose mode
      queue_prs_cmd("ST?", PRS_ST_MSG);  // get unit stats
   }
   else if(prs_msg_id == PRS_RC_MSG)   parse_prs_xx();
   else if(prs_msg_id == PRS_RS_MSG)   parse_prs_xx();
   else if(prs_msg_id == PRS_SN_MSG)   parse_prs_xx();
   else if(prs_msg_id == PRS_VB_MSG)   parse_prs_vb();
   else if(prs_msg_id == PRS_ID_MSG)   parse_prs_id();
   else if(prs_msg_id == PRS_ST_MSG)   parse_prs_st();
   else if(prs_msg_id == PRS_LM_MSG)   parse_prs_lm();
   else if(prs_msg_id == PRS_LO_MSG)   parse_prs_lo();
   else if(prs_msg_id == PRS_EP_MSG)   parse_prs_ep();
   else if(prs_msg_id == PRS_FC_MSG)   parse_prs_fc();
   else if(prs_msg_id == PRS_FC2_MSG)  parse_prs_fc2();
   else if(prs_msg_id == PRS_DS_MSG)   parse_prs_ds();
   else if(prs_msg_id == PRS_SF_MSG)   parse_prs_sf();
   else if(prs_msg_id == PRS_SS_MSG)   parse_prs_ss();
   else if(prs_msg_id == PRS_GA_MSG)   parse_prs_ga();
   else if(prs_msg_id == PRS_PH_MSG)   parse_prs_ph();
   else if(prs_msg_id == PRS_SP_MSG)   parse_prs_sp();
   else if(prs_msg_id == PRS_MS_MSG)   parse_prs_ms();
   else if(prs_msg_id == PRS_MO_MSG)   parse_prs_mo();
   else if(prs_msg_id == PRS_MR_MSG)   parse_prs_mr();
   else if(prs_msg_id == PRS_TT_MSG)   parse_prs_tt();
   else if(prs_msg_id == PRS_TS_MSG)   parse_prs_ts();
   else if(prs_msg_id == PRS_TO_MSG)   parse_prs_to();
   else if(prs_msg_id == PRS_PP_MSG)   parse_prs_xx();  // message can't be generated
   else if(prs_msg_id == PRS_PS_MSG)   parse_prs_ps();
   else if(prs_msg_id == PRS_PL_MSG)   parse_prs_pl();
   else if(prs_msg_id == PRS_PT_MSG)   parse_prs_pt();
   else if(prs_msg_id == PRS_PF_MSG)   parse_prs_pf();
   else if(prs_msg_id == PRS_PI_MSG)   parse_prs_pi();

   else if(prs_msg_id == PRS_SD0_MSG)  parse_prs_sd(0);
   else if(prs_msg_id == PRS_SD1_MSG)  parse_prs_sd(1);
   else if(prs_msg_id == PRS_SD2_MSG)  parse_prs_sd(2);
   else if(prs_msg_id == PRS_SD3_MSG)  parse_prs_sd(3);
   else if(prs_msg_id == PRS_SD4_MSG)  parse_prs_sd(4);
   else if(prs_msg_id == PRS_SD5_MSG)  parse_prs_sd(5);
   else if(prs_msg_id == PRS_SD6_MSG)  parse_prs_sd(6);
   else if(prs_msg_id == PRS_SD7_MSG)  parse_prs_sd(7);

   else if(prs_msg_id == PRS_AD0_MSG)  parse_prs_ad(0);
   else if(prs_msg_id == PRS_AD1_MSG)  parse_prs_ad(1);
   else if(prs_msg_id == PRS_AD2_MSG)  parse_prs_ad(2);
   else if(prs_msg_id == PRS_AD3_MSG)  parse_prs_ad(3);
   else if(prs_msg_id == PRS_AD4_MSG)  parse_prs_ad(4);
   else if(prs_msg_id == PRS_AD5_MSG)  parse_prs_ad(5);
   else if(prs_msg_id == PRS_AD6_MSG)  parse_prs_ad(6);
   else if(prs_msg_id == PRS_AD7_MSG)  parse_prs_ad(7);
   else if(prs_msg_id == PRS_AD8_MSG)  parse_prs_ad(8);
   else if(prs_msg_id == PRS_AD9_MSG)  parse_prs_ad(9);
   else if(prs_msg_id == PRS_AD10_MSG) parse_prs_ad(10);
   else if(prs_msg_id == PRS_AD11_MSG) parse_prs_ad(11);
   else if(prs_msg_id == PRS_AD12_MSG) parse_prs_ad(12);
   else if(prs_msg_id == PRS_AD13_MSG) parse_prs_ad(13);
   else if(prs_msg_id == PRS_AD14_MSG) parse_prs_ad(14);
   else if(prs_msg_id == PRS_AD15_MSG) parse_prs_ad(15);
   else if(prs_msg_id == PRS_AD16_MSG) parse_prs_ad(16);
   else if(prs_msg_id == PRS_AD17_MSG) parse_prs_ad(17);
   else if(prs_msg_id == PRS_AD18_MSG) parse_prs_ad(18);
   else if(prs_msg_id == PRS_AD19_MSG) parse_prs_ad(19);
   else if(prs_msg_id == SCPI_USER_MSG)     parse_scpi_user();
   else if(prs_msg_id == (0-SCPI_USER_MSG)) parse_scpi_user();

   i = get_norcvr_message();   // returns true if seconds just ticked
   if(SLOW_PRS_POLL && (seconds & 0x01));  // enable this to trigger high priority message polls every seoncd
                                           // ... but this slows polling loop cycle to around 1 minute
   else if(i && (prs_poll_tick == 0)) prs_poll_tick = 1;  // trigger high priority message polls
   poll_next_prs();

   prs_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
}


void get_prs_message()
{
u08 c;
static int row=0;

   // This routine buffers up an incoming PRS-10 message.  It is also used
   // for the SA35 and Spectratime SRO100 and LPFRS devices.  When the end of
   // the message is seen, the message is parsed and decoded with 
   // decode_prs_msg(), etc.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(c == 0x11) {    // we pretty much ignore XON/XOFF
      return;  // XON
   }
   else if(c == 0x13) {
      Sleep(200);
      return;  // XOFF
   }

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of messaage
      tsip_sync = 1;
      get_sync_time();
      tsip_wptr = 0;
      tsip_rptr = 0;
      goto build_msg;
   }
   else if(tsip_sync == 1) { // build the message
      build_msg:
      if(c == 0x0D) goto prs_end; 
      else if(c == 0x0A) goto prs_end; 

      if(tsip_wptr < (MAX_TSIP-1)) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         goto rst_msg;
      }
   }
   else {
      prs_end:
      if(rcvr_type == SA35_RCVR) {
         if(tsip_wptr) decode_sa35_msg();
      }
      else if(rcvr_type == SRO_RCVR) {
         if(tsip_wptr) decode_sro_msg();
      }
      else if(rcvr_type == LPFRS_RCVR) {
         if(tsip_wptr) decode_lpfrs_msg();
      }
      else decode_prs_msg();
      packet_end = 1;

      rst_msg:
      tsip_sync = 0;
      tsip_wptr = 0;
      tsip_rptr = 0;
   }
}



//
//
//   Symmetricom X72 stuff (rubidium oscillator)
//
//

void update_x72_screen()
{
int i;

   // update the screen every second.  When the seconds tick, request the
   // high priority messages.

   i = get_norcvr_message();   // returns true if seconds just ticked
   if(i && (prs_poll_tick == 0)) prs_poll_tick = 1;  // trigger high priority message polls

   if(i) {
      if(x72_tic_timer > 0) {  // tic reg changed, wait for it to take effect
         --x72_tic_timer;
         return;
      }
      else x72_tic_timer = 0;

      if(have_x72_pps && x72_state_set && x72_user_dis) {
         x72_sw_discipline();  // do disciplining
      }
      else if(x72_fw_discipline()) {
      }
      else {
         discipline_mode = DIS_MODE_NORMAL;
      }
   }
}


void parse_x72_response(int id)
{
   // prepare to decode the multi-line query response

   x72_response = id;
// if(debug_file) fprintf(debug_file, "X72 %d start (%s)\n", id, nmea_msg);
   x72_line = 0;
   scpi_col = 0;
   scpi_status_line[0] = 0;

   strcpy(scpi_status_line, nmea_msg);  // record the first line of the response
   parse_x72_val(x72_response);
}



void poll_next_x72()
{
int test;

   // request the next item from a X72 rubidium.

   if(need_x72_resync) {
      need_x72_resync = 0;
      restart_prs_polling();  // reset the message queues
   }

   if(need_x72_restore && have_x72_pps) {
      need_x72_restore = 0;
if(debug_file) fprintf(debug_file, "! restore x72 state!  fw_dis:%d\n", x72_fw_discipline());  //burp
      restore_x72_state();   // restore last known x72 settings from disk
   }

   test = 0;
   if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else {
      if(polled_req < 0) polled_req = 0;

      if(1 && (have_x72_info == 0)) {        // requesting info can disrupt device timing
         send_polled_cmd("i", X72_INFO_MSG); // ... so we only get it once
      }
      else if(prs_poll_tick) {   // get PPS value every second
         send_polled_cmd("j", X72_GET_PPS_MSG);
         prs_poll_tick = 0;
      }
      else {
         if     (polled_req == 0) send_polled_cmd("w", X72_HEALTH_MSG);
         else if(polled_req == 1) send_polled_cmd("p", X72_GET_CREG_MSG);

         if(++polled_req > 1) {
            polled_req = 0;
            ++all_polled;
            if(all_polled == 1) {  // reset the queues the first time through
               new_queue(RESET_ALL_QUEUES, 4598);
            }
         }
      }

      ++polled_seq;
   }
}


void decode_x72_msg(int why)
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;
tsip_error = 0;

   // get the response from the receiver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode x72 msg %d:(%s)  why:%d\n", x72_msg_id, nmea_msg, why);

   if(strstr(nmea_msg, "R>")) {  // >r prompt
      x72_msg_id = 0;
      return;
   }
   else if(nmea_msg[0] == 0) {  // empty line
      return;
   }
   else if(x72_msg_id == 0) {
if(debug_file) fprintf(debug_file, "response to:(%s) (status msg:%d) is next\n", nmea_msg, scpi_status);
      if     (strstr(nmea_msg, "A")) x72_msg_id = X72_SET_FC_MSG;
      else if(strstr(nmea_msg, "F")) x72_msg_id = X72_SET_DDS_MSG;
      else if(strstr(nmea_msg, "G")) x72_msg_id = X72_SET_DMODE_MSG;
      else if(strstr(nmea_msg, "H")) x72_msg_id = X72_HELP_MSG;
      else if(strstr(nmea_msg, "I")) x72_msg_id = X72_INFO_MSG;
      else if(strstr(nmea_msg, "J")) x72_msg_id = X72_GET_PPS_MSG;
      else if(strstr(nmea_msg, "K")) x72_msg_id = X72_SET_TIC_MSG;
      else if(strstr(nmea_msg, "L")) x72_msg_id = X72_SET_SRVC_MSG;
      else if(strstr(nmea_msg, "O")) x72_msg_id = X72_SET_FREQ_MSG;
      else if(strstr(nmea_msg, "P")) x72_msg_id = X72_GET_CREG_MSG;
      else if(strstr(nmea_msg, "Q")) x72_msg_id = X72_SET_CREG_MSG;
      else if(strstr(nmea_msg, "R")) x72_msg_id = X72_RUNR_MSG;
      else if(strstr(nmea_msg, "T")) x72_msg_id = X72_SAVE_TUNE_MSG;
      else if(strstr(nmea_msg, "W")) x72_msg_id = X72_HEALTH_MSG;
      else if(strstr(nmea_msg, "X")) x72_msg_id = X72_RUNX_MSG;
      else if(strstr(nmea_msg, "Y")) x72_msg_id = X72_TC_MSG;         // !!!! Y1
      else if(strstr(nmea_msg, "Y")) x72_msg_id = X72_DAMPING_MSG;    // !!!! Y2
      else if(strstr(nmea_msg, "Z")) x72_msg_id = X72_SAVE_DMODE_MSG; // !!!! Y2
      return;
   }

   if(x72_msg_id == X72_INFO_MSG) {  // multi-line response to the query
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_HEALTH_MSG) {  // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_GET_PPS_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_GET_CREG_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_HELP_MSG) { // multi-line response to the query 
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_CREG_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_TIC_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_FREQ_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_DMODE_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SAVE_TUNE_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_DDS_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_SRVC_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SET_FC_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_RUNR_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_RUNX_MSG) { // multi-line response to the query 
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_TC_MSG) {   // multi-line response to the query  
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_DAMPING_MSG) { // multi-line response to the query  
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == X72_SAVE_DMODE_MSG) { // multi-line response to the query  
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else if(x72_msg_id == SCPI_USER_MSG) {
      parse_x72_response(x72_msg_id);
      x72_msg_id = 0;
   }
   else {
      x72_msg_id = 0;
      poll_next_x72();
   }


// if(debug_file) fprintf(debug_file, "x72 %d response:%s\n", x72_msg_id, nmea_msg);
   update_x72_screen();

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


char *info_param(char *param)
{
int len;
char *s;

   if(param == 0) return 0;

   len = strlen(param);
   s = strstr(scpi_status_line, param);
   if(s) {
      return (s+len+1);
   }

   return 0;
}


float x72_float(char *s)
{
u32 val;

   // return value of ascii encoded hex 32-bit float

   if(s == 0) return 0.0;

   val = (u32) atohex(s);
   return  * ((float *) &val);
}

void parse_x72_info()
{
char *s;
char *comma;
int i;

   // get values from the X72 info response

   s = info_param("SDCP VERSION");
   if(s) {
      x72_fw = atof(s);
      have_x72_fw = 1;
      have_x72_info = 1;
      if(have_x72_type == 0) {
         x72_type = X72_TYPE;
         have_x72_type = 1;
      }

      s = info_param("OF");
      if(s) {
         x72_date[0] = 0;
         for(i=0; i<12; i++) {
            if(s[i] == ';') break;
            x72_date[i] = s[i];
            x72_date[i+1] = 0;
         }
      }
   }
   s = info_param("SA22 VERSION");
   if(s) {
      x72_fw = atof(s);
      have_x72_fw = 1;
      have_x72_info = 1;
      if(have_x72_type == 0) {
         x72_type = SA22_TYPE;
         have_x72_type = 1;
      }

      s = info_param("OF");
      if(s) {
         x72_date[0] = 0;
         for(i=0; i<12; i++) {
            if(s[i] == ';') break;
            x72_date[i] = s[i];
            x72_date[i+1] = 0;
         }
      }
   }

   s = info_param("LOADER VERSION");
   if(s) {
      x72_loader = atoi(s);
      have_x72_loader = 1;
      have_x72_info = 1;
   }

   s = info_param("STATE IS");
   if(s) {
      x72_tune = atoi(s);
      have_x72_tune = 1;
      have_x72_info = 1;
   }

   s = info_param("CODE IS");
   if(s) {
      comma = strchr(s, ',');
      if(comma) *comma = 0;
      for(i=0; i<20; i++) x72_serial[i] = s[i];
      have_x72_serial = 1;
      have_x72_info = 1;
   }


   s = info_param("CRYSTAL:");
   if(s) {
      x72_crystal = atof(s);
      have_x72_crystal = 1;
      have_x72_info = 1;
   }

   s = info_param("SINE:");
   if(s) {
      x72_sine = atof(s);
      have_x72_sine = 1;
      have_x72_info = 1;
   }

   s = info_param("ACMOS:");
   if(s) {
      x72_acmos = atof(s);
      have_x72_acmos = 1;
      have_x72_info = 1;
   }

   s = info_param("MODE");
   if(s) {
   }

   s = info_param("FC:");
   if(0 && s) {  // we got these values elsewhere
      if(strstr(s, "ENABLED")) x72_efc = 1;
      else                     x72_efc = 0;
      have_x72_efc = 1;
      have_x72_info = 1;
   }

   s = info_param("SRVC:");
   if(0 && s) {  // we got these values elsewhere
      if(strstr(s, "LOW")) x72_srvc = 0;
      else                 x72_srvc = 1;
      have_x72_srvc = 1;
      have_x72_info = 1;
   }

   s = info_param("RES TEMP OFF:");
   if(s) {
      x72_res_tempofs = (double) x72_float(s);
      have_x72_res_tempofs = 1;
      have_x72_info = 1;
   }

   s = info_param("LAMP TEMP OFF:");
   if(s) {
      x72_lamp_tempofs = (double) x72_float(s);
      have_x72_lamp_tempofs = 1;
      have_x72_info = 1;
   }

   s = strstr(scpi_status_line, "R>");
   if(s) {
      have_info |= ALL_ID_INFO;
   }

// sprintf(debug_text, "fw:%f  loader:%d  tune:%d  xtal:%f  acmos:%f  sine:%f  serial:%s", x72_fw,x72_loader,x72_tune,  x72_crystal,x72_acmos,x72_sine, x72_serial);
}

void decode_x72_creg()
{
   // set various flags based upon the control reg value

   if(x72_creg & 0x0008) pps_enabled = 0;
   else                  pps_enabled = 1;

   if(x72_creg & 0x0040) x72_sine_level = 0;
   else {
      x72_sine_level = 40;
      if(x72_creg & 0x0080) x72_sine_level += 30;
      if(x72_creg & 0x0100) x72_sine_level += 20;
      if(x72_creg & 0x0200) x72_sine_level += 10;
   }
}


int x72_sync_fail(int id)
{
int flag;
   // return true is message response is not valid for the requested message
   // !!!!! this routines needs to be more robust...  we currently only
   //       check for health response to a non-health request

   flag = 0;
   if(strstr(scpi_status_line, "ADATA") && (id != X72_HEALTH_MSG)) {  // health response
      need_x72_resync = id;
      flag = 1;
   }
   else if(strstr(scpi_status_line, "CONTROL REG") && (id != X72_GET_CREG_MSG)) {  // health response
      need_x72_resync = id;
      flag = 1;
   }
   else if(strstr(scpi_status_line, "DELTA REG") && (id != X72_GET_PPS_MSG)) {  // health response
      need_x72_resync = id;
      flag = 1;
   }

   if(flag) {  // unexpected response to a query was seen
      if(debug_file) fprintf(debug_file, "\n###! x72 msg %d sync fail! (%s)\n\n", id, scpi_status_line);
      return 1;
   }

   return 0;
}


int last_ival;
int last_dis_ival;

int fix_x72_tics(int val)
{
   // fixup a TIC value to avoid wrap probelms between 0 and X72_TICS
// !!!!!! we need a MUCH better way of doing this !!!!!!

   if(val > (X72_TICS / 2)) {
      val = val - X72_TICS;
   }

   return val;
}

void parse_x72_val(int id)
{
char *s;
char *s2;
u32 val;
float fp_val;
int fp;
int i;

   // parse and decode the FIRST value from a message response

   fp_val = 0.0F;
   val = 0;

   s = strchr(scpi_status_line, ':');  // see if there is a ':' numeric parameter on the line
   if(s) {
      if(id == X72_SET_DDS_MSG) {  // "f" set DDS frequency offset
         fp = 1;
         fp_val = (float) atof(s+1);
      }
      else if(strchr(scpi_status_line, '.')) {  // floating point value
         fp = 1;
         fp_val = x72_float(s+1);
      }
      else {  // decimal value
         fp = 0;
         val = (u32) atohex(s+1);
      }

      if(id == X72_GET_PPS_MSG) {  // see if PPS line also has hw discipline state
         s2 = strstr(scpi_status_line, "PPSSTATE:");
         if(s2) {
            have_x72_fw_dis = 1;
            if(x72_user_dis == 0) {
               x72_state = atoi(&s2[9]);
               have_x72_state = 2;
            
               discipline_mode = DIS_MODE_NORMAL;
               if(x72_state < X72_STATE_START0) discipline_mode = DIS_MODE_UNKNOWN;
               if(x72_state > X72_STATE_SLOPECALC) discipline_mode = DIS_MODE_UNKNOWN;

               if     (x72_state == X72_STATE_START0)   discipline_mode = DIS_MODE_NORMAL; // POWERUP; !!!!! qwerty
               else if(x72_state == X72_STATE_START1)   discipline_mode = DIS_MODE_POWERUP;
               else if(x72_state == X72_STATE_START2)   discipline_mode = DIS_MODE_POWERUP;
               else if(x72_state == X72_STATE_HOLDOVER) discipline_mode = DIS_MODE_AUTO_HOLD;
               else if(x72_state == X72_STATE_JAM1)     discipline_mode = DIS_MODE_RECOVERY;
               else if(x72_state == X72_STATE_JAM2)     discipline_mode = DIS_MODE_RECOVERY;
               else if(x72_state == X72_STATE_JAM2)     discipline_mode = DIS_MODE_RECOVERY;
            }
         }
      }

      *s = 0;  // trim the rest of the line after the first val
   }

   if(x72_sync_fail(id)) {  // see if message sync was lost (invalid parameter seen for a message response)
   }
   else if(id == X72_HEALTH_MSG) {  // "w" health message values
      if(strstr(scpi_status_line, "SCONT")) {
         x72_scont = val;
         have_x72_scont = 1;
      }
      else if(strstr(scpi_status_line, "SERNUM")) {
         x72_sernum = val;
         have_x72_sernum = 1;
      }
      else if(strstr(scpi_status_line, "PWRHRS")) {
         scpi_life = val;
         have_lifetime = 1;
      }
      else if(strstr(scpi_status_line, "PWRTICKS")) {
         x72_pwrticks = val;
         have_x72_pwrticks = 1;
      }
      else if(strstr(scpi_status_line, "LHHRS")) {
         x72_lhhrs = val;
         have_x72_lhhrs = 1;
      }
      else if(strstr(scpi_status_line, "LHTICKS")) {
         x72_lhticks = val;
         have_x72_lhticks = 1;
      }
      else if(strstr(scpi_status_line, "RHHRS")) {
         x72_rhhrs = val;
         have_x72_rhhrs = 1;
      }
      else if(strstr(scpi_status_line, "RHTICKS")) {
         x72_rhticks = val;
         have_x72_rhticks = 1;
      }
      else if(strstr(scpi_status_line, "DMP17")) {
         x72_dmp17 = (double) fp_val;
         have_x72_dmp17 = 1;
      }
      else if(strstr(scpi_status_line, "DMP5")) {
         x72_dmp5 = (double) fp_val;
         have_x72_dmp5 = 1;
      }
      else if(strstr(scpi_status_line, "DHTRVOLT")) {
         x72_dhtrvolt = (double) fp_val;
         have_x72_dhtrvolt = 1;
      }
      else if(strstr(scpi_status_line, "PLMP")) {
         x72_plmp = (double) fp_val;
         have_x72_plmp = 1;
      }
      else if(strstr(scpi_status_line, "PRES")) {
         x72_pres = (double) fp_val;
         have_x72_pres = 1;
      }
      else if(strstr(scpi_status_line, "DLVTHERMC")) {
         x72_dlvthermc = (double) fp_val;
         have_x72_dlvthermc = 1;
      }
      else if(strstr(scpi_status_line, "DRVTHERMC")) {
         x72_drvthermc = (double) fp_val;
         have_x72_drvthermc = 1;
      }
      else if(strstr(scpi_status_line, "DLVOLT")) {
         x72_dlvolt = (double) fp_val;
         have_x72_dlvolt = 1;
      }
      else if(strstr(scpi_status_line, "DMVOUTC")) {
         x72_dmvoutc = (double) fp_val;
         have_x72_dmvoutc = 1;
      }
      else if(strstr(scpi_status_line, "DTEMPLO")) {
         x72_dtemplo = (double) fp_val;
         have_x72_dtemplo = 1;
      }
      else if(strstr(scpi_status_line, "DTEMPHI")) {
         x72_dtemphi = (double) fp_val;
         have_x72_dtemphi = 1;
      }
      else if(strstr(scpi_status_line, "DVOLTLO")) {
         x72_dvoltlo = (double) fp_val;
         have_x72_dvoltlo = 1;
      }
      else if(strstr(scpi_status_line, "DVOLTHI")) {
         x72_dvolthi = (double) fp_val;
         have_x72_dvolthi = 1;
      }
      else if(strstr(scpi_status_line, "IFPGACTL")) {
         x72_creg = val;
         decode_x72_creg();
         have_x72_creg = 1;
      }
      else if(strstr(scpi_status_line, "DCURTEMP")) {
         temperature = (DATA_SIZE) fp_val;
         have_temperature = 105;
      }
      else if(strstr(scpi_status_line, "DLVOUTC")) {
         x72_dlvoutc = (double) fp_val;
         have_x72_dlvoutc = 1;
      }
      else if(strstr(scpi_status_line, "DRVOUTC")) {
         x72_drvoutc = (double) fp_val;
         have_x72_drvoutc = 1;
      }
      else if(strstr(scpi_status_line, "DMV2DEMAVG")) {
         x72_dmv2demavg = (double) fp_val;
         have_x72_dmv2demavg = 1;
      }
   }
   else if(id == X72_GET_CREG_MSG) {  // "p" get control reg
      if(strstr(scpi_status_line, "CONTROL REG")) {
         x72_creg = val;
         decode_x72_creg();
         have_x72_creg = 1;
      }
   }
   else if(id == X72_GET_PPS_MSG) {  // "j" get PPS offset value
      if(strstr(scpi_status_line, "DELTA REG")) {
         last_x72_pps = x72_pps;
         x72_pps = val;
         x72_ival = i = fix_x72_tics((int) val);
         if(have_x72_pps == 0) {
            last_ival = x72_ival;
            last_x72_pps = x72_pps;
         }
         x72_pps_diff = (x72_ival - last_ival);
         last_ival = x72_ival;

///      i = fix_x72_tics(x72_ival);
         pps_offset = (OFS_SIZE) (((double) i) * 1.0E9 / x72_osc);
last_pps_offset = pps_offset;
tsip_error = 0;
// if(x72_user_dis) sprintf(debug_text6, "x72_pps:%d  val:%d  lastiv:%d  i:%d  pps_offset:%g", x72_pps, val, i, last_ival, pps_offset);  //burp
         have_pps_offset = 1;
         have_x72_pps = 1;
         ++x72_run_time;

      }
   }
   else if(id == X72_SET_DDS_MSG) {  // "f" set DDS frequency offset
      if(strstr(scpi_status_line, "CHANGE FREQUENCY")) {
         x72_dds_word = fp_val;
         have_x72_dds_word = 1;
      }
   }
   else if(id == X72_SET_DMODE_MSG) {  // "g" set discipling
      if(strstr(scpi_status_line, "DISABLED")) {
         have_x72_fw_dmode = 1;
         x72_fw_dmode = 0;
      }
      else if(strstr(scpi_status_line, "ENABLED")) {
         have_x72_fw_dmode = 1;
         x72_fw_dmode = 1;
      }
   }
   else if(id == X72_SET_FC_MSG) {  // "a" set EFC enable
      if(strstr(scpi_status_line, "DISABLED")) { 
         x72_efc = 0; 
         have_x72_efc = 1; 
      }
      else if(strstr(scpi_status_line, "ENABLED")) { 
         x72_efc = 1; 
         have_x72_efc = 1; 
      }
   }
   else if(id == X72_SET_SRVC_MSG) {  // "l" set service output pin state
      if(strstr(scpi_status_line, "HIGH")) { 
         x72_srvc = 1; 
         have_x72_srvc = 1; 
      }
      else if(strstr(scpi_status_line, "LOW")) { 
         x72_srvc = 0; 
         have_x72_srvc = 1; 
      }
   }


if(0 && debug_file) {
   if((scpi_status_line[0] == 'R') && (scpi_status_line[1] == '>')) ;  // no obvious number to show
   else if(scpi_status_line[1] == 0) ; // no obvious number to show 
   else if(fp) fprintf(debug_file, "%s -> 0x%08X -> %g\n", scpi_status_line, val, fp_val);
   else        fprintf(debug_file, "%s -> 0x%08X -> %u\n", scpi_status_line, val,  val);
}
}


void get_x72_response(char c)
{
   // get the data returned by the HEALTH, etc messages
   if(c == 0x0D) return;
   if(c == 0x00) return;

   if(c == 0x0A) {  // end-of-line,  process it
      response_end:
      ++x72_line;
if(debug_file) fprintf(debug_file, "get_x72_response %d, line:%2d: %s\n", x72_response,x72_line, scpi_status_line);

      strupr(scpi_status_line);
      if(x72_response == X72_HEALTH_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_GET_CREG_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_GET_PPS_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_SET_DDS_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_SET_SRVC_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_SET_FC_MSG) {
         parse_x72_val(x72_response);
      }
      else if(x72_response == X72_INFO_MSG) {
         parse_x72_info();
      }

      if(strstr(scpi_status_line, "R>")) {  // command line prompt
         x72_response = 0;
         x72_line = 0;
         poll_next_x72();
      }

      scpi_col = 0;
      scpi_status_line[0] = 0;
      update_x72_screen();
   }
   else {  // accumulate the status line
      if(scpi_col < ((int)sizeof(scpi_status_line)-2)) {
         scpi_status_line[scpi_col++] = c;
         scpi_status_line[scpi_col] = 0;
         if((scpi_status_line[0] == 'r') && (scpi_status_line[1] == '>')) {  // command line prompt -> end of message data
            goto response_end;
         }
      }
   }
}


void get_x72_message()
{
u08 c;
static int row=0;

   // This routine buffers up an incoming X72 message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_x72_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(c == 0x0D) return;  // ignore CR,  we end if LF char

   if(x72_response) {     // we are reading multi-line response query results
      get_x72_response(c);
      return;
   }

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message
      tsip_sync = 1;
      get_sync_time();

      tsip_wptr = 0;
      tsip_rptr = 0;
      goto get_msg;
   }
   else if(tsip_sync == 1) { // message start has been seen, now build the message
      get_msg:
      if(c == 0x0A) goto x72_end; 
      else if(c == 0x0D) goto x72_end; 

      if(tsip_wptr < (MAX_TSIP-2)) {  // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
         if((tsip_buf[0] == 'r') && (tsip_buf[1] == '>')) {  // command prompt
            goto x72_end;
         }
      }
      else {  // buffer overlow
         goto rst_msg;
      }
   }
   else {
      x72_end:
      if(tsip_wptr > 0) {
         decode_x72_msg(2);
         packet_end = 1;
      }

      rst_msg:
      tsip_sync = 0;
      tsip_rptr = 0;
      tsip_wptr = 0;
   }
}



void set_x72_efc(int val)
{
   // set the X72 EFC input enabled
   if(read_only) return;

   last_x72_efc = val;
   user_set_x72_efc = 1;
   save_x72_state();

   val &= 1;
   sprintf(out, "a%d", val);
   queue_x72_cmd(out, X72_SET_FC_MSG);
///   queue_x72_cmd("i", X72_INFO_MSG);
}

void set_x72_tic(int val)
{
   // set the X72 PPS TIC offset value
   if(read_only) return;

   if(val < 0) {
      val = IABS(val) % ((int) x72_osc);
      if(val) val = ((int) x72_osc) - val;
   }
   else {
      val = (val % (int) x72_osc);
   }

   last_x72_tic = val;
   user_set_x72_tic = 1;
   save_x72_state();

   sprintf(out, "k%d", val);
   queue_x72_cmd(out, X72_SET_TIC_MSG);
   x72_tic_timer = 6;  // it takes 6 seconds for a TIC change to take effect
   x72_tic_changed = 1;
}

void set_x72_dds(double val)
{
#define MAX_DDS_STEP  4.0E-8
#define MAX_DDS_RANGE 1.0E-6
double dval;
double set_val;
double sign;
int i, j;

   // set the X72 DDS freq tune value
   if(read_only) return;

   if(fabs(val) > 1.0E-6) return;

   if(val < 0.0) sign = (-1.0);
   else          sign = 1.0;

   last_x72_dds = val;
   user_set_x72_dds = 1;
   save_x72_state();

   dval = fabs(val);
   if(dval > MAX_DDS_RANGE) return;  // freq change is too large
   j = (int) (MAX_DDS_RANGE / MAX_DDS_STEP) + 1;

   set_val = 0.0;
   for(i=0; i<j; i++) {  // max DDS change allowed in one step is 4.0E-8
      if(dval > MAX_DDS_STEP) set_val += MAX_DDS_STEP;
      else                    set_val += dval;

      osc_offset = set_val*sign;

      val = set_val / 1.0E-12;  // we get E-12 steps
      have_osc_offset = 333;
      val = val / 10.0;     // scale E-12 input to E-11 
      sprintf(out, "f%.2f", val*sign);
      queue_x72_cmd(out, X72_SET_DDS_MSG);

      dval -= MAX_DDS_STEP;
      if(dval <= 0.0) break;
   }
}

void set_x72_acmos_freq(int val)
{
   // set the X72 ACMOS freq
   if(read_only) return;

   last_x72_acmos_freq = val;
   user_set_x72_acmos_freq = 1;
   save_x72_state();

   sprintf(out, "o%d", val);
   queue_x72_cmd(out, X72_SET_FREQ_MSG);
}

void set_x72_creg(int val)
{
   // set the X72 control reg value
   if(read_only) return;


   val &= 0xFFFF;
   sprintf(out, "q%04X", val);
   queue_x72_cmd(out, X72_SET_CREG_MSG);
}

void set_x72_srvc(int val)
{
   // set the X72 service pin polarity
   if(read_only) return;

   last_x72_srvc = val;
   user_set_x72_srvc = 1;
   save_x72_state();

   val &= 1;
   sprintf(out, "l%d", val);
   queue_x72_cmd(out, X72_SET_SRVC_MSG);
///   queue_x72_cmd("i", X72_INFO_MSG);
}

void save_x72_tune()
{
   // save the tuning control value into eeprom
   if(read_only) return;

///queue_x72_cmd("t1", X72_SAVE_TUNE_MSG);
   queue_x72_cmd("t5987717", X72_SAVE_TUNE_MSG);
}


// functions for device firmware that supports 1PPS disciplining

int x72_fw_discipline()
{
   // returns true if the X72 supports firmware PPS disciplining
   if(rcvr_type != X72_RCVR) return 0;

   if(1 && have_x72_fw_dis) {  // use "j" command results to determine capability
      if(x72_type == X72_TYPE)  return 72;
      if(x72_type == X99_TYPE)  return 99;   // !!!!! what X99 firmware supports pps disciplining?
      if(x72_type == SA22_TYPE) return 22;
      return 1;
   }

   if(1 && have_x72_type) {  // use firmware rev to determine capability
      if((x72_type == X72_TYPE) && (x72_fw >= 5.02)) return -72;
      if((x72_type == X99_TYPE) && (x72_fw >= 5.02)) return -99;   // !!!!! what X99 firmware supports pps disciplining?
      if((x72_type == SA22_TYPE) && (x72_fw >= 6.05)) return -22;
   }

   return 0;
}

void set_x72_discipline(int val)
{
   // set the X72 PPS discipline mode
   // 0=off, 1=enabled, lock pin normal mode,  2=enabled, lock pin indicates Rb and disipline locked
   // 3=enable SW discipline on units with firmware capability
   if(read_only) return;

   if(val < 0) val = 0;
   else if(val > 3) val = 3;
//if(debug_file) fprintf(debug_file, "set dmode %d  have_pps:%d  hw:%d\n", val, have_x72_pps, x72_fw_discipline());  //burp
//sprintf(debug_text, "set dmode %d  have_pps:%d  hw:%d", val, have_x72_pps, x72_fw_discipline());

   if(have_x72_pps && val && (x72_fw_discipline() == 0)) {  // can only do software discipline
      val = 3;
   }

   have_x72_dmode = 1;
   user_set_x72_dmode = 1;
   x72_dmode_val = val;
   last_x72_dmode = val;

   save_x72_state();

   if(val > 2) {
      if(x72_fw_discipline()) {  // disable firmware disciplining
         sprintf(out, "g%d", 0);
         queue_x72_cmd(out, X72_SET_DMODE_MSG);
      }
      x72_user_dis = val; // enable SW disciplining
      x72_start_discipline();
   }
   else if(val) {  // enabling discipline
      if(x72_fw_discipline()) {  // firmware disciplining
         sprintf(out, "g%d", val);
         queue_x72_cmd(out, X72_SET_DMODE_MSG);
         x72_user_dis = 0;
      }
      else {  // enable software discipline algorithm
         x72_user_dis = val;
         x72_start_discipline();
      }
   }
   else {  // disabling disipline
      if(x72_fw_discipline()) {  // disable firmware disciplining
         sprintf(out, "g%d", val);
         queue_x72_cmd(out, X72_SET_DMODE_MSG);
      }
      x72_user_dis = val; // disable SW disciplining
   }
}

void set_x72_damping(double val)
{
   // set the X72 disciplining damping factor
   if(read_only) return;

   have_x72_damping = 1;
   x72_damping_val = val;
   user_damping_factor = (DATA_SIZE) val;
   have_osc_params |= PARAM_DAMP;

   last_x72_damping = val;
   user_set_x72_damping = 1;
   save_x72_state();

   if(x72_fw_discipline()) {
      sprintf(out, "y1\r%.2f", val);
      queue_x72_cmd(out, X72_DAMPING_MSG);
   }
}

void set_x72_tc(int val)
{
   // set the X72 disciplining time constant factor
   if(read_only) return;

   if(val < MIN_X72_TC) val = MIN_X72_TC;
   if(val > MAX_X72_TC) val = MAX_X72_TC;

   have_x72_tc = 1;
   x72_tc_val = val;
   user_time_constant = (DATA_SIZE) val;
   time_constant = (DATA_SIZE) val;
   have_osc_params |= PARAM_TC;
   x72_reset_filter();

   last_x72_tc = val;
   user_set_x72_tc = 1;
   save_x72_state();

   if(x72_fw_discipline()) {
      sprintf(out, "y2\r%d", val);
      queue_x72_cmd(out, X72_TC_MSG);
   }
}

void set_x72_jamthresh(double val)
{
   // set the X72 sw discipline forced jamsync threshold
   if(read_only) return;

//// if(x72_fw_discipline()) return;
// !!!!!!!!!!!!!! we need to change the X72_PPS_BINS code to implement this !!!!!!!!!!!!!!
   if(val <= 0.0) val = X72_JAMSYNC_THRESH;
   if(val >= X72_JAMSYNC_THRESH) val = X72_JAMSYNC_THRESH;

   have_x72_jamthresh = 1;
   x72_jamthresh_val = val;
   user_jam_sync = (DATA_SIZE) val;
   jam_sync = (DATA_SIZE) val;
   have_osc_params |= PARAM_JAMSYNC;

   last_x72_jamthresh = val;
   user_set_x72_jamthresh = 1;

   save_x72_state();
}

void set_x72_holdover(int val)
{
   // set the X72 sw discipline holdover analysis time
   if(read_only) return;

//// if(x72_fw_discipline()) return;
   if(val <= 0) val = X72_HOLDOVER_SIZE;

   have_x72_holdover = 1;
   x72_holdover_val = val;
   user_holdover_time = val;
   have_osc_params |= PARAM_HOLDOVER;

   last_x72_holdover = val;
   user_set_x72_holdover = 1;

   save_x72_state();
}

void save_x72_dmode()
{
   // save the disciplining factors into eeprom

   queue_x72_cmd("z1", X72_SAVE_DMODE_MSG);
}



void save_x72_state()
{
   // save current settings to disk file since STUPID Symmetricom does not
   // save most settings to eeprom

   if(x72_file == 0) {
      return;
   }

   fseek(x72_file, 0L, SEEK_SET);


   if(user_set_x72_dmode) {
      fprintf(x72_file, "%d DISCIPLINE\n", last_x72_dmode);
   }
   if(user_set_x72_tc) {
      fprintf(x72_file, "%d TC\n", last_x72_tc);
   }
   if(user_set_x72_damping) {
      fprintf(x72_file, "%g DAMPING\n", last_x72_damping);
   }
   if(user_set_x72_jamthresh) {
      fprintf(x72_file, "%g JAMTHRESH\n", last_x72_jamthresh);
   }
   if(user_set_x72_holdover) {
      fprintf(x72_file, "%d HOLDOVER\n", last_x72_holdover);
   }


   if(user_set_x72_osc) {
      fprintf(x72_file, "%.1f OSC\n", x72_osc);
   }

   if(user_set_x72_dds) { 
      fprintf(x72_file, "%g DDS\n", last_x72_dds);
   }

   if(user_set_x72_acmos_freq) { 
      fprintf(x72_file, "%d DIVIDER\n", last_x72_acmos_freq);
   }

   if(user_set_x72_efc) { 
      fprintf(x72_file, "%d EFC\n", last_x72_efc);
   }

   if(user_set_x72_pps_enable) {
      fprintf(x72_file, "%d PPS\n", last_x72_pps_enable);
   }

   if(user_set_x72_srvc) {
      fprintf(x72_file, "%d SRVC\n", last_x72_srvc);
   }

   if(user_set_x72_tic) { 
      fprintf(x72_file, "%d TIC\n", last_x72_tic);
   }


   fprintf(x72_file, "\n0 EOF\n");

   fflush(x72_file);   // !!!!! we should probably close and re-open the file
}


void restore_x72_state()
{
unsigned i;
double val;

   // restore last known settings from disk file since STUPID Symmetricom 
   // does not save them in EEPROM

   if(x72_file) {
      fclose(x72_file);
      x72_file = 0;
   }
   x72_state_set = 1;

   sprintf(x72_name, "%s%s", dump_prefix, SYM_EEP_FILE);
   x72_file = fopen(x72_name, "r");
   if(x72_file == 0) goto open_x72_for_write;

   while(fgets(out, sizeof out, x72_file) != NULL) {  // get the last saved settings
      if(out[0] == 0) continue;

      for(i=0; i<strlen(out); i++) {   // skip leading white space
         if(out[i] == ' ') continue;
         else if(out[i] == '\t') continue;
         else break;
      }


      if(out[i] == '.') ;          // first thing on the line should be a number
      else if(out[i] == '+') ;
      else if(out[i] == '-') ;
      else if(isdigit(out[i])) ;
      else continue;               // treat anything else as a comment

      strupr(out);
if(debug_file) fprintf(debug_file, "restore:%s\n", out);  //burp

      if(strstr(out, "DIVIDER")) {
         last_x72_acmos_freq = atoi(&out[i]);
         user_set_x72_acmos_freq = 1;
      }
      else if(strstr(out, "DDS")) {
         last_x72_dds = atof(&out[i]);
         user_set_x72_dds = 1;
      }
      else if(strstr(out, "OSC")) {
         val = atof(&out[i]);
         if(val > 0.0) {
            last_x72_osc = x72_osc = atof(&out[i]);
            user_set_x72_osc = 1;
         }
      }
      else if(strstr(out, "EFC")) {
         last_x72_efc = atoi(&out[i]);
         user_set_x72_efc = 1;
      }
      else if(strstr(out, "PPS")) {
         last_x72_pps_enable = atoi(&out[i]);
         user_set_x72_pps_enable = 1;
      }
      else if(strstr(out, "TIC")) {
         last_x72_tic = atoi(&out[i]);
         user_set_x72_tic = 1;
      }
      else if(strstr(out, "SRVC")) {
         last_x72_srvc = atoi(&out[i]);
         user_set_x72_srvc = 1;
      }

      else if(strstr(out, "DISCIPLINE")) { // discipling parameters
         last_x72_dmode = atoi(&out[i]);
         user_set_x72_dmode = 1;
      }
      else if(strstr(out, "DMODE")) {      // old name for this param
         last_x72_dmode = atoi(&out[i]);
         user_set_x72_dmode = 1;
      }
      else if(strstr(out, "TC")) { 
         last_x72_tc = atoi(&out[i]);
         user_set_x72_tc = 1;
      }
      else if(strstr(out, "DAMPING")) {
         last_x72_damping = atof(&out[i]);
         user_set_x72_damping = 1;
      }
      else if(strstr(out, "JAMTHRESH")) {
         last_x72_jamthresh = atof(&out[i]);
         user_set_x72_jamthresh = 1;
      }
      else if(strstr(out, "HOLDOVER")) {
         last_x72_holdover = atoi(&out[i]);
         user_set_x72_holdover = 1;
      }
      else if(strstr(out, "EOF")) {
         break;
      }
   }

   if(x72_file) {
      fclose(x72_file);
      x72_file = 0;
   }

   open_x72_for_write:
   x72_file = fopen(x72_name, "w");

   // send the last known settings values to the device and re-write the values to the settings file
   if(user_set_x72_dmode) set_x72_discipline(last_x72_dmode);
   if((last_x72_dmode == 1) || (last_x72_dmode == 2)) {  // firmware disciplining enabled
      // don't set TC or DAMPING values... this messes up X72 firmware disciplining
   }
   else {
      if(user_set_x72_dds)     set_x72_dds(last_x72_dds);
      if(user_set_x72_tic)     set_x72_tic(last_x72_tic);
      if(user_set_x72_tc)      set_x72_tc(last_x72_tc);
      if(user_set_x72_damping) set_x72_damping(last_x72_damping);

      // software disciplining parameters
      if(user_set_x72_jamthresh)  set_x72_jamthresh(last_x72_jamthresh);
      if(user_set_x72_holdover)   set_x72_holdover(last_x72_holdover);
   }

   if(user_set_x72_acmos_freq) set_x72_acmos_freq(last_x72_acmos_freq);
   if(user_set_x72_efc)        set_x72_efc(last_x72_efc);
   if(user_set_x72_srvc)       set_x72_srvc(last_x72_srvc);
   if(user_set_x72_pps_enable) {
      user_pps_enable = last_x72_pps_enable;
      set_pps(user_pps_enable, pps_polarity,  delay_value, pps1_delay,  pps_threshold, 4);
   }

   x72_restore_timeout = 10; // pause disciplining for 10 seconds after a settings restoration
}




//
//
//   Oscilloquartz STAR4 receiver stuff (also NEC GPSDO and OSA45xx)
//
//

void zpad(char *s, int n)
{
int i;
int minus;

   // replace blanks in a string with '0'

   if(s == 0) return;

   minus = 0;
   for(i=0; i<n; i++) {
      if(s[i] == 0) return;
      if(s[i] == ' ') s[i] = '0';
      if(s[i] == '-') {
         s[i] = '0';
         minus = 1;
      }
   }
   if(minus && (s[0] == '0')) s[0] = '-';
}

void poll_next_star(int why)
{
int test;

   // request an item from a STAR receiver.  Requests are alternated between
   // a position/time message and some receiver parameter.  The parameter requests
   // alternate between one of three important parameters and then the lesser
   // important ones.

   star_line = 0;
   star_msg = 0;

   test = 1;
   if(star_type == OSA_TYPE) { // OSA-453x
      if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(1);    // send the message
         if(no_response_msg) {  // the message sends no response
            no_response_msg = 0;
            send_polled_cmd("INFO_GPS", STAR_POS_MSG);  // request time and location message
         }
      }
      else if(polled_msg_id == STAR_POS_MSG) { // request next misc message every time message
         if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
            send_queued_cmd(2);
         }
         if(polled_req < 0) polled_req = 0;

         if     (polled_req == 0)  send_polled_cmd("INV;",              STAR_INV_MSG);
         else if(polled_req == 1)  send_polled_cmd("CONF;",             STAR_CONF_MSG);
         else if(polled_req == 2)  send_polled_cmd("HBSQ;",             STAR_HBSQ_MSG);
         else if(polled_req == 3)  send_polled_cmd("STATUS;",           STAR_STATUS_MSG);
         else if(polled_req == 4)  send_polled_cmd("TOD_STATE;",        STAR_TOD_MSG);
         else if(polled_req == 5)  send_polled_cmd("WTR;",              STAR_WTR_MSG);
         else if(polled_req == 6)  send_polled_cmd("AL_MASK;",          STAR_ALMASK_MSG);

         else if(polled_req == 7)  send_polled_cmd("PRIOR_TABLE;",      STAR_PRIOR_MSG);  // !!!! 4531
         else if(polled_req == 8)  send_polled_cmd("OUTPUT_TYPE;",      STAR_OUTPUT_MSG); // !!!! 4531
         else if(polled_req == 9)  send_polled_cmd("AUX_INPUT;",        STAR_AUX_MSG);    // !!!! 4531
         else if(polled_req == 10) send_polled_cmd("ADM_STATE;",        STAR_ADM_MSG);    // !!!! 4531

         ++polled_req;
         if(osa_model && (osa_model == 4530) && (polled_req > 6)) {
            polled_req = 0;
            ++all_polled;
         }
         else if(polled_req > 10) {
            polled_req = 0;
            ++all_polled;
         }

         if(no_response_msg) {
            no_response_msg = 0;
            send_polled_cmd("INFO_GPS", STAR_POS_MSG);  // request time and location message
         }

         ++polled_seq;
      }
      else {
         send_polled_cmd("INFO_GPS", STAR_POS_MSG);  // request time and location message
      }
   }
   else {  // STAR-4
      if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(1);
      }
      else if(polled_msg_id == STAR_POS_MSG) { // request next misc message every time message
         if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
            send_queued_cmd(2);
         }
         if(polled_req < 0) polled_req = 0;

         if(1 && ((polled_seq % 3) == 0)) send_polled_cmd("TEMPERATURE;",  STAR_TEMP_MSG); 
         else {
            if     (polled_req == 0)  send_polled_cmd("GPS_TIME;",         STAR_GPS_TIME_MSG);
            else if(polled_req == 1)  send_polled_cmd("MASK_ANGLE;",       STAR_ANGLE_MSG);
            else if(polled_req == 2)  send_polled_cmd("INV;",              STAR_INV_MSG);
            else if(polled_req == 3)  send_polled_cmd("CONF;",             STAR_CONF_MSG);

            else if(polled_req == 4)  send_polled_cmd("ALARM;",            STAR_ALARM_MSG);
            else if(polled_req == 5)  send_polled_cmd("HBSQ;",             STAR_HBSQ_MSG);
            else if(polled_req == 6)  send_polled_cmd("ATDC_STATUS;",      STAR_ATDC_MSG);
            else if(polled_req == 7)  send_polled_cmd("HOLD_PERF_STATUS;", STAR_PERF_MSG);

            else if(polled_req == 8)  send_polled_cmd("OUTPUT_STATE;",     STAR_STATE_MSG);   // !!! multi-line response 
            else if(polled_req == 9)  send_polled_cmd("STATUS;",           STAR_STATUS_MSG);
            else if(polled_req == 10) send_polled_cmd("TOD_STATE;",        STAR_TOD_MSG);
            else if(polled_req == 11) send_polled_cmd("TYPE;",             STAR_TYPE_MSG);
            else if(polled_req == 12) send_polled_cmd("ALARM_MASK;",       STAR_ALMASK_MSG);
            else if(polled_req == 13) send_polled_cmd("INPUT_TYPE(1);",    STAR_INP_TYPE_MSG);

            ++polled_req;
            if(polled_req > 13) {
               polled_req = 0;
               ++all_polled;
            }
         }

         ++polled_seq;
      }
      else {
         send_polled_cmd("INFO_GPS_POS;", STAR_POS_MSG);  // request time and location message
      }
   }
}


void parse_star_alarm()
{
int i;
int count;

   // device alarms and status
   log_packet_id("Star alarm");
// sprintf(debug_text2, "alarms:%s", nmea_msg);

   minor_alarms &= (~MINOR_ANT_NO_PWR);
   minor_alarms &= (~MINOR_NO_TRACK);
   minor_alarms &= (~MINOR_SURVEY);
   minor_alarms &= (~MINOR_PPS_SKIPPED);
   time_flags &= (~TFLAGS_INVALID);
   have_antenna = 222;

   critical_alarms &= (~CRIT_GPS);
   critical_alarms &= (~CRIT_OCXO);
   if(have_critical_alarms == 0) need_redraw = 222;
   have_critical_alarms = 222;

   count = 0;
   while(get_msg_field()) {
      if(++count > 12) break;

      if(isdigit(msg_field[0])) {
         i = atoi(msg_field);
         if(i == 1) {       // warmup
            discipline_mode = DIS_MODE_WARMUP;
         }
         else if(i == 2) {  // holdover
            discipline_mode = DIS_MODE_AUTO_HOLD;
         }
         else if(i == 3) {  // tracked fast
            discipline_mode = DIS_MODE_FAST_RECOVERY;
         }
         else if(i == 4) {  // ocxo fail
            critical_alarms |= CRIT_OCXO;
         }
         else if(i == 5) {  // squelched
            discipline_mode = DIS_MODE_RECOVERY;
         }
         else if(i == 6) {  // gps timing error
            minor_alarms |= MINOR_PPS_SKIPPED;
//          time_flags |= TFLAGS_INVALID;
         }
         else if(i == 7) {  // gps fail
            critical_alarms |= CRIT_GPS;
         }
         else if(i == 8) {  // antenna fault
            minor_alarms |= MINOR_ANT_NO_PWR;
         }
         else if(i == 9) {  // not surveyed
            minor_alarms |= MINOR_SURVEY;
         }
         else if(i == 10) { // temperature fault
         }
         else if(i == 11) { // missing aux PPS input
         }
      }
   }
}

void parse_star_status() 
{
int gps;
int mode;
char *s;

   // unit status
   log_packet_id("Star status");

   star_led = (-1);
   gps = 0;
   mode = 0;
//sprintf(plot_title, "status:%s", nmea_msg);

   if(star_type == OSA_TYPE) {
      s = strstr(nmea_msg, "ALARMS:");
      if(s) {  // !!!! 4531
         s = s + 7;
         if(s[0] == '1') {
            critical_alarms |= CRIT_GPS;
            have_critical_alarms = 1;
         }
         else if(s[0] == '0') {
            critical_alarms &= (~CRIT_GPS);
            have_critical_alarms = 1;
         }

         if(s[1] == '1') {
            minor_alarms |= MINOR_ANT_NO_PWR;
            have_antenna = 1;
         }
         else if(s[1] == '0') {
            minor_alarms &= (~MINOR_ANT_NO_PWR);
            have_antenna = 1;
         }

         if(s[5] == '1') {
            critical_alarms |= CRIT_OCXO;
            have_critical_alarms = 1;
         }
         else if(s[5] == '0') {
            critical_alarms &= (~CRIT_OCXO);
            have_critical_alarms = 1;
         }
      }

      s = strstr(nmea_msg, "LED:");
      if(s) {
         s = s + 4;
         star_led = atoi(s);
         have_star_led = 1;
      }

      s = strstr(nmea_msg, "STAT_IN:");  // !!!! 4531
      if(s) {
         s = s + 8;
         mode = atoi(s);
         if(osa_model != 4530) {
            osa_stat1 = s[0] - '0';
            osa_stat2 = s[1] - '0';
            osa_stat3 = s[2] - '0';
            have_osa_stat = 1;
         }
      }
   }
   else {
      if(get_msg_field()) {
        star_led = atoi(msg_field);
        have_star_led = 1;
      }

      if(get_msg_field()) {
         gps = msg_field[0];
         if(gps == 'A') {   // GPS alarm
            critical_alarms |= CRIT_GPS;
            have_critical_alarms = 1;
         }
         else if(gps == 'O') {   // GPS ok
            critical_alarms &= (~CRIT_GPS);
            have_critical_alarms = 1;
         }
      }

      if(get_msg_field()) {
         mode = msg_field[0];
         if     (mode == 'I') discipline_mode = DIS_MODE_POWERUP;
         else if(mode == 'F') discipline_mode = DIS_MODE_FAST_RECOVERY;
         else if(mode == 'H') discipline_mode = DIS_MODE_AUTO_HOLD;
         else if(mode == 'W') discipline_mode = DIS_MODE_WARMUP;
         else if(mode == 'S') discipline_mode = DIS_MODE_RECOVERY;
         else if(mode == 'T') discipline_mode = DIS_MODE_NORMAL;
         else                 discipline_mode = mode;
      }
   }
}


void parse_star_conf()   
{
char *s;

   // device configuration info
   log_packet_id("Star config");

   if(star_type == OSA_TYPE) {
      s = strstr(nmea_msg, "PPS_CABLE_DELAY:");
      if(s) {
         s = s+16;
         zpad(s,6);
         cable_delay = atof(s) / 1.0E9;
         have_cable_delay = 1;
      }

      s = strstr(nmea_msg, "PPS_OFFSET:");
      if(s) {
         s = s+11;
         zpad(s,9);
         pps1_delay = atof(s) / 1.0E9;
         have_pps_delay |= 0x01;
      }

      s = strstr(nmea_msg, "TAU:");
      if(s) {
         s = s+4;
         zpad(s,5);
         time_constant = (float) atof(s);  // user time const
         have_osc_params |= PARAM_TC;
         have_tc |= 0x01;

         s = s + 5 + 1;
         zpad(s,5);
         real_time_constant = (float) atof(s);
         have_tc |= 0x02;
      }

      if     (strstr(nmea_msg, "/INIT"))             discipline_mode = DIS_MODE_POWERUP;
      else if(strstr(nmea_msg, "/WARM-UP"))          discipline_mode = DIS_MODE_WARMUP;
      else if(strstr(nmea_msg, "/TRACKED-FAST"))     discipline_mode = DIS_MODE_FAST_RECOVERY;
      else if(strstr(nmea_msg, "/TRACKED"))          discipline_mode = DIS_MODE_NORMAL;
      else if(strstr(nmea_msg, "/HOLDOVER")) {
         if(strstr(nmea_msg, "MODE:HOLDOVER"))       discipline_mode = DIS_MODE_MANUAL_HOLD;
         else if(strstr(nmea_msg, "MODE:AUTOMATIC")) discipline_mode = DIS_MODE_AUTO_HOLD;
         else                                        discipline_mode = DIS_MODE_UNKNOWN;
      }
      else                                           discipline_mode = DIS_MODE_UNKNOWN;
   }
   else {
      if(get_msg_field()) {  // user time constant
         time_constant = (float) atof(msg_field);
         have_osc_params |= PARAM_TC;
         have_tc |= 0x01;
      }

      if(get_msg_field()) {  // real pll time constant
         real_time_constant = (float) atof(msg_field);
         have_tc |= 0x02;
      }

      if(get_msg_field()) {  // user mode (A)utomatic or (H)oldover
         if(msg_field[0] == 'H') rcvr_mode = RCVR_MODE_PROP;       // user holdover
         else if(msg_field[0] == 'A') {
            if(minor_alarms & MINOR_SURVEY) rcvr_mode = RCVR_MODE_3D;
            else rcvr_mode = RCVR_MODE_HOLD;  // position hold
         }
         else rcvr_mode = RCVR_MODE_UNKNOWN;
      }

      if(get_msg_field()) {  // time zone - !!!! we don't do this
      }

      if(get_msg_field()) {  // cable delay
         cable_delay = atof(msg_field) / 1.0E9;
         have_cable_delay = 22;
      }
   }
}


void parse_star_hbsq()  
{
char *s;

   // output squelch control

   log_packet_id("Star HBSQ");
   user_hbsq = current_hbsq = (-1);

   if(get_msg_field()) { 
      user_hbsq = atoi(msg_field);
      have_star_hbsq |= 0x01;
   }

   if(star_type == OSA_TYPE) {
      s = strchr(nmea_msg, '/');
      if(s) {
         s = s + 1;
         zpad(s,4);
         current_hbsq = atoi(s);
         have_star_hbsq |= 0x02;
      }
   }
   else {
      if(get_msg_field()) { 
         current_hbsq = atoi(msg_field);
         have_star_hbsq |= 0x02;
      }
   }
}


void parse_star_gps_time()   
{
int ls;
int dd,mm,yy;
int hrs,mins,secs;
char c[2];

   // gps time / leapsecond info
   log_packet_id("Star gps time");

   if(get_msg_field()) {  // GPS week
      gps_week = atoi(msg_field);
      faked_tow = 0;
      if(gps_week == 0) return;   // bogus 0 values will be in the message
      if(have_week == 0) need_redraw = 4354;
      have_week = 299;
   }

   if(get_msg_field()) {  // GPS TOW
      if(0) {   // !!!! we fake the GPS week and tow since this message only comes in every 10+ seconds
         pri_tow = atoi(msg_field);
         tow = pri_tow; 
         this_tow = tow;
         survey_tow = tow;

         if(have_tow == 0) need_redraw = 4029;
         have_tow = 59;
      }
   }

   dd = mm = yy = 0;
   hrs = mins = secs = 0;
   if(get_msg_field()) { // leap dd/mm/yy
      sscanf(msg_field, "%d%c%d%c%d", &dd,&c[0],&mm,&c[0],&yy);
   }
   if(get_msg_field()) { // leap hh/mm/ss
      sscanf(msg_field, "%d%c%d%c%d", &hrs,&c[0],&mins,&c[0],&secs);
   }

   if(get_msg_field()) { // leap pending
      if(gps_week) {  // if week is 0, the message was invalid
         ls = atoi(msg_field);
         if(ls) {
            minor_alarms |= MINOR_LEAP_PEND;

            if(time_flags & TFLAGS_NO_UTC_OFS) {
               jd_leap = 0.0;
               have_jd_leap = 0;
               have_leap_days = 0;
            }
            else if(have_time && (yy || dd || mm || hrs || mins || secs)) {
               if(yy && (yy < 100)) yy += 2000;
               jd_leap = jdate(yy,mm,dd) + jtime(hrs,mins,secs,0.0) - jtime(0,0,1,0.0);
               calc_jd_leap(5);
            }
         }
         else {
            minor_alarms &= (~MINOR_LEAP_PEND);
            jd_leap = 0.0;
            have_jd_leap = 0;
            have_leap_days = 0;
         }
         have_leap_info = 32;
      }
   }

   if(get_msg_field()) {  // leap second count
      ls = atoi(msg_field);
      if(!user_set_utc_ofs) utc_offset = ls;
      check_utc_ofs(39);
   }
}

void start_fake_seconds(int why)
{
   fake_msec = GetMsecs() + 1000.0;  // !!!! (1000.0 / nav_rate) ?
   fake_count = 0;                    // counts number of consecutive faked seconds
if(0 && debug_file) fprintf(debug_file, "start_fake(%d)\n", why);

///fake_msec -= (double) SCPI_SLEEP;  // compensates for Sleep() in send_polled_cmd()
///fake_msec -= (double) SCPI_SLEEP;  // compensates for Sleep() in send_polled_cmd()
///fake_msec += 50.0;  // compensates for Sleep() in send_polled_cmd()
// if(log_file) fprintf(log_file, "fake start(%d)  msec:%f\n", why,fake_msec);
}


int fake_missing_second(double delta)
{
double jd;
double this_t,last_t;
static double last_jd = 0.0;
int old_yy;
int old_mm;
int old_dd;
int old_hh;
int old_min;
int old_sec;
u32 old_tow;
double old_frac;
double old_ro;


   // this routine generates a fake time message every other second in order
   // to support telecom receivers that work on 2 second intervals.
   // Returns 1 if call would cause a duplicated time stamp, else returns 0.

   old_yy = year;      // used to fake missing odd time time stamps
   old_mm = month;
   old_dd = day;
   old_hh = hours;
   old_min = minutes;
   old_sec = seconds;
   old_frac = raw_frac;
   old_tow = tow;

   jd = jdate(year,month,day);
   jd += jtime(hours,minutes,seconds, 0.000);  // !!!! raw_frac?
if(0 && debug_file) fprintf(debug_file, "fake missing:%04d/%02d/%02d  %02d:%02d:%02d\n", year,month,day, hours,minutes,seconds);

   last_jd = jd;

   tow = pri_tow = this_tow = (tow - (int) (delta-0.50));  // !!!!!! survey_tow?
   set_gregorian_time(jd - (delta / (24.0*60.0*60.0)));  // back up delta seconds
if(0 && debug_file) fprintf(debug_file, "faked missing:%04d/%02d/%02d  %02d:%02d:%02d\n", year,month,day, hours,minutes,seconds);
   if(pri_frac <= 0.002) {
      pri_frac = g_frac = raw_frac = 0.0;
   }

   this_t = this_time_msec;
   last_t = last_time_msec;

   if(rcvr_type == STAR_RCVR) {
      if(0 && debug_file && (seconds == (SCPI_STATUS_SECOND+1)) && (last_misc_second == (SCPI_STATUS_SECOND+2))) {
         fprintf(debug_file, "fake backsteped!\n");
         if(dbg_flush_mode) fflush(debug_file);
      }
   }

if(0 && debug_file) fprintf(debug_file, "fake missing: secs:%d  last:%d\n", seconds, last_misc_second);
   fake_time_stamp = 1;
   if(seconds != last_misc_second) {
      old_ro = rollover;   // disable rollover correction for faked seconds
      rollover = 0.0;
      update_gps_screen(554);
      rollover = old_ro;
if(0 && debug_file) fprintf(debug_file, "fake missing: updated  secs:%d  last:%d\n", seconds,last_misc_second);
   }
   fake_time_stamp = 0;

   if(pri_seconds == SCPI_STATUS_SECOND) {
     if(rcvr_type == UCCM_RCVR)  queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
     else if(rcvr_type == SCPI_RCVR) queue_scpi_cmd(":SYST:STAT?", SCPI_STATUS_MSG);
     start_fake_seconds(1);
     sent_uccm_status = 1;
   }

   this_time_msec = this_t + (1000.0 * delta);  // fake the timestamp of the faked time stamp message
   last_time_msec = last_t + (1000.0 * delta);

   if(0) {
      pri_year = year = old_yy;        // restore real time stamp
      pri_month = month = old_mm;
      pri_day = day = old_dd;
      pri_hours = hours = old_hh;
      pri_minutes = minutes = old_min;
      pri_seconds = seconds = old_sec;
      pri_frac = raw_frac = old_frac;
   }

   tow = pri_tow = this_tow = survey_tow = old_tow;  // !!!!!! survey_tow?
   return 0;
}


void fake_second_check(int why)
{
double this_msec;

   // This routine checks to see if we need to fake a time message for receivers
   // that only send time every other second or for SCPI type receivers that
   // take a long time to process the SYST:STAT? message

if((why < 10) && (rcvr_type == UCCM_RCVR)) return;

   if(fake_msec) {                     // fake time stamp enabled
      this_msec = GetMsecs();
if(0 && debug_file) fprintf(debug_file, "fsc %d: this:%f fake:%f  count:%d\n", why, this_msec, fake_msec, fake_count);
      if(this_msec >= (fake_msec)) {  // it's time to fake it
         fake_missing_second(-1.000);  // negative value adds a second
         fake_msec += 1000.0;  // !!!! (1000.0 / nav_rate)?
         if(++fake_count > MAX_FAKE_COUNT) {
if(0 && debug_file) fprintf(debug_file, "fsc reset!  count=%d\n", fake_count);
            fake_count = 0;
            fake_msec = 0.0;  // limit number of consecutive faked seconds
         }
      }
   }
}


// #define FIX_STAR_TIME 0
#define FIX_STAR_TIME fix_star_ts

void parse_star_pos()    
{
int dd,mm,yy;
int hrs,mins,secs;
int ff;
char s[2];
char dir[2];
static int last_sec = (-99);
static double last_jd = 0.0;
double xlat,xlon,xalt;
int bad_msg;
double this_jd;
double delta_jd;
static int fix_count = 0;
char *sss;

   // position and time info

   log_packet_id("Star posn/time");

   fake_msec = 0.0;
   saw_star_time = 1;
   restart_count = 0;

   bad_msg = 0;
   xlat = lat;
   xlon = lon;
   xalt = alt;

   dd = mm = hrs = mins = secs = 99;
   yy = 9999;

   if(star_type == OSA_TYPE) {
      sss = strstr(nmea_msg, "LAT:");
      if(sss) {
         sss += 4;
         zpad(sss, 7);
         sscanf(sss, "%3d%2d%2d", &hrs,&mins,&secs);
         if(mins < 0) bad_msg |= 0x01;
         if(mins >= 60) bad_msg |= 0x01;
         if(secs < 0) bad_msg |= 0x01;
         if(secs >= 60) bad_msg |= 0x01;
         if(hrs < 0) {
            mins = 0-mins;
            secs = 0-secs;
         }

         lat = (double) hrs + ((double) mins/60.0) + ((double) secs/3600.0);
         if(lat < -90.0) bad_msg |= 0x01;
         if(lat > 90.0) bad_msg |= 0x01;
         lat = lat * PI/180.0;
      }
      else return;

      sss = strstr(nmea_msg, "LON:");
      if(sss) {
         sss += 4;
         zpad(sss, 8);
         sscanf(sss, "%4d%2d%2d", &hrs,&mins,&secs);
         if(mins < 0) bad_msg |= 0x02;
         if(mins >= 60) bad_msg |= 0x02;
         if(secs < 0) bad_msg |= 0x02;
         if(secs >= 60) bad_msg |= 0x02;

         if(hrs < 0) {
            mins = 0-mins;
            secs = 0-secs;
         }

         lon = (double) hrs + ((double) mins/60.0) + ((double) secs/3600.0);
         if(lon < -180.0) bad_msg |= 0x02;
         if(lon > 180.0)  bad_msg |= 0x02;
         lon = lon * PI/180.0;
      }
      else return;

      sss = strstr(nmea_msg, "HEI:");
      if(sss) {
         sss += 4;
         zpad(sss, 8);
         alt = atof(sss) / 100.0;
         if(alt < -4000.0) bad_msg |= 0x04;  // message probaly corrupted
         if(alt > 40000.0) bad_msg |= 0x04;  // message probaly corrupted
      }
      else return;

      sss = strstr(nmea_msg, "DATE:");
      if(sss) {
         sss += 5;
         zpad(sss, 8);
         sscanf(sss, "%2d%2d%4d", &dd,&mm,&yy);
         if(dd <= 0) bad_msg |= 0x08;
         if(dd > 31) bad_msg |= 0x08;
         if(mm <= 0) bad_msg |= 0x08;
         if(mm > 12) bad_msg |= 0x08;
         if(yy < 1980) bad_msg |= 0x08;
      }
      else return;

      sss = strstr(nmea_msg, "TIME:");
      if(sss) {
         sss += 5;
         zpad(sss, 6);
         if(strlen(sss) != 6) bad_msg |= 0x20;
         sscanf(sss, "%2d%2d%2d", &hrs,&mins,&secs);
         if(hrs < 0) bad_msg |= 0x20;
         if(hrs > 24) bad_msg |= 0x20;
         if(mins < 0) bad_msg |= 0x20;
         if(mins > 60) bad_msg |= 0x20;
         if(secs < 0) bad_msg |= 0x20;
         if(secs > 60) bad_msg |= 0x20;
      }
      else return;


      if(bad_msg) {  // corrupted message, fake the correct date/time/etc
         lat = xlat; // alt value 50989 seen in corrupted message after data loss reset
         lon = xlon;   
         alt = xalt;   

         gregorian(0, jd_utc+jtime(0,0,1,0.0-rollover));
if(debug_file) fprintf(debug_file, "yymmdd:%04d/%02d/%02d  %02d:%02d:%02d\n", yy,mm,dd, hrs,mins,secs);
if(debug_file) fprintf(debug_file, "greg:  %04d/%02d/%02d  %02d:%02d:%02d\n", g_year,g_month,g_day, g_hours,g_minutes,g_seconds);
         yy = g_year;
         mm = g_month;
         dd = g_day;
         hrs = g_hours;
         mins = g_minutes;
         secs = g_seconds;
if(debug_file) fprintf(debug_file, "bad pos msg:%02X\n", bad_msg);
      }
   }
   else {
      if(get_msg_field()) {  // lat
         strupr(msg_field);
         sscanf(msg_field, "%d%c%d%c%d%c%c", &dd,&s[0],&mm,&s[0],&ff,&s[0],&dir[0]);
         lat = (double) dd;
         lat += ((double) mm)/60.0;
         lat += ((double) ff)/(60.0*10000.0);
         if(dir[0] == 'S') lat *= (-1.0);
         lat = lat * PI/180.0;
      }

      if(get_msg_field()) {  // lon
         strupr(msg_field);
         sscanf(msg_field, "%d%c%d%c%d%c%c", &dd,&s[0],&mm,&s[0],&ff,&s[0],&dir[0]);
         lon = (double) dd;
         lon += ((double) mm)/60.0;
         lon += ((double) ff)/(60.0*10000.0);
         if(dir[0] == 'W') lon *= (-1.0);
         lon = lon * PI/180.0;
      }

      if(get_msg_field()) {  // alt
         alt = atof(msg_field);
      }

      if(get_msg_field()) { // dd/mm/yyyy
         sscanf(msg_field, "%d%c%d%c%d", &dd,&s[0],&mm,&s[0],&yy);
      }
      else return;
      if(get_msg_field()) { // hrs/mins/secs
         sscanf(msg_field, "%d%c%d%c%d", &hrs,&s[0],&mins,&s[0],&secs);
      }
      else return;
   }

   if(((dd == 99) && (mm == 99) && ((yy == 99) || (yy == 9999))) || ((hrs == 99) && (mins == 99) && (secs == 99))) { // no date / time avail
      get_clock_time();     // substitute system clock

      yy = clk_year % 100;
      yy += 2000;
      mm = clk_month;
      dd = clk_day;

      hrs =  clk_hours;
      mins = clk_minutes;
      secs = clk_seconds;
   }

   // the Star 4 occasionally produces skipped time stamps, we try to fix
   // them, by backing this one up by a second
   this_jd = jdate(yy,mm,dd) + jtime(hrs,mins,secs, 0.0);
   delta_jd = this_jd - (last_jd + jtime(0,0,2, 0.0));
if(debug_file) fprintf(debug_file, "thisjd:%f  lastjd:%f  delta:%.12f (%f)\n", this_jd,last_jd, delta_jd, delta_jd*60.0*60.0*24.0);
   if(this_jd < last_jd) ; 
   else if(star_type == OSA_TYPE) ;
   else if(FIX_STAR_TIME && (secs != (SCPI_STATUS_SECOND+2)) && (fabs(delta_jd) <= 0.0000001)) {            // time stamp skip detected
      this_jd -= jtime(0,0,1, 0.0); // ... back this time up a second
      ++fix_count;

      gregorian(0, this_jd);
      yy = g_year;
      mm = g_month;
      dd = g_day;
      hrs = g_hours;
      mins = g_minutes;
      secs = g_seconds;
if(debug_file) fprintf(debug_file, "!! time stamp skip fixed! %02d:%02d:%02d\n", hrs,mins,secs);
   }

   last_jd = this_jd;

   if((star_type == NEC_TYPE) && (secs == last_sec)) {
      dup_star_time = 1;
   }
   else if(FIX_STAR_TIME || (last_sec != secs)) {
      last_sec = secs;

      pri_year = yy;
      pri_month = mm;
      pri_day = dd;
      pri_hours = hrs;
      pri_minutes = mins;
      pri_seconds = secs;
      pri_frac = 0.0;

      if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
         utc_to_gps();
      }
      else {
         adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
      }

      if((seconds == (SCPI_STATUS_SECOND+1)) && (last_misc_second == (SCPI_STATUS_SECOND+2))) {
         if(debug_file) fprintf(debug_file, "fake timestamp backsteped!!!\n");
      } 
      else if(seconds != last_misc_second) {
         update_gps_screen(1554);
      }

      if(pri_seconds == SCPI_STATUS_SECOND) {
         if(star_type == OSA_TYPE) { 
            queue_star_cmd("INFO_VIS_SAT;", STAR_VIS_MSG);     // !!! multi-line response
            queue_star_cmd("INFO_CHAN", STAR_TRACK_MSG);   // !!! multi-line response
         }
         else {
            queue_star_cmd("INFO_TRACK_SAT;", STAR_TRACK_MSG);   // !!! multi-line response
//          queue_star_cmd("INFO_GPS_POS;",   STAR_POS_MSG);
            queue_star_cmd("INFO_VIS_SAT;",   STAR_VIS_MSG);     // !!! multi-line response
//          queue_star_cmd("INFO_GPS_POS;",   STAR_POS_MSG);
         }
      }
      if(pri_seconds == (SCPI_STATUS_SECOND+0)) start_fake_seconds(6);
      if(pri_seconds == (SCPI_STATUS_SECOND+1)) start_fake_seconds(7);
      if(pri_seconds == (SCPI_STATUS_SECOND+2)) start_fake_seconds(8); 
   }
}

void parse_star_output()
{
   // !!!! 4531
   log_packet_id("Star output");
   if(get_msg_field()) {
      if(strstr(msg_field, "E1")) {
         osa_output_type = 1;
         have_osa_output = 1;
      }
      else if(strstr(msg_field, "FR")) {
         osa_output_type = 2;
         have_osa_output = 1;
      }
   }
}

void parse_star_prior()
{
   // !!!! 4531
   log_packet_id("Star priority");
   if(get_msg_field()) {
      osa_gps_prior = msg_field[0] - '0';
      osa_aux_prior = msg_field[1] - '0';
      have_osa_prior = 1;
   }
}

void parse_star_aux_inp()
{
   // !!!! 4531
   log_packet_id("Star aux time");
   if(get_msg_field()) {
      osa_aux_c = msg_field[0] - '0';
      osa_aux_t = msg_field[1] - '0';
      have_osa_aux = 1;
   }
}

void parse_star_adm()
{
   // !!!! 4531
   log_packet_id("Star adm");
   if(get_msg_field()) {
      osa_gps_adm = msg_field[0] - '0';
      osa_aux_adm = msg_field[1] - '0';
      have_osa_adm = 1;
   }
}



void parse_star_vis()  
{
int prn;
int el;
int az;
int snr;
int health;
int dop;
char *s;

   // visible sat info
   log_packet_id("Star visibility");

   if(star_line) {
      --star_line;
      prn = el = az = health = dop = (-999);
      snr = (-999);

      if(star_type == OSA_TYPE) {
         s = strstr(nmea_msg, "ID:");
         if(s) {
            s += 3;
            zpad(s,2);
            prn = atoi(s);
         }

         s = strstr(nmea_msg, "AZIM:");
         if(s) {
            s += 5;
            zpad(s,3);
            az = atoi(s);
         }

         s = strstr(nmea_msg, "ELEV:");
         if(s) {
            s += 5;
            zpad(s,2);
            el = atoi(s);
         }

         s = strstr(nmea_msg, "STAT:");
         if(s) {
            s += 5;
            zpad(s,1);
            health = atoi(s);

            if     (health == 0) health = 2;
            else if(health == 1) health = 2;
            else                 health = 1;
         }

         s = strstr(nmea_msg, "DOP:");
         if(s) {
            s += 4;
            zpad(s,6);
            dop = atoi(s);
         }

         if((prn >= 1) && (prn <= MAX_PRN)) { 
            sat[prn].sig_level = (float) sat[prn].osa_snr;
            snr = sat[prn].osa_snr;
            if(sat[prn].osa_state == 8) {
               sat[prn].level_msg = 0x88;
               sat[prn].tracking = prn;
               have_snr |= rinex_gnss(prn);
            }
         }

      }
      else {
         get_msg_field();      // eat the line number

         if(get_msg_field()) prn = atoi(msg_field);
         if(get_msg_field()) el = atoi(msg_field);
         if(get_msg_field()) az = atoi(msg_field);
         if(get_msg_field()) snr = atoi(msg_field);
         if(get_msg_field()) {
            health = atoi(msg_field);
            if(strchr(msg_field, ';')) {  // end of list
               star_line = 0;
               star_msg = 0;
            }
         }
      }


      if((prn >= 1) && (prn <= MAX_PRN)) {  // save the info for sat prn
if(debug_file) fprintf(debug_file, "  star vis msg:%d  line:%d  prn:%d el:%d az:%d snr:%d health:%d\n", 
star_msg,star_line, prn,el,az,snr,health);
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].health_flag = health;  // 0=no_alm, 1=unhealthy, 2=healthy
         if((star_type == OSA_TYPE) && (dop != (-999))) {
            sat[prn].doppler = (double) dop;
            have_doppler |= rinex_gnss(prn);
         }
         have_sat_azel = 2;

         sat[prn].visible = 1;
         if(star_type != OSA_TYPE) { 
            sat[prn].sig_level = (float) snr;
            sat[prn].level_msg = 52;
            have_snr |= rinex_gnss(prn);
            record_sig_levels(prn);
         }
         level_type = "SNR";
      }
   }
   else if(get_msg_field()) {  // first line of vis message, setup to get the other lines
      star_msg = STAR_VIS_MSG;
      star_line = atoi(msg_field);
if(debug_file) fprintf(debug_file, "start star vis msg:%d  line:%d\n", star_msg,star_line);
      if(star_type == OSA_TYPE) {
         star_line = 12;
      }

      for(prn=0; prn<=MAX_PRN; prn++) { 
         sat[prn].visible = 0;
         sat[prn].level_msg = 0;
         if(star_type == OSA_TYPE) {
            sat[prn].tracking = 0;
         }
      }

      if(star_line == 0) {
         star_line = 0;
         star_msg = 0;
      }
   }
}


void parse_star_track()    
{
int prn;
int mode;
int snr;
char *s;

   // tracked sat info
   log_packet_id("Star tracking");

   prn = 0;
   mode = 0;
   snr = 0;
   if(star_line) {  // info lines
      --star_line;

      if(star_type == OSA_TYPE) {
         s = strstr(nmea_msg, "ID:");
         if(s) {
            s += 3;
            zpad(s, 2);
            prn = atoi(s);
         }

         s = strstr(nmea_msg, "MODE:");
         if(s) {
            s += 5;
            zpad(s, 1);
            mode = atoi(s);
         }

         s = strstr(nmea_msg, "S/N:");
         if(s) {
            s += 4;
            zpad(s, 3);
            snr = atoi(s);
         }

         if((prn >= 1) && (prn <= MAX_PRN)) {
            sat[prn].osa_snr = snr;
            sat[prn].osa_state = mode;
            sat[prn].state = mode;
            sat[prn].sig_level = (float) snr;
            sat[prn].level_msg = 52;
            sat[prn].visible = 1;
            if(have_state == 0) need_redraw = 2003;
            have_state = STAR_STATE;  // STATE

            if(snr) sat[prn].tracking = prn;
            else sat[prn].tracking = (-1);
            have_snr |= rinex_gnss(prn);
            record_sig_levels(prn);
         }

         if((star_line == 0) && (have_star_track == 0)) { // flush queues on first tracking info message
            new_queue(RESET_ALL_QUEUES, 1503);
         }
         have_star_track = 1;
      }
      else {
         get_msg_field();      // eat the line number
         if(get_msg_field()) { // sat PRN
            prn = atoi(msg_field);
            if((prn >= 1) && (prn <= MAX_PRN)) {
               sat[prn].tracking = prn;
            }
            if(strchr(msg_field, ';')) {  // end of list
               star_line = 0;
               star_msg = 0;
               if(have_star_track == 0) {
                  new_queue(RESET_ALL_QUEUES, 1502);
               }
               have_star_track = 1;
            }
         }
         else {
            star_line = star_msg = 0;
         }
      }
   }
   else if(star_type == OSA_TYPE) {  // first line of chan message
      star_line = 8;
      star_msg = STAR_TRACK_MSG;
      for(prn=0; prn<=MAX_PRN; prn++) {
         sat[prn].osa_snr = (-999);
         sat[prn].osa_state = (-999);
         sat[prn].visible = 0;
      }
      if(star_line == 0) {
         star_msg = 0;
      }
   }
   else if(get_msg_field()) {   // first line of STAR4 track message
      star_line = atoi(msg_field);
      star_msg = STAR_TRACK_MSG;
      reset_sat_tracking();

      sat_count = star_line;
      config_sat_count(sat_count);
      have_count = 40;

      if(star_line == 0) {
         star_msg = 0;
      }
   }
}


void parse_star_state()  
{
   // process the multi-line output state message
   log_packet_id("Star state");

   if(star_line) {  // info lines
      --star_line;
      get_msg_field();      // eat the line number
      if(get_msg_field()) {
         // !!!!!! get and process the info
         if(!strcmp(msg_field, "10M_S")) {      // sinewave output
            if(get_msg_field()) {
               if(strstr(msg_field, "OK")) {   
               }
               else {
                  discipline_mode = DIS_MODE_RECOVERY;
               }
               if(strchr(msg_field, ';')) {  // end of list
                  star_line = 0;
                  star_msg = 0;
               }
            }
         }
         else if(!strcmp(msg_field, "1PPS")) {  // 1PPS
            pps_enabled = 1;
            if(get_msg_field()) {
               if(strstr(msg_field, "OK")) {   
               }
               else {
                  discipline_mode = DIS_MODE_RECOVERY;
               }
               if(strchr(msg_field, ';')) {  // end of list
                  star_line = 0;
                  star_msg = 0;
               }
            }
         }
         else if(!strcmp(msg_field, "10M_L")) { // logic level output
            if(get_msg_field()) {
               if(strstr(msg_field, "OK")) {   
               }
               else {
                  discipline_mode = DIS_MODE_RECOVERY;
               }
               if(strchr(msg_field, ';')) {  // end of list
                  star_line = 0;
                  star_msg = 0;
               }
            }
         }
      }
   }
   else if(get_msg_field()) {  // first line of state message
      star_msg = STAR_STATE_MSG;
      star_line = atoi(msg_field);
   }
}


void parse_star_perf()
{
   // holdover performance

   log_packet_id("Star perf");
   if(get_msg_field()) {
      star_hold_perf = atoi(msg_field);  // 0=disable  1=enable
      have_star_perf = 1;
   }
}

void parse_star_wtr()
{
char *s;

   // wait to restore
   log_packet_id("Star WTR");

   if(get_msg_field()) {
      star_wtr = atoi(msg_field) * 10;
      have_star_wtr |= 0x01;
   }

   s = strchr(nmea_msg, '/');
   if(s) {
      ++s;
      zpad(s, 4);
      star_wtr_timer = atoi(s);
      have_star_wtr |= 0x02;
   }

   s = strchr(s, '/');
   if(s) { // !!!! 4531 aux timer
      ++s;
      zpad(s, 4);
      star_aux_timer = atoi(s);
      have_star_wtr |= 0x04;
   }
}

void set_star_hbsq(int secs)
{
   if(read_only) return;

   sprintf(out, "HBSQ=%d;", secs);
   queue_star_cmd(out, STAR_HBSQ_MSG);

   sprintf(out, "HBSQ;");
   queue_star_cmd(out, STAR_WTR_MSG);
}


void set_star_wtr(int secs)
{
   if(read_only) return;

   sprintf(out, "WTR=%d", secs/10);
   queue_star_cmd(out, STAR_WTR_MSG);

   sprintf(out, "WTR");
   queue_star_cmd(out, STAR_WTR_MSG);
}

void set_star_output(int mode)
{
   // !!!! 4531
   if(read_only) return;

   if(mode == 1) sprintf(out, "OUTPUT_TYPE=E1");
   else if(mode == 2) sprintf(out, "OUTPUT_TYPE=FR");
   else return;
   queue_star_cmd(out, STAR_OUTPUT_MSG);
   queue_star_cmd("OUTPUT_TYPE", STAR_OUTPUT_MSG);
}

void set_star_prior(int p1, int p2)
{
   // !!!! 4531
   if(read_only) return;

   sprintf(out, "PRIOR_TABLE=%d%d", p1, p2);
   queue_star_cmd(out, STAR_PRIOR_MSG);
   queue_star_cmd("PRIOR_TABLE", STAR_PRIOR_MSG);
}

void set_star_aux_inp(int c, int t)
{
   // !!!! 4531
   if(read_only) return;

   sprintf(out, "AUX_INPUT=%d%d", c, t);
   queue_star_cmd(out, STAR_AUX_MSG);
   queue_star_cmd("AUX_INPUT", STAR_AUX_MSG);
}

void set_star_adm(int gps, int aux)
{
   // !!!! 4531
   if(read_only) return;

   sprintf(out, "ADM_STATE=%d%d", gps, aux);
   queue_star_cmd(out, STAR_ADM_MSG);
   queue_star_cmd("ADM_STATE", STAR_ADM_MSG);
}

void clear_star_wtr()
{
   // clear wait to restore timer
   if(read_only) return;

   sprintf(out, "CLEAR_WTR_GPS");
   queue_star_cmd(out, STAR_CLEAR_GPS_MSG);
   if(osa_model != 4530) {
      sprintf(out, "CLEAR_WTR_AUX");
      queue_star_cmd(out, STAR_CLEAR_AUX_MSG);  // !!!! 4531
   }

   sprintf(out, "WTR");
   queue_star_cmd(out, STAR_WTR_MSG);
}

void parse_star_atdc()
{
   // atdc (automatic temperature and drift compensation) status
   log_packet_id("Star ATDC");

   if(get_msg_field()) {
      star_atdc_on = atoi(msg_field);  // 0=atdc active  1=atdc in progress
      have_star_atdc |= 0x01;
   }
   if(get_msg_field()) {
      star_atdc_time = atoi(msg_field); 
      have_star_atdc |= 0x02;
   }
}


void parse_star_temp()   
{
   // device temperature
   log_packet_id("Star temperature");

   if(get_msg_field()) {
      temperature = (float) atof(msg_field);
      have_temperature = 106;
   } 
}


void parse_star_tod()    
{
   // time-of-day output enable/disable (not on NEC GPSDO)
   log_packet_id("Star TOD");

   if(get_msg_field()) {
      if(strstr(msg_field, "OK")) ;
      else if(star_type == OSA_TYPE) {
         strupr(msg_field);
         if(strstr(msg_field, "E")) star_tod = 1;
         else if(strstr(msg_field, "D")) star_tod = 0;
         else star_tod = 2;
         have_pps_rate = 89;
         pps_enabled = 1;
      }
      else {
         star_tod = atoi(msg_field);  // 0=disable  1=enabke
         have_pps_rate = 88;
      }
   }
}


void parse_star_type()   
{
   // module type info
   log_packet_id("Star type");

   star_family[0] = star_variant[0] = 0;

   if(get_msg_field()) {
      msg_field[12] = 0;
      strcpy(star_family, msg_field);
   }

   if(get_msg_field()) {
      msg_field[12] = 0;
      strcpy(star_variant, msg_field);
   }
}


void parse_star_inv()    
{
   // hardware version info
   log_packet_id("Star inventory");

   if(star_type == OSA_TYPE) {
      msg_col = 5;     // index of next char to get from nmea buffer
      if(get_fixed_field(12)) {
         strcpy(star_module, msg_field);
         osa_model = atoi(star_module);
         if(set_al_mask) {  // set alarm mask the first time through here
            set_al_mask = 0;
            if(osa_model != 4530) queue_star_cmd("AL_MASK=0000000", STAR_ALMASK_MSG); // enable all alarms !!!! 4531
            else                  queue_star_cmd("AL_MASK=000000", STAR_ALMASK_MSG); // enable all alarms !!!! 4531
            queue_star_cmd("AL_MASK", STAR_ALMASK_MSG);
         }
      }
      if(get_fixed_field(12)) {
         strcpy(star_article, msg_field);
      }
      if(get_fixed_field(6)) {
         strcpy(star_commercial, msg_field);
      }
      if(get_fixed_field(5)) {
         strcpy(star_sn, msg_field);
      }
      if(get_fixed_field(2)) {  // layout version
         strcpy(star_layout, msg_field);
      }
      if(get_fixed_field(4)) {
         strcpy(star_fw, msg_field);
      }
      if(get_fixed_field(8)) {
         strcpy(star_test_date, msg_field);
      }
      if(get_fixed_field(8)) {  // reserved
      }
      if(get_fixed_field(4)) {
         strcpy(star_test_version, msg_field);
      }
      if(get_fixed_field(10)) {
         strcpy(star_osc, msg_field);
      }

      have_info |= ALL_ID_INFO;
   }
   else {
      if(get_msg_field()) {  // a: name of module (12 chars)
         msg_field[12] = 0;
         if(star_module[0] == 0) need_redraw = 5478;  // just got the inventory
         strcpy(star_module, msg_field);
         if(strstr(msg_field, "NEC")) star_type = NEC_TYPE;
         else star_type = STAR4_TYPE;
      }

      if(get_msg_field()) {  // b: article number (6 chars) 
         msg_field[6] = 0;
         strcpy(star_article, msg_field);
      }

      if(get_msg_field()) {  // c: serial number (6 chars) 
         msg_field[6] = 0;
         strcpy(star_sn, msg_field);
      }

      if(get_msg_field()) {  // d: hardware version (2 chars) 
         msg_field[2] = 0;
         strcpy(star_hw_ver, msg_field);
      }

      if(get_msg_field()) {  // e: firmware article (6 chars) 
         msg_field[6] = 0;
         strcpy(star_fw_article, msg_field);
      }

      if(get_msg_field()) {  // f: fw version
         msg_field[12] = 0;
         strcpy(star_fw, msg_field);
      }

      if(get_msg_field()) {  // g: date of test (ddmmyyyy)
         msg_field[8] = 0;
         strcpy(star_test_date, msg_field);
      }

      if(get_msg_field()) {  // h: test system version (4 chars) 
         msg_field[4] = 0;
         strcpy(star_test_version, msg_field);
      }

      if(get_msg_field()) {  // i: osc type (10 chars) 
         msg_field[10] = 0;
         strcpy(star_osc, msg_field);
      }

      if(get_msg_field()) {  // j: fpga version
         msg_field[12] = 0;
         strcpy(star_fpga, msg_field);
      }

      have_info |= ALL_ID_INFO;
   }
}


void parse_star_elmask()
{
float el_val;

   // antenna elevation mask
   log_packet_id("Star elmask");

   if(get_msg_field()) {
      el_val = (float) atof(msg_field);
      if((el_val >= 0.0) && (el_val <= 90.0)) {
         el_mask = el_val;
         have_el_mask = 1;
      }
   }
}


void parse_star_inp_type() 
{
   // input ref type: GPS or PPS (not on Star-4 ATDC devices)
   log_packet_id("Star input");

   if(get_msg_field()) {
      if(strstr(msg_field, "GPS")) {
         gpsdo_ref = 0;
         have_gpsdo_ref = 1;
      }
      else if(strstr(msg_field, "AUX")) {
         gpsdo_ref = 1;
         have_gpsdo_ref = 1;
      }
   }
}


void parse_star_alarm_mask()  
{
   // !!!! 4531
   log_packet_id("Star alarm mask");
}


void parse_star_mode()    
{
   // should never happen
   log_packet_id("Star mode");
}


void parse_star_tzone()
{
   // receiver time zone setting
   log_packet_id("Star timezone");
}


void parse_star_ok()    
{
   log_packet_id("Star OK");
   star_line = 0;
   star_msg = 0;
}


void parse_star_error()    
{
   log_packet_id("Star error");
   star_line = 0;
   star_msg = 0;
}



void decode_star_msg()
{
char c;
int i;
static int row = 0;
int time;


   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   if(strstr(nmea_msg, "TOD IS NOT VALID")) {  // use system clock if no gps time
      get_clock_time();
      time = (clk_hours*10000) + (clk_minutes*100) + clk_seconds;
      sprintf(nmea_msg, "$GPZDA,%06d,%02d,%02d,%04d,+00,00", time,clk_day,clk_month,clk_year);
//sprintf(debug_text, "fake time %02d:%02d:%02d:  %s", clk_hours,clk_minutes,clk_seconds, nmea_msg);
   }


   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);
   msg_col = 0;     // index of next char to get from nmea buffer

if(debug_file) fprintf(debug_file, "Decode STAR msg %d (m:%d l:%d etx:%d):[%s]\n", polled_msg_id, star_msg, star_line, saw_star_etx, nmea_msg);

if(saw_star_etx) {
   star_line = star_msg = 0;
   saw_star_etx = 0;
}
   if(star_msg && star_line) {  // getting multi-line response
      if     (star_msg == STAR_VIS_MSG) parse_star_vis();
      else if(star_msg == STAR_TRACK_MSG) parse_star_track();
      else if(star_msg == STAR_STATE_MSG) parse_star_state();
      else {
         star_line = star_msg = 0;
      }
      if(star_line == 0) {
         poll_next_star(1);
      }
      return;
   }
   else {
      star_line = star_msg = 0;
   }

   if(get_msg_field()) {  // get the STAR message type and parse it
      if     (!strcmp(msg_field, "ALARM"))            parse_star_alarm();
      else if(!strcmp(msg_field, "ALARM_MASK"))       parse_star_alarm_mask();
      else if(!strcmp(msg_field, "AL_MASK"))          parse_star_alarm_mask();
      else if(!strcmp(msg_field, "CONF"))             parse_star_conf();
      else if(!strcmp(msg_field, "GPS_TIME"))         parse_star_gps_time();
      else if(!strcmp(msg_field, "INPUT_TYPE(1)"))    parse_star_inp_type();
      else if(!strcmp(msg_field, "HBSQ"))             parse_star_hbsq();
      else if(!strcmp(msg_field, "INFO_GPS"))         parse_star_pos();
      else if(!strcmp(msg_field, "INV"))              parse_star_inv();
      else if(!strcmp(msg_field, "STATUS"))           parse_star_status();
      else if(!strcmp(msg_field, "TEMPERATURE"))      parse_star_temp();
      else if(!strcmp(msg_field, "TOD_STATE"))        parse_star_tod();
      else if(!strcmp(msg_field, "TYPE"))             parse_star_type();
      else if(!strcmp(msg_field, "MASK_ANGLE"))       parse_star_elmask(); 
      else if(!strcmp(msg_field, "ATDC_STATUS"))      parse_star_atdc(); 
      else if(!strcmp(msg_field, "HOLD_PERF_STATUS")) parse_star_perf(); 
      else if(!strcmp(msg_field, "UTC_OFFSET"))       parse_star_tzone(); 
      else if(!strcmp(msg_field, "WTR"))              parse_star_wtr(); 
      else if(!strcmp(msg_field, "PRIOR_TABLE"))      parse_star_prior();   // !!!! 4531
      else if(!strcmp(msg_field, "OUTPUT_TYPE"))      parse_star_output();  // !!!! 4531
      else if(!strcmp(msg_field, "AUX_INPUT"))        parse_star_aux_inp(); // !!!! 4531
      else if(!strcmp(msg_field, "ADM_STATE"))        parse_star_adm();     // !!!! 4531

      else if(!strcmp(msg_field, "INFO_VIS_SAT")) {    // multi-line response
         parse_star_vis();
         return;
      }
      else if(!strcmp(msg_field, "INFO_TRACK_SAT"))  { // multi-line response
         parse_star_track();
         return;
      }
      else if(!strcmp(msg_field, "INFO_CHAN"))  { // multi-line response
         parse_star_track();
         return;
      }
      else if(!strcmp(msg_field, "OUTPUT_STATE"))    { // multi-line response
         parse_star_state();
         return;
      }

      else if(!strcmp(msg_field, "$GPZDA")) {
start_fake_seconds(45);
         parse_gpzda(GPS); 
start_fake_seconds(45);
         if(pri_seconds == SCPI_STATUS_SECOND) {
            if(star_type == OSA_TYPE) { //OSA
               queue_star_cmd("INFO_GPS",      STAR_POS_MSG);   // !!! //OSA multi-line response
               queue_star_cmd("INFO_CHAN",     STAR_TRACK_MSG);   // !!! multi-line response
               queue_star_cmd("INFO_VIS_SAT;", STAR_VIS_MSG);     // !!! multi-line response
            }
         }
      }

      else if(!strcmp(msg_field, "MODE"))             parse_star_mode();   // !!!!!
      else if(!strcmp(msg_field, "PARAM_ERROR"))      parse_star_error();  // !!!!!
      else if(!strcmp(msg_field, "SYNTAX_ERROR"))     parse_star_error();  // !!!!!
      else if(!strcmp(msg_field, "UNKNOWN_CMD"))      parse_star_error();  // !!!!!
      else if(!strcmp(msg_field, "ERROR,"))           parse_star_error();  // !!!!!
      else if((msg_field[0] == 'O') && (msg_field[1] == 'K')) {
         parse_star_ok(); 
      }
   }

   poll_next_star(2);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }

   saw_rcvr_msg = 1;
   return;
}

void get_star_message()
{
u08 c;

   // This routine buffers up an incoming STAR4 message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_star_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(star_type == OSA_TYPE) {
      if(c == 0x03) {  // ETX
         if(star_line) saw_star_etx = 1;
         return;
      }
   }
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message
      tsip_wptr = 0;
      tsip_rptr = 0;
      if((c == 0x0A) || (c == 0x0D)) return;

      tsip_sync = 1;
      get_sync_time();
      goto star_msg;
   }
   else if(tsip_sync == 1) { // '$' has been seen, now build the message
      star_msg:
//    if((c == 0x0D) || (c == 0x0A)) goto star_end;  // message has no checksum
      if(c == 0x0D) return; // message has no checksum
      if(c == 0x0A) goto star_end;  // message has no checksum

      if(tsip_wptr < (MAX_TSIP-1)) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 3) {  // end of message
      star_end:
      decode_star_msg(); // process the message
      packet_end = 1;
      tsip_wptr = 0;     // prepare for next message
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
   }
}


//
//
//  Ublox receiver stuff
//
//

void set_ubx_rate(int id, int rate)
{
   // set periodic output rate for a UBX message
   if(read_only) return;

   send_ubx_start(UBX_SET_RATE, 3);
   send_byte((id >> 8) & 0xFF);
   send_byte(id & 0xFF);
   send_byte(rate);
   send_ubx_end();
}

void request_ubx_msg(int id)
{
   send_ubx_start(id, 0);
   send_ubx_end();
}


void parse_ubx_nak()
{
int id;

   log_packet_id("UBX_NAK");
   id = tsip_word();
}

void parse_ubx_ack()
{
int id;

   log_packet_id("UBX_ACK");
   id = tsip_word();
}

void parse_ubx_nav()
{
S32 msec;

   // get lat/lon/alt
   log_packet_id("UBX_NAV");

   msec = tsip_dword();
   lon = (double) (S32) tsip_dword();
   lat = (double) (S32) tsip_dword();
   alt = (double) (S32) tsip_dword();
   tsip_dword();
   tsip_dword();
   tsip_dword();

   lat = (lat / 1.0E7);
   lon = (lon / 1.0E7);
   alt = alt / 1000.0;

   lat = lat * PI / 180.0;
   lon = lon * PI / 180.0;
}

void parse_ubx_status()
{
int mode;

   // get receiver operating mode
   log_packet_id("UBX_STATUS");

   tsip_dword();  // tow
   mode = tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_double();

if(debug_file) fprintf(debug_file, "rcvr mode:%d\n", mode);

   if     (mode == 0) rcvr_mode = RCVR_MODE_ACQUIRE;
   else if(mode == 1) rcvr_mode = RCVR_MODE_UNKNOWN;  // dead reckoning
   else if(mode == 2) rcvr_mode = RCVR_MODE_2D;
   else if(mode == 3) rcvr_mode = RCVR_MODE_3D;
   else if(mode == 4) rcvr_mode = RCVR_MODE_3D;       // gps+dead reckonong
   else if(mode == 5) rcvr_mode = RCVR_MODE_HOLD;     // (time only fix)
   else               rcvr_mode = RCVR_MODE_UNKNOWN;
   have_rcvr_mode = 3;

   have_tracking = 1;
   if     (rcvr_mode == RCVR_MODE_NO_SATS) minor_alarms |= MINOR_NO_TRACK;
   else if(rcvr_mode == RCVR_MODE_2D_3D)   minor_alarms |= MINOR_NO_TRACK;
   else                                    minor_alarms &= (~MINOR_NO_TRACK);
}

void parse_ubx_clock()
{
S32 bias;
S32 drift;
u32 accu;
u32 freq;

   // get clock bias info  !!!! we need to do something with this
   log_packet_id("UBX_CLOCK");

   tsip_dword();  // tow
   bias = tsip_dword();
   drift = tsip_dword();
   accu = tsip_dword();
   freq = tsip_dword();
}

void parse_ubx_dop()
{
   // get DOP info
   log_packet_id("UBX_DOPPLER");

   tsip_dword();  // tow
   have_dops = 0;
   gdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // pdop
   pdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // pdop
   tdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // tdop
   vdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // tdop
   hdop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // tdop
   ndop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // tdop
   edop = ((DATA_SIZE) tsip_word()) / (DATA_SIZE) 100.0;   // tdop
   have_dops |= (GDOP | PDOP | TDOP | VDOP | NDOP | EDOP);
}

void parse_ubx_speed()
{
   // get course/speed info
   log_packet_id("UBX_SPEED");

   tsip_dword();  // tow
   tsip_dword();  
   tsip_dword();  
   tsip_dword();  
   speed = ((double) tsip_dword()) / 100.0;  // 3d speed
   tsip_dword();   // 2D speed
   heading = ((double) (S32) tsip_dword()) / 1.0E5;
   if(heading < 0.0) heading += 360.0;
   tsip_dword();  // speed accuracy
   tsip_dword();  // course accu

   have_speed = 15;
   have_heading = 15;
}

void parse_ubx_utc()
{
u32 gps_msec;
double accu;

   // get utc time
   log_packet_id("UBX_UTC");

   gps_msec = tsip_dword();
   pri_tow = tow = this_tow = (gps_msec / 1000);
   if(have_tow == 0) need_redraw = 2014;
   have_tow = 2;
   survey_tow = this_tow;
   accu = (double) tsip_dword();  // time error estimate in nanoseconds

   pri_frac = (double) (int) tsip_dword();  // !!!!!! can be negative
   pri_frac /= 1.0E9;
   raw_frac = pri_frac;

   pri_year = year = tsip_word();
   pri_month = month = tsip_byte();
   pri_day = day = tsip_byte();
   pri_hours = hours = tsip_byte();
   pri_minutes = minutes = tsip_byte();
   pri_seconds = seconds = tsip_byte();
   tsip_byte();  // validity flags

//if(log_file) fprintf(log_file, "  %02d:%02d:%02d.%f  %04d/%02d/%02d  tow:%d\n", 
//pri_hours,pri_minutes,pri_seconds, pri_frac, pri_year,pri_month,pri_day, tow); // zorky

   if(accu == (double) (u32) 0xFFFFFFFF) accu = 0.0;  // filter bogus power-up value
   pps_offset = (accu);
   have_pps_offset = 3;
   have_rcvr_pps = 3;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);

   osc_offset = pri_frac*1.0E9;
   have_osc_offset = 3;
   have_rcvr_osc = 3;
//adadad   if(jitter_adev == 0) do_osc_adev(osc_offset);

   time_flags |= TFLAGS_UTC;  // UTC based time
   have_timing_mode = 1;
   have_rcvr_tmode = 1;

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   update_gps_screen(1000);
}

void parse_ubx_gps()
{
int i;

   // get gps-utc offset info
   log_packet_id("UBX_GPS-UTC");

   tsip_dword();
   tsip_dword();
   gps_week = tsip_word();
   faked_tow = 0;
   i = (int) (s08) tsip_byte();
   if(!user_set_utc_ofs) utc_offset = i;
   tsip_byte();
   tsip_word();

   check_utc_ofs(3);

   if(have_week == 0) need_redraw = 2016;
   have_week = 2;
}

void parse_ubx_leap()
{
int i;
double a0, a1;
int tow;
int wnt;
int ls;
int wnf;
int dn;
int lsf;

   // calculate pending leapsecond info
   log_packet_id("UBX_LEAP");

   tsip_dword();
   a0 = tsip_double();
   a1 = tsip_double();
   tow = tsip_dword();
// pri_tow = this_tow = tow;
// if(have_tow == 0) need_redraw = 2017;
// have_tow = 3;
// survey_tow = tow;

   wnt = tsip_word();
   ls = tsip_word();
   wnf = tsip_word();
   dn = tsip_word();
   lsf = tsip_word();

   minor_alarms &= (~MINOR_LEAP_PEND);
   if(ls != lsf) {
      minor_alarms |= MINOR_LEAP_PEND;
   }
   have_leap_info = 2;
   calc_leap_days((double) wnf, dn, 11);

//sprintf(debug_text2, "ls:%d lsf:%d  dn:%d wnf:%d wnt:%d  ldays:%d", ls,lsf, dn,wnf,wnt, leap_days);

   for(i=34; i<72; i++) tsip_byte();
}

void parse_ubx_svn()
{
int chans;
int prn;
int flag;
int qual;
int sig;
int az;
int el;

   // get satellite position and signal info
   log_packet_id("UBX_SVIN");

   tsip_dword();  // tow
   chans = tsip_byte();
if(debug_file) fprintf(debug_file, "UBX_SVN chans:%d\n", chans);
   have_count = 50;
   tsip_byte();
   tsip_word();

   reset_sat_tracking();

   sat_count = 0;
   while(chans--) {
      tsip_byte();       // channel number
      prn = tsip_byte();
      flag = tsip_byte();
      qual = tsip_byte();
      sig = tsip_byte();
//sig += (sig/2);   // Ublox reports dBc levels that are around 50% less than most receivers
      el = tsip_byte();
      az = tsip_word();
      tsip_dword();      // pseudo range
if(0 && debug_file) fprintf(debug_file, "UBX_SVN %3d:: az:%-3d  el:%-3d  sig:%-3d  flag:%02X\n", prn, az,el, sig, flag);

//    if((az == 0) || (el == 0)) continue;

      if((prn >= 1) && (prn <= MAX_PRN)) {  
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].sig_level = (float) sig;
         sat[prn].level_msg = 3;
         sat[prn].sv_accuracy = 0.0F;
         sat[prn].state = qual;
         if(flag & 0x10) sat[prn].health_flag = 1;
         else            sat[prn].health_flag = 0;
         if(have_state == 0) need_redraw = 2033;
         have_state = UBX_STATE;
         have_snr |= rinex_gnss(prn);
         have_sat_azel = 3;

if(debug_file) fprintf(debug_file, "UBX_SVN %3d:  az:%-3d  el:%-2d  sig:%-2d  flag:%02X\n", prn, az,el, sig, flag);
         if(flag & 0x01) sat[prn].tracking = 1;
         else            sat[prn].tracking = (-1);

         record_sig_levels(prn);
         ++sat_count;
         have_count = 20;
      }
   }

   level_type = "dBc";
   config_sat_count(sat_count); 
}


void parse_ubx_raw()
{
int sats;
double carrier;
double range;
float doppler;
int prn;
int snr;
int lol;
int tow;
int week;
double meas_tow;
int xtow;

   // get doppler and code phase data (only on special receivers)
   log_packet_id("UBX_RAW");
   if(have_ubx_rawx) return;

   tow = tsip_dword();  // tow
   week = tsip_word();  // week
   sats = tsip_byte();

   meas_tow = ((double) tow) / 1000.0;
   if(1 || (nav_rate > 1.0)) {
      xtow = (int) (meas_tow*(double) nav_rate);  // raw Hz 
//sprintf(debug_text, "meas_tow:%.7ff  xtow=%d  ", meas_tow, xtow);  //rnx3
      if(xtow % (int) ((double)raw_msg_rate*nav_rate)) return;
   }

   obs_tow = meas_tow;
   jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   if(first_obs == 1) return;

   while(sats--) {
      tsip_byte();
      carrier = tsip_double();
      range = tsip_double();
      doppler = tsip_single();
      prn = tsip_byte();  // !!!! SVN?
      snr = tsip_byte();
      lol = tsip_byte();  // lock quality

      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].doppler = doppler;
         sat[prn].code_phase = carrier;
         sat[prn].range = range;


         sat[prn].ca_lli = 0;
         sat[prn].l1_lli = 0;
         sat[prn].l2_lli = 0;
         if(lol < 6) sat[prn].ca_lli |= LOCK_LOST;
//       sat[prn].sig_level = (float) snr;
//       sat[prn].level_msg = 4;
//       record_sig_levels(prn);

         have_snr |= rinex_gnss(prn);
         if(doppler != 0.0F) {
            if(have_doppler == 0) need_redraw = 2018;
            have_doppler |= rinex_gnss(prn);
         }
         if(range != 0.0F) {
            have_range |= rinex_gnss(prn);
         }
         if(carrier != 0.0F) {
            have_phase |= rinex_gnss(prn);
         }
      }
   }
}


void parse_ubx_rawx()
{
double meas_tow;
int ls;
int num_meas;
int rec_stat;
double carrier;
double range;
float doppler;
int gnssid;
int prn;
int snr;
int lli;
int week;
int xtow;

//sprintf(debug_text6, "rawx");
   log_packet_id("UBX_RAWX");
   have_ubx_rawx = 1;

   // get doppler and code phase data (only on special receivers)

   meas_tow = tsip_double(); // measurement tow
   week = tsip_word();  // week

   if(raw_msg_rate == 0) return; 

   if(1 || (nav_rate > 1.0)) {
      xtow = (int) (meas_tow*(double) nav_rate);  // raw Hz 
//    sprintf(debug_text, "meas_tow:%.7f  xtow=%d", meas_tow, xtow);  // rnx3
      if(xtow % (int) ((double)raw_msg_rate*nav_rate)) return;
   }

   obs_tow = meas_tow;
   jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);


   ls = tsip_byte();  // leap seconds
   num_meas = tsip_byte();
   rec_stat = tsip_byte();
   tsip_byte();
   tsip_byte();    // reserved
   tsip_byte();
if(0 && debug_file) fprintf(debug_file, "RAWX num_meas:%d  rec_stat:%d\n",num_meas, rec_stat); //rnx3

   while(num_meas--) {
      range = tsip_double();
      carrier = tsip_double();
      doppler = tsip_single();

      gnssid = tsip_byte();   // sat system code
      prn = tsip_byte();      // SVN
      tsip_byte();            // reserved
      tsip_byte();            // glonass freq id
      tsip_word();            // carrier phase locktime counter
      snr = tsip_byte();      // sig level
      tsip_byte();            // peudorange sdev
      lli = tsip_byte();      // carrier phase sdev
      tsip_byte();            // doppler sdev
      tsip_byte();            // stacking status bitfield
      tsip_byte();            // reserved

//carrier = rinex_cppr(prn, range, carrier);  // testing CPPR mode - which makes things worse
//lli = 0;
//if(debug_file) fprintf(debug_file, "prn:%-2d  pr:%.3f  cppr:%.3f\n", prn,range,carrier);

      // convert gnssid:svn to equivalent prn
if(0 && debug_file) fprintf(debug_file, "RAWX gnssid:%d  svn:%2d->", gnssid,prn); //rnx3
      if(gnssid == 0) {       // GPS
      }
      else if(gnssid == 1) {  // SBAS
      }
      else if(gnssid == 2) {  // Galileo
         prn += 210;
      }
      else if(gnssid == 3) {  // Beidou
         if(prn < 6) prn += 158;     // 1..5
         else        prn += (33-6);  // 33..64
      }
      else if(gnssid == 4) {  // IMES
         prn += 172;  // 173..182
         continue;    // does not do raw data
      }
      else if(gnssid == 5) {  // QZSS
         prn += 192;
      }
      else if(gnssid == 6) {  // GLONASS
         if(prn == 255) continue;  // undetermined prn, ignore
         prn += 64;
      }
      else continue;

      if((prn >= 1) && (prn <= MAX_PRN)) { 
if(0 && debug_file) fprintf(debug_file, "%3d (%04X) range:%f carrier:%f  dop:%f\n", prn,rinex_gnss(prn), range,carrier,doppler);
         sat[prn].doppler = doppler;
         sat[prn].code_phase = carrier;
         sat[prn].range = range;

         sat[prn].ca_lli = 0;
         sat[prn].l1_lli = 0;
         sat[prn].l2_lli = 0;
         if(lli == 0x0F) sat[prn].ca_lli |= LOCK_LOST;  // loss of lock
//       sat[prn].sig_level = (float) snr;
//       sat[prn].level_msg = 4;
//       record_sig_levels(prn);

         have_snr |= rinex_gnss(prn);
         if(doppler != 0.0F) {
            if(have_doppler == 0) need_redraw = 2018;
            have_doppler |= rinex_gnss(prn);
         }
         if(range != 0.0) {
            have_range |= rinex_gnss(prn);
         }
         if(carrier != 0.0) {
            have_phase |= rinex_gnss(prn);
         }
      }
   }
if(0 && debug_file) fprintf(debug_file, "have dop:%04X  phase:%04X  range:%04X\n", have_doppler,have_phase,have_range);
}

void parse_ubx_orb()
{
   log_packet_id("UBX_ORB");
}

void parse_ubx_sbas()
{
   log_packet_id("UBX_SBAS");
}

void parse_ubx_sfrb()
{
   log_packet_id("UBX_SFRB");
}

void parse_ubx_sfrbx()
{
   log_packet_id("UBX_SFRBX");
}

void parse_trk_sfrbx()
{
   log_packet_id("UBX_TRK_SFRBX");
}

void parse_ubx_sol()
{
   log_packet_id("UBX_SOL");
}

void parse_trk_meas()
{
//sprintf(debug_text6, "meas");
   log_packet_id("UBX_MEAS");
}


void parse_ubx_mon()
{
int i;
u08 ant;
u08 ant_pwr;

   // used to get antenna power monitor info
   log_packet_id("UBX_MON");

   for(i=0; i<20; i++) tsip_byte();
   ant = tsip_byte();
   ant_pwr = tsip_byte();
   for(i=22; i<=59; i++) tsip_byte(); 

   minor_alarms &= (~MINOR_ANT_NO_PWR);
   if     (ant == 2);                             // ok
   else if(ant == 3)     minor_alarms |= MINOR_ANT_SHORT;  // short
   else if(ant == 4)     minor_alarms |= MINOR_ANT_OPEN;   // open
   else if(ant_pwr == 0) minor_alarms |= MINOR_ANT_NO_PWR; // no power
   have_antenna = 1;
//sprintf(plot_title, "ant state:%02X  pwr:%02X", ant, ant_pwr);
}

void parse_ubx_ant()
{
u16 a1, a2;

   log_packet_id("UBX_ANT");
   a1 = tsip_word();
   a2 = tsip_word();
}


void set_ubx_config(int mode, double slat,double slon,double salt)
{
   if(read_only) return;

   lla_to_ecef(slat, slon, salt);

   if((have_ubx_tmode == 0) || (have_ubx_tmode == 1)) {
      send_ubx_start(UBX_CFG_TMODE, 28);
      send_dword((u32) mode);
      send_dword((S32) (ecef_x*100.0));
      send_dword((S32) (ecef_y*100.0));
      send_dword((S32) (ecef_z*100.0));
      if(mode == 1) {
         send_dword(50000);       // fixed posn variance
         send_dword(do_survey);   // min survey time
         send_dword(0xFFFFFFFF);  // survey stop required variance (mm^2)
      }                           // ... we set to max value so survey is based only on time
      else {
         send_dword(0);   // fixed posn variance
         send_dword(0);   // min survey time
         send_dword(0);   // survey stop required variance (mm^2)
      }
      send_ubx_end();

      request_ubx_msg(UBX_CFG_TMODE);
   }


   // M8T survey / timing mode
   if((have_ubx_tmode == 0) || (have_ubx_tmode == 2)) {
      send_ubx_start(UBX_CFG_TMODE2, 28);
      send_dword((u32) mode);
      send_dword((S32) (ecef_x*100.0));
      send_dword((S32) (ecef_y*100.0));
      send_dword((S32) (ecef_z*100.0));
      if(mode == 1) {
         send_dword(50000);       // fixed posn variance
         send_dword(do_survey);   // min survey time
         send_dword(0xFFFFFFFF);  // survey stop required variance (mm^2)
      }                           // ... we set to max value so survey is based only on time
      else {
         send_dword(0);   // fixed posn variance
         send_dword(0);   // min survey time
         send_dword(0);   // survey stop required variance (mm^2)
      }
      send_ubx_end();

      request_ubx_msg(UBX_CFG_TMODE2);
   }
}

void parse_ubx_tmode(int tmode)
{
u32 mode;
u32 slen;

   // also UBX_TMODE2 for M8T
   log_packet_id("UBX_TMODE");

   saw_timing_msg |= 0x02;
   have_ubx_tmode = tmode;

   mode = tsip_dword();
   tsip_dword();
   tsip_dword();
   tsip_dword();
   tsip_dword();   // fixed posn variance
   slen = tsip_dword();   // min survey time
   tsip_dword();   // survey stop required variance (mm^2)

   if(mode == 1) {
      minor_alarms |= MINOR_SURVEY;
      do_survey = (long) slen;
      survey_why = 10;
   }
   else {
      minor_alarms &= (~MINOR_SURVEY);
      if(precision_survey == 0) {
         do_survey = 0;
         survey_why = (-10);
      }
   }
}

void parse_ubx_svin()
{
u32 dur;        // current duration of survey
double ecef_x;
double ecef_y;
double ecef_z;
u32 obs;        // number of observations used
u08 valid;
u08 active;
u32 rsvd;

   log_packet_id("UBX_SVIN");
   saw_timing_msg |= 0x01;

   dur = tsip_dword();  // dur
   ecef_x = (double) (S32) tsip_dword();
   ecef_y = (double) (S32) tsip_dword();
   ecef_z = (double) (S32) tsip_dword();
   ubx_svar = tsip_dword();  // var
   obs = tsip_dword();   // observation count
   valid = tsip_byte();
   active = tsip_byte(); 
   rsvd  = tsip_word();

   if(do_survey) survey_progress = (int) ((100 * dur) / do_survey);  // !!!! use obs instead of dur?
   else          survey_progress = 0;
   have_progress = 3;
//sprintf(plot_title, "obs:%d  dur:%d  svar:%d  progress:%d  act:%d  valid:%d", 
//obs,dur,ubx_svar,survey_progress, active,valid);  // zorky
}

void set_ubx_antenna(u08 mode)
{ 
   if(read_only) return;

   send_ubx_start(UBX_CFG_ANT, 4);
   send_word(mode);
   send_word(0x0000);  // dont re-config pins - LEA-5T has a98b
   send_ubx_end();
}

void parse_ubx_navx5()
{
   log_packet_id("UBX_NAVX5");
   have_amu = 1;

   tsip_word();      // msg version
   tsip_word(); // update amu mask 
   tsip_dword();
   tsip_byte();      // rsvd
   tsip_byte();      // rsvd
   tsip_byte();      // min sv's
   tsip_byte();      // max sv'ss
   amu_mask = (float) tsip_byte();
   tsip_byte();      // rsvd
   tsip_byte();      // initial fix
   tsip_byte();      // rsvd
   tsip_byte();      // rsvd
   tsip_byte();      // rsvd
   tsip_word();      // rollover week
   tsip_dword();     // rsvd
   tsip_dword();     // rsvd
   tsip_dword();     // rsvd
   tsip_dword();     // rsvd
   tsip_dword();     // rsvd
}

void set_ubx_amu(float amu)
{
   if(read_only) return;

   send_ubx_start(UBX_NAVX5, 40);

   send_word(0);      // msg version
   send_word(0x0008); // only update amu mask 
   send_dword(0);
   send_byte(0);      // rsvd
   send_byte(0);      // rsvd
   send_byte(1);      // min sv
   send_byte(16);     // max sv
   send_byte((s08) amu);
   send_byte(0);      // rsvd
   send_byte(0);      // initial fix
   send_byte(0);      // rsvd
   send_byte(0);      // rsvd
   send_byte(0);      // rsvd
   send_word(0);      // rollover week
   send_dword(0);     // rsvd
   send_dword(0);     // rsvd
   send_dword(0);     // rsvd
   send_dword(0);     // rsvd
   send_dword(0);     // rsvd

   send_ubx_end();
}


void parse_ubx_ver()
{
int i;
int line;

   // note: docs say the message is 70+ bytes long, we only see 40 bytes
   // on a NEO-6M
   log_packet_id("UBX_VER");

   saw_version |= 0x100;

   for(i=0; i<30; i++) {  // sw version
      ubx_sw[i] = tsip_byte();
   }
ubx_sw[21] = 0;  // trim it so info fits on screen
   if(ubx_sw[0]) ubx_fw_ver = (float) atof(ubx_sw);
   else          ubx_fw_ver = (float) atof(ubx_sw);

   for(i=0; i<10; i++) {  // hw vers
      ubx_hw[i] = tsip_byte();
   }
   ubx_hw[9] = 0;

   for(line=0; line<UBX_ROM_INFO; line++) {  // clear rom version info
      ubx_rom[line][0] = 0;
   }

   for(line=0; line<UBX_ROM_INFO; line++) {  // get rom version info
      if(tsip_error) {  // past end of message
         break;
      }

      for(i=0; i<30; i++) {   // rom version (not on NEO-6M)
         ubx_rom[line][i] = tsip_byte();
         if(tsip_error) {
            ubx_rom[line][0] = 0;
            break;
         }
      }
      ubx_rom[line][30] = 0;
   }

   have_info |= ALL_ID_INFO;

// show_version_info();
}

void parse_ubx_datum()
{
   log_packet_id("UBX_DATUM");
   datum = (int) tsip_word();
   have_datum = 1;
   // !!!! ignore the rest of the message for now
}

void parse_ubx_cfg()
{
int fix;  // 1=2D  2=3D  3=2D/3D
int el;
int i;

   log_packet_id("UBX_CFG");

   tsip_word();
   tsip_byte();
   fix = tsip_byte();
   for(i=4; i<12; i++) tsip_byte();
   el = tsip_byte();
   // ignore bytes 13..35

   el_mask = (float) el;
   have_el_mask = 1;
}

void set_ubx_nav_rate(DATA_SIZE rate, int align)
{
   if(read_only) return;

   send_ubx_start(UBX_NAV_RATE, 6);
   send_word((u16) rate);  // in msecs
   send_word(1);
   send_word(align);
   send_ubx_end();
}


void parse_ubx_pps()
{
u08 status;
u08 flags;
u08 rsvd;
u32 rate;
u32 width;

   // get timepulse1 info
   log_packet_id("UBX_TP1");
   saw_ubx_tp = 1;

   rate = tsip_dword();  // interval in usec
   if     (rate == 1000000) pps_rate = RATE_1PPS;    // 1pps
   else if(rate == 10000)   pps_rate = RATE_100PPS;  // 100 pps
   else if(rate == 1000)    pps_rate = RATE_1000PPS; // 1000 pps
   else                     pps_rate = RATE_USER;    // user defined rate
   have_pps_rate = 3;
//sprintf(debug_text, "ubxpps: rate:%d", rate);

   width = tsip_dword();  // width in us

   status = tsip_byte();
   if(status == 0) pps_enabled = 0;
   else {
      pps_enabled = 1;
      if(status & 0x80) pps_polarity = 1; // falling
      else              pps_polarity = 0; // rising
      have_pps_polarity = 2;
   }
   have_pps_enable = 2;

   tsip_byte();   // align 0=UTC 1=GPS 2=LOCAL
   flags = tsip_byte();  // 1=always on, 0=when tracking
   rsvd = tsip_byte();   // rsvd

   cable_delay = (double) (s16) tsip_word();
   cable_delay /= 1.0E9;
// if(have_cable_delay == 0) need_redraw = 2020;
   have_cable_delay = 1;

   tsip_word();   // rf group delay
   pps1_delay = (double) (S32) tsip_dword();
   have_pps_delay |= 0x01;

   show_cable_delay();
// sprintf(debug_text2, "UBXPPS: rate:%d  width:%d  ofs:%f  mode:%d flags:%d rcvd:%02X", rate,width, pps1_delay, status,flags,rsvd);
}


void request_ubx_tp5(int chan)
{
   if(no_poll) return;

   send_ubx_start(UBX_TP5, 1);
   send_byte(chan);
   send_ubx_end();
}

void parse_ubx_tp5()
{
u08 chan;
u32 freq;
u32 lfreq;
u32 duty;
u32 lduty;
S32 dly;
u32 flags;

   log_packet_id("UBX_TP5");

   chan = tsip_byte();     // output number (0 / 1)
   tsip_byte();            // rsvd
   tsip_word();            // rsvd

   cable_delay = (double) (s16) tsip_word();
   cable_delay /= 1.0E9;
// if(have_cable_delay == 0) need_redraw = 2021;
   have_cable_delay = 1;

   tsip_word();            // signed RF delay(ns)
   freq = tsip_dword();    // freq / period
   lfreq = tsip_dword();   // gps locked freq/period
   duty = tsip_dword();    // width / duty cycle
   lduty = tsip_dword();   // gps locked width / duty cycle
   dly = tsip_dword();     // time pulse delay (ns)
   flags = tsip_dword();   // flags

   if(chan) {  // pps2
      saw_ubx_tp5 |= 2;
      pps2_freq = freq;
      pps2_duty = ((double) duty) / (double) (u32) 0xFFFFFFFF;
      pps2_delay = (double) dly;
      pps2_flags = flags;
      have_pps_duty |= 0x02;
      have_pps_freq |= 0x02;
      have_pps_delay |= 0x02;
   }
   else {  // pps1
      saw_ubx_tp5 |= 1;
      pps1_freq = (double) freq;
      pps1_duty = ((double) duty) / (double) (u32) 0xFFFFFFFF;
      pps1_delay = (double) dly;
      pps1_flags = flags;
      have_pps_duty |= 0x01;
      have_pps_freq |= 0x01;
      have_pps_delay |= 0x01;

      if(pps1_flags & 0x0001) pps_enabled = 1;
      else                    pps_enabled = 0;
      have_pps_enable = 3;

      if(pps1_flags & 0x0040) pps_polarity = 0;
      else                    pps_polarity = 1;
      have_pps_polarity = 3;

      if(pps1_freq == 100)       pps_rate = RATE_100PPS;
      else if(pps1_freq == 1000) pps_rate = RATE_1000PPS;
      else if(pps1_freq == 1)    pps_rate = RATE_1PPS;
      else                       pps_rate = RATE_USER;  // user defined rate
      have_pps_rate = 4;
//sprintf(debug_text2, "ubxtp5: rate:%d freq:%g duty:%g  flags:%04X  enbl:%d pol:%d", pps_rate, pps1_freq, pps1_duty, pps1_flags, pps_enabled, pps_polarity);
   }

   show_cable_delay();

//if(chan == 0) { // dddd
//   sprintf(plot_title, "f:%d  lf:%d  d:%d  ld:%d  dly:%d  flags:%08X", freq,lfreq,duty,lduty, dly, flags);
//}
//else {
//   sprintf(debug_text, "f:%d  lf:%d  d:%d  ld:%d  dly:%d  flags:%08X", freq,lfreq,duty,lduty, dly, flags);
//}
}


void set_ubx_pps(int chan, u08 pps_rate, u08 pps_enable,  u08 pps_polarity,  double delay, double pps_delay, int save)
{
   if(read_only) return;

   if(saw_ubx_tp5) {
      if(pps_enable == 0) {
//sprintf(debug_text2, "pps disable:%02X  tp5:%02X", pps_rate, saw_ubx_tp5); 
         set_pps_freq(chan, 0.0, 0.10, pps_polarity, delay, pps_delay, save);
      }
      else {
         if(pps_rate == RATE_100PPS) {  // 100 hz
            set_pps_freq(chan, 100.0, 0.10, pps_polarity, delay, pps_delay, save);
         }
         else if(pps_rate == RATE_1000PPS) { // 1000 Hz
            set_pps_freq(chan, 1000.0, 0.10, pps_polarity, delay, pps_delay, save);
         }
         else {
            set_pps_freq(chan, 1.0, 0.10, pps_polarity, delay, pps_delay, save);
         }
//sprintf(debug_text2, "pps enable:%02X  tp5:%02X", pps_rate, saw_ubx_tp5);
      }
   }
   else {
      send_ubx_start(UBX_PPS, 20);

      if(pps_rate == RATE_100PPS) {
         send_dword(10000);    // 100 pps
         send_dword(100);      // 100 us width
      }
      else if(pps_rate == RATE_1000PPS) {
         send_dword(1000);     // 1000 pps
         send_dword(500);      // 500 us width
      }
      else {
         send_dword(1000000);  // 1 sec
         send_dword(10000);    // 10 msec width
      }

      if(pps_enable == 0)   send_byte(0);    // pulse off
      else if(pps_polarity) send_byte(0xFF); // neg pulse
      else                  send_byte(1);    // pos pulse

      if(time_flags & TFLAGS_UTC) send_byte(0);  // align to UTC
      else                        send_byte(1);  // align to GPS

      send_byte(1);  // always on

      send_byte(0);  // rsvd

      send_word((s16) (delay*1.0E9));
      send_word(0);  // rf delay
      send_dword((S32) pps_delay);

      send_ubx_end();
   }


   if(save) save_segment(6, 28);  // save PPS timing config in EEPROM

   if(saw_ubx_tp5) request_ubx_tp5(chan);
   else if(chan == 0) request_ubx_msg(UBX_PPS);
}


void set_pps_freq(int chan, double freq, double duty, int polarity, double cable_delay, double pps_delay, int save)
{
u32 flags;
u32 val;
int i;

   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      if(freq <= 11.0) freq *= 1.0E6;
      set_cs_freq(chan+1, freq);
   }
   else if((rcvr_type == ESIP_RCVR) && (chan == 1)) {  // GCLK
      if((freq == 0.0) || (duty == 0.0)) {
         sprintf(out, "PERDAPI,FREQ,0,%d,%d,0", (int) pps2_freq, (int) (pps2_duty*100.0));
      }
      else {
         sprintf(out, "PERDAPI,FREQ,1,%d,%d,0", (int) freq, (int) (duty*100.0));
      }
      send_esip_cmd(out);
      if(save) save_segment(129, 87);
      request_rcvr_config(8787);
   }
   else if(rcvr_type == NVS_RCVR) {
      if(chan != 0) return;
      if(freq <= 0.0) return;
      freq = 1.0;  // can only do 1pps

      val = nvs_pps_width;
      nvs_pps_width = (u32) ((1.0E9 / freq) * duty);
//sprintf(debug_text, "nvs set width: %d ns", nvs_pps_width);
      set_pps(user_pps_enable, polarity,  cable_delay, pps1_delay,  pps_threshold, 45);
      nvs_pps_width = val;
   }
   else if(rcvr_type == TM4_RCVR) {
      if     (chan == 0) sprintf(out, "#09,%d", (int) freq);
      else if(chan == 1) sprintf(out, "#14,%d", (int) freq); 
      else return;
      send_tm4_cmd(out);
   }
   else if(rcvr_type == UBX_RCVR) {
      if(saw_ubx_tp5 == 0) return;

      send_ubx_start(UBX_TP5, 32);

      send_byte(chan); // output number (0 / 1)
      send_byte(0);    // rsvd
      send_word(0);    // rsvd
      send_word((s16) (cable_delay*1.0E9));
      send_word(0);    // rf delay

      flags = 0x0001;     // enable PPS
      if(freq <= 0.0) {
         flags = 0x0000;  // disable PPS
         freq = 1.0;
      }

      if(duty <= 0.0) duty = 0.500;
      else if(duty >= 100.0) duty = 0.500;
      val = (u32) (duty * (double) 0xFFFFFFFFU);

      send_dword((u32) freq); // freq / period
      send_dword((u32) freq); // gps locked freq/period

      send_dword(val); // ratio / duty cycle
      send_dword(val); // gps locked ratio / duty cycle

      send_dword((S32) pps_delay);

      flags |= 0x0001;  // !!!! pulse active
      flags |= 0x0002;  // sync to GPS
      flags |= 0x0004;  // !!!! enable alt values if not locked to GPS

      flags |= 0x0008;  // 1=freq mode         0=rate mode
//    flags |= 0x0010;  // 1=pulse width mode  0=duty cycle mode
      flags |= 0x0020;  // !!!! align pulse to TOW
      if(polarity == 0) flags |= 0x0040;   // flag bit: 1=rising edge  0=falling edge
      if((time_flags & TFLAGS_UTC) == 0) flags |= 0x0080;  // sync to GPS time

// !!!!! bits 8/9/10/11 are what GNSS time system to use !!!!!
//       0=UTC 1=GPS 2=GLONASS 3=BEIDOU 4=GALILEO
// !!!!! bits 12/13/14 are how to sync time

      send_dword(flags);    // flags

      send_ubx_end();

// sprintf(plot_title, "SETPPS %d: %lf %lf flags:%08X", chan, freq, duty, flags); 

      if(save) save_segment(6, 29);

      if(saw_ubx_tp5) request_ubx_tp5(chan);
      else            request_ubx_msg(UBX_PPS);
   }
   else if(rcvr_type == VENUS_RCVR) {
//    if(chan != 0) return;
      if(freq <= 0.0) return;

      send_venus_start(SET_VENUS_FREQ);
      send_byte(3);
      send_dword((u32) freq);
      send_venus_save(1);

      if(duty > 0.0) {
         val = (u32) ((1.0E6 / freq) * duty);
         send_venus_start(SET_VENUS_WIDTH);
         send_byte(1);
         send_dword(val);
         send_venus_save(1);
      }
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(duty == (-1.0)) i = (-1);
      else if(duty == (-2.0)) i = (-2);
      else i = (int) duty;
      sprintf(out, "$PULW,%d", i);
      send_zyfer_cmd(out);
   }
}

void parse_ubx_tp()
{
u32 tow;
u32 subms;
S32 quant;
u16 week;
u08 flags;
u08 rsvd;

   log_packet_id("UBX_TP");

   tow = tsip_dword();
   subms = tsip_dword();
   quant = (S32) tsip_dword();
   week = tsip_word();
   flags = tsip_byte();
   rsvd = tsip_byte();

   have_sawtooth = 1;
   dac_voltage = ((float) quant) / 1000.0F;
}


void parse_ubx_rate()
{
int rate;

   log_packet_id("UBX_RATE");

   rate = tsip_word();
   tsip_word();
   tsip_word();

   if(rate > 0) {
      if(!pause_data) {
         nav_rate = 1000.0F / (float) rate;
         have_nav_rate = 1;
      }
   }
}

void parse_ubx_gnss()
{
int hw_chans;
int use_chans;
int blocks;
int id;
int min_chans;
int max_chans;
u32 flags;

   log_packet_id("UBX_GNSS");

   tsip_byte();  // msg version
   hw_chans = tsip_byte();
   use_chans = tsip_byte();
   blocks = tsip_byte();
//sprintf(debug_text2, "GNSS info hw_chans:%d  use:%d  blocks:%d", hw_chans,use_chans,blocks);

   if(blocks == 0) return;

   gnss_mask = 0x0000;
   have_gnss_mask = 1;
   while(blocks--) {
      id = tsip_byte();
      min_chans = tsip_byte();
      max_chans = tsip_byte();
      tsip_byte();  // reserved
      flags = tsip_dword();

      if(id == 0) {       // GPS
         if(flags & 0x0001) gnss_mask |= GPS;
      }
      else if(id == 1) {  // SBAS
         if(flags & 0x0001) gnss_mask |= SBAS;
      }
      else if(id == 2) {  // GALILEO
         if(flags & 0x0001) gnss_mask |= GALILEO;
      }
      else if(id == 3) {  // Beidou
         if(flags & 0x0001) gnss_mask |= BEIDOU;
      }
      else if(id == 4) {  // IMES
         if(flags & 0x0001) gnss_mask |= IMES;
      }
      else if(id == 5) {  // QZSS
         if(flags & 0x0001) gnss_mask |= QZSS;
      }
      else if(id == 6) {  // GLONASS
         if(flags & 0x0001) gnss_mask |= GLONASS;
      }

if(0 && debug_file) {
   fprintf(debug_file, "gnss blk:%d  hw:%d use:%d  id:%d min:%d max:%d flags:%08X  mask:%04X\n", 
   blocks, hw_chans, use_chans, id,min_chans,max_chans,flags, gnss_mask);
}
   }
// sprintf(debug_text2, "GNSS got mask:%04X", gnss_mask);
}


void ignore_ubx_msg(int id)
{
   sprintf(out, "UBX_IGNORED: 0x%04X", id);
   log_packet_id(out);
}

void decode_ubx_msg()
{
static int ubx_bytes = 0;  // how many bytes received between time messages
   // Here we decode and parse Ublox UBX format messages

   start_msg_decode(1);
if(ubx_msg_id == UBX_UTC) ubx_bytes = (tsip_wptr+8);
else ubx_bytes += (tsip_wptr+8);
if(ubx_bytes > max_ubx_bytes) max_ubx_bytes = ubx_bytes;
if(1 && debug_file) {  //plugh
   fprintf(debug_file, "Decode UBX: %04X  len:%-3d  bytes:%-4d  max:%-4d\n", ubx_msg_id,tsip_wptr+8, ubx_bytes, max_ubx_bytes);
}

   if     (ubx_msg_id == UBX_NAV)        parse_ubx_nav();
   else if(ubx_msg_id == UBX_STATUS)     parse_ubx_status();
   else if(ubx_msg_id == UBX_CLOCK)      parse_ubx_clock();
   else if(ubx_msg_id == UBX_DOP)        parse_ubx_dop();
   else if(ubx_msg_id == UBX_SPEED)      parse_ubx_speed();
   else if(ubx_msg_id == UBX_UTC)        parse_ubx_utc();
   else if(ubx_msg_id == UBX_GPS)        parse_ubx_gps();
   else if(ubx_msg_id == UBX_SVN)        parse_ubx_svn();
   else if(ubx_msg_id == UBX_RAW)        parse_ubx_raw();
   else if(ubx_msg_id == UBX_RAWX)       parse_ubx_rawx();
   else if(ubx_msg_id == UBX_SBAS)       parse_ubx_sbas();
   else if(ubx_msg_id == UBX_ORB)        parse_ubx_orb();
   else if(ubx_msg_id == UBX_SOL)        parse_ubx_sol();
   else if(ubx_msg_id == UBX_SFRBX)      parse_ubx_sfrbx();
   else if(ubx_msg_id == UBX_SFRB)       parse_ubx_sfrb();
   else if(ubx_msg_id == TRK_SFRBX)      parse_trk_sfrbx();
   else if(ubx_msg_id == TRK_MEAS)       parse_trk_meas();
   else if(ubx_msg_id == UBX_PPS)        parse_ubx_pps();
   else if(ubx_msg_id == UBX_TP)         parse_ubx_tp();
   else if(ubx_msg_id == UBX_TP5)        parse_ubx_tp5();
   else if(ubx_msg_id == UBX_GNSS)       parse_ubx_gnss();
   else if(ubx_msg_id == UBX_CFG)        parse_ubx_cfg();
   else if(ubx_msg_id == UBX_MON)        parse_ubx_mon();
   else if(ubx_msg_id == UBX_VER)        parse_ubx_ver();
   else if(ubx_msg_id == UBX_LEAP)       parse_ubx_leap();
   else if(ubx_msg_id == UBX_DATUM)      parse_ubx_datum();
   else if(ubx_msg_id == UBX_NAK)        parse_ubx_nak();
   else if(ubx_msg_id == UBX_ACK)        parse_ubx_ack();
   else if(ubx_msg_id == UBX_CFG_ANT)    parse_ubx_ant();
   else if(ubx_msg_id == UBX_NAVX5)      parse_ubx_navx5();
   else if(ubx_msg_id == UBX_CFG_TMODE)  parse_ubx_tmode(1);
   else if(ubx_msg_id == UBX_CFG_TMODE2) parse_ubx_tmode(2);  // M8T
   else if(ubx_msg_id == UBX_NAV_RATE)   parse_ubx_rate();
   else if(ubx_msg_id == UBX_SVIN)       parse_ubx_svin();
   else                                  ignore_ubx_msg(ubx_msg_id);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_ubx_message()
{
u08 c;

   // This routine buffers up an incoming UBX message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_ubx_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }


   if(tsip_sync == 0) {         // syncing to start of message, search for a 0xB5
      if(c == 0xB5) {
         tsip_sync = 1;
         get_sync_time();
      }
      else if(c == '$') {  // ignore NMEA msg
         tsip_sync = 100;
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 100) {  // skipping NMEA message
      if(c == 0x0A) {
         tsip_sync = 0;
         packet_end = 1;
      }
   }
   else if(tsip_sync == 1) { // 0xB5 has been seen, now checking next byte
      if(c != 0x62) goto rst_msg;
      ++tsip_sync;           // 0xB5 0x62 seen... so accumulate the message
      ubx_rxa = ubx_rxb = 0; // init received message checksum
   }
   else if(tsip_sync == 2) {    // get ubx message class
      ubx_rx_class = c;
      ubx_msg_id = (c & 0xFF);
      ubx_rxa += c;
      ubx_rxb += ubx_rxa;
      ++tsip_sync;
   }
   else if(tsip_sync == 3) {    // get ubx message id
      ubx_rx_id = c;
      ubx_msg_id = (ubx_msg_id * 256) + (c & 0xFF);
      ubx_rxa += c;
      ubx_rxb += ubx_rxa;
      ++tsip_sync;
   }
   else if(tsip_sync == 4) {    // low byte of payload length
      ubx_rx_len = c;
      ubx_rxa += c;
      ubx_rxb += ubx_rxa;
      ++tsip_sync;
   }
   else if(tsip_sync == 5) {    // high byte of payload length
      ubx_rx_len += (((u32) c) * 256);
      ubx_msg_len = ubx_rx_len;
      ubx_rxa += c;
      ubx_rxb += ubx_rxa;
      ++tsip_sync;
      if(ubx_rx_len == 0) ++tsip_sync;  // message has no payload
   }
   else if(tsip_sync == 6) {   // get ubx message payload
      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
         ubx_rxa += c;
         ubx_rxb += ubx_rxa;
         --ubx_rx_len;
         if(ubx_rx_len == 0) ++tsip_sync;  // message payload processed, now get checksums
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 7) {  // first byte of message checksum
      ++tsip_sync;
      ubx_msg_rxa = c;
//packet_end = 0;
   }
   else if(tsip_sync == 8) {  // last byte of message checksum, end of ubx message
      tsip_sync = 0;
      ubx_msg_rxb = c;
      if((ubx_msg_rxa != ubx_rxa) || (ubx_msg_rxb != ubx_rxb)) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }

      decode_ubx_msg();  // message checksum matches, process the message
      packet_end = 1;
   }
   else {     // should never happen
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      ubx_rxa = ubx_rxb = 0; // init received message checksum
   }
}


//
//
//  Sirf receiver stuff (binary protocol)
//
//

void send_sirf_start(u16 sirf_cmd, int len)
{
   // start sending a Sirf message
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend sirf start %04X  len:%d\n", sirf_cmd, len);
   }

   sendout(RCVR_PORT, 0xA0, ADD_CHAR); // send message start code
   sendout(RCVR_PORT, 0xA2, ADD_CHAR);

   send_byte((len / 256) & 0xFF);  // send message length
   send_byte((len % 256) & 0xFF); 

   sirf_tx_cksum = 0; // init transmit checksum bytes

   send_byte(sirf_cmd & 0xFF);  // send message id
}


void send_sirf_end()
{
u16 cksum;

   // end the sirf message
   cksum = sirf_tx_cksum;
   cksum &= 0x7FFF;
   sendout(RCVR_PORT, cksum / 256, ADD_CHAR);   // send checksum
   sendout(RCVR_PORT, (cksum % 256) & 0xFF, ADD_CHAR);

   sendout(RCVR_PORT, 0xB0, ADD_CHAR);
   sendout(RCVR_PORT, 0xB3, EOM);

   if(sim_file == 0) Sleep(100); // rate limit send messages gggg
}

void query_sirf_msg(int msg)
{
   send_sirf_start(msg, 2);
   send_byte(0);
   send_sirf_end();
}


void parse_sirf_sw_ver()
{
int i;
int len;

   log_packet_id("sirf_sw_ver");

   sirf_sw_id[0] = 0;
   if(sirf_msg_len > 80) len = 80-2;
   else len = sirf_msg_len-2;

   for(i=0; i<len; i++) {
      sirf_sw_id[i] = tsip_byte();
      sirf_sw_id[i+1] = 0;
   }

   have_info |= ALL_ID_INFO;
}

void parse_sirf_track()
{
int chans;
int prn;
float az,el;
float cno;
u16 state;

   log_packet_id("sirf_track");

   gps_week = tsip_word();
   faked_tow = 0;
   pri_tow = this_tow = tsip_dword() / 100; 
   chans = tsip_byte();

   reset_sat_tracking();

   sat_count = 0;
   while(chans--) {
      prn = tsip_byte();
      az = ((float) tsip_byte() * 3.0F / 2.0F);
      el = ((float) tsip_byte() / 2.0F);
      state = tsip_word();
      cno  = ((float) tsip_byte());  // cno1
      cno += ((float) tsip_byte());  // cno2
      cno += ((float) tsip_byte());  // cno3
      cno += ((float) tsip_byte());  // cno4
      cno += ((float) tsip_byte());  // cno5
      cno += ((float) tsip_byte());  // cno6
      cno += ((float) tsip_byte());  // cno7
      cno += ((float) tsip_byte());  // cno8
      cno += ((float) tsip_byte());  // cno9
      cno += ((float) tsip_byte());  // cno10
      cno /= 10.0F;

      if((prn >= 1) && (prn <= MAX_PRN)) {
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].sig_level = cno;
         sat[prn].level_msg = 24;

         have_sat_azel = 4;

         if(state & 0x0001) sat[prn].tracking = prn;
         else               sat[prn].tracking = (-1);

         have_snr |= rinex_gnss(prn);

         sat[prn].state = state;
         if(have_state == 0) need_redraw = 2022;
         have_state = SIRF_STATE;  // STATE

         record_sig_levels(prn);
         ++sat_count;
         have_count = 21;
      }
   }
config_sat_count(sat_count);


   if(have_week == 0) need_redraw = 2023;
   have_week = 3;

   if(have_tow == 0) need_redraw = 2024;
   have_tow = 3;

   level_type = "dBc";
}

void parse_sirf_vis()
{
u08 sats;
int prn;
float az, el;

   log_packet_id("sirf_vis");
return; // bbbb - this causes sat info to toggle between yellow and green, best to not do it

   reset_sat_tracking();

   sats = tsip_byte();
   while(sats--) {
      prn = tsip_byte();
      az = ((float) tsip_byte() * 3.0F / 2.0F);
      el = ((float) tsip_byte() / 2.0F);

      if((prn >= 1) && (prn <= MAX_PRN)) {
         set_sat_azel(prn, (float) az, (float) el);
         have_sat_azel = 5;
      }
   }
}


void parse_sirf_nav()
{
u16 valid;
u16 nav_type;
u32 sats;
u16 secs;
u32 utc_tow;

   log_packet_id("sirf_nav");

   valid = tsip_word();
   nav_type = tsip_word();

   gps_week = tsip_word();
   faked_tow = 0;
   pri_tow = this_tow = tsip_dword();
   pri_tow /= 1000;  // gggg use msecs?

   pri_year = year = tsip_word();
   pri_month = month = tsip_byte();
   pri_day = day = tsip_byte();
   pri_hours = hours = tsip_byte();
   pri_minutes = minutes = tsip_byte();
   secs = tsip_word();

   pri_frac = raw_frac = ((double) (secs % 1000)) / 1000.0;
   pri_seconds = seconds = (secs / 1000);


   if(have_sirf_pps == 0) {  // fake the UTC offset from tow values since some receivers do not do the 52 message
      utc_tow = pri_hours * 24*60*60;
      utc_tow += pri_minutes * 60;
      utc_tow += pri_seconds;
      utc_tow %= 60;

      if(!user_set_utc_ofs) {
         utc_offset = (pri_tow % 60) - utc_tow;
         if(utc_offset < 0) utc_offset += 60;
         utc_offset %= 60;
         check_utc_ofs(4);
      }
//sprintf(plot_title, "utc_tow:%d  tow:%d  delta:%d  valid:%04X  nav:%04X", utc_tow,pri_tow%60, utc_offset, valid,nav_type);
   }

   time_flags |= TFLAGS_UTC;   // UTC based time
   have_timing_mode = 1;
   have_rcvr_tmode = 1;

   if(timing_mode == TMODE_GPS) {  // convert utc time to gps time
      utc_to_gps();
   }

   sats = tsip_dword();
   lat = ((float) (S32) tsip_dword()) * 1.0E-7 * PI / 180.0;
   lon = ((float) (S32) tsip_dword()) * 1.0E-7 * PI / 180.0;
   alt = ((float) (S32) tsip_dword()) * 1.0E-2;

   tsip_dword(); // msl
   tsip_byte();  // datum
   speed = ((double)tsip_word()) / 100.0;    // speed
   heading = ((double) tsip_word()) / 100.0; // course
   tsip_word();  // mag var
   tsip_word();  // climb
   tsip_word();  // heading rate
   tsip_dword(); // horiz err
   tsip_dword(); // vert err
   tsip_dword(); // time err
   tsip_word();  // horiz velocity err
   tsip_dword(); // clock bias
   tsip_dword(); // bias err
   tsip_dword(); // clock drift
   tsip_dword(); // drift err
   tsip_dword(); // distance
   tsip_word();  // distance err
   tsip_word();  // heading err
   tsip_byte();  // sat count
   hdop = ((float) (u08) tsip_byte()) / 5.0F;
   have_dops |= HDOP;
   tsip_byte();  // info

   have_heading = 1;
   have_speed = 1;

   nav_type &= 0x07;
   if((nav_type == 4) || (nav_type == 6)) rcvr_mode = RCVR_MODE_3D;
   else if((nav_type == 3) || (nav_type == 5)) rcvr_mode = RCVR_MODE_2D;
   else rcvr_mode = RCVR_MODE_ACQUIRE;

   if(have_week == 0) need_redraw = 2026;
   have_week = 4;

   if(have_tow == 0) need_redraw = 2027;
   have_tow = 4;

   update_gps_screen(1001);
}

void parse_sirf_pps()
{
double utc_frac;
u08 status;
int i;

   // WARNING: not all receivers output this message
   log_packet_id("sirf_pps");

   have_sirf_pps = 1;

   tsip_byte();  // hh
   tsip_byte();  // mm
   tsip_byte();  // ss
   tsip_byte();  // day
   tsip_byte();  // month
   tsip_word();  // year
   i = (int) (s16) tsip_word();  // utc offset
   utc_frac = ((double) (S32) tsip_dword()) * 1.0E-9;
   status = tsip_byte();  // bit0:valid time  bit1:utc time  bit2:utc offset info valid

   if(!user_set_utc_ofs) {
      if(status & 0x04) {    // UTC offset valid
         utc_offset = i;
         check_utc_ofs(5);
      }
   }

   if(status & 0x01) {  // time is valid
   }

   if(status & 0x02) {  // UTC time 
   }
}

void parse_sirf_clock()
{
u32 drift;
u32 bias;
u32 time;

   log_packet_id("sirf_clock");

   tsip_word();  // gps week
   tsip_dword(); // tow
   tsip_byte();  // sats
   drift = tsip_dword(); // clock drift in Hz
   bias = tsip_dword();  // clock bias in nanosecs
   time = tsip_dword();  // GPS time in msecs

   have_pps_offset = 20;
   have_rcvr_pps = 20;
   if(drift) {
      pps_offset = 1.0 / (double) drift;  // convert Hz to nanoseconds
//adadad      if(jitter_adev == 0) do_pps_adev(pps_offset);
   }
   else pps_offset = 0.0;
   pps_offset *= 1.0E9;

   osc_offset = ((double) bias) / 1.0E6;
   have_osc_offset = 20;
   have_rcvr_osc = 20;
//adadad   if(jitter_adev == 0) do_osc_adev(osc_offset);
}

void parse_sirf_nav_params()
{
int sub_id;
u08 tsm;
u08 snm;

   log_packet_id("sirf_nav_params");

   sub_id = tsip_byte();

   tsip_byte();  // rsvd
   tsip_byte();
   tsip_byte();

   tsip_byte();  // alt hold mode
   tsip_byte();  // alt hold source
   tsip_word();  // alt source input

   tsip_byte();  // degraded mode
   tsip_byte();  // degraded timeout
   tsip_byte();  // DR timeout
   tsm = tsip_byte();  // track smooth mode
   snm = tsip_byte();  // static navigation
   tsip_byte();  // 3SV least squares
   tsip_dword(); // rsvd
   tsip_byte();  // DOP mask mode

   el_mask = ((float) (s16) tsip_word()) / 10.0F;
   have_el_mask = 1;

   amu_mask = (float) tsip_byte();  // power mask
   have_amu = 1;

   tsip_dword(); // rsvd
   // ... gggg lots more info follows

//sprintf(debug_text2, "tsm:%02X  snm:%02X", tsm,snm);
}

void parse_sirf_ack()
{
   log_packet_id("sirf_ack");
}

void parse_sirf_nak()
{
   log_packet_id("sirf_nak");
}

void parse_sirf_nav2()
{
   log_packet_id("measured nav");
}

void parse_sirf_dgps()
{
   log_packet_id("sirf_dgps");
}

void parse_sirf_throughput()
{
   log_packet_id("sirf_throughput");
}

void parse_sirf_unkn(int id) 
{
   sprintf(out, "unsupported msg: 0x%02X", id);
   log_packet_id(out);
}

void decode_sirf_msg()
{
u08 id;

   // process the received Sirf message
   start_msg_decode(1);

   id = tsip_byte();
// if(debug_file) fprintf(debug_file, "decode sirf:%02X (%d)  len:%d\n", id,id, sirf_msg_len);

   if     (id == SIRF_TRACK_MSG)      parse_sirf_track();
   else if(id == SIRF_SW_VER_MSG)     parse_sirf_sw_ver();
   else if(id == SIRF_CLOCK_MSG)      parse_sirf_clock();
   else if(id == SIRF_VIS_MSG)        parse_sirf_vis();
   else if(id == SIRF_NAV_PARAM_MSG)  parse_sirf_nav_params();
   else if(id == SIRF_NAV_MSG)        parse_sirf_nav();
   else if(id == SIRF_PPS_MSG)        parse_sirf_pps();
   else if(id == SIRF_ACK_MSG)        parse_sirf_ack();
   else if(id == SIRF_NAK_MSG)        parse_sirf_nak();
   else if(id == SIRF_NAV2_MSG)       parse_sirf_nav2();
   else if(id == SIRF_DGPS_MSG)       parse_sirf_dgps();
   else if(id == SIRF_THROUGHPUT_MSG) parse_sirf_throughput();
   else                               parse_sirf_unkn(id);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_sirf_message()
{
u08 c;

   // This routine buffers up an incoming UBX message.  When the end of the
   // message is seen, the message is parsed and decoded with parse_ubx_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }


   if(tsip_sync == 0) {      // syncing to start of message, search for a 0xA0
      if(c == 0xA0) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // 0xA0 has been seen, now checking next byte
      if(c != 0xA2) goto rst_msg;
      ++tsip_sync;           // 0xA2 seen... so accumulate the message
      sirf_rx_cksum = 0;     // init received message checksum
   }
   else if(tsip_sync == 2) { // high byte of payload length
      sirf_rx_len = ((u32) c);
      sirf_msg_len = sirf_rx_len;
      ++tsip_sync;
   }
   else if(tsip_sync == 3) {    // low byte of payload length
      sirf_rx_len *= 256;
      sirf_rx_len += (((u32) c) & 0xFF);
      sirf_msg_len = sirf_rx_len;
      ++tsip_sync;
      if(sirf_rx_len == 0) ++tsip_sync;  // message has no payload
   }
   else if(tsip_sync == 4) {   // get sirf message payload
      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         sirf_rx_cksum += c;
         tsip_buf[tsip_wptr++] = c;
         --sirf_rx_len;
         if((int) sirf_rx_len <= 0) ++tsip_sync;  // message payload processed, now get checksums
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 5) {  // first (high) byte of message checksum
      sirf_msg_cksum = c;
      ++tsip_sync;
   }
   else if(tsip_sync == 6) {  // last byte of message checksum, end of sirf message
      sirf_msg_cksum = (sirf_msg_cksum * 256) + (((u16) c) & 0xFF);
      sirf_msg_cksum &= 0x7FFF;
      sirf_rx_cksum &= 0x7FFF;

      if(sirf_msg_cksum != sirf_rx_cksum) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }
      tsip_sync = 7;
//    tsip_sync = 0;
//    decode_sirf_msg();  // message checksum matches, process the message
//    packet_end = 1;
   }
   else if(tsip_sync == 7) {  // end-of-message bytes
      tsip_sync = 8;
   }
   else if(tsip_sync == 8) {  // end-of-message bytes 
      decode_sirf_msg();  // message checksum matches, process the message
      packet_end = 1;
      tsip_sync = 0;
   }
   else {     // should never happen
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      sirf_rx_cksum = 0; // init received message checksum
   }
}


//
//
//   Venus receiver stuff
//
//

void send_venus_start(int id, int len)
{
   // send a Venus binary message start header
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend venus start %02X  len=%d\n", id, len);
   }

   if(id == 0x08) return;  // protect against possible brickage (firmware download)
   venus_start = id;
   venus_len = len;

   sendout(RCVR_PORT, 0xA0, ADD_CHAR);
   sendout(RCVR_PORT, 0xA1, ADD_CHAR);
   send_word(len);
   venus_tx_cksum = 0;
   send_byte(id);
}

void send_venus_end()
{
   venus_tx_cksum &= 0xFF;
   sendout(RCVR_PORT, venus_tx_cksum, ADD_CHAR);
   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);
   venus_start = venus_len = 0;
   if(sim_file == 0) Sleep(20);   // slightly rate limit sent messages
}

void send_venus_save(int allow_eeprom)
{
   if(VENUS_SAVE && allow_eeprom && (no_eeprom_writes == 0)) {
      send_byte(1);  // update SRAM and EEPROM
BEEP(507);  // gggg
      ++ee_write_count;
   }
   else {
      send_byte(0);           // update SRAM
   }
   send_venus_end();
}

void query_venus_msg(int id, int sub_id)
{
   if(sub_id >= 0) {
      send_venus_start(id, 2);
      send_byte(sub_id);
   }
   else {
      send_venus_start(id, 1);
   }
   send_venus_end();
}


void parse_venus_nav()
{
double jd;
u08 fix_mode;

   log_packet_id("venus_nav");
   if(saw_venus_raw & 0x02) return;  //rnx2

   fix_mode = tsip_byte();  // fix mode
   if(minor_alarms & MINOR_SURVEY) rcvr_mode = RCVR_MODE_SURVEY;
   else if(venus_hold_mode)        rcvr_mode = RCVR_MODE_HOLD;
   else if(fix_mode == 0)          rcvr_mode = RCVR_MODE_ACQUIRE;
   else if(fix_mode == 1)          rcvr_mode = RCVR_MODE_2D;
   else if(fix_mode == 2)          rcvr_mode = RCVR_MODE_3D;
   else if(fix_mode == 3)          rcvr_mode = RCVR_MODE_3D;
   else                            rcvr_mode = RCVR_MODE_UNKNOWN;

   tsip_byte();  // sat count
   gps_week = tsip_word();  // week
   faked_tow = 0;
   pri_tow = this_tow = tow = survey_tow = tsip_dword(); // tow

   lat = ((double) (S32) tsip_dword()) * 1.0E-7 * PI / 180.0; // lat
   lon = ((double) (S32) tsip_dword()) * 1.0E-7 * PI / 180.0; // lon
   alt = ((double) (S32) tsip_dword()) / 100.0; // lon
   tsip_dword(); // msl alt

   gdop = ((float) (s16) tsip_word()) / 100.0F;  // GDOP
   pdop = ((float) (s16) tsip_word()) / 100.0F;  // PDOP
   hdop = ((float) (s16) tsip_word()) / 100.0F;  // HDOP
   vdop = ((float) (s16) tsip_word()) / 100.0F;  // VDOP
   tdop = ((float) (s16) tsip_word()) / 100.0F;  // TDOP
   have_dops |= (GDOP | PDOP | HDOP | VDOP | TDOP);

   ecef_x = tsip_dword(); // ecefx
   ecef_y = tsip_dword(); // ecefy
   ecef_z = tsip_dword(); // ecefz
   tsip_dword(); // ecefvx
   tsip_dword(); // ecefvy
   tsip_dword(); // ecefvz

   if(have_tow == 0) need_redraw = 2029;
   have_tow = 5;

   if(have_week == 0) need_redraw = 2030;
   have_week = 5;

   jd = (double) (u32) pri_tow;
   jd /= 100.0;
   jd += 0.01;  // adjust for possible roundoff

   if(timing_mode != TMODE_GPS) {  // we want UTC time - convert gps to utc
      jd -= (double) utc_offset;
   }
   
   jd /= (24.0*60.0*60.0);
   jd += GPS_EPOCH;
   jd += ((double) gps_week) * 7.0;
   set_gregorian_time(jd);

   pri_tow /= 100;
   this_tow /= 100;
   survey_tow /= 100;

   query_venus_msg(QUERY_VENUS_LEAP);  // get UTC offset

   level_type = "dBc";
   update_gps_screen(1002); 
}

void parse_venus_masks()
{
u08 flags;
u08 el;
u08 cnr;

   log_packet_id("venus_masks");
   flags = tsip_byte();
   el = tsip_byte();
   cnr = tsip_byte();

   if((flags == 1) || (flags == 2)) {
      el_mask = (float) el;
      have_el_mask = 1;
   }

   if((flags == 1) || (flags == 3)) {
      amu_mask = (float) cnr;
      have_amu = 1;
   }
}

void parse_venus_cable()
{
   log_packet_id("venus_cable");
   cable_delay = (float) (S32) tsip_dword();
   cable_delay *= 1.0E-11;

// if(have_cable_delay == 0) need_redraw = 2031;
   have_cable_delay = 1;

   show_cable_delay();
}

void parse_venus_survey(int msg)
{
u08 mode;
u32 len;
u32 sdev;
double slat,slon,salt;
u08 rtime;
u32 rlen;

   log_packet_id("venus_survey");

   if(saw_venus_raw == 0) config_venus_timing();
   saw_timing_msg |= 0x04;
   
   mode = tsip_byte();   // timing mode
   len = tsip_dword();   // survey length
   sdev = tsip_dword();  // std dev
   slat = tsip_double(); // saved lat
   slon = tsip_double(); // saved lon
   salt = (double) tsip_single(); // saved alt
   rtime = tsip_byte();  // run-time timing mode
   rlen = tsip_dword();  // run-time survey length

   if(do_survey > 0) survey_progress = 100 - ((100 * rlen) / do_survey);
   else              survey_progress = (-1);
   have_progress = 4;
//sprintf(debug_text, "mode:%d msg:%04X  len:%d  sdev:%d  lla:%f %f %f   rtime:%d  rlen:%d  prog:%d",
//mode, msg, len, sdev, slat,slon,salt, rtime, rlen, survey_progress);

   minor_alarms &= (~MINOR_SURVEY);
   venus_hold_mode = 0;
   if((rlen == 0) && (saw_venus_raw == 0)) ;  // survey completed
   else if(rtime == 0) { // PVT mode
      rcvr_mode = RCVR_MODE_3D;
   }
   else if(rtime == 1) {  // surveying
      minor_alarms |= (MINOR_SURVEY);
      rcvr_mode = RCVR_MODE_SURVEY;
   }
   else if(rtime == 2) {  // position hold
      venus_hold_mode = 1;
      rcvr_mode = RCVR_MODE_HOLD;
   }
}

void parse_venus_pps()
{
u08 sub_code;
u32 freq;
u32 width;

pps_enabled = pps_mode = 1; // zzzzz
   have_pps_enable = 4;
   have_pps_mode = 4;
   sub_code = tsip_byte();
   freq = width = 0;

   if(sub_code == 0x80) {   // width (us) 1..100000us
      log_packet_id("pps width");
      width = tsip_dword();
      if(saw_timing_msg & 0x08) {
         pps2_duty = 0.50;
         have_pps_duty |= 0x02;
      }
      else {
         if(pps1_freq) {
            pps1_duty = (((double) (width)) / 1.0E6) /  (1.0 / pps1_freq);
            have_pps_duty |= 0x01;
         }
      }
   }
   else if(sub_code == 0x81) {  // freq (not all firmware does this)
      log_packet_id("pps freq");
      freq = tsip_dword();
      if(saw_timing_msg & 0x08) {
         pps2_freq = (double) freq;
         have_pps_freq |= 0x02;
      }
      else {
//!!!!   pps1_freq = (double) freq;
         pps1_freq = 1.0;        // only does 1PPS, can't set the freq
         have_pps_freq |= 0x01;
      }
   }
   else {
      log_packet_id("unsupported pps subcode");
   }
//sprintf(debug_text, "freq %d:%d  width %d:%d  duty:%f", have_pps_freq,freq,  have_pps_duty,width,pps1_duty); // qqqqqqqq
}


void parse_venus_rtk()
{
int sub_code;

   sub_code = tsip_byte();
   if(sub_code == 0x80) {
      log_packet_id("venus rtk");
      rtk_mode = tsip_byte();
      have_rtk_mode = 1;
   }
   else {
      log_packet_id("unsupported rtk subcode");
   }
}

void parse_venus_sbas()
{
u08 sub_code;
u08 flag;
u08 qzss_chans;
u08 sbas_mode;
u08 sbas_ura;
u08 sbas_correct;
u08 sbas_chans;
u08 sbas_mask;

   // message type 0x62 responses

   sub_code = tsip_byte();
   flag = tsip_byte();
   if(sub_code == 0x80) {  // SBAS status
      log_packet_id("venus sbas status");
      if(flag) gnss_mask |= SBAS;
      else     gnss_mask &= (~SBAS);
      sbas_mode = tsip_byte();
      sbas_ura = tsip_byte();
      sbas_correct = tsip_byte();
      sbas_chans = tsip_byte();
      sbas_mask = tsip_byte();
//sprintf(plot_title, "sbas flag:%02X mode:%02X ura:%02X correct:%02X chans:%d mask:%d",
//flag, sbas_mode, sbas_ura, sbas_correct, sbas_chans, sbas_mask);
   }
   else if(sub_code == 0x81) {  // QZSS status
      log_packet_id("venus qzss status");
      if(flag) gnss_mask |= QZSS;
      else     gnss_mask &= (~QZSS);

      qzss_chans = tsip_byte();
//sprintf(debug_text, "qzss flag:%02X chans:%d", flag,qzss_chans);
   }
   else {
      log_packet_id("unsupported sbas subcode");
   }
}

void parse_venus_status()
{
u08 sub_code;
int def_ofs;
int cur_ofs;
int flags;
u08 jam_status;
u32 tow;
u08 flash_status;
u08 flash_type;

   // message type 0x64 responses

   sub_code = tsip_byte();
   if(sub_code == 0x80) {  // boot status
      log_packet_id("venus boot status");
      flash_status = tsip_byte();
      flash_type = tsip_byte();
      if(flash_status != 0) {
         critical_alarms |= CRIT_ROM;
      }
      else { 
         critical_alarms &= (~CRIT_ROM);
      }
      if(!have_critical_alarms) need_redraw = 7702;
      have_critical_alarms = 2;
   }
   else if(sub_code == 0x83) {  // jamming mode
      log_packet_id("venus jamming mode");
      foliage_mode = tsip_byte();
      jam_status = tsip_byte();
   }
   else if(sub_code == 0x8C) {  // GNSS system selection mask
      log_packet_id("venus gnss selection");
      gnss_mask = tsip_word();
      have_gnss_mask = 1;
//sprintf(plot_title, "gnss mask:%04X", gnss_mask); // ggggg
   }
   else if(sub_code == 0x8E) {  // utc offset
      log_packet_id("venus utc offset status");
      tow = tsip_dword(); // tow in msecs
      tsip_dword();       // tow fraction
      tsip_word();        // week
      def_ofs = (int) (s08) tsip_byte();  // gps offset default
      cur_ofs = (int) (s08) tsip_byte();  // gps offset current
      flags = tsip_byte();

      if(!user_set_utc_ofs && (flags & 0x04)) {
         utc_offset = cur_ofs;
         check_utc_ofs(6);
      }
   }
   else {
      log_packet_id("unsupported status subcode");
   }
}

void parse_venus_version()
{
u08 sw_type;
u32 kernel;
u32 odm;
u32 rev;

   log_packet_id("venus_version");
   sw_type = tsip_byte();
   kernel = tsip_dword();
   odm = tsip_dword();
   rev = tsip_dword();

   sprintf(venus_kern, "%04d.%02d.%02d", (kernel>>16), (kernel>>8)&0xFF, kernel&0xFF);
   sprintf(venus_odm,  "Ver:  %04d.%02d.%02d", (odm>>16), (odm>>8)&0xFF, odm&0xFF);
   sprintf(venus_rev,  "Rev:  %04d.%02d.%02d", (rev>>16), (rev>>8)&0xFF, rev&0xFF);

   have_info |= ALL_ID_INFO;
//sprintf(plot_title, "k:%08X  odm:%08X  rev:%08X", kernel,odm,rev);
}

void parse_venus_ack()
{
u08 ack;

   log_packet_id("venus_ack");
   ack = tsip_byte();
}

void parse_venus_nak()
{
u08 nak;

   log_packet_id("venus_nak");
   nak = tsip_byte();
}

void parse_venus_rate()
{
float rate;

   log_packet_id("venus_rate");
   rate = (float) tsip_byte();
   if(!pause_data) {
      nav_rate = rate;
      have_nav_rate = 2;
   }
}


void parse_venus_sv()
{
int count;
int i;
int prn;
int state1;
int ura;
int snr;
int az,el;
int state2;

   // sky view
   log_packet_id("venus_sv");

   saw_venus_raw |= 0x01;
   minor_alarms &= (~MINOR_NO_TRACK);
   tsip_byte();  // iod
   count = tsip_byte();

   reset_sat_tracking();
   for(i=0; i<count; i++) {
      tsip_byte(); // channel
      prn = tsip_byte();
      state1 = tsip_byte();
      ura = tsip_byte();
      snr = tsip_byte();
      el = (int) tsip_word();
      az = (int) tsip_word();
      state2 = tsip_byte();

      if((prn >= 1) && (prn <= MAX_PRN)) {
         sat[prn].sv_accuracy = ura_to_dist(prn, ura); // convert to distance

         have_accu = 1;

         if(state1 & 0x04) {  // healthy
            sat[prn].health_flag = 0;
            sat[prn].tracking = 1;
         }
         else {
            sat[prn].health_flag = 1;  // docs say health flag... usage seems more like tracking flag
            sat[prn].tracking = (-1);
         }
         if((state2 & 0x30) == 0) sat[prn].tracking = (-1);
//if(log_file) fprintf(log_file, "prn:%02d  state1:%02X  state2:%02X\n", prn,state1,state2);  // rnx3

         sat[prn].sig_level = (float) snr;
         set_sat_azel(prn, (float) az, (float) el);
         have_sat_azel = 42;

         sat[prn].level_msg = 1;
         level_type = "SNR";
         record_sig_levels(prn);
      }
   }
}

void parse_venus_xnav()
{
int fix_mode;
int week;
double vtow;
double bias;
float drift;
double jd;

   log_packet_id("venus_xnav");
   saw_venus_raw |= 0x02;
   minor_alarms &= (~MINOR_NO_TRACK);

   tsip_byte();  // iod
   fix_mode = tsip_byte();
   week = tsip_word();
   vtow = tsip_double();
   ecef_x = tsip_double();
   ecef_y = tsip_double();
   ecef_z = tsip_double();
   tsip_single();  // velocity
   tsip_single();
   tsip_single();
   bias = tsip_double();   // meters
   drift = tsip_single();  // meters/sec
   gdop = tsip_single();
   pdop = tsip_single();
   hdop = tsip_single();
   vdop = tsip_single();
   tdop = tsip_single();
   have_dops |= (GDOP | PDOP | HDOP | VDOP | TDOP);

   if(1) ;
   else if(minor_alarms & MINOR_SURVEY) rcvr_mode = RCVR_MODE_SURVEY;
   else if(venus_hold_mode)             rcvr_mode = RCVR_MODE_HOLD;
   else if(fix_mode == 0)               rcvr_mode = RCVR_MODE_NO_SATS;
   else if(fix_mode == 1)               rcvr_mode = RCVR_MODE_ACQUIRE;
   else if(fix_mode == 2)               rcvr_mode = RCVR_MODE_2D;
   else if(fix_mode == 3)               rcvr_mode = RCVR_MODE_3D;
   else if(fix_mode == 4)               rcvr_mode = RCVR_MODE_DGPS;
   else                                 rcvr_mode = RCVR_MODE_UNKNOWN;

   pri_tow = this_tow = tow = survey_tow = (long) vtow; // tow

   ecef_to_lla(ecef_x,ecef_y,ecef_z);
   lat = elat;
   lon = elon;
   alt = ealt;

   if(week >= 0) {
      gps_week = week;
      faked_tow = 0;
      if(have_week == 0) need_redraw = 2007;
      have_week = 222;
   }

   pri_tow = tow = this_tow = (int) vtow;
   if(have_tow == 0) need_redraw = 2008;
   have_tow = 222;
   survey_tow = tow;

   jd = vtow;
   jd /= (24.0*60.0*60.0);
   jd += (week * 7.0);
   jd += GPS_EPOCH;

   set_gregorian_time(jd);

   if(timing_mode == TMODE_UTC) {  // we want UTC time - convert gps time to utc
      gps_to_utc();
   }

   if(TICC_USED == 0) {
      pps_offset = bias;
      have_pps_offset = 1;
      plot[PPS].plot_id = "Bias";
      plot[PPS].units = "m";
      if(user_set_pps_plot == 0) {
         user_set_pps_plot = 1;
         plot[PPS].show_plot = 1;
      }

      osc_offset = drift;
      have_osc_offset = 1;
      plot[OSC].plot_id = "Drift";
      plot[OSC].units = "m/s";
      plot[OSC].ref_scale = 1.0F;
      if(user_set_osc_plot == 0) {
         plot[OSC].show_plot = 1;
         user_set_osc_plot = 1;
      }
      if(plot[OSC].user_set_float == 0) plot[OSC].float_center = 1;

      if(user_set_lla_plots == 0) {
         if(plot[ONE].user_set_show == 0)   plot[ONE].show_plot = 0;
         if(plot[TWO].user_set_show == 0)   plot[TWO].show_plot = 0;
         if(plot[THREE].user_set_show == 0) plot[THREE].show_plot = 0;
         user_set_lla_plots = 1;
      }
   }

   update_gps_screen(1223); 
}

void parse_venus_mtime()
{
int tow;
int week;
double meas_tow;
int xtow;

   // raw measurement epoch
   log_packet_id("venus_mtime");
if(saw_venus_raw & 0x10) return;  // use extended raw data

   saw_venus_raw |= 0x04;
   minor_alarms &= (~MINOR_NO_TRACK);
   tsip_byte();  // iod
   week = tsip_word();
   tow = tsip_dword();
   tsip_word();  // measurement period
   if(raw_msg_rate == 0) return;

   meas_tow = ((double) tow) / 1000.0; // measurement tow
   xtow = (int) (meas_tow*nav_rate);   // raw Hz

   if(1) {  // this might cause time stamp faults in CSRS-PPP  rnx3
      if(xtow % (int) ((double)raw_msg_rate*nav_rate)) return;

      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }
   else {  // Only 1Hz nav rate
      if(((int) meas_tow % raw_msg_rate) != 0) return;  // drop unwanted messages

      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }
}

void parse_venus_raw()
{
int count;
int i;
int prn;
int snr;
double range;
double phase;
float doppler;
int flags;

   // raw measurements
   log_packet_id("venus_raw");
if(saw_venus_raw & 0x10) return;  // use extended raw data

   saw_venus_raw |= 0x08;
   minor_alarms &= (~MINOR_NO_TRACK);
   tsip_byte();  // iod
   count = tsip_byte();

   for(i=0; i<count; i++) {
      prn = 0;
      snr = 0;
      range = 0.0;
      phase = 0.0;
      doppler = 0.0;

      prn = tsip_byte();
      snr = tsip_byte();
      range = tsip_double();
      phase = tsip_double();
      doppler = tsip_single();
      flags = tsip_byte();

      if((prn >= 1) && (prn <= MAX_PRN)) {
         if((flags & 0x01) == 0.0) range = 0.0;
         if((flags & 0x02) == 0.0) doppler = 0.0F;
         if((flags & 0x04) == 0) phase = 0.0;

         sat[prn].doppler = doppler;
         sat[prn].range = range;
         sat[prn].code_phase = phase;
         if(flags & 0x08) sat[prn].ca_lli = LOCK_LOST;
         else             sat[prn].ca_lli = 0;

         sat[prn].sig_level = (float) snr;
         have_snr |= rinex_gnss(prn);

         if(doppler != 0.0F) {
            if(have_doppler == 0) need_redraw = 2018;
            have_doppler |= rinex_gnss(prn);
         }
         if(range != 0.0F) {
            have_range |= rinex_gnss(prn);
         }
         if(phase != 0.0F) {
            have_phase |= rinex_gnss(prn);
         }
      }
   }
}

void parse_venus_ext_raw()
{
int count;
int i;
int svid;
int prn;

int snr;
double range;
double phase;
float doppler;
int lli;

int flags;
int week;
int tow;
double meas_tow;
int xtow;
int gnss;
int meas;
int freq;
int lti;

   // extended raw measurements
   log_packet_id("venus_ext_raw");

   saw_venus_raw |= 0x10;
   minor_alarms &= (~MINOR_NO_TRACK);

   tsip_byte();  // message version
   tsip_byte();  // iod
   week = tsip_word();  // week
   tow = tsip_dword();  // tow in msecs
   tsip_word();         // measurement period
   tsip_byte();         // measurement indicator
   tsip_byte();         // reserved
   count = tsip_byte();

   meas_tow = tow / 1000.0; // measurement tow
   if(raw_msg_rate == 0) return;
   xtow = (int) (meas_tow*nav_rate);  // raw Hz 

   if(1) {  // this causes time stamp faults in CSRS-PPP  //rnx3
      if(xtow % (int) ((double)raw_msg_rate*nav_rate)) return;

      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }
   else {  // Only 1Hz nav rate
      if(((int) meas_tow % raw_msg_rate) != 0) return;  // drop unwanted messages

      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }


if(0 && log_file) fprintf(log_file, "\njd_obs:%.9f  count:%d  week:%d\n", jd_obs, count, week);

   for(i=0; i<count; i++) {
      gnss = tsip_byte();
      meas = gnss >> 4;
      gnss &= 0x0F;

      svid = prn = tsip_byte();
      if     (gnss == 5) prn += 200; // Beidou  201..237
      else if(gnss == 3) prn += 300; // Galileo 301..350 (Heather values)
      else if(gnss == 2) prn += 64;  // Glonass 65..96
      else if(gnss == 1) prn += 0;   // SBAS    120..158
      else if(gnss == 0) prn += 0;   // GPS     1..37 (s/b 1..32)
      else prn = 0;

      freq = tsip_byte();
      lti = freq >> 4;   //lock time
      freq &= 0x0F;      //Glonass only

      snr = tsip_byte();
      range = tsip_double();
      phase = tsip_double();
      doppler = tsip_single();
      tsip_byte();   // pseudorange sdev
      tsip_byte();   // carrierphase sdev
      tsip_byte();   // doppler sdev
      flags = tsip_word();
      tsip_word();   // reserved

      if((flags & 0x01) == 0) range = 0.0;
      if((flags & 0x02) == 0) doppler = 0.0F;
      if((flags & 0x04) == 0) phase = 0.0;
      if((flags & 0x08) == 0) lli = 0;
      else                    lli = LOCK_LOST;
if(0 && log_file) fprintf(log_file, "  svid:%d  prn:%d  gnss:%d  meas:%02X  flags:%04X\n", svid, prn, gnss, meas, flags);

      if((prn >= 1) && (prn <= MAX_PRN)) {  // !!!! we need to handle non-C/A code "meas" value
         if(meas == 0) {  // L1 C/A
            sat[prn].range = range;
            sat[prn].doppler = doppler;
            sat[prn].code_phase = phase;
            sat[prn].ca_lli = lli;
            sat[prn].sig_level = (float) snr;

            if(snr != 0)  {
               have_snr |= rinex_gnss(prn);
            }
            if(range != 0.0) {
               have_range |= rinex_gnss(prn);
            }
            if(phase != 0.0)  {
               have_phase |= rinex_gnss(prn);
            }

            if(doppler != 0.0F) {
               if(have_doppler == 0) need_redraw = 2018;
               have_doppler |= rinex_gnss(prn);
            }
         }
         else if(meas == 1) {  // L1
            sat[prn].l1_range = range;
            sat[prn].l1_doppler = doppler;
            sat[prn].l1_code_phase = phase;
            sat[prn].l1_lli = lli;
            sat[prn].l1_sig_level = (float) snr;

            if(snr != 0) {
               have_l1_snr   |= rinex_gnss(prn);
            }
            if(range != 0.0F) {
               have_l1_range |= rinex_gnss(prn);
            }
            if(phase != 0.0F) {
               have_l1_phase |= rinex_gnss(prn);
            }
            if(doppler != 0.0F) {
               have_l1_doppler |= rinex_gnss(prn);
            }
         }
         else if(meas == 2) {  // L2
            sat[prn].l2_range = range;
            sat[prn].l2_doppler = doppler;
            sat[prn].l2_code_phase = phase;
            sat[prn].l2_lli = lli;
            sat[prn].l2_sig_level = (float) snr;

            if(snr != 0) {
               have_l2_snr   |= rinex_gnss(prn);
            }
            if(range != 0.0) {
               have_l2_range |= rinex_gnss(prn);
            }
            if(phase != 0.0 ) {
               have_l2_phase |= rinex_gnss(prn);
            }
            if(doppler != 0.0F) {
               have_l2_doppler |= rinex_gnss(prn);
            }
         }
         else if(meas == 4) {  // L5  E5A B2I  GLONASS L3
            sat[prn].l5_range = range;
            sat[prn].l5_doppler = doppler;
            sat[prn].l5_code_phase = phase;
            sat[prn].l5_lli = lli;
            sat[prn].l5_sig_level = (float) snr;

            if(snr != 0) {
               have_l5_snr   |= rinex_gnss(prn);
            }
            if(range != 0.0) {
               have_l5_range |= rinex_gnss(prn);
            }
            if(phase != 0.0) {
               have_l5_phase |= rinex_gnss(prn);
            }
            if(doppler != 0.0F) {
               have_l5_doppler |= rinex_gnss(prn);
            }
         }
         else if(meas == 5) {  // Galileo E5B
         }
         else if(meas == 6) {  // Galileo E6
         }
      }
   }
}


void parse_venus_rtcm()
{
   log_packet_id("venus_rtcm");
}


void parse_venus_meas()
{
   log_packet_id("venus_meas");
}


void parse_venus_unkn(int id)
{
   sprintf(out, "unsupported message: 0x%02X", id);
   log_packet_id(out);
}


void decode_venus_msg()
{
u08 id;

   // process the received Venus message
   start_msg_decode(1);

   id = tsip_byte();
// if(debug_file) fprintf(debug_file, "decode venus:%02X (%d)  len:%d\n", id,id, venus_msg_len);

   if     (id == VENUS_NAV_MSG)      parse_venus_nav();
   else if(id == VENUS_MASK_MSG)     parse_venus_masks();
   else if(id == VENUS_CABLE_MSG)    parse_venus_cable();
   else if(id == VENUS_SURVEY_MSG)   parse_venus_survey(id);
   else if(id == VENUS_BASE_MSG)     parse_venus_survey(id);
   else if(id == VENUS_PPS_MSG)      parse_venus_pps();
   else if(id == VENUS_RTK_MSG)      parse_venus_rtk();
   else if(id == VENUS_BOOT_MSG)     parse_venus_status();
   else if(id == VENUS_TIME_MSG)     parse_venus_status();
   else if(id == VENUS_JAMMING_MSG)  parse_venus_status();
   else if(id == VENUS_GNSS_MSG)     parse_venus_sbas();
   else if(id == VENUS_SBAS_MSG)     parse_venus_sbas();
   else if(id == VENUS_QZSS_MSG)     parse_venus_status();
   else if(id == VENUS_VERSION_MSG)  parse_venus_version();
   else if(id == VENUS_ACK_MSG)      parse_venus_ack();
   else if(id == VENUS_NAK_MSG)      parse_venus_nak();
   else if(id == VENUS_RATE_MSG)     parse_venus_rate();
   else if(id == VENUS_MTIME_MSG)    parse_venus_mtime();
   else if(id == VENUS_RAW_MSG)      parse_venus_raw();
   else if(id == VENUS_SV_MSG)       parse_venus_sv();
   else if(id == VENUS_XNAV_MSG)     parse_venus_xnav();
   else if(id == VENUS_EXTRAW_MSG)   parse_venus_ext_raw();
   else if(id == VENUS_RTCM_MSG)     parse_venus_rtcm();
   else if(id == VENUS_MEAS_MSG)     parse_venus_meas();
   else                              parse_venus_unkn(id);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_venus_message()
{
u08 c;

   // This routine buffers up an incoming Venus message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_venus_msg()

if(venus_nmea) {   // vvvvv - mixed NMEA and Venus binary messages
   get_nmea_message();
   return;
}

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }


   if(tsip_sync == 0) {         // syncing to start of message, search for a 0xA1
      if(c == 0xA0) {
         tsip_sync = 1;
         get_sync_time();
         venus_nmea = 0;
      }
      else if(c == '$') {  // mixed Venus binary and NMEA messages
         tsip_sync = 1;
         get_sync_time();
         venus_nmea = 1;
      }
      nmea_vfy_cksum = 0;  // the calculated message checksum
      nmea_msg_cksum = 0;  // the checksum in the message
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // 0xA1 has been seen, now checking next byte
      if(c != 0xA1) goto rst_msg;
      ++tsip_sync;           // 0xA0 0xA1 seen... so accumulate the message
      venus_vfy_cksum = 0;
   }
   else if(tsip_sync == 2) {    // payload len high byte
      venus_rx_len = ((u32) c);
      venus_msg_len = venus_rx_len;
      ++tsip_sync;
   }
   else if(tsip_sync == 3) {    // payload len low byte
      venus_rx_len *= 256;
      venus_rx_len += (((u32) c) & 0xFF);
      venus_msg_len = venus_rx_len;
      ++tsip_sync;
      if(venus_rx_len == 0) ++tsip_sync;
   }
   else if(tsip_sync == 4) {   // get Venus message payload
      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         venus_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
         --venus_rx_len;
         if((int) venus_rx_len <= 0) {
            ++tsip_sync;  // message payload processed, now get checksums
         }
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 5) {  // message checksum, end of venus message
      tsip_sync = 0;
venus_msg_id = tsip_buf[0];
// fprintf(debug_file, "venus msg %02X  len:%02X  vchk:%02X  c=%02X\n", venus_msg_id, venus_msg_len, venus_vfy_cksum, c);
      venus_vfy_cksum ^= c;
      if(venus_vfy_cksum) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }
      tsip_sync = 6;

      if(0) {
         decode_venus_msg();  // message checksum matches, process the message
         packet_end = 1;
         tsip_sync = 0;
      }
   }
   else if(tsip_sync == 6) {  // 0x0D
      tsip_sync = 7;
   }
   else if(tsip_sync == 7) {  // 0x0A
      decode_venus_msg();  // message checksum matches, process the message
      packet_end = 1;
      tsip_sync = 0;
   }
   else {     // should never happen
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
   }
}


//
//
//  Zodiac receiver stuff
//
//

void send_zod_start(u16 id, u16 len, u16 flags)
{
u16 cksum;

   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend zodiac start %04X  len:%u  flags:%04X\n", id, len,flags);
   }

   if(id == ZOD_FW_UPDATE) return;  // we don't allow this - might brick things

   len -= 6;
   cksum = (0x81FF + id + len + flags) & 0xFFFF;
   if(cksum != 0x8000) cksum = (0 - cksum) & 0xFFFF;

   zod_seq_num = (zod_seq_num + 1) & 0x7FFF;

   send_word(0x81FF);
   send_word(id);
   send_word(len);
   send_word(flags);
   send_word(cksum);

   zodiac_tx_cksum = 0;
   zodiac_tx_cnt = 0;
}

void send_zod_end()
{
   if(zodiac_tx_cksum != 0x8000) zodiac_tx_cksum = (0 - zodiac_tx_cksum) & 0xFFFF;

   sendout(RCVR_PORT, zodiac_tx_cksum % 256, ADD_CHAR);
   sendout(RCVR_PORT, zodiac_tx_cksum / 256, EOM);
   if(sim_file == 0) Sleep(50);
}

void send_zod_seq()
{
   send_word(zod_seq_num);
}

void query_zod_msg(int msg)
{
   send_zod_start(msg, 6, 0x0800);
   send_zod_end();
}

void get_zod_seq(int sat_meas)
{
int ts;
int seq;
int sat_seq;

   ts = tsip_dword();  // timestamp
   seq = tsip_word();  // seq
   if(sat_meas) {      // satellite measurement sequence number
      sat_seq = tsip_word();
   }
}

void parse_zod_temp()
{
u16 t0;
s16 tref;
s16 tfilt;
s16 s0;
float dt;

   log_packet_id("temperature");
   tfilt = 0;     // !!!! current temp sensor reading - but no messages
                  //      return it... thus, this code is USELESS !!!!

   get_zod_seq(0);

   tsip_word();

   tsip_word();
   tsip_word();
   tsip_word();
   tsip_word();
   tsip_word();

   tsip_word();
   tsip_word();

   tref = tsip_word();
   t0 = tsip_word();
   s0 = tsip_word();

   tsip_word();
   tsip_word();

   dt = ((float) s0) / (65536.0F*100.0F); // s0 = deg/count
   dt *= ((float) (tfilt-t0));             // t0 = counts, tfilt=current sensor reading

   temperature = (DATA_SIZE) ((((float) tref) * 0.01F) - dt);  // !!!! but no way to get tfilt !!!!
   have_temperature = 107;
}


void parse_zod_snr()
{
int i;
int flags;
int prn;
int snr;

   log_packet_id("sig levels");

   get_zod_seq(1);
   
   gps_week = tsip_word();
   faked_tow = 0;
   if(have_week == 0) need_redraw = 2033;
   have_week = 6;

   pri_tow = tow = this_tow = tsip_dword();
   if(have_tow == 0) need_redraw = 2034;
   have_tow = 6;
   survey_tow = tow;

   tsip_dword(); // epoch nanoseconds

   reset_sat_tracking();

   for(i=0; i<12; i++) {
      flags = tsip_word();
      prn = tsip_word();
      snr = tsip_word();
      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].sig_level = (float) snr;
         sat[prn].level_msg = 9;
         have_snr |= rinex_gnss(prn);
         if(flags & 0x0001) sat[prn].tracking = 1;
         else               sat[prn].tracking = (-1);
         record_sig_levels(prn);
      }
   }

   level_type = "SNR";
}

void parse_zod_vis()
{
int i;
int prn;
double a, e;

   log_packet_id("sat visibility");

   get_zod_seq(0);

   gdop = ((float) tsip_word()) / 100.0F;
   pdop = ((float) tsip_word()) / 100.0F;
   hdop = ((float) tsip_word()) / 100.0F;
   vdop = ((float) tsip_word()) / 100.0F;
   tdop = ((float) tsip_word()) / 100.0F;
   have_dops = (GDOP | PDOP | HDOP | VDOP | TDOP);

   i = tsip_word();
   sat_count = i;
   have_count = 4;
   config_sat_count(i);

   if(i > 12) i = 12;
   else if(i < 0) i = 0;
   while(i--) {
      prn = tsip_word();
      a = (((double) (s16) tsip_word()) * 1.0E-4 * 180.0 / PI);
      if(a < 0.0) a += 360.0;
      e = (((double) (s16) tsip_word()) * 1.0E-4 * 180.0 / PI);

      if((prn >= 1) && (prn <= MAX_PRN)) { 
         set_sat_azel(prn, (float) a, (float) e);
         have_sat_azel = 6;
      }
   }
}


void parse_zod_mark()
{
double secs;
int flags;

   log_packet_id("tow / utc offset");

   get_zod_seq(0);
   tsip_word();  // rsvd
   tsip_word(); 
   tsip_word(); 
   tsip_word(); 
   tsip_word(); 

   pri_tow = tow = this_tow = tsip_dword();
   if(have_tow == 0) need_redraw = 2035;
   have_tow = 7;
   survey_tow = tow;

   secs  = (double) tsip_word();
   secs += ((double) tsip_dword()) / 1.0E9;
   if(!user_set_utc_ofs) {
      utc_offset = (int) (secs + 0.50);
      check_utc_ofs(7);
   }

   flags = tsip_word();

   minor_alarms &= (~MINOR_PPS_SKIPPED);
//sprintf(debug_text2, "mark flags:%04X", flags);
   if((flags & 0x0001) == 0) minor_alarms |= MINOR_PPS_SKIPPED;  // time mark invalid
   if(flags & 0x0008) minor_alarms |= MINOR_PPS_SKIPPED;  // traim alarm

}

void parse_zod_traim_config()
{
S32 val;
u16 mode;
S32 slat;
S32 slon;
S32 salt;
u16 flag;

   log_packet_id("traim config");

   if(minor_alarms & MINOR_SURVEY) use_traim_lla = 1;
   else if(rcvr_mode == RCVR_MODE_HOLD) use_traim_lla = 0;
   else if(1) use_traim_lla = 0;
   else if(precision_survey) use_traim_lla = 2;
   else                      use_traim_lla = 3;
//use_traim_lla = 0;

   get_zod_seq(0);
   mode = tsip_word(); // rcvr mode
   tsip_word();        // power up in posn hold mode

   val = tsip_dword();
   cable_delay = ((float) val) / 1.0E9;
// if(have_cable_delay == 0) need_redraw = 2037;
   have_cable_delay = 1;

   survey_length = tsip_word();  // survey hours

   slat = tsip_dword();
   slon = tsip_dword();
   salt = tsip_dword();

   tsip_word();  // align to UTC

   tsip_word();  // traim alarm due to any time fault

   flag = tsip_word();  // traim disabled
   traim_threshold = tsip_word()*50;
   if(flag) {
      traim_mode = 0;
      traim_threshold = 0;
   }
   else traim_mode = 1;
   have_traim = 1;

   tsip_dword();  // reserved

   if(use_traim_lla) {
      lat = ((double) (S32) slat) * 1.0E-8;
      lon = ((double) (S32) slon) * 1.0E-8;
      alt = ((double) (S32) salt) * 1.0E-2;
//sprintf(debug_text2, "lla from traim");
   }

   show_cable_delay();
//sprintf(debug_text, "zod config %d: mode %d  traim threshold: %d  slat:%d", use_traim_lla, mode, traim_threshold, slat);
}

void parse_zod_traim_status()
{
u16 mode;
u16 survey;
u32 surv_count;
u32 surv_dur;
u16 hold_status;
u16 pps_status;
u16 traim_alarm;
u16 traim_disable;
u16 t_status;
u32 excluded;

   log_packet_id("traim status");

   get_zod_seq(0);

   mode = tsip_word();         //0=survey  1=posn hold   2=nav
   survey = tsip_word(); 
   surv_count = tsip_dword(); 
   surv_dur = tsip_dword(); 
   hold_status = tsip_word(); 
   pps_status = tsip_word(); 
   traim_alarm = tsip_word(); 

   traim_disable = tsip_word();
   t_status = tsip_word();
   excluded = tsip_dword();

   pps_offset = (((double) tsip_dword()) * 0.10);
   have_pps_offset = 4;
   have_rcvr_pps = 4;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);

   minor_alarms &= (~MINOR_SURVEY);
   if(mode == 0) {  // survey mode
      minor_alarms |= MINOR_SURVEY;
      rcvr_mode = RCVR_MODE_SURVEY;
   }
   else if(mode == 1) {  // position hold  zorky
      rcvr_mode = RCVR_MODE_HOLD;
   }
   else if(mode == 2) {  // standard nav
      rcvr_mode = RCVR_MODE_3D;
   }
   else rcvr_mode = RCVR_MODE_UNKNOWN; 

   if(pps_status & 0x02) {  // gps time
      time_flags &= (~TFLAGS_UTC);  // GPS based time 
      timing_mode = TMODE_GPS;
      have_timing_mode = 1;
   }
   else {    // utc time
      time_flags |= TFLAGS_UTC;     // UTC based time
      timing_mode = TMODE_UTC;
      have_timing_mode = 1;
   }
   have_rcvr_tmode = 1;

   if(t_status == 3) traim_status = 3;
   else              traim_status = 0;
   // !!!! note pps status bit 1 is traim alarm flag - the documentation says
   //      1 is traim error... this appears to be wrong... 0=error !!!!
//sprintf(plot_title, "rcvr mode:%d  zod mode:%d  traim_disable:%d  t_status:%d  pps_status:%04X  tflags:%02X  exclude:%08X", rcvr_mode, mode,traim_disable,traim_status,pps_status, time_flags, excluded);
}

void parse_zod_posn()
{
u16 flag1;
u16 type;
u16 used;
u16 flag2;
S32 val;

   log_packet_id("time / position");

   pps_enabled = pps_mode = 1;
   have_pps_enable = 5;
   have_pps_mode = 5;

   get_zod_seq(1);

   flag1 = tsip_word();
   type = tsip_word();
   used = tsip_word();
   flag2 = tsip_word();

   gps_week = tsip_word();
   faked_tow = 0;
   if(have_week == 0) need_redraw = 2038;
   have_week = 7;

   pri_tow = tow = this_tow = tsip_dword();
   if(have_tow == 0) need_redraw = 2039;
   have_tow = 7;
   survey_tow = tow;
   tsip_dword();  // tow nsecs

   pri_day = day = tsip_word();
   pri_month = month = tsip_word();
   pri_year = year = tsip_word();
   pri_hours = hours = tsip_word();
   pri_minutes = minutes = tsip_word();
   pri_seconds = seconds = tsip_word();
   pri_frac = raw_frac = ((double) tsip_dword()) * 1.0E-9;


   if(timing_mode == TMODE_GPS) {  // convert utc time to gps time
      utc_to_gps();
   }

   if(use_traim_lla == 0) {
      lat = ((double) (S32) tsip_dword()) * 1.0E-8;
      lon = ((double) (S32) tsip_dword()) * 1.0E-8;
      alt = ((double) (S32) tsip_dword()) * 1.0E-2;
   }
   else {
      tsip_dword();
      tsip_dword();
      tsip_dword();
   }

   tsip_word();   // geoid separation
   speed = ((double) tsip_dword()) / 100.0;  // speed
   heading = (((double)tsip_word()) / 1000.0) * 180.0 / PI; // course
   tsip_word();   // mvar 
   tsip_word();   // climb
   tsip_word();   // datum
   tsip_dword();  // horiz err
   tsip_dword();  // vert err
   tsip_dword();  // time err
   tsip_word();   // hv err
   val = tsip_dword();  // clock bias in meters
   tsip_dword();  // bias sdev
   tsip_dword();  // clock drift
   tsip_dword();  // clock drift sdev

   have_heading = 5;
   have_speed = 5;

   osc_offset = ((double) val) * 1.0E-2;  // clock bias (in meters)
   have_osc_offset = 4;
   have_rcvr_osc = 4;
osc_offset /= 299792458.0;  // convert meters to secs
osc_offset *= 1.0E9;        // convert secs to ns
//adadad   if(jitter_adev == 0) do_osc_adev(osc_offset);

// query_zod_msg(ZOD_TEMP_MSG);  // this does no good, current temp sensor reading is not sent by any message
   query_zod_msg(ZOD_TRAIM_CONFIG_MSG);  // to get dynamic lat/lon/alt values 
   update_gps_screen(1003);
}

void parse_zod_ee_written()
{
u16 flags;

   log_packet_id("eeprom write");

   get_zod_seq(0);
   flags = tsip_word();
   BEEP(508); // gggg
   ++ee_write_count;
//sprintf(debug_text, "ee_write:%04X  count:%d", flags,ee_write_count); 
}

void parse_zod_ee_status()
{
u16 flags;
u32 alm_fail;
u32 fail;
u32 alm_status;
u32 status;

   log_packet_id("eeprom status");

   get_zod_seq(0);
   flags = tsip_word();
   alm_fail = tsip_dword();
   fail = tsip_dword();
   alm_status = tsip_dword();
   status = tsip_dword();

   if(flags & 0x01) have_eeprom = 0;
   else             have_eeprom = 1;
}

void parse_zod_power()
{
u16 flags;

   log_packet_id("power");

   get_zod_seq(0);
   flags = tsip_word();
}

void parse_zod_id()
{
int i;

   log_packet_id("receiver id");

   get_zod_seq(0);

   for(i=0; i<20; i++) {
      zod_chans[i] = tsip_byte();
      zod_chans[i+1] = 0;
   }

   for(i=0; i<20; i++) {
      zod_sw[i] = tsip_byte();
      zod_sw[i+1] = 0;
   }

   for(i=0; i<20; i++) {
      zod_date[i] = tsip_byte();
      zod_date[i+1] = 0;
   }

   for(i=0; i<20; i++) {
      zod_opt[i] = tsip_byte();
      zod_opt[i+1] = 0;

   }

   for(i=0; i<20; i++) {
      zod_rsvd[i] = tsip_byte();
      zod_rsvd[i+1] = 0;
   }

   have_info |= ALL_ID_INFO;

// show_version_info();
}

void parse_zod_settings()
{
u16 snr_threshold;
u16 elev;
u16 platform;

   log_packet_id("setttings");

   get_zod_seq(0);

   zod_nav_flags = tsip_word();
   snr_threshold = ((zod_nav_flags >> 9) & 0x7F);

   tsip_word();        // col start timeout
   tsip_word();        // dgps timeout

   elev = tsip_word();
   el_mask = (float) elev;
   el_mask += 0.005F;
   el_mask = el_mask * (float) ((180.0/PI) / 1000.0);
   have_el_mask = 1;

   sats_enabled = tsip_dword();  // selected sats bit mask
   tsip_word();        // solution flags
   tsip_word();        // required sat count
   tsip_dword();       // required horiz err
   tsip_dword();       // required vert err
   platform = tsip_word();

   update_disable_list(sats_enabled);
}

void parse_zod_diags()
{
int ram;
int rom;
int ee;
int dp_ram;
int dsp;
int rtc;

   log_packet_id("diagnostics");

   get_zod_seq(0);
   rom = tsip_word();
   ram = tsip_word();
   ee  = tsip_word();
   dp_ram = tsip_word();
   dsp = tsip_word();
   rtc = tsip_word();

   tsip_word();   // serial port stats
   tsip_word();
   tsip_word();
   tsip_word();

   critical_alarms = 0;
   if(have_eeprom == 0) ee = 0;
   minor_alarms &= (~MINOR_EEPROM);

   if(rom) critical_alarms |= CRIT_ROM;   // ROM
   if(rtc) critical_alarms |= CRIT_OCXO;  // 1KHz / DCXO
   if(dsp) critical_alarms |= CRIT_FPGA;  // FPGA
   if(ram | dp_ram) critical_alarms |= CRIT_RAM;  // RAM
   if(ee) {
      minor_alarms |= MINOR_EEPROM;      // EEPROM
      have_eeprom = 1;
   }
   if(!have_critical_alarms) need_redraw = 7703;
   have_critical_alarms = 3;
}


void set_zod_sat_mask(u32 val)
{
   if(read_only) return;

   send_zod_start(ZOD_SET_SAT_MASK, 10, 0);
   send_zod_seq();
   send_dword(val);
   send_word(0);     // don't write to EEPROM
   send_zod_end();

   query_zod_msg(ZOD_SETTINGS_MSG);
}


void set_zod_nav_mode(int flags)
{
   if(read_only) return;

   send_zod_start(ZOD_SET_NAV_MODE, 15, 0);
   send_zod_seq();
   send_word(flags);
   send_word(0);
   send_word(0);
   send_word(0);
   send_word(0);
   send_word(0);
   send_word(0);
   send_word(0);
   send_zod_end();
}

void set_zod_protocol(int prot)
{
   if(read_only) return;

   if(prot < 0) return;
   if(prot > 1) return;

   send_zod_start(ZOD_SET_PROTOCOL, 9, 0);
   send_zod_seq();
   send_word(0);
   send_word(prot);
   send_zod_end();

   Sleep(250);
   if     (prot == 0) rcvr_type = ZODIAC_RCVR;
   else if(prot == 1) rcvr_type = NMEA_RCVR;
   config_rcvr_type(0);
   need_msg_init = 2006;
   init_messages(60, 1);
}

void set_zod_power(int power)
{
   if(read_only) return;

   send_zod_start(ZOD_SET_POWER, 8, 0);
   send_zod_seq();
   send_word(power);
   send_zod_end();
   Sleep(100);

   query_zod_msg(ZOD_POWER_MSG);
}

void set_zod_platform(int platform)
{
   if(read_only) return;

   send_zod_start(ZOD_SET_PLATFORM, 8, 0);
   send_zod_seq();
   send_word(platform);
   send_zod_end();
   Sleep(100);

   query_zod_msg(ZOD_SETTINGS_MSG);
}

void set_zod_config(int mode, double slat,double slon,double salt, u32 traim, int why)
{
S32 val;
u16 pps_suppress;

//sprintf(debug_text2, "set zod config: %d", why);
   if(read_only) return;

   send_zod_start(ZOD_SET_CONFIG, 24, 0);
   send_zod_seq();

   send_word(mode);
   send_word(1);     // power up in posn hold mode
   send_dword((S32) (cable_delay*1.0E9));
   send_word((u16) do_survey);  // hours

   val = (S32) (slat * 1.0E8);    // lat lon alt
   send_dword(val);
   val = (S32) (slon * 1.0E8);
   send_dword(val);
   val = (S32) (salt * 1.0E2);
   send_dword(val);

   pps_suppress = 0;  // !!!! zorky set to 1 to suppress PPS pulses if traim error

   if(time_flags & TFLAGS_UTC) send_word(0x0000 | pps_suppress);  // align to UTC
   else                        send_word(0x0002 | pps_suppress);  // align to GPS

   send_word(0x0007);  // traim alarm due to any time fault

   if(traim == 0) send_word(1);  // traim disabled
   else           send_word(0);  // traim enabled
   send_word(traim/50);

   send_dword(0);  // reserved

   send_zod_end();

   Sleep(200);  // zorky
   query_zod_msg(ZOD_TRAIM_CONFIG_MSG);
}


void decode_zod_message()
{
u16 id;

   start_msg_decode(1);

   id = zodiac_hdr[0];

   if     (id == ZOD_POSN_MSG)         parse_zod_posn();
   else if(id == ZOD_SNR_MSG)          parse_zod_snr();
   else if(id == ZOD_VIS_MSG)          parse_zod_vis();
   else if(id == ZOD_TRAIM_STATUS_MSG) parse_zod_traim_status();
   else if(id == ZOD_TRAIM_CONFIG_MSG) parse_zod_traim_config();
   else if(id == ZOD_DIAG_MSG)         parse_zod_diags();
   else if(id == ZOD_MARK_MSG)         parse_zod_mark();
   else if(id == ZOD_TEMP_MSG)         parse_zod_temp();
   else if(id == ZOD_EE_WRITE_MSG)     parse_zod_ee_written();
   else if(id == ZOD_EE_STATUS_MSG)    parse_zod_ee_status();
   else if(id == ZOD_POWER_MSG)        parse_zod_power();
   else if(id == ZOD_SETTINGS_MSG)     parse_zod_settings();
   else if(id == ZOD_ID_MSG)           parse_zod_id();
// else sprintf(debug_text, "unk zod msg:%d", id);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}

void get_zod_message()
{
static int hdr_ptr = 0;
u08 c;
static u16 cksum;
static u16 byte_count;
static int row = 3;

   // This routine buffers up an incoming Venus message.  When the end of the
   // message is seen, the message is parsed and decoded with parse_zodiac_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
   }


//if(tsip_sync == 0) fprintf(debug_file, "\n");
//if(debug_file) fprintf(debug_file, "%02X ", c);

   if(tsip_sync == 0) {         // syncing to start of message, search for a 0xFF
      if(c == 0xFF) {
         tsip_sync = 1;
         get_sync_time();
      }

      tsip_wptr = 0;
      tsip_rptr = 0;
      zodiac_rx_len = 0;
      zodiac_rx_cksum = 0;
      cksum = 0;
      byte_count = 0;
      zodiac_vfy_cksum = 0;
      hdr_ptr = 0;
      zodiac_hdr[0] = zodiac_hdr[1] = zodiac_hdr[2] = zodiac_hdr[3] = 0;
      return;
   }
   else if(tsip_sync == 1) { // 0xFF has been seen, now checking next byte
      if(c != 0x81) goto rst_msg;
      ++tsip_sync;           // 0xFF 0x81 seen... so get the message header
   }
   else if(tsip_sync == 2) { // header packet
      if(hdr_ptr >= 8) goto rst_msg;   // should never happen

      if(hdr_ptr & 1) {  // high byte
         zodiac_hdr[hdr_ptr>>1] += (((u16) c) * 256);
         zodiac_hdr[hdr_ptr>>1] &= 0xFFFF;
      }
      else {  // low byte
         zodiac_hdr[hdr_ptr>>1] = ((u16) c) & 0xFF;
      }

      if(++hdr_ptr >= 8) {  // end of header
         cksum = (0x81FF + zodiac_hdr[0] + zodiac_hdr[1] + zodiac_hdr[2]) & 0xFFFF;   
         if(cksum != 0x8000) cksum = (0 - cksum) & 0xFFFF;
         if(cksum != zodiac_hdr[3]) goto rst_msg;  // bad checksum;
         zodiac_rx_len = (zodiac_hdr[1]*2);
         if(zodiac_rx_len == 0) goto got_it;  // message has no payload, go parse it
         else {
            ++tsip_sync;
            cksum = 0;
//if(debug_file) fprintf(debug_file, "  [%d]  ", byte_count);
         }
      }
   }
   else if(tsip_sync == 3) {   // get Zodiac message payload
      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
         if(byte_count & 1) zodiac_rx_cksum += ((((u16) c) * 256) + cksum);
         else               cksum = (u16) c;    // low byte of word
         ++byte_count;
         --zodiac_rx_len;
         if(zodiac_rx_len == 0) ++tsip_sync;  // message payload processed, now get checksums
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 4) {  // get message checksum low byte
      zodiac_vfy_cksum = (u16) c;   // low byte of message checksum
      ++tsip_sync;
   }
   else if(tsip_sync == 5) {  // message checksum, end of venus message
      zodiac_vfy_cksum += ((u16) c) * 256;

      if(zodiac_rx_cksum != 0x8000) zodiac_rx_cksum = (0 - zodiac_rx_cksum) & 0xFFFF;
//sprintf(out, "id:%-4d  len:%-4d  flags:%04X  vfy:%04X  rx:%04X  bc:%-4d  dif:%04X", 
//zodiac_hdr[0], zodiac_hdr[1], zodiac_hdr[2], zodiac_vfy_cksum, zodiac_rx_cksum, byte_count, (zodiac_rx_cksum-zodiac_vfy_cksum)&0xFFFF);
//vidstr(row,3, YELLOW, out);
//if(row++>30) row = 0;
//refresh_page();
//if(debug_file) fprintf(debug_file, "  (v:%04X calc:%04X)\n", zodiac_vfy_cksum, zodiac_rx_cksum);
      if(zodiac_rx_cksum != zodiac_vfy_cksum) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }

      got_it:
      tsip_sync = 0;
      decode_zod_message();  // message checksum matches, process the message
      packet_end = 1;
   }
   else {     // should never happen
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
   }
}




//
//
//  Motorola receiver stuff  (binary message protocol)
//
//


void send_moto_start(char *s)
{
   // send a Motorola binary message start header
   if(s == 0) return;
   if(log_file && (log_stream & LOG_PACKET_START)) {
      fprintf(log_file, "\nSend moto start %s\n", s);
   }

   sendout(RCVR_PORT, '@', ADD_CHAR);
   sendout(RCVR_PORT, '@', ADD_CHAR);
   moto_tx_cksum = 0;
   send_byte(s[0]);
   send_byte(s[1]);
}

void send_moto_end()
{
   // send Motorola binary message checksum and end-of-packet
   sendout(RCVR_PORT, moto_tx_cksum, ADD_CHAR);
   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);
   if(sim_file == 0) Sleep(50);
}

void request_moto_leap(int rate)
{
   if(no_poll) return;

   send_moto_start("Gj");
   send_moto_end();

   send_moto_start("Bj");
   send_byte(rate);
   send_moto_end();
}


void get_moto_lla()
{
   // get lat/lon/alt fields from a motorola binary message

   lat = ((double) (S32) tsip_dword());  // filtered or unfiltered posn
   lon = ((double) (S32) tsip_dword());
   alt = ((double) (S32) tsip_dword());  // gps altitude

   lat = (lat / 3600000.0) * PI / 180.0; // milliarcseconds to radians
   lon = (lon / 3600000.0) * PI / 180.0;
   alt /= 100.0;  // convert cm to meters
}

void get_moto_time(int set_time)
{
   if(set_time) {
      pri_month = month = tsip_byte();
      pri_day = day = tsip_byte();
      pri_year = year = tsip_word();
      pri_hours = hours = tsip_byte();
      pri_minutes = minutes = tsip_byte();
      pri_seconds = seconds = tsip_byte();
      pri_frac = raw_frac = 0.0;
   }
   else {
      tsip_byte();
      tsip_byte();
      tsip_word();
      tsip_byte();
      tsip_byte();
      tsip_byte();
   }
}

void get_moto_tz()
{
   tsip_byte();  // local time zone offset
   tsip_byte();  // hours
   tsip_byte();  // minutes
}


void set_survey_status(int flag)
{
   if(flag) minor_alarms |= MINOR_SURVEY;    
   else     minor_alarms &= (~MINOR_SURVEY);
}

void decode_posn_mode()
{
   // convert position mode word into tbolt equivalents

   set_survey_status(0);

   if     (posn_mode == 0) rcvr_mode = RCVR_MODE_3D;
   else if(posn_mode == 1) rcvr_mode = RCVR_MODE_HOLD;
   else if(posn_mode == 2) rcvr_mode = RCVR_MODE_2D;
   else if(posn_mode == 3) set_survey_status(1);
   have_rcvr_mode = 4;
}


void decode_moto_status(int r_status)
{
int ant;
int mode;

   // convert status word into tbolt equivalents

   // Bit fields:
   //    0x0006 = antenna status
   //    0x0008 = no sats
   //    0x0010 = survey mode
   //    0x0020 = posn lock
   //    0x0040 = differential mode
   //    0x0080 = cold start
   //    0x0100 - unfiltered GPS
   //    0x0200 - fast acquisition mode
   //    0x0400 - narrow band filter
   //    0xE000 = rcvr mode
   //             7=3d  6=2d  5=propogeate 4=posn hold  3=acquiring 2=bad geom

   ant = (r_status >> 1) & 0x03;

   minor_alarms &= (~MINOR_ANT_NO_PWR);  // antenna state
   if     (ant == 3) minor_alarms |= MINOR_ANT_NO_PWR;  // unbiased
   else if(ant == 2) minor_alarms |= MINOR_ANT_OPEN;    // open
   else if(ant == 1) minor_alarms |= MINOR_ANT_SHORT;   // short
   have_antenna = 1;

   if(r_status & 0x0008) {
      minor_alarms |= MINOR_NO_TRACK;    // no sats
      gps_status = GPS_NO_SATS;
   }
   else { 
      minor_alarms &= (~MINOR_NO_TRACK);
      gps_status = GPS_FIXES;
   }
   have_gps_status = 1;
   have_tracking = 1;

   set_survey_status(r_status & 0x0010);

   if(r_status & 0x0080) minor_alarms |= MINOR_ALMANAC;   // cold start/no almanac
   else                  minor_alarms &= (~MINOR_ALMANAC);
   have_almanac = 1;

   //  mode: 7=3d  6=2d  5=propogate 4=posn hold  3=acquiring 2=bad geom
   mode = (r_status >> 13) & 0x07;  

   if(mode == 3) discipline_mode = DIS_MODE_RECOVERY;
   else          discipline_mode = DIS_MODE_NORMAL;

   if     (mode == 7) rcvr_mode = RCVR_MODE_3D;
   else if(mode == 6) rcvr_mode = RCVR_MODE_2D;
   else if(mode == 5) rcvr_mode = RCVR_MODE_PROP;
   else if(mode == 4) rcvr_mode = RCVR_MODE_HOLD;
   else if(mode == 3) rcvr_mode = RCVR_MODE_ACQUIRE;
   else if(mode == 2) rcvr_mode = RCVR_MODE_BAD_GEOM;
   else               rcvr_mode = RCVR_MODE_UNKNOWN;
   have_rcvr_mode = 5;
}


int get_moto_status()
{
int r_status;

   r_status = tsip_word();
   decode_moto_status(r_status);
   return r_status;
}


void get_moto_tag()
{
   id_tag[0] = tsip_byte();  // id string
   id_tag[1] = tsip_byte();
   id_tag[2] = tsip_byte();
   id_tag[3] = tsip_byte();
   id_tag[4] = tsip_byte();
   id_tag[5] = tsip_byte();
   id_tag[6] = 0;
}


void parse_moto_Ad()
{
   log_packet_id("latitude");
   lat = ((double) (S32) tsip_dword());  // lat
   lat = (lat / 3600000.0) * PI / 180.0; // milliarcseconds to radians
}

void parse_moto_Ae()
{
   log_packet_id("longitude");
   lon = ((double) (S32) tsip_dword());  // lon
   lon = (lon / 3600000.0) * PI / 180.0; // milliarcseconds to radians
}

void parse_moto_Af()
{
   log_packet_id("altitude");
   alt = ((double) (S32) tsip_dword());  // GPS height in cm
   tsip_dword();                         // MSL height in cm
   alt = (alt / 100.0); // cm to meters
}

void parse_moto_Ag()
{
   // elevation mask
   log_packet_id("elevation mask");
   el_mask = tsip_byte();
   have_el_mask = 1;
}

void parse_moto_Am()
{
u32 val;

   log_packet_id("ignore sats");
   tsip_byte();
   val = tsip_dword();  // sat ignore bitmask

   val = (~val);
   sats_enabled = val;
   update_disable_list(sats_enabled);

}

void parse_moto_AN()
{
u08 v_filter;

   // marine velocity filter
   log_packet_id("marine filter");
   v_filter = tsip_byte();
   marine_filter = v_filter;
   if((v_filter >= 10) && (v_filter <= 100)) have_filter |= MARINE_FILTER;
   else                                      have_filter &= (~MARINE_FILTER);
}

void parse_moto_AP()
{
   // PPS rate (1 / 100 PPS)
   log_packet_id("pps rate");
   pps_rate = tsip_byte();
   have_pps_rate = 5;
}

void parse_moto_Ap()
{
   log_packet_id("user datum");
}

void parse_moto_Aq()
{
u08 iono;

   // ionosphere corrections
   log_packet_id("iono/tropo filters");
   iono = tsip_byte();  // 0x01=iono, 0x02:tropo
   if(iono & 0x01) static_filter = 1;
   else            static_filter = 0;
   have_filter |= STATIC_FILTER;

   // troposphere corrections
   if(iono & 0x02) alt_filter = 1;
   else            alt_filter = 0;
   have_filter |= ALT_FILTER;
//sprintf(plot_title, "iono:%02x", iono);
}

void parse_moto_AQ()
{
u08 v_filter;

   // position filter
   log_packet_id("pv filter");
   v_filter = tsip_byte();
   pv_filter = v_filter;
   have_filter |= PV_FILTER;
//sprintf(debug_text, "Pfilter:%02x", pv_filter);
}

void parse_moto_Ar()
{
u08 fix_type;

   // fix type
   log_packet_id("fix type");
   fix_type = tsip_byte();  // 0=best 4, 1=all in view
//sprintf(debug_text2, "fix type:%02x", fix_type);
}

void parse_moto_At()
{
   // position hold status
   log_packet_id("positioning mode");
   posn_mode = tsip_byte();  // 0=3D, 1=posn hold
   decode_posn_mode();
}

void parse_moto_Ay()
{
   // pps delay
   log_packet_id("pps delay");
   pps1_delay = (double) (S32) tsip_dword();
   have_pps_delay |= 0x01;
   show_cable_delay();
}

void parse_moto_Aw()
{
u08 x;

   // GPS (0) UTC (1) select
   log_packet_id("timing mode");
   x = tsip_byte();  
   if(x == 0) {
      time_flags &= (~TFLAGS_UTC);
      timing_mode = TMODE_GPS;
      have_timing_mode = 1;
   }
   else {
      time_flags |= (TFLAGS_UTC);
      timing_mode = TMODE_UTC;
      have_timing_mode = 1;
   }
   have_rcvr_tmode = 1;
}

void parse_moto_Az()
{
S32 val;

   // cable delay
   log_packet_id("cable delay");
   val = tsip_dword();
   cable_delay = ((double) val) / 1.0E9;
// if(have_cable_delay == 0) need_redraw = 2040;
   have_cable_delay = 1;
   show_cable_delay();
}


void parse_moto_Wb()
{
   // message used to put Jupiter-T into Zodiac mode
   log_packet_id("language mode");
//BEEP(509); //gggggg
}

void parse_moto_Bb()
{
int i;
int nsats;
int prn;
s16 doppler;
int el;
int az;
int health;

   log_packet_id("sat visibility");
   nsats = tsip_byte();
   for(i=0; i<12; i++) {
      prn     = tsip_byte();
      doppler = tsip_word();
      el      = tsip_byte();
      az      = tsip_word();
      health  = tsip_byte();

      if((prn >= 1) && (prn <= MAX_PRN)) { 
         set_sat_azel(prn, (float) az, (float) el);
         sat[prn].doppler = (float) doppler;
         sat[prn].health_flag = health;  // 0=healthy  1=unhealthy
         have_sat_azel = 7;
         if(sat[prn].doppler != 0.0F) {
            if(have_doppler == 0) need_redraw = 2041;
            have_doppler |= rinex_gnss(prn);
         }
      }
   }
}

void parse_moto_Bd()
{
u08 valid;
u08 week;
u08 time;
u08 sv_count;
u32 sv_mask;

   // almanac status
   log_packet_id("almanac status");

   valid = tsip_byte();
   week = tsip_byte();
   time = tsip_byte();
   sv_count = tsip_byte();
   sv_mask = tsip_dword();

   tsip_byte();  // reserved bytes
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();
   tsip_byte();

   if(valid) minor_alarms &= (~MINOR_ALMANAC);
   else      minor_alarms |= MINOR_ALMANAC;
   have_almanac = 1;
}


void parse_moto_Bj()
{
int leap;

   // get leapscond pending info
   log_packet_id("leapsecond info");
   if(have_moto_Gj) return;  // M12 messes this up, always reports no leap

   leap = tsip_byte();
   if(leap) {
      minor_alarms |= MINOR_LEAP_PEND;
   }
   else { 
      minor_alarms &= (~MINOR_LEAP_PEND);
   }
   have_leap_info = 3;
}

void parse_moto_Bo()
{
int i;

   // gps/utc time offset
   log_packet_id("utc offset");
   i = (int) (s08) tsip_byte(); 

   if(!user_set_utc_ofs) {
      utc_offset = i;
      check_utc_ofs(8);
   }
}


void parse_moto_Ca()
{
u16 status;

   log_packet_id("self test results");
   status = tsip_word();     // 6 channel self test

   critical_alarms = 0;
   minor_alarms &= (~MINOR_EEPROM);

   if(status & 0x0280) critical_alarms |= CRIT_ROM;   // ROM
   if(status & 0x0500) critical_alarms |= CRIT_RAM;   // RAM
   if(status & 0x1040) critical_alarms |= CRIT_OCXO;  // 1KHz / DCXO
   if(status & 0xE03F) critical_alarms |= CRIT_FPGA;  // FPGA

   if(status & 0x0800) minor_alarms |= MINOR_EEPROM;  // EEPROM
   have_eeprom = 1;
   if(!have_critical_alarms) need_redraw = 7704;
   have_critical_alarms = 4;

   init_messages(24, 1);
}

void parse_moto_Cg()
{
   log_packet_id("device active");
   moto_active = tsip_byte();     // 0=idle 1=active
}


                                    
void parse_moto_Cj()
{
int c;
int i;

   // Motorola receiver id message:

   // <cr><lf>
   // COPYRIGHT 1991-199X MOTOROLA INC.<cr><lf> 
   // SFTW P/N # XXXXXXXXXXXXXXX<cr><lf> 
   // SOFTWARE VER # XXXXXXXXXXX<cr><lf> 
   // SOFTWARE REV # XXXXXXXXXXX<cr><lf> 
   // SOFTWARE DATE  XXXXXXXXXXX<cr><lf> 
   // MODEL #    XXXXXXXXXXXXXXX<cr><lf> 
   // HDWR P/N # XXXXXXXXXXXXXXX<cr><lf> 
   // SERIAL #   XXXXXXXXXXXXXXX<cr><lf> 
   // MANUFACTUR DATE XXXXXXXXXX<cr><lf> 
   // OPTIONS LIST    XXXXXXXXXX<cr><lf> 

   log_packet_id("receiver id");
   i = 0;
   moto_id_lines = 0;
   moto_id[moto_id_lines][0] = 0;

   while(moto_msg_len > 0) {  // get the lines from the device id message
      c = tsip_byte();

      if(c == 0x00) ;
      else if(c == 0x0D) ;
      else if(c == 0x0A) {
         ++moto_id_lines;
         if(moto_id_lines >= MAX_ID_LINES) break;
         i = 0;
         moto_id[moto_id_lines][0] = 0;
      }
      else if(i <= 128) {
         moto_id[moto_id_lines][i++] = c;
         moto_id[moto_id_lines][i] = 0;
      }
      --moto_msg_len;
   }
   if(1 || moto_id_lines) saw_version |= 0x1000;

   have_info |= ALL_ID_INFO;
   furuno_moto = 0;
   if(moto_id[1][0]) {
      if(strstr(moto_id[1], "Furuno")) furuno_moto = 1;
   }

// show_version_info();

if(debug_file) {
   for(i=0; i<moto_id_lines; i++) fprintf(debug_file, "[%s]\n", &moto_id[i][0]);
}
}

void parse_moto_Ea(int num_chans)
{
int i;
int prn;
int mode;
int sig;
int s1;
int s2;
int dop;
S32 frac;

   if(num_chans == 6)      log_packet_id("6-chan sat info");
   else if(num_chans == 8) log_packet_id("8-chan sat info");
   else                    log_packet_id("unkn-chans sat info");

   if((num_chans == 6) && have_moto_Ea) return;

   if(num_chans != moto_chans) {
      moto_chans = num_chans;
      config_msg_ofs();
   }

   get_moto_time(1);   //+0
   frac = (S32) tsip_dword();    //+7 !!!! fractional time in nsec 
   pri_frac = raw_frac = ((double) frac) / 1.0E9;

   get_moto_lla();     //+11
   tsip_dword();       //+23 msl altitude

   speed = ((double) tsip_word()) / 100.0;   //+27 3d speed
   heading = ((double) tsip_word() / 10.0);  //+29 heading

   have_speed = 6;
   have_heading = 6;

   dop = tsip_word();  //+30
   i = tsip_byte();    //+32

   have_dops = 0;
   if(i) {
      hdop = ((float) dop) / 10.0F;
      have_dops |= HDOP;
   }
   else {
      pdop = ((float) dop) / 10.0F;
      have_dops |= PDOP;
   }

   sat_count = tsip_byte();    //+33 visible
   have_count = 5;
   track_count = tsip_byte();  //+34 tracked

   reset_sat_tracking();

   sat_count = 0;
   for(i=0; i<num_chans; i++) {  //+35
      prn = tsip_byte();
      mode = tsip_byte();
      sig = tsip_byte();
      s1 = tsip_byte();
      if((prn >= 1) && (prn <= MAX_PRN)) { 
         if(sig >= 2) sat[prn].sig_level = (float) (20.0*log10((double) sig)+6.00);
         else         sat[prn].sig_level = ((float) sig);
         sat[prn].level_msg = 12;
         sat[prn].sv_accuracy = 0.0F;
         sat[prn].state= mode;
         if(mode == 8) sat[prn].tracking = 1;
         else          sat[prn].tracking = (-1);

         have_snr |= rinex_gnss(prn);
         if(have_state == 0) need_redraw = 2043;
         have_state = MOTO_STATE;   // STATE

         record_sig_levels(prn);
         ++sat_count;
         have_count = 22;
      }
   }
   config_sat_count(sat_count);

   s2 = tsip_byte();

   level_type = "dBc";

   have_temperature = 0;
   plot[TEMP].show_plot = 0;

   request_moto_leap(0);
   update_gps_screen(1003);
}


void parse_moto_Eg(int num_chans)
{
u32 xtow;
int week;
double jd;
int i;
int prn;
int mode;
double sat_tow;
double range;
double phase;
u32 icp;
u32 icp2;
u32 cycles;
int lli;

   // raw measurement data
   if(num_chans == 6)      log_packet_id("6-chan raw observation info");
   else if(num_chans == 8) log_packet_id("8-chan raw observation info");
   else                    log_packet_id("unkn-chans observation info");

   if((num_chans == 6) && have_moto_Eg) return;

   have_moto_range = num_chans;
   if(num_chans != moto_chans) {
      moto_chans = num_chans;
      config_msg_ofs();
   }

   xtow = tsip_word() * 256;
   xtow += tsip_byte();
   obs_tow = ((double) tsip_dword()) / 1.0E9;
   obs_tow += (double) xtow;

   jd = jd_gps - GPS_EPOCH;   // !!!! will this work
   week = (int) (jd / 7.0);
   jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,obs_tow);

   for(i=0; i<num_chans; i++) {
      prn = tsip_byte();
      if(prn <= 0) continue;
      if(prn > 32) continue;

      mode = tsip_byte();
      if(mode & 0xC0) lli = LOCK_LOST;
      else            lli = 0;
      sat[prn].ca_lli = lli;

      xtow = tsip_tbyte();
      sat_tow = ((double) tsip_dword()) / 1.0E9;
      sat_tow += (double) xtow;

      range = (obs_tow - sat_tow) * (LIGHTSPEED*1000.0);  // !!!!! fix end-of-week rollover
if(sat[prn].tracking <= 0.0) range = 0.0;
      sat[prn].range = range;  
      if(range) {
         have_range |= rinex_gnss(prn);
      }

      icp = (u32) (u16) tsip_word();  // raw carrier phase
      icp2 = (u32) (u16) tsip_word();
if(debug_file && show_debug_info) fprintf(debug_file, "@@Eg %2d: %u %u ", prn, icp,icp2);
      phase = ((double) icp) * 65536.0;
      phase += (double) icp2;

      phase = phase * 360.0 / 65536.0;  // in degrees
//phase = phase / 360.0; 
if(sat[prn].tracking <= 0.0) phase = 0.0;
      sat[prn].code_phase = phase;
      if(0 && phase) { 
         have_phase |= rinex_gnss(prn);
      }

      cycles = tsip_tbyte(); // raw code phase
if(debug_file && show_debug_info) fprintf(debug_file, "tow:%.3f  phase:%.3f  range:%.3f  cycles:%d  endian:%d\n", sat_tow, phase, range, cycles, ENDIAN);
      tsip_word(); // code discriminator
   }
}

void parse_moto_Ek(int num_chans)
{
u16 dop;
int i;
int bias;
int osc;

   if(num_chans == 6)      log_packet_id("6-chan position info");
   else if(num_chans == 8) log_packet_id("8-chan position info");
   else                    log_packet_id("unkn-chans position info");

   if((num_chans == 6) && have_moto_Ek) return;

   if(num_chans != moto_chans) {
      moto_chans = num_chans;
      config_msg_ofs();
   }

   have_dops = 0;
   dop = tsip_word();
   gdop = ((float) dop) / 10.0F;
   dop = tsip_word();
   pdop = ((float) dop) / 10.0F;
   dop = tsip_word();
   hdop = ((float) dop) / 10.0F;
   dop = tsip_word();
   vdop = ((float) dop) / 10.0F;
   dop = tsip_word();
   tdop = ((float) dop) / 10.0F;
   have_dops |= (GDOP | PDOP | HDOP | VDOP | TDOP);

   tsip_word();  // mag variation
   tsip_word();  // north velocity
   tsip_word();  // east velocity
   tsip_word();  // up velocity

   tsip_word();  // differential age
   tsip_dword(); // ecef coords
   tsip_dword();
   tsip_dword();   

   for(i=0; i<num_chans; i++) {
      tsip_byte();  // r
   }

   for(i=0; i<10; i++) {
      tsip_word();  // a1 elements
   }

   bias = (int) (s16) tsip_word();  // clock bias
   osc_offset = bias;  // !!!! zzzzz
   have_osc_offset = 5;
   have_rcvr_osc = 5;
//adadad   if(jitter_adev == 0) do_osc_adev(osc_offset);
   osc = tsip_word();  // osc offset
}

void parse_moto_En(int num_chans)
{
int i;
S32 sawtooth;
s16 accu;

   if(num_chans == 6)      log_packet_id("6-chan traim info");
   else if(num_chans == 8) log_packet_id("8-chan traim info");
   else                    log_packet_id("unkn-chans traim info");

   if((num_chans == 6) && have_moto_En) return;

   if(num_chans != moto_chans) {
      moto_chans = num_chans;
      config_msg_ofs();
   }

   tsip_byte();  // output rate
   traim_mode = tsip_byte();
   have_traim = 1;
   traim_threshold = tsip_word();
   pps_enabled = pps_mode = tsip_byte();  // 0=off, 1=always on,  2=on when tracking, 3=on when traim met
   have_pps_enable = 6;
   have_pps_mode = 6;

   tsip_byte();  // pps rate   // !!!!! have_pps_rate
   tsip_byte();
   tsip_byte();

   tsip_byte();  // next pps time
   tsip_byte();
   tsip_word();
   tsip_byte();
   tsip_byte();
   tsip_byte();

   tsip_byte();  // pps status (=0off, 1=enabled)
   tsip_byte();  // 0=sync to UTC  1=sync to GPS
   traim_status = tsip_byte();
   tsip_byte();

   accu = tsip_word();     // time accuracy
   sawtooth = tsip_byte(); // sawtooth
   if(sawtooth & 0x80) sawtooth |= (~(S32)0xFF);
   have_sawtooth = 1;

   dac_voltage = (float) sawtooth;
   pps_offset = (double) accu;
   have_pps_offset = 5;
   have_rcvr_pps = 5;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);

   for(i=0; i<num_chans; i++) {
      tsip_byte();  // prn
      tsip_dword(); // time fraction
   }
//sprintf(debug_text2, "En: thresh:%d tmode:%d tstat:%d  pps:%d  saw:%d  rate:%d   ", 
//traim_threshold,traim_mode,traim_status,pps_mode,sawtooth,pps_rate);
}

void parse_moto_Eq()
{
   // ascii position message
   log_packet_id("ascii position");
}

void parse_moto_Fa()
{
u16 status;

   log_packet_id("self test results");
   status = tsip_word();     // 8 channel self test

   critical_alarms = 0;
   minor_alarms &= (~MINOR_EEPROM);

   if(status & 0x0600) critical_alarms |= CRIT_ROM;   // ROM
   if(status & 0x1800) critical_alarms |= CRIT_RAM;   // RAM
   if(status & 0x4100) critical_alarms |= CRIT_OCXO;  // 1KHz / DCXO
   if(status & 0x80FF) critical_alarms |= CRIT_FPGA;  // FPGA

   if(status & 0x2000) minor_alarms |= MINOR_EEPROM;  // EEPROM
   have_eeprom = 1;
   if(!have_critical_alarms) need_redraw = 7705;
   have_critical_alarms = 5;

   init_messages(25, 1);
}

void parse_moto_Ga()
{
   log_packet_id("position");
   get_moto_lla();
   tsip_byte();     // height type
}

void parse_moto_Gb()
{
   log_packet_id("time");
   get_moto_time(1);
   get_moto_tz();
}

void parse_moto_Gc()
{
   log_packet_id("pps state");
   pps_enabled = pps_mode = tsip_byte();  // 0=off, 1=always on,  2=on when tracking, 3=on when traim met
   have_pps_enable = 7;
   have_pps_mode = 7;
}

void parse_moto_Gd()
{
   log_packet_id("positioning mode");
   posn_mode = tsip_byte();  // 0=3D, 1=posn hold,  2=2D, 3=timing auto survey
   decode_posn_mode();
}

void parse_moto_Ge()
{
   log_packet_id("traim enable");
   traim_mode = tsip_byte();  // 0=disabled  1=enabled
}

void parse_moto_Gf()
{
   log_packet_id("traim threshold");
   traim_threshold = tsip_word();  // in 100nS increments
}


void parse_moto_Gj()
{
u08 present, future;
u16 leap_year;
u08 leap_month;
u16 leap_day;
u08 leap_hour;
u08 leap_min;
u08 leap_sec;
double jd;

   // leapsecond info
   log_packet_id("leapsecond info");
   present = tsip_byte();
   future = tsip_byte();
   leap_year = tsip_word();
   leap_month = tsip_byte();
   leap_day = tsip_byte();

   tsip_byte();
   tsip_dword();

   leap_hour = tsip_byte();
   leap_min = tsip_byte();
   leap_sec = tsip_byte(); 

   if(present != future) {    // leapsecond pending
      minor_alarms |= (MINOR_LEAP_PEND);
      jd = jdate(leap_year, leap_month, leap_day) - 1.0;  // -1 since moto says 2017/1/1
      jd_leap = jd + jtime(23,59,59,0.0);
      have_jd_leap = 3;
      calc_jd_leap(3);

//      jd -= jdate(year, month, day);  // days until leap occurs
//      leap_days = ((int) jd);
//      have_leap_days = 0;
//      if(leap_days >= LEAP_THRESH) leap_days = (-1);
//      else have_leap_days = 2;
//sprintf(plot_title, "pres:%d fut:%d %04d/%02d/%02d   days:%d", present,future,leap_year,leap_month,leap_day, leap_days);
   }
   else {
      minor_alarms &= (~MINOR_LEAP_PEND);
   }

   have_moto_Gj = 1;
   have_leap_info = 4;
}

void parse_moto_Gk()
{
   log_packet_id("device tag");
   get_moto_tag();
}


void parse_moto_Ha(int long_msg)
{
int i;
int prn;
int mode;
int sig;
int iode;
int status;
int r_status;
int dop;
int bias;
u16 tword;
S32 ofs;
int utc;
int acc;
float t;
S32 frac;

//max_sats = 12;
//ebolt = 1;
   log_packet_id("position/satellite info");
   if(moto_chans != 12) {
      moto_chans = 12;
      config_msg_ofs();
   }

   get_moto_time(1);
   frac = (S32) tsip_dword();  // !!!! fractional time in nsec 
   pri_frac = raw_frac = ((double) frac) / 1.0E9;

   get_moto_lla();
   tsip_dword();  // msl altitude

   if(long_msg) {
      tsip_dword();  // unfiltered posn
      tsip_dword();
      tsip_dword();
      tsip_dword();  // msl altitude
   }

   speed = ((double) tsip_word()) / 100.0;   // 3d speed
   tsip_word();                              // 2d speed
   heading = ((double) tsip_word()) / 10.0;  // heading

   have_heading = 2;
   have_speed = 2;

   dop = tsip_word();
   have_dops = 0;

   sat_count = tsip_byte();    // visible
   track_count = tsip_byte();  // tracked
   have_count = 6;

   if(long_msg) {
      reset_sat_tracking();
      sat_count = 0;
      for(i=0; i<12; i++) {
         prn = tsip_byte();
         mode = tsip_byte();
         sig = tsip_byte();
         iode = tsip_byte();
         status = tsip_word();
         if((prn >= 1) && (prn <= MAX_PRN)) { 
            if(0 && (sig >= 2)) sat[prn].sig_level = (float) (20.0*log10((double) sig)+6.00);
            else sat[prn].sig_level = ((float) sig);

            sat[prn].level_msg = 13;

            sat[prn].state = mode;
            sat[prn].iode = (u08) iode;

            have_snr |= rinex_gnss(prn);

            acc = (status & 0x000F);
            sat[prn].sv_accuracy = ura_to_dist(prn, acc);

            if(have_state == 0) need_redraw = 2044;
            have_state = MOTO_STATE;  // STATE

            if(have_accu == 0) need_redraw = 2045;
            have_accu = 1;

            sat[prn].tracking = (-1);
            if(status & 0x0880) {
               if(0 || (mode == 8)) {
                  sat[prn].tracking = 1;
               }
            }

            record_sig_levels(prn);
            ++sat_count;
            have_count = 23;
         }
      }
      config_sat_count(sat_count);
   }

   r_status = get_moto_status();

   have_dops = 0;
   if((r_status & 0xE000) == 0xE000) {
      pdop = ((float) dop) / 10.0F;  // 3D fix
      have_dops |= PDOP;
   }
   else if((r_status & 0xE000) == 0x6000) {
      hdop = ((float) dop) / 10.0F;  // 2D fix
      have_dops |= HDOP;
   }
   else {
      hdop = pdop = ((float) dop) / 10.0F;  // 2D fix
      have_dops |= (HDOP | PDOP);  // !!!!
   }

   tsip_word();  // reserved

   if(long_msg) {
      bias = (int) (s16) tsip_word();  // nanoseconds
      ofs = tsip_dword();
      osc_offset = bias;  // !!!! zzzzz
      have_osc_offset = 6;
      have_rcvr_osc = 6;
//adadad      if(jitter_adev == 0) do_osc_adev(osc_offset);

      tword = tsip_word();  // temperature
      t = ((float) (s16) tword) / 2.0F;  // temperature
//sprintf(debug_text2, "tword:%d %04X  t=%g", tword,tword,t);
      if(have_temperature || (t != 0.0)) {
         temperature = t;
         have_temperature = 108;
      }

      utc = tsip_byte();  // time mode 
      if(utc & 0x80) time_flags |= TFLAGS_UTC;     // utc time
      else           time_flags &= (~TFLAGS_UTC);  // gps time

      if(utc & 0x40) time_flags &= (~TFLAGS_NO_UTC_OFS);  // utc offset avail
      else           time_flags |= (TFLAGS_NO_UTC_OFS);

      if(!user_set_utc_ofs) {
         utc_offset = utc & 0x1F;
         check_utc_ofs(9);
      }

      get_moto_tz();
   }

   get_moto_tag();

//sprintf(plot_title, "r_status:%04X  bias:%d  ofs:%d  t:%f  utc:%02X  tag:%s  tmode:%d thresh:%d", 
//r_status, bias, ofs, t, utc, id_tag, traim_mode,traim_threshold);

   level_type = "dBc"; 

   update_gps_screen(1005);
}

void parse_moto_Hn()
{
int i;
S32 sawtooth;
s16 accu;
int traim_flag;
int prn;
u32 frac;

   log_packet_id("traim info");
   if(moto_chans != 12) {
      moto_chans = 12;
      config_msg_ofs();
   }

   tsip_byte();   // pulse
   tsip_byte();   // synced to
   traim_status = tsip_byte();  // timing solution
   traim_flag = tsip_byte();    // traim status
   have_traim = 1;
//sprintf(debug_text2, "traim status:%d", traim_status);
   tsip_dword();  // Traim removed sats vector

   accu = tsip_word();     // time accuracy
   sawtooth = tsip_byte(); // sawtooth
   if(sawtooth & 0x80) sawtooth |= (~(S32)0xFF);
   have_sawtooth = 1;

   dac_voltage = (float) sawtooth;
   pps_offset = (double) accu;
   have_pps_offset = 6;
   have_rcvr_pps = 6;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);

   for(i=0; i<12; i++) {
      prn = tsip_byte();  // prn
      frac = tsip_dword(); // time fraction
      if(frac >= 1000000000) frac = 0;

      if(0 && (prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].sat_bias = (float) (((double) frac) * 1.0E-9);
         sat[prn].last_bias_msg = 2;

         if(frac > 0) {
            if(have_bias == 0) need_redraw = 2047;
            have_bias = 2;
         }
      }
   }
//sprintf(debug_text2, "Hn: thresh:%d tmode:%d tstat:%d flag:%d   pps:%d  saw:%d  rate:%d  accu:%d ", 
//traim_threshold,traim_mode,traim_status,traim_flag,   pps_mode,sawtooth,pps_rate,accu);
//sprintf(debug_text, "baud:%d db:%d par:%d stop:%d", baud_rate,com[RCVR_PORT].data_bits,com[RCVR_PORT].parity,com[RCVR_PORT].stop_bits);
}


void parse_moto_Hr()
{
int i;
int prn;
u08 iode;
double pr;

   log_packet_id("inverse differential");
   if(moto_chans != 12) {
      moto_chans = 12;
      config_msg_ofs();
   }
   have_moto_Hr = 1;

   get_moto_time(0);                  

   gps_week = tsip_word();  // these are what we really want from this message         
   faked_tow = 0;
   if(have_week == 0) need_redraw = 2048;
   have_week = 8;
   pri_tow = tow = this_tow = tsip_dword();               
   if(have_tow == 0) need_redraw = 2049;
   have_tow = 8;
   survey_tow = tow;

   obs_tow = (double) tow;
   jd_obs = GPS_EPOCH + ((double) gps_week * 7.0) + jtime(0,0,0,tow);

   get_moto_lla();    // lat/lon/alt               
   speed = tsip_word();   // speed          
   heading = tsip_word(); // heading        
   get_moto_status();                
   tsip_word();       // dop            
   tsip_byte();       // dop type       

   tsip_byte();       // vis count      
   tsip_word();       // fix vector     

   have_speed = 3;
   have_heading = 3;
                                     
   for(i=0; i<12; i++) {
      prn = tsip_byte();    // prn
      iode = tsip_byte();   // iode
      pr = (double) (unsigned) tsip_dword();   // pseudorange in cm
      pr /= 100.0;    // meters
      tsip_dword();   // range rate

      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].iode = (u08) iode;
         if(have_moto_range == 0) {  // use the @@Bg/@@Eg message
            sat[prn].range = pr;
            if(pr) {
               have_range |= rinex_gnss(prn);
            }
         }
      }
   }
                                     
   get_moto_tag();    // id tag         
}

void parse_moto_Ia()
{
u08 stat1;
u16 stat2;
u32 status;

   log_packet_id("alarms");

   stat1 = tsip_byte();
   stat2 = tsip_word();

   status = stat1;
   status <<= 16;
   status |= stat2; 

   critical_alarms = 0;
   minor_alarms &= (~MINOR_EEPROM);

   if(status & 0x020000) critical_alarms |= CRIT_ROM;  // ROM
   if(status & 0x040000) critical_alarms |= CRIT_RAM;  // RAM
   if(status & 0x012000) critical_alarms |= CRIT_OCXO; // 1KHz / DCXO
   if(status & 0x000FFF) critical_alarms |= CRIT_FPGA; // FPGA
   if(status & 0x305000) critical_alarms |= CRIT_FPGA; // FPGA

   if(status & 0x000000) minor_alarms |= MINOR_EEPROM; // EEPROM
   have_eeprom = 1;
   if(!have_critical_alarms) need_redraw = 7706;
   have_critical_alarms = 6;

   init_messages(26, 1);
}

void parse_moto_Sz()
{
   // power up self test failed
   log_packet_id("power-up test results");

   tsip_byte();

   critical_alarms = CRIT_ALL;  // 0x1F;
   if(!have_critical_alarms) need_redraw = 7707;
   have_critical_alarms = 7;
   minor_alarms = MINOR_ALL;
}


void skip_moto_msg()
{
   log_packet_id("ignored message");
   while(moto_msg_len > 0) {
      tsip_byte();
      --moto_msg_len;
   }
}


int find_moto_cmd(int cmd1, int cmd2)
{
   // !!!!! lookup Motorola binary command and return message length
   if     ((cmd1 == 'A') && (cmd2 == '@')) return (-1);

   else if((cmd1 == 'A') && (cmd2 == 'a')) return (10-7);
   else if((cmd1 == 'A') && (cmd2 == 'A')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'b')) return (10-7);
   else if((cmd1 == 'A') && (cmd2 == 'B')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'c')) return (11-7);
   else if((cmd1 == 'A') && (cmd2 == 'C')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'd')) return 11-7;
   else if((cmd1 == 'A') && (cmd2 == 'D')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'e')) return 11-7;
   else if((cmd1 == 'A') && (cmd2 == 'E')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'f')) return 15-7;
   else if((cmd1 == 'A') && (cmd2 == 'g')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'h')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'i')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'j')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'k')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'l')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'm')) return 12-7;
   else if((cmd1 == 'A') && (cmd2 == 'M')) return 11-7;
   else if((cmd1 == 'A') && (cmd2 == 'n')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'N')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'o')) return 25-7;
   else if((cmd1 == 'A') && (cmd2 == 'O')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'p')) return 25-7;
   else if((cmd1 == 'A') && (cmd2 == 'P')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'q')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'Q')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'r')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 's')) return (20-7);
   else if((cmd1 == 'A') && (cmd2 == 't')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'u')) return (12-7);
   else if((cmd1 == 'A') && (cmd2 == 'v')) return (8-7);
   else if((cmd1 == 'A') && (cmd2 == 'w')) return 8-7;
   else if((cmd1 == 'A') && (cmd2 == 'x')) return (9-7);
   else if((cmd1 == 'A') && (cmd2 == 'y')) return 11-7;
   else if((cmd1 == 'A') && (cmd2 == 'z')) return 11-7;

   else if((cmd1 == 'B') && (cmd2 == 'a')) return 68-7;
   else if((cmd1 == 'B') && (cmd2 == 'b')) return 92-7;
   else if((cmd1 == 'B') && (cmd2 == 'c')) return 82-7;
   else if((cmd1 == 'B') && (cmd2 == 'd')) return 23-7;
   else if((cmd1 == 'B') && (cmd2 == 'e')) return 33-7;
   else if((cmd1 == 'B') && (cmd2 == 'f')) return 80-7;
   else if((cmd1 == 'B') && (cmd2 == 'g')) return 122-7;
   else if((cmd1 == 'B') && (cmd2 == 'h')) return 52-7;
   else if((cmd1 == 'B') && (cmd2 == 'i')) return 80-7;
   else if((cmd1 == 'B') && (cmd2 == 'j')) return 8-7;
   else if((cmd1 == 'B') && (cmd2 == 'k')) return 69-7;
   else if((cmd1 == 'B') && (cmd2 == 'l')) return 41-7;
   else if((cmd1 == 'B') && (cmd2 == 'n')) return 59-7;
   else if((cmd1 == 'B') && (cmd2 == 'o')) return 8-7;
   else if((cmd1 == 'B') && (cmd2 == 'p')) return 29-7;

   else if((cmd1 == 'C') && (cmd2 == 'a')) return 9-7;
   else if((cmd1 == 'C') && (cmd2 == 'b')) return 9-7;
   else if((cmd1 == 'C') && (cmd2 == 'd')) return 171-7;
   else if((cmd1 == 'C') && (cmd2 == 'e')) return 7-7;
   else if((cmd1 == 'C') && (cmd2 == 'f')) return 7-7;
   else if((cmd1 == 'C') && (cmd2 == 'g')) return 8-7;
   else if((cmd1 == 'C') && (cmd2 == 'h')) return 9-7;
   else if((cmd1 == 'C') && (cmd2 == 'i')) return 8-7;   // actually msg has no response
   else if((cmd1 == 'C') && (cmd2 == 'j')) return 294-7;
   else if((cmd1 == 'C') && (cmd2 == 'k')) return 7-7;
   else if((cmd1 == 'C') && (cmd2 == 'o')) return 29-7;

   else if((cmd1 == 'E') && (cmd2 == 'a')) return 76-7;
   else if((cmd1 == 'E') && (cmd2 == 'c')) return 82-7;
   else if((cmd1 == 'E') && (cmd2 == 'g')) return 158-7;
   else if((cmd1 == 'E') && (cmd2 == 'k')) return 71-7;
   else if((cmd1 == 'E') && (cmd2 == 'n')) return 69-7;
   else if((cmd1 == 'E') && (cmd2 == 'q')) return 96-9;  // !!!! BASTARD format

   else if((cmd1 == 'F') && (cmd2 == 'a')) return 9-7;
   else if((cmd1 == 'F') && (cmd2 == 'd')) return 189-7;

   else if((cmd1 == 'G') && (cmd2 == 'a')) return 20-7;
   else if((cmd1 == 'G') && (cmd2 == 'b')) return 17-7;
   else if((cmd1 == 'G') && (cmd2 == 'c')) return 8-7;
   else if((cmd1 == 'G') && (cmd2 == 'd')) return 8-7;
   else if((cmd1 == 'G') && (cmd2 == 'e')) return 8-7;
   else if((cmd1 == 'G') && (cmd2 == 'f')) return 9-7;
   else if((cmd1 == 'G') && (cmd2 == 'j')) return 21-7;
   else if((cmd1 == 'G') && (cmd2 == 'k')) return 13-7;

   else if((cmd1 == 'H') && (cmd2 == 'a')) return 154-7;
   else if((cmd1 == 'H') && (cmd2 == 'b')) return 54-7;
   else if((cmd1 == 'H') && (cmd2 == 'n')) return 78-7;
   else if((cmd1 == 'H') && (cmd2 == 'r')) return 170-7;

   else if((cmd1 == 'I') && (cmd2 == 'a')) return 10-7;

   else if((cmd1 == 'S') && (cmd2 == 'z')) return 8-7;

   else if((cmd1 == 'W') && (cmd2 == 'b')) return 8-7;

   return (-1);
}

void decode_moto_msg(int cmd1, int cmd2)
{
   start_msg_decode(1);  // ggggg
   // parse and decode Motorola binary message
   if     ((cmd1 == 'A') && (cmd2 == 'A')) skip_moto_msg();   // sat positions

   else if((cmd1 == 'A') && (cmd2 == 'a')) skip_moto_msg();   // time
   else if((cmd1 == 'A') && (cmd2 == 'A')) skip_moto_msg();   // ephemeris hold correction
   else if((cmd1 == 'A') && (cmd2 == 'b')) skip_moto_msg();   // GMT correction
   else if((cmd1 == 'A') && (cmd2 == 'B')) skip_moto_msg();   // application type select
   else if((cmd1 == 'A') && (cmd2 == 'c')) skip_moto_msg();   // date
   else if((cmd1 == 'A') && (cmd2 == 'C')) skip_moto_msg();   // 2D to 0D dop threshold
   else if((cmd1 == 'A') && (cmd2 == 'd')) parse_moto_Ad();   // lat
   else if((cmd1 == 'A') && (cmd2 == 'D')) skip_moto_msg();   // correction thresholds
   else if((cmd1 == 'A') && (cmd2 == 'e')) parse_moto_Ae();   // lon
   else if((cmd1 == 'A') && (cmd2 == 'E')) skip_moto_msg();   // output align
   else if((cmd1 == 'A') && (cmd2 == 'f')) parse_moto_Af();   // alt
   else if((cmd1 == 'A') && (cmd2 == 'g')) parse_moto_Ag();   // elevation mask
   else if((cmd1 == 'A') && (cmd2 == 'h')) skip_moto_msg();   // satellite select options
   else if((cmd1 == 'A') && (cmd2 == 'i')) skip_moto_msg();   // manual satellite select
   else if((cmd1 == 'A') && (cmd2 == 'j')) skip_moto_msg();   // DOP type
   else if((cmd1 == 'A') && (cmd2 == 'J')) skip_moto_msg();   // differential timeout select
   else if((cmd1 == 'A') && (cmd2 == 'k')) skip_moto_msg();   // DOP hysteresis
   else if((cmd1 == 'A') && (cmd2 == 'l')) skip_moto_msg();   // 3D to 2D dop threshold
   else if((cmd1 == 'A') && (cmd2 == 'm')) parse_moto_Am();   // sat ignore list
   else if((cmd1 == 'A') && (cmd2 == 'M')) skip_moto_msg();   // 
   else if((cmd1 == 'A') && (cmd2 == 'n')) skip_moto_msg();   // almanac update
   else if((cmd1 == 'A') && (cmd2 == 'N')) parse_moto_AN();   // velocity filter
   else if((cmd1 == 'A') && (cmd2 == 'o')) skip_moto_msg();   // datum
   else if((cmd1 == 'A') && (cmd2 == 'O')) skip_moto_msg();   // RTCM baud rate
   else if((cmd1 == 'A') && (cmd2 == 'p')) parse_moto_Ap();   // user datum
   else if((cmd1 == 'A') && (cmd2 == 'P')) parse_moto_AP();   // PPS rate
   else if((cmd1 == 'A') && (cmd2 == 'q')) parse_moto_Aq();   // ionospheic correction enabled
   else if((cmd1 == 'A') && (cmd2 == 'Q')) parse_moto_AQ();   // position filter
   else if((cmd1 == 'A') && (cmd2 == 'r')) parse_moto_Ar();   // position fix algorithm type
   else if((cmd1 == 'A') && (cmd2 == 's')) skip_moto_msg();   // position hold position
   else if((cmd1 == 'A') && (cmd2 == 't')) parse_moto_At();   // position hold select
   else if((cmd1 == 'A') && (cmd2 == 'u')) skip_moto_msg();   // altitude hold height
   else if((cmd1 == 'A') && (cmd2 == 'v')) skip_moto_msg();   // altitude hold select
   else if((cmd1 == 'A') && (cmd2 == 'w')) parse_moto_Aw();   // gps/utc select
   else if((cmd1 == 'A') && (cmd2 == 'x')) skip_moto_msg();   // measurement epcho offser
   else if((cmd1 == 'A') && (cmd2 == 'y')) parse_moto_Ay();   // pps offset delay
   else if((cmd1 == 'A') && (cmd2 == 'z')) parse_moto_Az();   // cable delay (for 1PPS)

   else if((cmd1 == 'B') && (cmd2 == 'a')) {
      have_moto_Ba = 1;
      parse_moto_Ea(6);  // 6 chan positioning
   }
   else if((cmd1 == 'B') && (cmd2 == 'b')) parse_moto_Bb();   // sat positions
   else if((cmd1 == 'B') && (cmd2 == 'c')) skip_moto_msg();   // 6 chan dops
   else if((cmd1 == 'B') && (cmd2 == 'd')) parse_moto_Bd();   // almanac status
   else if((cmd1 == 'B') && (cmd2 == 'e')) skip_moto_msg();   // almanac data
   else if((cmd1 == 'B') && (cmd2 == 'f')) skip_moto_msg();   // ephermeris data
   else if((cmd1 == 'B') && (cmd2 == 'g')) {
      have_moto_Bg = 1;
      parse_moto_Eg(6);  // 6 chan range
   }
   else if((cmd1 == 'B') && (cmd2 == 'h')) skip_moto_msg();   // pseudorange data
   else if((cmd1 == 'B') && (cmd2 == 'i')) skip_moto_msg();   // ephemeris data
   else if((cmd1 == 'B') && (cmd2 == 'j')) parse_moto_Bj();   // leapsecond pending
   else if((cmd1 == 'B') && (cmd2 == 'k')) {
      have_moto_Bk = 1;
      parse_moto_Ek(6);  // 6 chan position
   }
   else if((cmd1 == 'B') && (cmd2 == 'l')) skip_moto_msg();   // broadcast data data
   else if((cmd1 == 'B') && (cmd2 == 'n')) {
      have_moto_Bn = 1;
      parse_moto_En(6);  // 6 chan traim
   }
   else if((cmd1 == 'B') && (cmd2 == 'o')) parse_moto_Bo();   // UTC offset from GPS time
   else if((cmd1 == 'B') && (cmd2 == 'p')) skip_moto_msg();   // ionosphere data

   else if((cmd1 == 'C') && (cmd2 == 'a')) parse_moto_Ca();   // 6-channel self test
   else if((cmd1 == 'C') && (cmd2 == 'b')) skip_moto_msg();   // almanac input response
   else if((cmd1 == 'C') && (cmd2 == 'd')) skip_moto_msg();   // alert planning
   else if((cmd1 == 'C') && (cmd2 == 'e')) skip_moto_msg();   // pseudorange correction
   else if((cmd1 == 'C') && (cmd2 == 'f')) skip_moto_msg();   // receiver set to defaults
   else if((cmd1 == 'C') && (cmd2 == 'g')) parse_moto_Cg();   // idle/fix mode
   else if((cmd1 == 'C') && (cmd2 == 'h')) skip_moto_msg();   // almanac ack
   else if((cmd1 == 'C') && (cmd2 == 'i')) skip_moto_msg();   // switch I/O format
   else if((cmd1 == 'C') && (cmd2 == 'j')) parse_moto_Cj();   // receiver id
   else if((cmd1 == 'C') && (cmd2 == 'k')) skip_moto_msg();   // psudorange ack
   else if((cmd1 == 'C') && (cmd2 == 'o')) skip_moto_msg();   // ionosphere data

   else if((cmd1 == 'E') && (cmd2 == 'a')) {
      have_moto_Ea = 1;
      parse_moto_Ea(8);  // 8 chan positioning
   }
   else if((cmd1 == 'E') && (cmd2 == 'c')) skip_moto_msg();   // 8 chan dops
   else if((cmd1 == 'E') && (cmd2 == 'g')) {
      have_moto_Eg = 1;
      parse_moto_Eg(8);  // 8 chan range
   }
   else if((cmd1 == 'E') && (cmd2 == 'k')) {
      have_moto_Ek = 1;
      parse_moto_Ek(8);  // 8 chan position
   }
   else if((cmd1 == 'E') && (cmd2 == 'n')) {
      have_moto_En = 1;
      parse_moto_En(8);  // 8 chan traim
   }

   else if((cmd1 == 'E') && (cmd2 == 'q')) parse_moto_Eq();   // !!!! BASTARD FORMAT ascii position

   else if((cmd1 == 'F') && (cmd2 == 'a')) parse_moto_Fa();   // 8-channel self test
   else if((cmd1 == 'F') && (cmd2 == 'd')) skip_moto_msg();   // alert planning

   else if((cmd1 == 'G') && (cmd2 == 'a')) parse_moto_Ga();   // lat/lon/alt
   else if((cmd1 == 'G') && (cmd2 == 'b')) parse_moto_Gb();   // date and time
   else if((cmd1 == 'G') && (cmd2 == 'c')) parse_moto_Gc();   // PPS status
   else if((cmd1 == 'G') && (cmd2 == 'd')) parse_moto_Gd();   // positioning mode
   else if((cmd1 == 'G') && (cmd2 == 'e')) parse_moto_Ge();   // traim mode
   else if((cmd1 == 'G') && (cmd2 == 'f')) parse_moto_Gf();   // traim alarm threshold
   else if((cmd1 == 'G') && (cmd2 == 'j')) parse_moto_Gj();   // leapsecond info
   else if((cmd1 == 'G') && (cmd2 == 'k')) parse_moto_Gk();   // vehicle id tag

   else if((cmd1 == 'H') && (cmd2 == 'a')) parse_moto_Ha(1);  // 
   else if((cmd1 == 'H') && (cmd2 == 'b')) parse_moto_Ha(0);  // 
   else if((cmd1 == 'H') && (cmd2 == 'n')) parse_moto_Hn();   // !!!! traim
   else if((cmd1 == 'H') && (cmd2 == 'r')) parse_moto_Hr();   // inverse differential

   else if((cmd1 == 'I') && (cmd2 == 'a')) parse_moto_Ia();   // 12-channel self test

   else if((cmd1 == 'S') && (cmd2 == 'z')) parse_moto_Sz();   // power-up test failure
   else if((cmd1 == 'W') && (cmd2 == 'b')) parse_moto_Wb();   // Jupiter-T message format switch

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_moto_message()
{
u08 c;
static int cmd1 = 0;
static int cmd2 = 0;
static int eq_cksum = 0; // ascii Eq message checksum

   // this routine buffers up an incoming Motorola binary message

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {         // syncing to start of message, search for a @
      if(c == '@') {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      moto_msg_len = moto_msg_ptr = 0;
      moto_vfy_cksum = 0;
      return;
   }
   else if(tsip_sync == 1) {    // @ had been seen, now check next byte for '@'
      if(c != '@') goto rst_msg;
      ++tsip_sync;
   }
   else if(tsip_sync == 2) {    // get first byte of command
      if((c >= 'A') && (c <= 'Z')) {
         cmd1 = c;
         moto_vfy_cksum ^= c;
         ++tsip_sync;
      }
      else goto rst_msg;
   }
   else if(tsip_sync == 3) {   // next byte of command
      if((tolower(c) >= 'a') && (tolower(c) <= 'z')) {
         cmd2 = c;
         moto_vfy_cksum ^= c;
         moto_msg_len = moto_msg_ptr = find_moto_cmd(cmd1, cmd2);
         if(moto_msg_len < 0) goto rst_msg;       // unknown command
         else if(moto_msg_len == 0) ++tsip_sync;  // no payload bytes
      }
      else goto rst_msg;
      ++tsip_sync;
   }
   else if(tsip_sync == 4) {   // buffer up message bytes
      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         moto_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
      if(--moto_msg_ptr <= 0) ++tsip_sync;  // end of message payload
   }
   else if(tsip_sync == 5) {   // get checksum and verify, parse payload
      if((cmd1 == 'E') && (cmd2 == 'q')) {  // BASTARD ASCII message format
         eq_cksum = (c - '0');
         ++tsip_sync;
      }
      else {
         if(c != moto_vfy_cksum) goto rst_msg;
         tsip_sync = 8;  // get 0x0D 0x0A
         if(0) {
            decode_moto_msg(cmd1, cmd2);
            packet_end = 1;
            tsip_sync = 0;
         }
      }
   }
   else if(tsip_sync == 6) {  // second byte of ascii checksum - ascii posn msg
      eq_cksum = (eq_cksum*10) + (c - '0');
      ++tsip_sync;
   }
   else if(tsip_sync == 7) {  // final byte of ascii checksum - ascii posn msg
      eq_cksum = (eq_cksum*10) + (c - '0');
//sprintf(plot_title, "c:%c eq:%d vfy:%d", c, eq_cksum, moto_vfy_cksum);
      if(eq_cksum != moto_vfy_cksum) goto rst_msg;
      tsip_sync = 8;  // get 0x0A 0x0A
      if(0) {
         decode_moto_msg(cmd1, cmd2);
         packet_end = 1;
         tsip_sync = 0;
      }
   }
   else if(tsip_sync == 8) {  // 0x0D
      tsip_sync = 9;
   }
   else if(tsip_sync == 9) {  // 0x0A
      decode_moto_msg(cmd1, cmd2);
      packet_end = 1;
      tsip_sync = 0;
   }
   else {
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
   }
}




//
//
//  SCPI receiver stuff
//
//

int get_fixed_field(int width)
{
char c;
int i;

   // get a fixed with field from a message

   msg_field[0] = 0;
   if(width <= 0) return 0;
   if(nmea_msg[msg_col] == 0) return 0;  // at end-of-message

   i = 0;
   while(width--) {   // get next field from the nmea message
      c = nmea_msg[msg_col];
      if(c == 0) {  // reached end-of-message
         break;
      }

      if(i < ((int)sizeof(msg_field)-2)) {
         msg_field[i++] = c;
         msg_field[i] = 0;
         ++msg_col;
      }
   }

   return msg_field[0];
}

int get_scpi_delim(char delim)
{
char c;
int i;

   msg_field[0] = 0;
   if(nmea_msg[msg_col] == 0) return 0;  // at end-of-message

   i = 0;
   while(1) {   // get next field from the nmea message
      c = nmea_msg[msg_col];
      if(c == 0) {  // reached end-of-message
         break;
      }
      if(c == delim) {  // reached end-of-field
         ++msg_col;
         break;
      }

      if(i < ((int)sizeof(msg_field)-2)) {
         msg_field[i++] = c;
         msg_field[i] = 0;
         ++msg_col;
      }
   }

   return msg_field[0];
}

void parse_scpi_time()
{
u32 val;
static u32 last_tval = 0;
double jd;

   log_packet_id("scpi time");

pps_enabled = pps_mode = 1; // zzzzz
   have_pps_enable = 8;
   have_pps_mode = 8;
   sent_uccm_status = 0;

   fake_msec = 0.0;

   msg_col = 0;
   get_fixed_field(3);  // get " T#"
if(debug_file) fprintf(debug_file, "scpi time:%s\n", msg_field);

   if(!strcmp(msg_field, " T1")) {  // hex format time
      get_fixed_field(2);
      if(strcmp(msg_field, "#H")) return;
      get_fixed_field(8);
      val = atohex(msg_field);

      if(scpi_type == NORTEL_TYPE) {
         if(val == last_tval) ++val;
         last_tval = val;
      }

if(debug_file) fprintf(debug_file, "time val:%08X(%u)", val,val);

      jd = (double) (u32) val;
      jd /= (24.0*60.0*60.0);
      jd += GPS_EPOCH;
      
      set_gregorian_time(jd); 

      if((scpi_type == NORTEL_TYPE) && (time_flags & TFLAGS_UTC)) {
         gps_to_utc();
      }

      goto time_info;
   }
   else if(!strcmp(msg_field, " T2")) {
      get_fixed_field(4);
      pri_year = year = atoi(msg_field);
      get_fixed_field(2);
      pri_month = month = atoi(msg_field);
      get_fixed_field(2);
      pri_day = day = atoi(msg_field);

      get_fixed_field(2);
      pri_hours = hours = atoi(msg_field);
      get_fixed_field(2);
      pri_minutes = minutes = atoi(msg_field);
      get_fixed_field(2);
      pri_seconds = seconds = atoi(msg_field);
      pri_frac = raw_frac = 0.0;

      time_info:
      if(get_fixed_field(1)) {  // TFOM
         tfom = atoi(msg_field);
         have_tfom = 2;
      }
      if(get_fixed_field(1)) {  // FFOM
         ffom = atoi(msg_field);
         have_ffom = 2;
      }

      get_fixed_field(1);  // leap pending
      if(msg_field[0] == '+') {
         minor_alarms |= (MINOR_LEAP_PEND);
         have_leap_info = 5;
      }
      else if(msg_field[0] == '-') {
         minor_alarms |= (MINOR_LEAP_PEND);
         have_leap_info = 6;
      }
      else if(msg_field[0] == '0') {
         minor_alarms &= (~MINOR_LEAP_PEND);
         have_leap_info = 7;
      }

      get_fixed_field(1);  // request for service

      get_fixed_field(1);  // time validity
      if(msg_field[0] == '1') {       // time invalid
         time_flags |= TFLAGS_INVALID;
      }
      else if(msg_field[0] == '0') {  // time valid
         time_flags &= (~TFLAGS_INVALID);
      }

      get_fixed_field(2);  // checksum
if(debug_file) fprintf(debug_file, "time code: %04d/%02d/%02d %02d:%02d:%02d\n", pri_year,pri_month,pri_day, pri_hours,pri_minutes,pri_seconds);

      fake_time_stamp = 0;

      if(seconds != last_misc_second) {
         update_gps_screen(1006);
      }

      if(sent_uccm_status) ;
      else if(scpi_type == NORTEL_TYPE) ;
      else if(pri_seconds == SCPI_STATUS_SECOND) {
         if(rcvr_type == UCCM_RCVR) queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
         else                       queue_scpi_cmd(":SYST:STAT?", SCPI_STATUS_MSG);
         start_fake_seconds(4);
      }
   }
   else {  // message requests/responses out of sync?
      BEEP(510);  // gggg
      if(debug_file) fprintf(debug_file, "Message sync error (%s): %s\n", msg_field, nmea_msg);
      Sleep(500);
      need_msg_init = 123;
      return;
drain_port(RCVR_PORT);
tsip_sync = 0;
tsip_wptr = 0;
tsip_rptr = 0;
init_messages(123, 0);   // setup the receiver
redraw_screen();
   }
}


void parse_scpi_vis()
{
int prn;
int sat_count;

   log_packet_id("scpi vis");

   sat_count = 0;
   for(prn=0; prn<=MAX_PRN; prn++) {
      sat[prn].visible = 0;
   }

   msg_col = 0;
   while(get_msg_field()) {
      prn = atoi(msg_field);
      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].visible = (-1);
         ++sat_count;
         have_count = 40;
      }
   }

   config_sat_count(sat_count);
}


void parse_scpi_track()
{
int prn;

   log_packet_id("scpi track");

   for(prn=0; prn<=MAX_PRN; prn++) { 
      sat[prn].tracking = sat[prn].visible;
      if(sat[prn].visible) sat[prn].level_msg = 14;
      else                 sat[prn].level_msg = 0;
      have_snr |= rinex_gnss(prn);
   }

   msg_col = 0;
   while(get_msg_field()) {
      prn = atoi(msg_field);
      if((prn >= 1) && (prn <= MAX_PRN)) { 
         sat[prn].tracking = (1);
      }
   }
}

void parse_scpi_efc()
{
   log_packet_id("scpi efc");

   msg_col = 0;
   if(get_msg_field()) {
      dac_voltage = (float) atof(msg_field);
      if(rcvr_type == CS_RCVR) dac_voltage *= 100.0;
      have_dac = 1;
   }
}

void parse_uccm_efc()
{
u32 val;

//kkkkkkuuuuuu
   log_packet_id("uccm efc");

   msg_col = 0;
   if(strstr(nmea_msg, "TO GPS")) {  // recovering from manual mode
      discipline_mode = DIS_MODE_RECOVERY;  // recovery
   }
   else if(strstr(nmea_msg, "RANGE")) {  // out of range
   }
   else if(get_msg_field() > 2) {
      if(discipline_mode == DIS_MODE_RECOVERY) discipline_mode = DIS_MODE_NORMAL;
      val = atohex(&msg_field[2]);
      uccm_voltage = (float) val;
   }
// sprintf(debug_text, "uccm voltage:%f  msg:%s", uccm_voltage, nmea_msg); 
}

void parse_uccm_led()
{
int i;

   log_packet_id("uccm led");

   if(scpi_type == UCCMP_TYPE) { 
      if     (strstr(nmea_msg, "0")) strcpy(uccm_led_msg, "Initializing   ");
      else if(strstr(nmea_msg, "1")) strcpy(uccm_led_msg, "Normal         ");
      else goto uccm_style;
   }
   else {
      uccm_style:
      nmea_msg[16] = 0;
      strcpy(uccm_led_msg, nmea_msg);
      for(i=strlen(uccm_led_msg); i<16; i++) uccm_led_msg[i] = ' ';
      uccm_led_msg[16] = 0;
      strupr(uccm_led_msg);
   }
}

void parse_scpi_cable()
{
   log_packet_id("scpi cable");

   msg_col = 0;
   if(get_msg_field()) {
      cable_delay = atof(msg_field);
      if(cable_delay >= 1.0) {  // cable delay is probably in nanoseconds (early firmware?)
         cable_delay *= 1.0E-9;
         cable_nsecs = 1;
      }
      else cable_nsecs = 0;  // standard is in seconds

      have_cable_delay = 1;
      show_cable_delay();
   }
}

void parse_scpi_elev()
{
   log_packet_id("scpi elev");

   msg_col = 0;
   if(get_msg_field()) {
      el_mask = (float) atof(msg_field);
      have_el_mask = 1;
   }
}

void parse_scpi_utc_ofs()
{
   log_packet_id("scpi utc ofs");

   msg_col = 0;
   if(!user_set_utc_ofs && get_msg_field()) {
      utc_offset = (int) atof(msg_field);
      check_utc_ofs(10);
   }
}

void parse_scpi_leaptime()
{
char *s;
u32 val;
int yy,mm,dd;
double leap_day;

   // calculates the date of the next leapsecond event
   log_packet_id("scpi leaptime");

   val = 0;

   msg_col = 0;
   if(get_msg_field()) { 
      strupr(msg_field);
      s = strstr(msg_field, "#H");
      if(scpi_type == NORTEL_TYPE) {
         s = "";
         val = atohex(&msg_field[0]);
         goto hex_time;
      }
      else if(s) {  // hex format
         if(s[2] == 0) return;
         val = atohex(s+2);

         hex_time:
         leap_day = (double) (u32) val;
         leap_day /= (24.0*60.0*60.0);
         leap_day += GPS_EPOCH;
         leap_day -= jtime(0,0,utc_offset, 0.0);  // convert GPS to UTC
         leap_day = ((double) (int) leap_day) + 0.50;  // removes time fraction
         leap_day -= jtime(0,0,0, 1.0);  // gets time of leap to 23:59:59
         have_scpi_hex_leap = 1;
//gregorian(0, leap_day);
//sprintf(debug_text2, "hexday:%f utcofs:%d  %04d/%02d/%02d %02d:%02d:%02d", leap_day, utc_offset, g_year,g_month,g_day, g_hours,g_minutes,g_seconds);
      }
      else if(0 && have_scpi_hex_leap) {  // we have leap date from the hex format message
         return;
      }
      else { // yyyy mm dd format  // this message can be wrong on devcices that send both formats
          yy = atoi(msg_field);   // ... might say 30 Sep if leap pending flag
          if(yy < 2016) return;    // ... was broadcast in July
          if(yy > 2100) return;

          if(get_msg_field() == 0) return;
          mm = atoi(msg_field);
          if(mm < 1) return;
          if(mm > 12) return;

          if(get_msg_field() == 0) return;
          dd = atoi(msg_field);
          if(dd < 1) return;
          if(dd > 31) return;

          leap_day = jdate(yy, mm, dd) + jtime(23,59,59,0.0);
          if(dd == 1) leap_day -= 1.0;
          sprintf(out, "%04d/%02d/%02d", yy,mm,dd);
//sprintf(debug_text3, "lday2:%f  %s", leap_day, out);
          s = &out[0];
      }

      leap_day += (double) (rolled * 1024*7);
      jd_leap = leap_day;
      calc_jd_leap(4);
///have_leap_days = 30;
///gregorian(0, leap_day);
//sprintf(plot_title, "rolled:%d  lday:%04d/%02d/%02d  %02d:%02d:%02d  today:%04d/%02d/%02d", rolled, g_year,g_month,g_day, g_hours,g_minutes,g_seconds, year,month,day);
///      today = jdate(year, month, day);
///      leap_days = (int) (leap_day - today);
///      have_leap_days = 3;
///sprintf(debug_text, "leap_day:%f today:%f leap_days:%d  rolled:%d", leap_day,today,leap_days, rolled);

if(debug_file) fprintf(debug_file, "### leaptime:%08X(%u)  leap_day:%f  leap_days:%d  s:%s", val, val, jd_leap, leap_days, s);
   }
}

void verify_scpi_type(char *unit_name)
{
   if(unit_name == 0) return;

   if(detect_rcvr_type && (rcvr_type == SCPI_RCVR) && (scpi_type_changed == 0)) {
      if(strstr(unit_name, "3801")) {
         rcvr_type = SCPI_RCVR;
         scpi_type = SCPI_TYPE;
         config_rcvr_type(0);
         need_msg_init = 2007;
         need_msg_init = 0;
         scpi_type = SCPI_TYPE;
         scpi_type_changed = SCPI_RCVR;
      }
      else if(strstr(unit_name, "3805")) {
         goto hp_rcvr;
      }
      else if(strstr(unit_name, "3810")) {
         goto hp_rcvr;
      }
      else if(strstr(unit_name, "3811")) {
         rcvr_type = SCPI_RCVR;
         scpi_type = LUCENT_TYPE;
         config_rcvr_type(0);
         need_msg_init = 2008;
         need_msg_init = 0;
         scpi_type = LUCENT_TYPE;
         scpi_type_changed = SCPI_RCVR;
      }
      else if(strstr(unit_name, "3812")) {
         rcvr_type = SCPI_RCVR;
         scpi_type = LUCENT_TYPE;
         config_rcvr_type(0);
         need_msg_init = 2009;
         need_msg_init = 0;
         scpi_type = LUCENT_TYPE;
         scpi_type_changed = SCPI_RCVR;
      }
      else if(strstr(unit_name, "3815")) {
         goto hp_rcvr;
      }
      else if(strstr(unit_name, "3816")) {
         goto hp_rcvr;
      }
      else if(strstr(unit_name, "3817")) {
         goto hp_rcvr;
      }
      else if(strstr(unit_name, "5071")) {  // this should never happen - handled in decode_scpi_msg()
         rcvr_type = CS_RCVR;
         scpi_type = 0;
         scpi_type_changed = CS_RCVR;
         config_rcvr_type(0);
         need_msg_init = 2010;
         scpi_type_changed = CS_RCVR;
         scpi_type = 0;
         init_messages(666, 1);
      }
      else if(strstr(unit_name, "58")) {  // HP58xxx
         hp_rcvr:
         rcvr_type = SCPI_RCVR;
         scpi_type = HP_TYPE;
         config_rcvr_type(0);
         need_msg_init = 2011;
         need_msg_init = 0;
         scpi_type = HP_TYPE;
         scpi_type_changed = SCPI_RCVR;
      }
      else if(strstr(unit_name, "59")) {  // HP59xxx has pulse edge control
         rcvr_type = SCPI_RCVR;
         scpi_type = HP_TYPE2;
         config_rcvr_type(0);
         need_msg_init = 2012;
         need_msg_init = 0;
         scpi_type = HP_TYPE2;
         scpi_type_changed = SCPI_RCVR;
      }
   }
}


void parse_scpi_id()
{
int i;

   log_packet_id("scpi id");

   msg_col = 0;
   if(get_msg_field()) {  // manufacturer
      if(msg_field[0] == ' ') {
         sprintf(scpi_mfg_id, "Mfg: %-18.18s", &msg_field[0]);
         strncpy(scpi_mfg, &msg_field[1], 20);
      }
      else {
         sprintf(scpi_mfg_id, "Mfg:  %-17.17s", msg_field);
         strncpy(scpi_mfg, msg_field, 20);
      }
      scpi_mfg[20] = 0;
      scpi_mfg_id[24] = 0;
   }

   if(get_msg_field()) {  // model
      for(i=0; i<UNIT_LEN; i++) unit_name[i] = ' ';
      unit_name[UNIT_LEN] = 0;
      for(i=0; i<UNIT_LEN; i++) {
         if(msg_field[i] == 0) break;
         unit_name[i] = msg_field[i];
         scpi_model[i] = msg_field[i];
         scpi_model[i+1] = 0;
      }

      verify_scpi_type(unit_name);

      if(strstr(scpi_mfg, "SAMSUNG")) {
         if(strstr(unit_name, "UCCM-L")) {  // samsung (-LPK, -L8)
            if(user_set_scpi_type == 0) scpi_type = SAMSUNG_TYPE;
         }
      }
   }

   scpi_serno[0] = 0;
   if(get_msg_field()) {  // serial number
      if     (scpi_type == UCCMP_TYPE) sprintf(scpi_serno, "Ser:  %s", &msg_field[5]);
      else if(rcvr_type == UCCM_RCVR)  sprintf(scpi_serno, "Ser:  %s", &msg_field[3]);
      else                             sprintf(scpi_serno, "Ser:  %s", msg_field);
      strncpy(scpi_sn, msg_field, 22);
      scpi_sn[22] = 0;
      scpi_serno[23] = 0;
   }

   scpi_fw[0] = 0;
   if(get_msg_field()) {  // fw rev
      strncpy(scpi_fw, msg_field, 22);
      scpi_fw[22] = 0;
      strcat(scpi_serno, " ");
      strcat(scpi_serno, scpi_fw);
      scpi_serno[23] = 0;
   }

   if(scpi_type == NORTEL_TYPE) {
      scpi_serno[0] = 0;
      if(get_msg_field()) {  // CPC - serial number
         if     (scpi_type == UCCMP_TYPE) sprintf(scpi_serno, "Ser:  %s", &msg_field[5]);
         else if(rcvr_type == UCCM_RCVR)  sprintf(scpi_serno, "Ser:  %s", &msg_field[3]);
         else                             sprintf(scpi_serno, "Ser:  %s", msg_field);
         strncpy(scpi_sn, msg_field, 22);
         scpi_sn[22] = 0;

         strcat(scpi_serno, " ");
         strcat(scpi_serno, scpi_fw);
         scpi_serno[23] = 0;
      }

      if(get_msg_field()) {  // PEC - model
         for(i=0; i<UNIT_LEN; i++) unit_name[i] = ' ';
         unit_name[UNIT_LEN] = 0;
         for(i=0; i<UNIT_LEN; i++) {
            if(msg_field[i] == 0) break;
            unit_name[i] = msg_field[i];
            scpi_model[i] = msg_field[i];
            scpi_model[i+1] = 0;
         }
      }

      if(get_msg_field()) {  // hardware version
         msg_field[2] = 0;
         strcat(scpi_serno, "-");
         strcat(scpi_serno, msg_field);
         scpi_serno[23] = 0;
      }
   }

   have_info |= ALL_ID_INFO;

if(debug_file) fprintf(debug_file, "### id:%s  have_info:%02X\n", nmea_msg, have_info);

//show_version_info();
}

void parse_scpi_tint()
{
   log_packet_id("scpi tint");

   msg_col = 0;
   if(get_msg_field()) {
      if(scpi_type == NORTEL_TYPE) pps_offset = (float) atof(msg_field)*1.0;
      else                         pps_offset = (float) atof(msg_field)*1.0E9;
      // doing adves of TINT handled in secondary_timing()
      have_pps_offset = 7;
      have_rcvr_pps = 7;
   }
}

void parse_scpi_progress()
{
   log_packet_id("scpi progress");

   msg_col = 0;
   if(get_msg_field()) {
      survey_progress = (int) atof(msg_field);
      have_progress = 5;
      if(scpi_type == NORTEL_TYPE) {
         if(survey_progress != 100) minor_alarms |= MINOR_SURVEY;
         else                       minor_alarms &= (~MINOR_SURVEY);
      }
   }
}

void parse_scpi_survey()
{
   log_packet_id("scpi survey");

   msg_col = 0;
// !!! should restore com_timeout
   if(get_msg_field()) {
      strupr(msg_field);
      if(strstr(msg_field, "ONCE"))   minor_alarms |= MINOR_SURVEY;
      else if(strstr(msg_field, "1")) minor_alarms |= MINOR_SURVEY;
      else                            minor_alarms &= (~MINOR_SURVEY);
   }
}


void parse_scpi_holdover()
{
int state;

   log_packet_id("scpi holdover");

   msg_col = 0;
   if(get_msg_field()) {
      holdover = (int) atof(msg_field);
   }

   if(get_msg_field()) {
      state = atoi(msg_field);
      if(state) {  // in holdover mode
         discipline_mode = DIS_MODE_MANUAL_HOLD;
         if(!have_scpi_hold) user_holdover = 1;
if(scpi_type != UCCMP_TYPE) {  // kkkkkk
   rcvr_mode = RCVR_MODE_PROP;
   have_rcvr_mode = 10;
}
      }
      else {   // not in holdover
         discipline_mode = DIS_MODE_NORMAL;
         if(!have_scpi_hold) user_holdover = 0;
if(scpi_type != UCCMP_TYPE) {  // kkkkkk
   rcvr_mode = RCVR_MODE_HOLD;
   have_rcvr_mode = 10;
}
      }
      have_scpi_hold = 1;
   }
// !!! should restore com_timeout
if(debug_file) fprintf(debug_file, "### holdover:%d  dmode:%d  user:%d\n", holdover, discipline_mode, user_holdover);
}

void parse_scpi_jamsync()
{
   log_packet_id("scpi jamsync");
}

void parse_scpi_utc()
{
int state;

   log_packet_id("scpi utc");

   msg_col = 0;
   if(get_msg_field()) {
      state = (int) atof(msg_field);
      if(state == 0) {  // GPS time
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else {  // utc time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
      have_rcvr_tmode = 1;
   }
}

void parse_scpi_tunc()
{
   log_packet_id("scpi tunc");

   msg_col = 0;
   if(get_msg_field()) {
      osc_offset = (float) atof(nmea_msg);
      have_osc_offset = 7;
      have_rcvr_osc = 7;
osc_offset *= 1000.0;
//    if(jitter_adev == 0) do_osc_adev(osc_offset);  // makes no sense to ADEV
   }
}

void parse_scpi_edge()
{
   log_packet_id("scpi edge");

   msg_col = 0;
   if(get_msg_field()) {
      strupr(msg_field);
      if     (strstr(msg_field, "RIS")) {
         pps_polarity = 0;
         have_pps_polarity = 12;
      }
      else if(strstr(msg_field, "FAL")) {
         pps_polarity = 1;
         have_pps_polarity = 12;
      }
   }
}

void parse_scpi_life()
{
   log_packet_id("scpi life");

   msg_col = 0;
   if(get_msg_field()) {
      scpi_life = atoi(msg_field) * 3;
      have_lifetime = 1;
   }
}

void parse_scpi_user()
{
int i;

   log_packet_id("scpi user msg");

   i = (int) sizeof(debug_text2)-20;
   if(i < (int) sizeof(nmea_msg)) nmea_msg[i] = 0;

   sprintf(debug_text2, "response to msg %d:%s", user_msg_num, nmea_msg);
   need_redraw = 543;  // why is this needed for X11?
}

void parse_scpi_test()
{
// !!! should restore com_timeout
   log_packet_id("scpi test");

   msg_col = 0;
   if(get_msg_field()) {
      scpi_test = atoi(nmea_msg);
      have_scpi_test = 1;
if(debug_file) fprintf(debug_file, "### self test:%04X\n", scpi_test);
   }
}

void parse_scpi_hardware()
{
int status;

   log_packet_id("scpi hardware");

   msg_col = 0;
   if(get_msg_field()) {
      status = atoi(nmea_msg);
if(debug_file) fprintf(debug_file, "### hardware status:%04X\n", status);
      if(scpi_type == NORTEL_TYPE) {
        // 0x0001 - self test fail
        // 0x0002 - power fail
        // 0x0004 - GPS 1PPS fail
        // 0x0008 - OCXO fail
        // 0x0010 - EFC fail
        // 0x0020 - PLL fail
        // 0x0040 - EEPROM fail
        // 0x0080 - RAM fail
        // 0x0100 - FPGA fail
        // 0x0200 - antenna RF signal too high
        // 0x0400 - antenna RF signal too low
        // 0x0800 - GPS fail (TRAIM failure)
        // 0x1000 - PDOP fail
        if(status & 0x0002) critical_alarms |= CRIT_PWR;      // power
        else                critical_alarms &= (~CRIT_PWR);
        if(status & 0x0008) critical_alarms |= CRIT_OCXO;     // ocxo
        else                critical_alarms &= (~CRIT_OCXO);
        if(status & 0x0080) critical_alarms |= CRIT_RAM;      // RAM
        else                critical_alarms &= (CRIT_RAM);
        if(status & 0x01A5) critical_alarms |= CRIT_FPGA;     // various hardware
        else                critical_alarms &= (~CRIT_FPGA);
        if(!have_critical_alarms) need_redraw = 7701;
        have_critical_alarms = 555;

        if(status & 0x0010) minor_alarms |= MINOR_OSC_AGE;    // EFC limit
        else                minor_alarms &= (~MINOR_OSC_AGE);
        have_osc_age = 1;

        if(status & 0x0040) minor_alarms |= MINOR_EEPROM;    // eeprom
        else                minor_alarms &= (~MINOR_EEPROM);
        have_eeprom = 1;
      }
      else {
         critical_alarms = 0x0000;
         if(status & 0x003E) critical_alarms |= CRIT_PWR;       // power
         if(status & 0x0300) critical_alarms |= CRIT_GPS;       // GPS
         if(status & 0x1000) critical_alarms |= CRIT_OCXO;      // ref failure

         if(status & 0x00C0) minor_alarms |= MINOR_OSC_AGE;     // EFC limit
         else                minor_alarms &= (~MINOR_OSC_AGE);  // EFC limit

         if(status & 0x0800) minor_alarms |= MINOR_EEPROM;      // EEPROM fault
         else                minor_alarms &= (~MINOR_EEPROM) ;  // EEPROM ok
         have_eeprom = 1;

         if(!have_critical_alarms) need_redraw = 7708;
         have_critical_alarms = 8;
      }
   }
}

void parse_scpi_operation()
{
int status;

   log_packet_id("scpi operation");

   if(scpi_type != NORTEL_TYPE) return;

   // 0x0002 - locked
   // 0x0004 - holdover/unlocked modes
   // 0x0008 - position hold
   // 0x0010 - sats tracked
   // 0x0020 - hardware status reg set
   // 0x0040 - diagnostic log almost full
   // 0x0080 - over temp
   // 0x0100 - under temp
   // 0x0200 - antenna fault

   msg_col = 0;
   if(get_msg_field()) {
      status = atoi(nmea_msg);
if(debug_file) fprintf(debug_file, "### operation status:%04X\n", status);
      if(status & 0x0080) {       // over temperature alarm
         temperature = 71.0F;
         have_temperature = 109;
      }
      else if(status & 0x0100) {  // under temperature alarm
         temperature = (-1.0F);
         have_temperature = 110;
      }
      else {
         temperature = 30.0F;     // normal temperature
         have_temperature = 111;
      }

      if(status & 0x0010) minor_alarms &= (~MINOR_NO_TRACK);  // sat tracking OK
      else                minor_alarms |= MINOR_NO_TRACK;
      have_tracking = 1;
   }
}

void parse_scpi_pos()
{
   log_packet_id("scpi pos");
}

void parse_scpi_ignore()
{
u32 val;
int count;
int prn;
int flag;

   log_packet_id("scpi ignore");

   count = 0;
   val = 0;

   msg_col = 0;
   while(get_msg_field()) {
      prn = atoi(msg_field);
      if((prn >= 1) && (prn <= 32)) { 
         val |= (1 << (prn-1));
         ++count;
      }
   }

   single_sat_prn = 0;
   have_single_prn = 1;
   if(count == 31) {  // all but 1 sat excluded
      for(prn=1; prn <= 32; prn++) {
         flag = (val & (1 << (prn-1)));
         if(flag == 0) {
            single_sat_prn = prn; 
            have_single_prn = 1;
            break;
         }
      }
   }

   val = (~val);
   sats_enabled = val;
   update_disable_list(sats_enabled);
}

void parse_scpi_ign_count()
{
int val;

   log_packet_id("scpi count");

   msg_col = 0;
   if(get_msg_field()) {
      val = atoi(msg_field);  // single_sat_prn
      if(val & (single_sat_prn == 0)) {
         single_sat_prn = 32;  // !!!!! kludge
         have_single_prn = 0;
      }
   }
}

void parse_scpi_include()
{
u32 val;
int count;
int prn;
int last_prn;

   log_packet_id("scpi include");

   if(scpi_type != NORTEL_TYPE) return;

   count = 0;
   val = 0;
   last_prn = 0;
   msg_col = 0;
   while(get_msg_field()) {
      prn = atoi(msg_field);
      if((prn >= 1) && (prn <= 32)) { 
         val |= 1 << (prn-1);
         last_prn = prn;
         ++count;
      }
   }

   if(count == 1) single_sat_prn = last_prn; 
   else           single_sat_prn = 0;
   have_single_prn = 1;

   sats_enabled = val;
   update_disable_list(sats_enabled);
}



void parse_scpi_posn()
{
double sign;

   log_packet_id("scpi posn");

   sign = 1.0;
   msg_col = 0;
   if(get_msg_field()) {
      if(msg_field[0] == 'S') sign = (-1.0);
      else if(msg_field[1] == 'S') sign = (-1.0);
   }
   if(get_msg_field()) {
      lat = atof(msg_field);
   }
   if(get_msg_field()) {
      lat += atof(msg_field) / 60.0;
   }
   if(get_msg_field()) {
      lat += atof(msg_field) / 3600.0;
   }
   lat *= sign;

   sign = 1.0;
   if(get_msg_field()) {
      if(msg_field[0] == 'W') sign = (-1.0);
   }
   if(get_msg_field()) {
      lon = atof(msg_field);
   }
   if(get_msg_field()) {
      lon += atof(msg_field) / 60.0;
   }
   if(get_msg_field()) {
      lon += atof(msg_field) / 3600.0;
   }
   lon *= sign;

   if(get_msg_field()) {
      alt = atof(msg_field);
   }
if(debug_file) fprintf(debug_file, "###lla: %.9f %.9f %.3f\n", lat,lon,alt);
   lat = lat * PI / 180.0;
   lon = lon * PI / 180.0;
}

void parse_scpi_reset()
{
// !!! should restore com_timeout
   log_packet_id("scpi reset");
}

void parse_scpi_power()
{
   log_packet_id("scpi power");
}

void parse_scpi_antenna()
{
   log_packet_id("scpi antenna");

   minor_alarms &= (~MINOR_ANT_NO_PWR);
   if(strstr(nmea_msg, "OK")) ;
   else if(strstr(nmea_msg, "SHORT")) minor_alarms |= MINOR_ANT_SHORT;
   else if(strstr(nmea_msg, "OPEN"))  minor_alarms |= MINOR_ANT_OPEN; 
   else                               minor_alarms |= MINOR_ANT_NO_PWR; 
   have_antenna = 1;
}


void parse_scpi_ffom()
{
   log_packet_id("scpi ffom");
}

void parse_uccm_rate()
{
   log_packet_id("uccm rate");

   msg_col = 0;
   if(get_msg_field()) {
      if(strstr(msg_field, "PP1S")) {
         pps_rate = RATE_1PPS;
         have_pps_rate = 6;
//pps_enabled = 1;
      }
      else if(strstr(msg_field, "PP2S")) {
         pps_rate = RATE_PP2S;
         have_pps_rate = 6;
//pps_enabled = 1;
      }
//    have_pps_enable = 10;
   }
}

void parse_uccm_state()
{
   log_packet_id("uccm state");

   msg_col = 0;
   if(get_msg_field()) {
      if(strstr(msg_field, "ALARM")) { 
      }

      if(strstr(msg_field, "BLOCK")) {
         pps_enabled = 0;
         have_pps_enable = 10;
      }
      else if(1 || strstr(msg_field, "ACTIVE")) {
         pps_enabled = 1;
         have_pps_enable = 10;
      }
      else if(strstr(msg_field, "NORMAL")) {
         pps_enabled = 1;
         have_pps_enable = 10;
      }
      else if(strstr(msg_field, "UNLOCK")) {
         pps_enabled = 1;
         have_pps_enable = 10;
      }
   }
}


void parse_uccm_pullin()
{
char *s;

   log_packet_id("uccm pullin");

   msg_col = 0;
   s = strchr(nmea_msg, '[');
   if(s) {
      if(*s+1) {
         if(strstr(s+1, "UNLIMITED")) pullin_range = 0;
         else                         pullin_range = atoi(s+1);
         have_pullin = 1;
      }
   }
}


void parse_uccm_hw_alarm()
{
   log_packet_id("uccm hw alarm");

   msg_col = 0;
   if(get_msg_field()) {
      have_critical_alarms = 666;
      critical_alarms &= (~CRIT_PWR);
      if(strstr(msg_field, "POWER")) {   // SAMSUNG_TYPE
         critical_alarms |= (CRIT_PWR);
      }
   }
}


void parse_uccm_oper_alarm()
{
   log_packet_id("uccm oper alarm");

   msg_col = 0;
   if(get_msg_field()) {
   }
}

int scpi_tracked, scpi_not_tracked;

void parse_scpi_status()
{
//if(debug_file) fprintf(debug_file, "%s\n", nmea_msg);

   // decode the HIDEIOUS multi-line SCPI STATUS message (that takes three
   // seconds for the receiver to send.
   log_packet_id("scpi status");

   scpi_status = 1;
   saw_uccm_dmode = 0;
   scpi_tracked = scpi_not_tracked = 0;
   scpi_col = 0;
   scpi_status_line[0] = 0;
   no_uccm_ref = 0;
}


int send_queued_cmd(int why)
{
int id;

   // send the next message in the request queue to the receiver

   if(polled_q_in == polled_q_out) return 0;
   id = polled_q[polled_q_out].id;

if(debug_file) fprintf(debug_file, "SEND Q %d: sqe:%d  old_id=%d: %s  why:%d\n", polled_q_out, polled_q_entries, polled_msg_id, polled_q[polled_q_out].msg, why);

   send_polled_cmd(polled_q[polled_q_out].msg, polled_q[polled_q_out].id);


   if(++polled_q_out >= POLLED_Q_SIZE) polled_q_out = 0;
   --polled_q_entries;

   if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == BRANDY_RCVR) ;
   else if((id == SCPI_TEST_MSG) && (scpi_type != UCCMP_TYPE)) {
      if(sim_file == 0) Sleep(20000);    // wait for reset to complete

      erase_screen();
      vidstr(0,0, YELLOW, "Re-establishing communications in 30 seconds...");
      refresh_page();

      drain_com_data();      // flush com data
      reset_com_timer(RCVR_PORT);
      polled_q_in = 0;           // reset SCPI message send queue pointers
      polled_q_out = 0;
      polled_q_entries = 0;
      polled_req = 0;
      polled_seq = 0;
      need_redraw = 3487;
   }
   return 1;
}


void queue_polled_cmd(char *s, int id)
{
static int last_id = 0;

   // add a command to a queue of messages to send to the receiver.  SCPI 
   // receivers are REALLY dumb and not designed for talking to computer
   // programs.  Their responses to messages have NO indication of what
   // request the response is from.  If responses get out of sync with
   // requests, you a SCREWED!
   if((id == STAR_CONF_MSG) && (last_id == STAR_CONF_MSG)) {
      return;
   }
   last_id = id;
   brandy_msg_id = id;

   strcpy(polled_q[polled_q_in].msg, s);
   polled_q[polled_q_in].id = id;
   ++polled_q_entries;
   if(++polled_q_in >= POLLED_Q_SIZE) polled_q_in = 0;

if(debug_file) fprintf(debug_file,   "\nQ SCPI id:%d  sqe:%d  in:%d out:%d: %s\n", id, polled_q_entries, polled_q_in,polled_q_out, s);
}



void poll_next_scpi()
{
int test;

   // request an item from a SCPI receiver.  Requests are alternated between
   // a time message and some receiver parameter.  The parameter requests are 
   // alternated between one of three important parameters and then the lesser
   // important ones.

   test = 1;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else if(polled_msg_id == SCPI_TIME_MSG) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
      }
      else if(scpi_type == NORTEL_TYPE) {
         if(polled_req < 0) polled_req = 0;

         if((polled_seq % 10) == 0) send_polled_cmd("PTIME:INTERVAL?",       SCPI_TINT_MSG);    
         else if((polled_seq % 10) == 1) send_polled_cmd("ROSC:CONT?",       SCPI_EFC_MSG);
         else {
            if     (polled_req ==  0) send_polled_cmd("PTIME:LEAPSECOND?",           SCPI_LEAPTIME_MSG);
            else if(polled_req ==  1) send_polled_cmd("PTIME:ACC:LEAPSECOND?",       SCPI_UTC_OFS_MSG);
            else if(polled_req ==  2) send_polled_cmd("*IDN?",                       SCPI_ID_MSG);
            else if(polled_req ==  3) send_polled_cmd("GPS:POSITION?",               SCPI_POSN_MSG);
            else if(polled_req ==  4) send_polled_cmd("GPS:REF:ADELAY?",             SCPI_GET_CABLE_MSG);
            else if(polled_req ==  5) send_polled_cmd("GPS:SAT:TRAC:EMANGLE?",       SCPI_ELEV_MSG);
            else if(polled_req ==  6) send_polled_cmd("ANTENNA:CONDITION?",          SCPI_ANTENNA_MSG);
            else if(polled_req ==  7) send_polled_cmd("STATUS:OPERATION:CONDITION?", SCPI_OPERATION_MSG);
            else if(polled_req ==  8) send_polled_cmd("STATUS:HARDWARE:CONDITION?",  SCPI_HARDWARE_MSG);
            else if(polled_req ==  9) send_polled_cmd("GPS:POS:SURVEY:PROGRESS?",    SCPI_PROGRESS_MSG);
            else if(polled_req == 10) send_polled_cmd("GPS:SAT:TRACKING?",           SCPI_TRACK_MSG);
            else if(polled_req == 11) send_polled_cmd("GPS:SAT:VIS:PRED?",           SCPI_VIS_MSG);
            else if(polled_req == 12) send_polled_cmd("ROSC:HOLD:DUR?",              SCPI_HOLDOVER_MSG);
            else if(polled_req == 13) send_polled_cmd("GPS:SAT:TRAC:IGNORE?",        SCPI_IGNORE_MSG);
            else if(polled_req == 14) send_polled_cmd("GPS:SAT:TRAC:INCLUDE?",       SCPI_INCLUDE_MSG);
            else if(polled_req == 15) send_polled_cmd("DIAG:LIFETIME:COUNT?",        SCPI_LIFE_MSG);
            else if(polled_req == 16) send_polled_cmd("SYNC:FFOM?",                  SCPI_FFOM_MSG);

            if(++polled_req > 16) {
               polled_req = 0;
               ++all_polled;
            }
         }
         ++polled_seq;
      }
      else {
//       queue_scpi_cmd(":DIAG:ROSC:EFC?", SCPI_EFC_MSG);     // we want these as often as possible
//       queue_scpi_cmd(":PTIM:TINT?",     SCPI_TINT_MSG);
//       queue_scpi_cmd(":ROSC:HOLD:TUNC:PRED?",    SCPI_TUNC_MSG);

         if(polled_req < 0) polled_req = 0;

         if(     (polled_seq % 10) == 0) send_polled_cmd(":PTIM:TINT?",           SCPI_TINT_MSG);
         else if((polled_seq % 10) == 1) send_polled_cmd(":DIAG:ROSC:EFC?",       SCPI_EFC_MSG);
         else {
            if     (polled_req == 0)  send_polled_cmd(":PTIM:LEAP:ACC?",          SCPI_UTC_OFS_MSG);
            else if(polled_req == 1)  {
               if(scpi_type == HP_TYPE) {
                  send_polled_cmd(":GPS:POS?", SCPI_POSN_MSG);
               }
               else {
                  send_polled_cmd(":GPS:POS:ACT?",            SCPI_POSN_MSG);
               }
            }
            else if(polled_req == 2)  send_polled_cmd("*IDN?",                    SCPI_ID_MSG);
            else if(polled_req == 3)  send_polled_cmd(":PTIM:GPS:SAT:VIS:PRED?",  SCPI_VIS_MSG);
            else if(polled_req == 4)  send_polled_cmd(":PTIM:GPS:SAT:TRAC?",      SCPI_TRACK_MSG);
            else if(polled_req == 5)  send_polled_cmd(":GPS:SAT:TRAC:IGN?"      , SCPI_IGNORE_MSG);
            else if(polled_req == 6)  send_polled_cmd(":STATUS:OPER:HARD:COND?",  SCPI_HARDWARE_MSG);
            else if(polled_req == 7)  send_polled_cmd(":ROSC:HOLD:DUR?",          SCPI_HOLDOVER_MSG);
            else if(polled_req == 8)  send_polled_cmd(":DIAG:GPS:UTC?",           SCPI_UTC_MSG);

            else if(polled_req == 9)  send_polled_cmd(":PTIM:GPS:EMAN?",          SCPI_ELEV_MSG);
            else if(polled_req == 10) send_polled_cmd(":PTIM:GPS:ADEL?",          SCPI_GET_CABLE_MSG);
            else if(polled_req == 11) send_polled_cmd(":PTIM:GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);
            else if(polled_req == 12) send_polled_cmd(":PTIM:GPS:POS:SURV:PROG?", SCPI_PROGRESS_MSG);
            else if(polled_req == 13) send_polled_cmd(":PTIM:LEAP:GPST?",         SCPI_LEAPTIME_MSG);
            else if(polled_req == 14) send_polled_cmd(":PTIM:LEAP:DATE?",         SCPI_LEAPTIME_MSG);
            else if(polled_req == 15) send_polled_cmd(":PTIM:PPS:EDGE?",          SCPI_EDGE_MSG);
            else if(polled_req == 16) send_polled_cmd(":DIAG:LIF:COUNT?",         SCPI_LIFE_MSG);
            else if(polled_req == 17) send_polled_cmd(":ROSC:HOLD:TUNC:PRED?", SCPI_TUNC_MSG);

            if(++polled_req > 17) {
               polled_req = 0;
               ++all_polled;
            }
         }
         ++polled_seq;
      }
   }
   else {
      send_polled_cmd(":PTIME:TCODE?", SCPI_TIME_MSG);  // request time message
   }
}



void send_polled_cmd(char *s, int id)
{
int i, j;

   if(s == 0) return;
   no_response_msg = 0;

   if(rcvr_type == BRANDY_RCVR) {
      if(id == BRANDY_SATINFO_MSG) {  // prevent time codes processing from falling behind
         drain_port(RCVR_PORT);
      }

      if(s[0] == '$') {  // NMEA formatted command
         send_brandy_cmd(&s[1]);
      }
      else {  // query command
         send_brandy_char(s[0]);
         send_brandy_char(0x0D);
         send_brandy_char(0x0A);
      }
      goto msg_done;
   }

   j = strlen(s);
   for(i=0; i<j; i++) {
      if((rcvr_type == STAR_RCVR) && (star_type == OSA_TYPE) && (s[i] == ';')) ;
      else send_byte((u08) s[i]);
   }

   if(rcvr_type == STAR_RCVR) {
      send_byte(0x0D);
      star_line = 0;
      star_msg = 0;
   }

   eom_flag = EOM;
   if(rcvr_type == CS_RCVR) {
      pkt_end1 = 0x0D;
      pkt_end2 = 0x0A;
      send_byte(0x0A);
   }
   else if(rcvr_type == LPFRS_RCVR) {
      pkt_end1 = 0x0D;
      send_byte(0x0D);
   }
   else if(rcvr_type == PRS_RCVR) {
      pkt_end1 = 0x0D;
      send_byte(0x0D);
   }
   else if(rcvr_type == SA35_RCVR) {
      pkt_end1 = 0x0D;
      pkt_end2 = 0x0A;
//    send_byte(0x0A);
   }
   else if(rcvr_type == SRO_RCVR) {
      pkt_end1 = 0x0D;
      send_byte(0x0D);
      if(id == SRO_RESET_MSG) {
         Sleep(5000);
         restart_prs_polling();
      }
   }
   else if(rcvr_type == STAR_RCVR) {
      pkt_end1 = 0x0A;
      send_byte(0x0A);
   }
   else if(rcvr_type == UCCM_RCVR) {
      pkt_end1 = 0x0D;
      send_byte(0x0D);
   }
   else if(rcvr_type == X72_RCVR) {
      pkt_end1 = 0x0D;
      pkt_end2 = 0x0A;
//eom_flag = FLUSH_COM;
      send_byte(0x0D);
   }
   else if(scpi_type == NORTEL_TYPE) {
      pkt_end1 = 0x0D;
      send_byte(0x0D);
   }
   else {
      pkt_end1 = 0x0A;
      send_byte(0x0A);
   }

   eom_flag = ADD_CHAR;

   if(rcvr_type == STAR_RCVR) {
////      saw_star_etx = 0;
   }
   else if(id == SCPI_SET_CABLE_MSG) {  // setting cable delay ties up receiver for several seconds
      if(sim_file == 0) Sleep(5000);
   }
else if(id == SCPI_FDUP_MSG) {  // setting fdup mode takes a while
   if(sim_file == 0) Sleep(1000);
}

   msg_done:
   polled_msg_id = id;

   if(sim_file) ; 
   else if(rcvr_type == BRANDY_RCVR) {
      if(BRANDY_SLEEP) Sleep(BRANDY_SLEEP); 
   }
   else if(rcvr_type == CS_RCVR) {
      if(CS_SLEEP) Sleep(CS_SLEEP); 
   }
   else if(rcvr_type == LPFRS_RCVR) {
      if(LPFRS_SLEEP) Sleep(LPFRS_SLEEP); 
      if     (id == LPFRS_C_WRITE_MSG) no_response_msg = id;
      else if(id == LPFRS_F_WRITE_MSG) no_response_msg = id;
   }
   else if(rcvr_type == PRS_RCVR) {
////  if(PRS_SLEEP) Sleep(PRS_SLEEP);   // if no sleep, message cycle lasts 11 seconds

      if(id < 0) {        // we just sent a command that changes a param
         last_prs_set[0] = s[0];  // remember the last param set command
         last_prs_set[1] = s[1];
         last_prs_set[2] = 0;

         eom_flag = ADD_CHAR; // ... these don't send a response back
         send_byte('V');      // ... so force a response from the unit
         send_byte('B');      // ... so that the message polling does not timeout
         send_byte('1');
         eom_flag = EOM;
         send_byte(0x0D);
         Sleep(PRS_SLEEP);
      }
   }
   else if(rcvr_type == SA35_RCVR) {
      if(SA35_SLEEP) Sleep(SA35_SLEEP); 
   }
   else if(rcvr_type == SCPI_RCVR) {
      if(SCPI_SLEEP) Sleep(SCPI_SLEEP); 
   }
   else if(rcvr_type == SRO_RCVR) {
      if(SRO_SLEEP) Sleep(SRO_SLEEP); 
   }
   else if((rcvr_type == STAR_RCVR) && (star_type == OSA_TYPE)) {
      if(OSA_SLEEP) Sleep(OSA_SLEEP);   // allow time for receiver to digest the command
      if(strchr(s, '=')) {  // !!!!! commands that do not send a resposnse
         if     (id == STAR_ALMASK_MSG)    no_response_msg = id;
         else if(id == STAR_ADM_MSG)       no_response_msg = id;
         else if(id == STAR_AUX_MSG)       no_response_msg = id;
         else if(id == STAR_BAUD_MSG)      no_response_msg = id;
         else if(id == STAR_CABLE_MSG)     no_response_msg = id;
         else if(id == STAR_HBSQ_MSG)      no_response_msg = id;
         else if(id == STAR_HOLD_MSG)      no_response_msg = id;
         else if(id == STAR_OFFSET_MSG)    no_response_msg = id;
         else if(id == STAR_OUTPUT_MSG)    no_response_msg = id;
         else if(id == STAR_PRIOR_MSG)     no_response_msg = id;
         else if(id == STAR_TZONE_MSG)     no_response_msg = id;
         else if(id == STAR_TAU_MSG)       no_response_msg = id;
         else if(id == STAR_WTR_MSG)       no_response_msg = id;
      }
      else if(id == STAR_CLEAR_GPS_MSG)    no_response_msg = id;
      else if(id == STAR_CLEAR_AUX_MSG)    no_response_msg = id;
   }
   else if(rcvr_type == STAR_RCVR) {
      if(STAR_SLEEP) Sleep(STAR_SLEEP);
   }
   else if(rcvr_type == X72_RCVR) {
////  if(X72_SLEEP) Sleep(X72_SLEEP); 
x72_msg_id = id;
   }
   else {
      if(DEFAULT_SLEEP) Sleep(DEFAULT_SLEEP);   // allow time for receiver to digest the command
   }
fake_second_check(10);  // see if time to simulate the missing second
if(debug_file) fprintf(debug_file,   "\nSEND SCPI id:%d  sqe:%d  in:%d out:%d: %s\n", id, polled_q_entries, polled_q_in,polled_q_out, s);
}


void decode_scpi_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the reciver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %d:[%s]\n", polled_msg_id, nmea_msg);
   if((polled_msg_id == SCPI_CLS_MSG) && strstr(nmea_msg, "*CLS")) {  // receiver is echoing
      scpi_echo_mode = 1;
   }

if(1 && detect_rcvr_type && scpi_echo_mode && (com[RCVR_PORT].baud_rate == 9600)) {
   rcvr_type = CS_RCVR;
   polled_q_in = polled_q_out = 0;
   config_rcvr_type(0);
   need_msg_init = 2020;
   scpi_echo_mode = 1;
   scpi_type_changed = CS_RCVR;
   config_screen(8734);
   if(debug_file) fprintf(debug_file, "### switching to HP-5071A mode\n");
   return;
}

   if(nmea_msg[0] == ' ') {
      i = 1;
      if((nmea_msg[i] == 'E') && (nmea_msg[i+1] == '-')) {  // message returned error
         queue_scpi_cmd("*CLS", SCPI_CLS_MSG);  // reset the error
         scpi_msg_id = 0;
         poll_next_scpi();
         return;
      }
      else if((nmea_msg[i] == 'E') && (nmea_msg[i+1] == '+')) {  // message returned error
         queue_scpi_cmd("*CLS", SCPI_CLS_MSG);  // reset the error
         scpi_msg_id = 0;
         poll_next_scpi();
         return;
      }
      else if((nmea_msg[i] == 'S') && (nmea_msg[i+1] == 'C') && (nmea_msg[i+2] == 'P')) { // message with no data to return
         scpi_msg_id = 0;
         poll_next_scpi();
         return;
      }
   }

   scpi_msg_id = polled_msg_id;

   if     (scpi_msg_id == SCPI_TIME_MSG)      parse_scpi_time();
   else if(scpi_msg_id == SCPI_VIS_MSG)       parse_scpi_vis();
   else if(scpi_msg_id == SCPI_TRACK_MSG)     parse_scpi_track();
   else if(scpi_msg_id == SCPI_EFC_MSG)       parse_scpi_efc();
   else if(scpi_msg_id == SCPI_ELEV_MSG)      parse_scpi_elev();
   else if(scpi_msg_id == SCPI_GET_CABLE_MSG) parse_scpi_cable();
   else if(scpi_msg_id == SCPI_SET_CABLE_MSG) parse_scpi_cable();
   else if(scpi_msg_id == SCPI_UTC_OFS_MSG)   parse_scpi_utc_ofs();
   else if(scpi_msg_id == SCPI_TINT_MSG)      parse_scpi_tint();
   else if(scpi_msg_id == SCPI_STATUS_MSG)    parse_scpi_status();
   else if(scpi_msg_id == SCPI_PROGRESS_MSG)  parse_scpi_progress();
   else if(scpi_msg_id == SCPI_SURVEY_MSG)    parse_scpi_survey();
   else if(scpi_msg_id == SCPI_RESET_MSG)     parse_scpi_reset();
   else if(scpi_msg_id == SCPI_POSN_MSG)      parse_scpi_posn();
   else if(scpi_msg_id == SCPI_POS_MSG)       parse_scpi_pos();
   else if(scpi_msg_id == SCPI_HOLDOVER_MSG)  parse_scpi_holdover();
   else if(scpi_msg_id == SCPI_UTC_MSG)       parse_scpi_utc();
   else if(scpi_msg_id == SCPI_TUNC_MSG)      parse_scpi_tunc();
   else if(scpi_msg_id == SCPI_TEST_MSG)      parse_scpi_test();
   else if(scpi_msg_id == SCPI_HARDWARE_MSG)  parse_scpi_hardware();
   else if(scpi_msg_id == SCPI_LEAPTIME_MSG)  parse_scpi_leaptime();
   else if(scpi_msg_id == SCPI_ID_MSG)        parse_scpi_id();
   else if(scpi_msg_id == SCPI_IGNORE_MSG)    parse_scpi_ignore();
   else if(scpi_msg_id == SCPI_IGN_COUNT_MSG) parse_scpi_ign_count();
   else if(scpi_msg_id == SCPI_INCLUDE_MSG)   parse_scpi_include();
   else if(scpi_msg_id == SCPI_JAMSYNC_MSG)   parse_scpi_jamsync();
   else if(scpi_msg_id == SCPI_EDGE_MSG)      parse_scpi_edge();
   else if(scpi_msg_id == SCPI_LIFE_MSG)      parse_scpi_life();
   else if(scpi_msg_id == SCPI_POWER_MSG)     parse_scpi_power();
   else if(scpi_msg_id == SCPI_USER_MSG)      parse_scpi_user();
   else if(scpi_msg_id == SCPI_ANTENNA_MSG)   parse_scpi_antenna();
   else if(scpi_msg_id == SCPI_FFOM_MSG)      parse_scpi_ffom();
   else if(scpi_msg_id == SCPI_OPERATION_MSG) parse_scpi_operation();

if(scpi_msg_id == SCPI_STATUS_MSG) {  //;;;;;
   scpi_msg_id = 0;  // next message polled when status command completes
}
else {
   scpi_msg_id = 0;
   poll_next_scpi();
}

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void parse_scpi_azel()
{
int n;
int prn, aaa,eee,sss;
char *s;

   // process the SYST:STAT? az/el info line
   log_packet_id("scpi azel");

   if(no_uccm_ref) {
      gps_status = GPS_NO_SATS;
      have_gps_status = 1;
      minor_alarms |= MINOR_NO_TRACK;
      have_tracking = 1;
   }
   else if(rcvr_type == UCCM_RCVR) {
      have_gps_status = 0;
      minor_alarms &= (~MINOR_NO_TRACK);
      have_tracking = 1;

      if(strstr(scpi_status_line, "MODE")) {
         s = strstr(scpi_status_line, "SURVEY");
         if(s) {
            rcvr_mode = RCVR_MODE_SURVEY;
            minor_alarms |= (MINOR_SURVEY);
            if(scpi_type == SAMSUNG_TYPE) {
               survey_progress = atoi(s+7);
               have_progress = 6;
            }
            else {
               survey_progress = atoi(s+9);
               have_progress = 7;
            }
         }
         else if(strstr(scpi_status_line, "HOLD")) {
            rcvr_mode = RCVR_MODE_HOLD;
            minor_alarms &= (~MINOR_SURVEY);
         }
         else if(strstr(scpi_status_line, "FIXED")) {  // samsung
            rcvr_mode = RCVR_MODE_HOLD;
            minor_alarms &= (~MINOR_SURVEY);
         }
         else {
            rcvr_mode = RCVR_MODE_UNKNOWN;
         }
      }
   }

   while(1) {  // convert '*' (attempting to track) to ' '
      s = strchr(scpi_status_line, '*');
      if(s == 0) break;
      *s = ' ';
   }
   scpi_status_line[17] = 0; // break line between TRACKED and NOT-TRACKED areas

   prn = aaa = eee = sss = (-1);
   n = sscanf(scpi_status_line, "%d %d %d %d", &prn, &eee,&aaa,&sss);
   if((n == 4) && (prn >= 1) && (prn <= MAX_PRN) && (sss >= 0)) {  // 32
      if((aaa >= 0) && (eee >= 0)) {
         set_sat_azel(prn, (float) aaa, (float) eee);
         have_sat_azel = 10;
      }

      sat[prn].sig_level = ((float) sss);
      if(adjust_scpi_ss) {  // scale sig strength level to 0..50
         if(sss > 0) {
            sat[prn].sig_level = (float) (20.0 * log10((double) sss) + 6.00);
         }
         level_type = "SIG";
      }
      else level_type = "C/N";

      sat[prn].level_msg = 15;
      have_snr |= rinex_gnss(prn);
      ++scpi_tracked;
if(rcvr_type == UCCM_RCVR) sat[prn].tracking = 1; // uuuuuu
      record_sig_levels(prn);
   }

   // get not-tracked info
   sss = 0; 
   prn = aaa = eee = (-1);
   n = sscanf(&scpi_status_line[17+1], "%d %d %d", &prn, &eee,&aaa);
   if((n == 3) && (prn >= 1) && (prn <= MAX_PRN) && (aaa >= 0) && (eee >= 0)) { // 32
      set_sat_azel(prn, (float) aaa, (float) eee);
      have_sat_azel = 11;

      sat[prn].sig_level = ((float) 0.001);  // sig levek >0 and <1 allows untracked sat to show in sat map
      sat[prn].level_msg = 16;
      sat[prn].tracking = (-1); // uuuuuu
      have_snr |= rinex_gnss(prn);
      ++scpi_not_tracked;
      record_sig_levels(prn);
   }

   if(0) {  // second column of untracked sats
      sss = 0;
      prn = aaa = eee = (-1);
      n = sscanf(&scpi_status_line[30+1], "%d %d %d", &prn, &eee,&aaa);
      if((n == 3) && (prn >= 1) && (prn <= MAX_PRN) && (aaa >= 0) && (eee >= 0)) { // 32
         set_sat_azel(prn, (float) aaa, (float) eee);
         have_sat_azel = 11;

         sat[prn].sig_level = ((float) 0.001);  // sig levek >0 and <1 allows untracked sat to show in sat map
         sat[prn].level_msg = 16;
         sat[prn].tracking = (-1); // uuuuuu
         have_snr |= rinex_gnss(prn);
         ++scpi_not_tracked;
         record_sig_levels(prn);
      }
   }
}

void parse_scpi_status_test()
{

   // parse the STATUS message self test line

   scpi_self_test = 0;
   scpi_int_power = 0;
   scpi_oven_power = 0;
   scpi_ocxo = 0;
   scpi_efc = 0;
   scpi_gps = 0;

   if(strstr(scpi_status_line, "SELF TEST:")) {
      if(strstr(scpi_status_line, "SELF TEST: OK")) scpi_self_test = 1;
      have_scpi_self_test = 1;
   }

   if(strstr(scpi_status_line, "INT PWR:")) {
      if(strstr(scpi_status_line, "INT PWR: OK")) scpi_int_power = 1;
      have_scpi_int_power = 1;
   }

   if(strstr(scpi_status_line, "OVEN PWR:")) {
      if(strstr(scpi_status_line, "OVEN PWR: OK")) scpi_oven_power = 1;
      have_scpi_oven_power = 1;
   }

   if(strstr(scpi_status_line, "OCXO:")) {
      if(strstr(scpi_status_line, "OCXO: OK")) scpi_ocxo = 1;
      have_scpi_ocxo = 1;
   }

   if(strstr(scpi_status_line, "EFC:")) {
      if(strstr(scpi_status_line, "EFC: OK")) scpi_efc = 1;
      have_scpi_efc = 1;
   }

   if(strstr(scpi_status_line, "GPS RCV:")) {
      if(strstr(scpi_status_line, "GPS RCV: OK")) scpi_gps = 1;
      have_scpi_gps = 1;
   }
}

void get_scpi_status(u08 c)
{
   if(c == 0x0D) return;

   if(c == 0x0A) {  // end-of-line, process it
      strupr(scpi_status_line);
      if(strstr(scpi_status_line, "SELF TEST")) {
         parse_scpi_status_test();
         scpi_status = 0;
poll_next_scpi(); //;;;;;;;;
      }
      else if(strstr(scpi_status_line, "PRN") && strstr(scpi_status_line, "EL")) {  // tracking info follows
         if(strstr(scpi_status_line, "SS")) adjust_scpi_ss = 1;
         else                               adjust_scpi_ss = 0;
         scpi_status = 2;
         if(rcvr_type == UCCM_RCVR) {
            reset_sat_tracking();
         }
      }
      else if(strstr(scpi_status_line, "ELEV") && strstr(scpi_status_line, "MASK")) {  // end of tracking info
         scpi_status = 4; // skip lines until we see the "SELF TEST" or "------------" end-of-status line
      }
      if(scpi_status == 2) {
         parse_scpi_azel();
      }

      scpi_col = 0;
      scpi_status_line[0] = 0;
   }
   else {
      if(scpi_col < ((int)sizeof(scpi_status_line)-2)) {
         scpi_status_line[scpi_col++] = c;
         scpi_status_line[scpi_col] = 0;
      }
   }
}

void get_scpi_message()
{
u08 c;
static int row = 0;

   // This routine buffers up an incomming SCPI message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_scpi_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }


   c = get_com_char();
   if(scpi_status) {   // we are reading the SYST:STAT? results
      get_scpi_status(c);
      return;
   }

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == '>') {
         tsip_sync = 1;
         get_sync_time();
      }

      rst_msg:
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // '>' has been seen, now build the message
      if(c == 0x0D) goto scpi_end; 
      else if(c == 0x0A) goto scpi_end; 
      else if(c == '>')  {  // null response to SCPI command
         decode_scpi_msg();
         packet_end = 1;
         tsip_sync = 1; 
         tsip_rptr = 0;
         tsip_wptr = 0;
         return;
      }

      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_sync = 0;
         goto rst_msg;
      }
   }
   else {
      scpi_end:
      decode_scpi_msg();
      packet_end = 1;
      tsip_sync = 0;
   }
}

//
//
//   UCCM receiver stuff
//
//

void parse_uccm_loop()
{
   // prepare to decode the multi-line UCCM LOOP status message 
   log_packet_id("uccm loop");

   uccm_loop = 1;
   loop_fmt = TRIMBLE_FMT;   // assume Trimble format
   scpi_col = 0;
   scpi_status_line[0] = 0;
}


void poll_next_uccm()
{
int test;

   // request an item from a UCCM receiver.  Requests are alternated between
   // a time message and some receiver parameter.  The parameter requests are 
   // alternated between one of three important parameters and then the lesser
   // important ones.

   test = 0;
   if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else {
      if(polled_req < 0) polled_req = 0;

      if(     (polled_seq % 10) == 0) send_polled_cmd("DIAG:LOOP?",       UCCM_LOOP_MSG);
///   if(     (polled_seq % 10) == 0) send_polled_cmd("SYNC:TINT?",       SCPI_TINT_MSG);
//    else if((polled_seq % 10) == 1) send_polled_cmd("DIAG:LOOP?",       UCCM_LOOP_MSG); // ggggggg
      else {
         if     (polled_req == 0)  send_polled_cmd("DIAG:ROSC:EFC:REL?",  SCPI_EFC_MSG);
         else if(polled_req == 1)  send_polled_cmd("DIAG:ROSC:EFC:DATA?", UCCM_EFC_MSG);
         else if(polled_req == 2)  send_polled_cmd("GPS:POS?",            SCPI_POSN_MSG);
         else if(polled_req == 3)  send_polled_cmd("*IDN?",               SCPI_ID_MSG);
         else if(polled_req == 4)  send_polled_cmd("GPS:SAT:TRAC:IGN?",   SCPI_IGNORE_MSG);
         else if(polled_req == 5)  send_polled_cmd("GPS:SAT:TRAC:EMAN?",  SCPI_ELEV_MSG);
         else if(polled_req == 6)  send_polled_cmd("GPS:REF:ADEL?",       SCPI_GET_CABLE_MSG);
         else if(polled_req == 7)  send_polled_cmd("OUTP:TP:SEL?",        UCCM_RATE_MSG);
         else if(polled_req == 8)  send_polled_cmd("OUTP:STAT?",          UCCM_STATE_MSG);
         else if(polled_req == 9)  send_polled_cmd("LED:GPSL?",           UCCM_LED_MSG);
         else if(polled_req == 10) send_polled_cmd("PULLINRANGE?",        UCCM_GET_PULLIN_MSG);
         else if(polled_req == 11) send_polled_cmd("ALARM:HARD?",         UCCM_GET_HW_ALARM);
         else if(polled_req == 12) send_polled_cmd("ALARM:OPER?",         UCCM_GET_OPER_ALARM);

         if(scpi_type != UCCMP_TYPE) {
            if(++polled_req > 12) {
               polled_req = 0;
               ++all_polled;
            }
         }
         else {
            if     (polled_req == 13) send_polled_cmd(":ROSC:HOLD:DUR?",     SCPI_HOLDOVER_MSG); //kkkkkk
            else if(polled_req == 14) send_polled_cmd(":GPS:POS:SURV:STAT?", SCPI_SURVEY_MSG);   //kkkkkk
            else if(polled_req == 15) send_polled_cmd(":GPS:POS:SURV:PROG?", SCPI_PROGRESS_MSG); //kkkkkk
            if(++polled_req > 15) {
               polled_req = 0;
               ++all_polled;
            }
         }

      }
      ++polled_seq;
   }
}

void parse_uccm_time(int why)
{
int vals[50];
int i,j;
double jd, jd0;
char *s;

   log_packet_id("uccm time");

   j = 0;
   fake_msec = 0.0;
   sent_uccm_status = 0;
   s = strstr(nmea_msg, "C5 ");

if(debug_file) fprintf(debug_file, "uccm time %d loop:%d  len:%d: [%s]\n", why, have_uccm_loop, (int) strlen(nmea_msg), nmea_msg);
   if(s == 0) return;


   for(i=0; i<131; i+=3) {  // get the values from the time line
      vals[j] = atohex(&s[i]);
      j++;
   }

   if(!user_set_utc_ofs && vals[32]) {  // leap second offset from UTC
      utc_offset = vals[32];
      check_utc_ofs(-111);
   }

   // vals[33]: 40=PPS validity?  41:phase settling  50:pps invalid?
   //           60:stable  62:stable, leap pending?
   // on power up: 41 -> 43 -> 63 -> 60/62 (62=leap pending?) Trimble
   // on power up: 41 -> 43 -> 60 -> 62 (62=leap pending?)    Trimble UCCM-P
   if(1) {
      have_leap_info = 8;
      if(vals[33] & 0x02) {  // leap pending flag?
         minor_alarms |= MINOR_LEAP_PEND;
      }
      else {
         minor_alarms &= (~MINOR_LEAP_PEND);
      }
   }


   // vals[34]: 04=normal 0C=antenna open/shorted  06=normal?
   // on power up: 00 -> 04
   // disconnect antenna: 04 -> 0C
   // reconnect antenna   0C -> 04


   // vals[35]: 8F=FFOM >0/settling/no antenna    85:FFOM 0,locked? - Symmetricom UCCMP
   // on power up: 8F -> 85           Symmetricom
   // disconnect antenna: 85 -> 8F    Symmetricom
   // reconnect antenna:  8F -> 85    Symmetricom
   //
   // vals[35]: 41=power up  4F=FFOM >0/settling/no antenna    45:FFOM 0,locked? - Trimble
   // on power up: 4F -> 45           Trimble UCCM-P
   // on power up: 41 -> 4F -> 45     Trimble UCCM
   // on antenna disconnect 45 -> 4F  Trimble
   // on antenna connect    4F -> 45 


   // vals[36]: 40=have date?/normal  50/60:date invalid?/no antenna
   // power up 50 -> 40                   Symmetricom 
   // disconnect antenna: 40 -> 50 -> 60  Symmetricom 
   // reconnect antenna:  60 -> 50 -> 40  Symmetricom 
   //
   // vals[36]: 80=have date?/normal  90:date invalid?/no antenna
   // power up 90 -> 80                   Trimble 
   // disconnect antenna: 80 -> 90        Trimble UCCM-P
   // reconnect antenna:  90 -> 80        Trimble UCCM-P

   jd = jd0 = (double) ((vals[27] * (256*256*256)) + (vals[28]*(256*256)) + (vals[29]*(256)) + vals[30]);

   if(timing_mode != TMODE_GPS) {  // we want UTC time - convert GPS to UTC
      jd -= (double) utc_offset;
   }

   jd /= (24.0*60.0*60.0);
   jd += GPS_EPOCH;

   set_gregorian_time(jd);

   fake_time_stamp = 0;
   start_fake_seconds(5);

   gps_week = (int) (jd0 / (7.0*24.0*60.0*60.0));
   faked_tow = 3;
   if(have_week == 0) need_redraw = 2054;
   have_week = 9;

//   tow = pri_tow = this_tow = survey_tow = (int) (jd - ((double) gps_week) * (7.0*24.0*60.0*60.0));
   tow = pri_tow = this_tow = survey_tow = (int) (jd0 - ((double) gps_week) * (7.0*24.0*60.0*60.0));
   have_tow = 9;

//if(log_file) fprintf(log_file, "uccm1 jd:%f  week:%d  tow:%d  %04d/%02d/%02d  %02d:%02d:%02d  %02X:%02X:%02X:%02X\n", 
//jd0,gps_week,tow,year,month,day,hours,minutes,seconds, vals[27],vals[28],vals[29],vals[30]);  //kkkkk
//if(raw_file) fprintf(raw_file, "uccm1 jd:%f  week:%d  tow:%d  %04d/%02d/%02d  %02d:%02d:%02d  %02X:%02X:%02X:%02X\n", 
//jd0,gps_week,tow,year,month,day,hours,minutes,seconds, vals[27],vals[28],vals[29],vals[30]);  //kkkkk

   if(seconds != last_misc_second) {
      update_gps_screen(555);
   }

   if(sent_uccm_status) ;
   else if(pri_seconds == SCPI_STATUS_SECOND) {
      queue_uccm_cmd("SYST:STAT?", UCCM_STATUS_MSG);
   }

   if(1) {  // samsung
      tsip_buf[0] = 0;
      tsip_wptr = 0;
      tsip_rptr = 0;
      tsip_sync = 0; 
   }
}

void parse_uccm_temp()
{
char *s;

   log_packet_id("uccm temp");

   s = strstr(nmea_msg, "TEMP = ");  // samsung
   if(s) {
      temperature = (DATA_SIZE) atof(s+7);
      if(user_set_temp_plot == 0) plot[TEMP].show_plot = 1;
      have_temperature = 112;
   }
}

int uccm_time_line(int why)
{

   // this routine handles the case where the Symmetricom units send a 
   // time code packet in the middle of another message's response
   
   if(scpi_status_line[0] != 'C') return 0;  // line is not a time code line
   if(scpi_status_line[1] != '5') return 0;

   strcpy(nmea_msg, scpi_status_line);  // prepare to decode the time code line
   parse_uccm_time(why);                   // decode it

   scpi_col = 0;              // prepare to get the next line
   scpi_status_line[0] = 0;

   poll_next_uccm();  //kkkkkk
   return 1;
}

int uccm_msg_id = 0;

void decode_uccm_msg(int why)
{
char c;
int i, j;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   j = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[j++] = c;
      nmea_msg[j] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the receiver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode uccm msg %d:%s\n", uccm_msg_id, nmea_msg);

   if(strstr(nmea_msg, "UCCM-L")) {  // samsung ID message (-LPK, -L8)
   }
   else if(strstr(nmea_msg, "UCCM-P")) {  // UCCM error response?
      if(user_set_scpi_type == 0) scpi_type = UCCMP_TYPE; // samsung
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "UCCM")) {  // UCCM error response?
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "COMMAND COMPLETE")) {
      if(uccm_msg_id == SCPI_IGNORE_MSG) {  // null response to ignore message - no sats exclued
         sats_enabled = 0xFFFFFFFF;
         update_disable_list(sats_enabled);
      }
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "COMMAND ERROR")) {
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "UNDEFINED HEADER")) {
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "INVALID PARAMETER")) {
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "DATA OUT OF RANGE")) {  // samsung
      uccm_msg_id = 0;
      return;
   }
   else if(strstr(nmea_msg, "CORRUPT")) {  // "Data corrupt or stale" uccmp
      uccm_msg_id = 0;
      return;
   }
   else if((nmea_msg[0] == 'C') && (nmea_msg[1] == '5')) {  // time string 132 bytes (44 values) long
      parse_uccm_time(123);

      uccm_time:
if(1 || have_uccm_loop) {
   send_polled_cmd("SYNC:TINT?", SCPI_TINT_MSG);
   poll_next_uccm();
}

if(1 || (scpi_type != UCCMP_TYPE)) {  //kkkkkkkkkkkkk
   poll_next_uccm();
   poll_next_uccm();
   poll_next_uccm();
//poll_next_uccm();
//poll_next_uccm();
//poll_next_uccm();
}
      return;
   }
   else if(uccm_msg_id == 0) {
if(debug_file) fprintf(debug_file, "response to:%s (status msg:%d) is next\n", nmea_msg, scpi_status);
      if     (strstr(nmea_msg, "GPS:POS?"))                uccm_msg_id = SCPI_POSN_MSG;
      else if(strstr(nmea_msg, "SYNC:TINT?"))              uccm_msg_id = SCPI_TINT_MSG;
      else if(strstr(nmea_msg, "ALARM:HARD?"))             uccm_msg_id = UCCM_GET_HW_ALARM;
      else if(strstr(nmea_msg, "ALARM:OPER?"))             uccm_msg_id = UCCM_GET_OPER_ALARM;
      else if(strstr(nmea_msg, "DIAG:ROSC:EFC:REL?"))      uccm_msg_id = SCPI_EFC_MSG;
      else if(strstr(nmea_msg, "LED:GPSL?"))               uccm_msg_id = UCCM_LED_MSG;
      else if(strstr(nmea_msg, ":GPS:POS:SURV:STAT?"))     uccm_msg_id = SCPI_SURVEY_MSG;
      else if(strstr(nmea_msg, ":GPS:POS:SURV:PROG?"))     uccm_msg_id = SCPI_PROGRESS_MSG;
      else if(strstr(nmea_msg, ":GPS:POS:SURV:STAT ONCE")) uccm_msg_id = SCPI_SURVEY_MSG;
      else if(strstr(nmea_msg, "ROSC:HOLD:DUR?"))          uccm_msg_id = SCPI_HOLDOVER_MSG;
      else if(strstr(nmea_msg, "SYNC:IMM"))                uccm_msg_id = SCPI_JAMSYNC_MSG;
      else if(strstr(nmea_msg, "DIAG:ROSC:EFC:DATA?"))     uccm_msg_id = UCCM_EFC_MSG;
      else if(strstr(nmea_msg, "GPS:SAT:TRAC:EMAN?"))      uccm_msg_id = SCPI_ELEV_MSG;
      else if(strstr(nmea_msg, "GPS:SAT:TRAC:IGN?"))       uccm_msg_id = SCPI_IGNORE_MSG;
      else if(strstr(nmea_msg, "GPS:REF:ADEL?"))           uccm_msg_id = SCPI_GET_CABLE_MSG;
      else if(strstr(nmea_msg, "GPS:REF:ADEL "))           uccm_msg_id = SCPI_SET_CABLE_MSG;
      else if(strstr(nmea_msg, "PULLINRANGE?"))            uccm_msg_id = UCCM_GET_PULLIN_MSG;
      else if(strstr(nmea_msg, "PULLINRANGE"))             uccm_msg_id = UCCM_SET_PULLIN_MSG;
      else if(strstr(nmea_msg, "OUTP:TP:SEL?"))            uccm_msg_id = UCCM_RATE_MSG;
      else if(strstr(nmea_msg, "OUTP:STAT?"))              uccm_msg_id = UCCM_STATE_MSG;
      else if(strstr(nmea_msg, "*IDN?"))                   uccm_msg_id = SCPI_ID_MSG;
      else if(strstr(nmea_msg, "*TST?"))                   uccm_msg_id = SCPI_TEST_MSG;
      else if(strstr(nmea_msg, "SYST:STAT?")) {
         uccm_msg_id = UCCM_STATUS_MSG;
         parse_scpi_status();
      }
      else if(strstr(nmea_msg, "DIAG:LOOP?")) {
         uccm_msg_id = SCPI_EFC_MSG;
         parse_uccm_loop();
      }
      else if(strstr(nmea_msg, "C5")) {  //kkkkkkkkk
         uccm_msg_id = 0;
         parse_uccm_time(144);
         goto uccm_time;
      }
      return;
   }

if(debug_file) fprintf(debug_file, "uccm %d response:%s\n", uccm_msg_id, nmea_msg);
   if     (uccm_msg_id == SCPI_POSN_MSG)       parse_scpi_posn();
   else if(uccm_msg_id == SCPI_TINT_MSG)       parse_scpi_tint();
   else if(uccm_msg_id == SCPI_EFC_MSG)        parse_scpi_efc();
   else if(uccm_msg_id == UCCM_LED_MSG)        parse_uccm_led();
   else if(uccm_msg_id == UCCM_EFC_MSG)        parse_uccm_efc();
   else if(uccm_msg_id == SCPI_TEST_MSG)       parse_scpi_test();
   else if(uccm_msg_id == SCPI_ELEV_MSG)       parse_scpi_elev();
   else if(uccm_msg_id == SCPI_IGNORE_MSG)     parse_scpi_ignore();
   else if(uccm_msg_id == SCPI_GET_CABLE_MSG)  parse_scpi_cable();
   else if(uccm_msg_id == SCPI_SET_CABLE_MSG)  parse_scpi_cable();
   else if(uccm_msg_id == SCPI_ID_MSG)         parse_scpi_id();
   else if(uccm_msg_id == SCPI_SURVEY_MSG)     parse_scpi_survey();
   else if(uccm_msg_id == SCPI_PROGRESS_MSG)   parse_scpi_progress();
   else if(uccm_msg_id == SCPI_JAMSYNC_MSG)    parse_scpi_jamsync();
   else if(uccm_msg_id == SCPI_HOLDOVER_MSG)   parse_scpi_holdover();
   else if(uccm_msg_id == UCCM_RATE_MSG)       parse_uccm_rate();
   else if(uccm_msg_id == UCCM_STATE_MSG)      parse_uccm_state();
   else if(uccm_msg_id == UCCM_GET_PULLIN_MSG) parse_uccm_pullin();
   else if(uccm_msg_id == UCCM_GET_HW_ALARM)   parse_uccm_hw_alarm();
   else if(uccm_msg_id == UCCM_GET_OPER_ALARM) parse_uccm_oper_alarm();
   else if(uccm_msg_id == UCCM_STATUS_MSG) {
      if(strstr(nmea_msg, "TEMP = ")) {  // samsung temperature value
         parse_uccm_temp();
      }
   }
   uccm_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_uccm_status(u08 c)
{
char *s;

   // get values from SYST:STAT message response
   if(c == 0x0D) return;   // samsung
   if(c == 0x00) return;

   if(c == 0x0A) {  // end-of-line,  process it
      strupr(scpi_status_line);
      if(uccm_time_line(1)) return;  // time code message in middle of the status message

      if(strstr(scpi_status_line, "SETTLING")) {
         discipline_mode = DIS_MODE_WARMUP;
         saw_uccm_dmode = 1;
      }
      else if(strstr(scpi_status_line, "WARMUP")) {
         discipline_mode = DIS_MODE_WARMUP;
         saw_uccm_dmode = 2;
      }
      else if(strstr(scpi_status_line, "UNLOCK")) {
         discipline_mode = DIS_MODE_UNLOCK;
         saw_uccm_dmode = 3;
      }
      else if(strstr(scpi_status_line, "LOCK")) {
         discipline_mode = DIS_MODE_NORMAL;
         saw_uccm_dmode = 3;
      }
      else if(strstr(scpi_status_line, "NORMAL")) {
         discipline_mode = DIS_MODE_NORMAL;
         saw_uccm_dmode = 3;
      }
      else if(strstr(scpi_status_line, "SURVEY")) {
         discipline_mode = DIS_MODE_NORMAL;
         saw_uccm_dmode = 3;
      }

      if(strstr(scpi_status_line, "COMMAND COMPLETE")) {
//       scpi_status = 0;
      }
      else if(strstr(scpi_status_line, "TFOM")) {
         s = strstr(scpi_status_line, "TFOM");
         if(s) {
            tfom = atoi(s+4);
            have_tfom = 3;
         }
         s = strstr(scpi_status_line, "FFOM");
         if(s) {
            ffom = atoi(s+4);
            have_ffom = 3;
         }
      }
      else if(strstr(scpi_status_line, "NO REF")) {
         no_uccm_ref = 1;
         rcvr_mode = RCVR_MODE_ACQUIRE;  // !!!! RCVR_MODE_NO_SATS
      }
      else if(strstr(scpi_status_line, "WAIT FOR GPS")) {
         no_uccm_ref = 1;
         rcvr_mode = RCVR_MODE_ACQUIRE;
      }
      else if(strstr(scpi_status_line, "PRN") && strstr(scpi_status_line, "EL")) {  // tracking info follows
         if(strstr(scpi_status_line, "SS")) adjust_scpi_ss = 1;
         else                               adjust_scpi_ss = 0;
         scpi_status = 2;
         if(rcvr_type == UCCM_RCVR) {
            reset_sat_tracking();
         }
      }
      else if(strstr(scpi_status_line, "ELEV") && strstr(scpi_status_line, "MASK")) {  // end of tracking info
         scpi_status = 4; // skip lines until we see the COMMAND COMPLETE
         have_count = 44;
         sat_count = scpi_tracked + scpi_not_tracked;
         config_sat_count(sat_count);
         s = strstr(scpi_status_line, "V=");
         if(s) {
            ant_v1 = atof(s+2);
            have_ant_v1 = 1;
         }
         s = strstr(scpi_status_line, "I=");
         if(s) {
            ant_ma = atof(s+2);
            have_ant_ma = 1;
         }
      }
      else if((scpi_status == 4) && strstr(scpi_status_line, "------")) {
         scpi_status = 0;
      }
      if(scpi_status == 2) {  // we are in the az/el area, decode it
         parse_scpi_azel();
      }

      scpi_col = 0;
      scpi_status_line[0] = 0;
   }
   else {  // accumulate the status line
      if(scpi_col < ((int)sizeof(scpi_status_line)-2)) {
         scpi_status_line[scpi_col++] = c;
         scpi_status_line[scpi_col] = 0;
      }
// if(debug_file) fprintf(debug_file, "sline col:%d c:%d: stat:%d [%s]\n", scpi_col, c, scpi_status, scpi_status_line);
   }
}

#define NUM_DIFFS 30
double fdifs[NUM_DIFFS+2];

void decode_uccm_temp()
{
char *s;

   if(have_temperature) return;  // samsung

   s = strstr(scpi_status_line, "=");   //kkkkk
   if(s) {
      temperature = (float) atof(s+1);
      temperature *= 1.0E12F;
      if(temperature) have_uccm_tcor = 1;
      if(have_uccm_tcor) plot[TEMP].plot_id = "TCOR";
   }
}

void decode_uccm_phase()
{
char *s;

   s = strstr(scpi_status_line, "=");   //kkkkk
   if(s) {
      pcorr = atof(s+1) * 1.0E12;
      have_uccm_pcor = 1;
   }
}

void decode_uccm_gps_phase()
{
char *s;

   s = strstr(scpi_status_line, "=");   //kkkkk
   if(s) {
      uccm_gps_phase = atof(s+1);
      have_uccm_gps_phase = 1;
   }
}

void decode_uccm_loop()
{
float dac_link;
float dac_avg;
float dac_gps;    // same as dac_link?
float freq_corr;  // always 0.0?
float link_off;   // changes
float freq_diff;  // changes
float freq_frac;  // 0 during recovery
char *s;

if(debug_file) fprintf(debug_file, "decode_uccm_loop fmt:%d: %s\n", loop_fmt, scpi_status_line);

   freq_diff = 999.0;

   if(loop_fmt == SAMSUNG_FMT) {
      s = strstr(scpi_status_line, "OCXO : ");
      if(s) { 
         if(strstr(s+7, "UNAVAILABLE")) ;
         else {
            freq_diff = (float) atof(s+7);
            osc_offset = (double) (freq_diff*1.0E9);
            // adevs of loop value is done in secondary_timing();
            have_osc_offset = 10;
            have_rcvr_osc = 10;
         }
      }

      s = strstr(scpi_status_line, "EXT : ");
      if(s) {   // !!!! do something with this value
         if(strstr(s+6, "UNAVAILABLE")) ;
         else { 
            uccm_ext_val = (float) atof(s+6);
            have_uccm_ext_val = 10;
         }
      }
      return;
   }
   else if(loop_fmt == SYMMETRICOM_FMT) {  // Symmetricom
      s = strstr(scpi_status_line, "=");
      if(s) {
         freq_diff = (float) atof(s+1);
      }
   }
   else {  // Trimble
      sscanf(scpi_status_line, "%g %g %g %g %g %g %g", 
         &dac_link, &dac_avg, &dac_gps, &freq_corr, &link_off, &freq_diff, &freq_frac);

      if(saw_uccm_dmode && (discipline_mode == DIS_MODE_WARMUP)) ;
      else if((discipline_mode == DIS_MODE_NORMAL) && (freq_corr != 0.0F)) {
         discipline_mode = DIS_MODE_MANUAL_HOLD;
      }
      else if(discipline_mode && (freq_corr == 0.0F)) {
         discipline_mode = DIS_MODE_NORMAL;
      }
   }

   if(freq_diff < (-2.00E-7)) ;      // bogus value -2.79E-7 shows up occasionally on Trimble
   else if(freq_diff > (2.00E-7)) ;  // bogus value shows up occasionally on Trimble
   else {
      osc_offset = (double) (freq_diff*1.0E9);
      // adevs of loop value is done in secondary_timing();
      have_osc_offset = 10;
      have_rcvr_osc = 10;
   }

//sprintf(plot_title, "%g %g %g %g %g %g %g", 
//dac_link, dac_avg, dac_gps, freq_corr, link_off, freq_diff, freq_frac);
}

void get_uccm_loop(u08 c)
{
   if(c == 0x0D) return;   // samsung
   if(c == 0x00) return;

   if(c == 0x0A) {  // end-of-line,  process it
      strupr(scpi_status_line);
      if(uccm_time_line(2)) return;  // time code message in middle of the loop message

      if(strstr(scpi_status_line, "COMMAND COMPLETE")) {
         uccm_loop = 0;
      }
      else if(strstr(scpi_status_line, "DAC")) {  // loop info header line
         uccm_loop = 2;
      }
      else if(strstr(scpi_status_line, "----")) {  // Symmetricom loop info header line
         uccm_loop = 2;
         loop_fmt = SYMMETRICOM_FMT;
         if(scpi_type != UCCMP_TYPE) {
            if(user_set_temp_plot == 0) plot[TEMP].show_plot = 1;
         }
         if(user_set_scpi_type == 0) scpi_type = UCCMP_TYPE;
         config_msg_ofs();
      }
      else if(uccm_loop == 2) { // skip the header line(s)
         if(0 || strstr(scpi_status_line, "SERIAL NUMBER")) { // we got syst:stat
            have_uccm_loop = 0;
            uccm_loop = 4;
         }
         else if(loop_fmt == SYMMETRICOM_FMT) {  // Symmetricom
            if(strstr(scpi_status_line, "FREQ COR")) {  // the payload line we want
               decode_uccm_loop();
            }
            else if(strstr(scpi_status_line, "TEMP COR")) {  // the payload line we want
               decode_uccm_temp();
            }
            else if(strstr(scpi_status_line, "PHASE COR")) {  // the payload line we want
               decode_uccm_phase();
            }
            else if(strstr(scpi_status_line, "GPS PHASE")) {  // the payload line we want
               decode_uccm_gps_phase();
            }
         }
         else uccm_loop = 3;    // next line has the goodies
      }
      else if(uccm_loop == 4) {  // skip to Command Complete
      }
      else if(strstr(scpi_status_line, "OCXO : ")) {  // samsung
         loop_fmt = SAMSUNG_FMT;
         decode_uccm_loop();
      }
      else if(strstr(scpi_status_line, "EXT : ")) {  // samsung
         loop_fmt = SAMSUNG_FMT;
         decode_uccm_loop();
      }

      if(uccm_loop == 3) {  // we are in the info data area, decode it
         decode_uccm_loop();
      }

      scpi_col = 0;
      scpi_status_line[0] = 0;
   }
   else {  // accumulate the status line
      if(scpi_col < ((int)sizeof(scpi_status_line)-2)) {
         scpi_status_line[scpi_col++] = c;
         scpi_status_line[scpi_col] = 0;
      }
// if(debug_file) fprintf(debug_file, "info_line col:%d c:%d: stat:%d [%s]\n", scpi_col, c, uccm_loop, scpi_status_line);
   }
}



void get_uccm_message()
{
static u08 c = 0;   // samsung
static int row = 0;
static int last_uccm_c = 0x0D;
static int null_decode = 0;
static int time_msg = 0;

   // This routine buffers up an incoming UCCM message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_uccm_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   last_uccm_c = c;
   c = get_com_char();
   if(time_msg == 1) {
      if(c != '5') time_msg = 0;
      else time_msg = 2;
   }
   if(c == 0x0D) return; // samsung

   if(scpi_status) {    // we are reading the SYST:STAT? results
      get_uccm_status(c);
      return;
   }
   else if(uccm_loop) {  // we are reading the UCCM LOOP results
      get_uccm_loop(c);
      return;
   }

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

if(null_decode) {
   null_decode = 0;
   if(c == 0x0A) ;
   else if(c == 0x0D) ;
   else if(c == ' ') return;
   else if(tsip_wptr < (MAX_TSIP-1)) {  // so add it to the message buffer
      tsip_buf[tsip_wptr++] = c;
      tsip_buf[tsip_wptr] = 0;
      tsip_sync = 1;
      return;
   }
}

   if(tsip_sync == 0) {    // syncing to start of message, search for a '>'
      if(c == '>') {
         tsip_sync = 1;
         get_sync_time();
      }
      else if((c == 'C') || (c == 'c')) {
         tsip_sync = 2; // maybe the time field?
         time_msg = 1;
         get_sync_time();
      }
      else {
         tsip_sync = 1;
         get_sync_time();
      }
if((last_uccm_c == 0x0A) || (last_uccm_c == 0x0D)) {   // samsung
   if(tsip_wptr < (MAX_TSIP-1)) {  // so add it to the message buffer
      tsip_buf[tsip_wptr++] = c;
      tsip_buf[tsip_wptr] = 0;
      tsip_sync = 1;
   }
   return;
}

      rst_msg:
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // '>' has been seen, now build the message
      if(c == 0x0A) goto uccm_end; 
      else if(c == 0x0D)  goto uccm_end; 
      else if(c == '>')  {  // null response to UCCM command
         decode_uccm_msg(1);
         packet_end = 1;
         null_decode = 1;  // put next char in tsip_bug
         tsip_sync = 1;
         tsip_rptr = 0;
         tsip_wptr = 0;
         return;
      }


      if(tsip_wptr < (MAX_TSIP-1)) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         tsip_sync = 0;
         goto rst_msg;
      }
if(time_msg && (last_uccm_c = 'c') && (c == 'a')) {  // samsung does not end time message with 0x0D 0x0A
   if(strlen((char *) tsip_buf) > 130) {
      goto uccm_end;
   }
}
   }
   else if(tsip_sync == 2) {  // C5 timecode message
      if(c == '5') {
         if(tsip_wptr < (MAX_TSIP-2)) {  // so add it to the message buffer
            tsip_buf[tsip_wptr++] = 'C';
            tsip_buf[tsip_wptr++] = '5';
            tsip_buf[tsip_wptr] = 0;
            tsip_sync = 1;
         }
      }
      else tsip_sync = 0;
   }
   else {
      uccm_end:
//if(debug_file) fprintf(debug_file, "Got:: {%s}\n", tsip_buf);
      decode_uccm_msg(2);
      packet_end = 1;
      tsip_sync = 0;
      time_msg = 0;
   }
}


//
//
//   HP5071A receiver stuff (cesium beam oscillator)
//
//

int cs_msg_id = 0;


void get_cs_message()
{
u08 c;
static int row = 0;

   // This routine buffers up an incoming 5071A message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_cs_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '>'
      if(c == '>') {
         tsip_sync = 1;
         get_sync_time();
      }
      else {
         tsip_sync = 1;
         get_sync_time();
      }

      rst_msg:
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // '>' has been seen, now build the message
      if(c == 0x0D) goto cs_end; 
      else if(c == 0x0A) goto cs_end; 
      else if(c == '>')  {  // null response to command
         decode_cs_msg();
         packet_end = 1;
         tsip_sync = 1; 
         tsip_rptr = 0;
         tsip_wptr = 0;
         return;
      }

      if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_sync = 0;
         goto rst_msg;
      }
   }
   else {
      cs_end:
      decode_cs_msg();
      packet_end = 1;
      tsip_sync = 0;
   }
}


void poll_cs_log()
{
static int log_req_tick;
static int all_log_req = 0;
static int last_log_req = 0;
int i;

   if(cs_log_count <= CS_LOG_SHOW) {
      send_polled_cmd("DIAG:LOG?", CS_LOGINFO_MSG);
   }
   else if(log_req_tick & 1) {  // alternate requests for all log entries and last log entries
      if(all_log_req >= cs_log_count) all_log_req = 0;
      sprintf(out, "DIAG:LOG?  %d", all_log_req);
      send_polled_cmd(out, CS_LOGINFO_MSG);
      all_log_req = (all_log_req + 1) % MAX_CS_LOGS;
   }
   else {
      i = cs_log_count - last_log_req - 1;
      if(i >= 0) {
         sprintf(out, "DIAG:LOG? %d", i);
         send_polled_cmd(out, CS_LOGINFO_MSG);
      }
      last_log_req = (last_log_req + 1) % CS_LOG_SHOW;
   }

   ++log_req_tick;
}


void poll_next_cs()  
{                    
int test;            

   // request an item from a HP5071A.  Requests are alternated between         
   // a time message and some receiver parameter.  The parameter requests are  
   // alternated between one of three important parameters and then the lesser 
   // important ones.                                                          

   if(need_cs_timeset && cs_remote) {  // set the HP5071A date and time from the system clock
      set_cs_time(need_cs_timeset);
      restore_cs_remote();
   }

   test = 1;
   if(test && (polled_q_in != polled_q_out)) {  // we have a special message request queued
      send_queued_cmd(1);
   }
   else if((cs_msg_id != polled_msg_id) && (cs_msg_id != CS_MJD_MSG)) ;  // only process last requested message
   else if(polled_msg_id == CS_TIME_MSG) { // request next misc message every time
      if((test == 0) && (polled_q_in != polled_q_out)) {  // we have a special message request queued
         send_queued_cmd(2);
      }
      else {
         if(polled_req < 0) polled_req = 0;

         if((polled_seq % 10) == 0)   poll_cs_log();
         else {
            if     (polled_req ==  0) send_polled_cmd("*IDN?",              SCPI_ID_MSG);
            else if(polled_req ==  1) send_polled_cmd("SYST:REM?",          CS_REM_MSG);
            else if(polled_req ==  2) send_polled_cmd(":DISP:ENAB?",        CS_DISP_MSG);
            else if(polled_req ==  3) send_polled_cmd(":PTIM:STAN?",        CS_STANDBY_MSG);
            else if(polled_req ==  4) send_polled_cmd(":ROSC:CONT?",        SCPI_EFC_MSG);
            else if(polled_req ==  5) send_polled_cmd("DIAG:CBTS?",         CS_CBTID_MSG);
            else if(polled_req ==  6) send_polled_cmd("DIAG:CONT:STAT?",    CS_LAMP_MSG);
            else if(polled_req ==  7) send_polled_cmd("DIAG:CURR:BEAM?",    CS_BEAM_MSG);
            else if(polled_req ==  8) send_polled_cmd("DIAG:CURR:PUMP?",    CS_PUMP_MSG);
            else if(polled_req ==  9) send_polled_cmd("DIAG:GAIN?",         CS_GAIN_MSG);
            else if(polled_req == 10) send_polled_cmd("DIAG:RFAM?",         CS_RFAM_MSG);
            else if(polled_req == 11) send_polled_cmd("DIAG:STAT:GLOB?",    CS_GLOB_MSG);
            else if(polled_req == 12) send_polled_cmd("DIAG:STAT:SUPP?",    CS_SUPPLY_MSG);
            else if(polled_req == 13) send_polled_cmd("DIAG:TEMP?",         CS_TEMP_MSG);
            else if(polled_req == 14) send_polled_cmd("DIAG:VOLT:COV?",     CS_COVEN_MSG);
            else if(polled_req == 15) send_polled_cmd("DIAG:VOLT:ROSC?",    CS_QOVEN_MSG);
            else if(polled_req == 16) send_polled_cmd("DIAG:VOLT:EMUL?",    CS_EMUL_MSG);
            else if(polled_req == 17) send_polled_cmd("DIAG:VOLT:HWI?",     CS_HWI_MSG);
            else if(polled_req == 18) send_polled_cmd("DIAG:VOLT:MSP?",     CS_MSP_MSG);
            else if(polled_req == 19) send_polled_cmd("DIAG:VOLT:PLL?",     CS_PLL_MSG);
            else if(polled_req == 20) send_polled_cmd("DIAG:VOLT:SUPP?",    CS_VOLT_MSG);
            else if(polled_req == 21) send_polled_cmd("DIAG:CURR:CFI?",     CS_CFIELD_MSG);
            else if(polled_req == 22) send_polled_cmd(":ROSC:FREQ1?",       CS_FREQ1_MSG);
            else if(polled_req == 23) send_polled_cmd(":ROSC:FREQ2?",       CS_FREQ2_MSG);
            else if(polled_req == 24) send_polled_cmd(":ROSC:STE?",         CS_STER_MSG);
            else if(polled_req == 25) send_polled_cmd(":PTIM:SYNC?",        CS_SYNC_MSG);
            else if(polled_req == 26) send_polled_cmd(":PTIM:LEAP:STAT?",   CS_LEAPSTAT_MSG);
            else if(polled_req == 27) send_polled_cmd(":PTIM:LEAP:DUR?",    CS_LEAPDUR_MSG);
            else if(polled_req == 28) send_polled_cmd(":PTIM:LEAP:MJD?",    CS_LEAPMJD_MSG);
            else if(polled_req == 29) send_polled_cmd("DIAG:LOG:COUN?",     CS_LOGCOUNT_MSG);

            if(++polled_req > 29) {  // start the request cycle over
               polled_req = 0;
               if(all_polled == 0) {
                  new_queue(RESET_ALL_QUEUES, 123);
               }
               ++all_polled;
            }
         }
         ++polled_seq;
      }
   }
   else {
      send_polled_cmd(":PTIM:MJD?", CS_MJD_MSG);   // request date message
      send_polled_cmd(":PTIM:TIME?", CS_TIME_MSG); // request time message
   }
}

void parse_cs_time()
{
double jd;

   if(get_msg_field()) {
      pri_hours = hours = cs_hours = atoi(msg_field);
   }
   if(get_msg_field()) {
      pri_minutes = minutes = cs_minutes = atoi(msg_field);
   }
   if(get_msg_field()) {
      pri_seconds = seconds = cs_seconds = atoi(msg_field);
   }
   pri_frac = 0.0;

   if(have_cs_mjd && cs_mjd) {
      jd = cs_mjd + JD_MJD;
      gregorian(0, jd);
      pri_year = year = g_year;
      pri_month = month = g_month;
      pri_day = day = g_day;
   }
   else {  // no MJD set, get it from system clock
      get_clock_time();   // get system clock time in UTC
      pri_year = year = clk_year;
      pri_month = month = clk_month;
      pri_day = day = clk_day;
   }

   have_cs_time = 1;

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   if(seconds != last_misc_second) {
      update_gps_screen(1006);
   }
}

void parse_cs_mjd()
{
   if(get_msg_field()) {
      cs_mjd = atof(msg_field);
      have_cs_mjd = 1;
   }
}

void parse_cs_cbtid()
{
   if(get_msg_field()) {
      strcpy(cs_cbtid, msg_field);
      have_cs_cbtid = 1;
   }
}

void parse_cs_cont() 
{
   if(get_msg_field()) {
      if(strstr(msg_field, "OFF")) cs_cont = 0;
      else if(strstr(msg_field, "ENAB")) cs_cont = 1;
      else if(strstr(msg_field, "ON")) cs_cont = 2;
      have_cs_cont = 1;
   }
}

void parse_cs_beam() 
{ 
   if(get_msg_field()) {
      cs_beam = atof(msg_field) * 1.0E9; 
      have_cs_beam = 1;
   }
}

void parse_cs_cfield() 
{ 
   if(get_msg_field()) {
      cs_cfield = atof(msg_field) * 1.0E3; 
      have_cs_cfield = 1;
   }
}

void parse_cs_pump() 
{
   if(get_msg_field()) {
      cs_pump = atof(msg_field) * 1.0E6; 
      have_cs_pump = 1;
      pps_offset = cs_pump;
      have_pps_offset = 1;
   }
}

void parse_cs_gain() 
{
   if(get_msg_field()) {
      cs_gain = atof(msg_field) * 100.0; 
      have_cs_gain = 1;
   }
}

void parse_cs_rfam() 
{
   if(get_msg_field()) {
      cs_rfam1 = atof(msg_field) * 100.0; 
      have_cs_rfam |= 0x01;
   }
   if(get_msg_field()) {
      cs_rfam2 = atof(msg_field) * 100.0; 
      have_cs_rfam |= 0x02;
   }
}

void parse_cs_glob() 
{
   if(get_msg_field()) {
      strcpy(cs_glob, msg_field); 
      have_cs_glob = 1;
   }
}

void parse_cs_slew() 
{
   // !!!! HP5071A does not let us query this setting

   if(get_msg_field()) {
      cs_slew = atof(msg_field); 
      have_cs_slew = 1;
   }
}

void parse_cs_sync() 
{
   if(get_msg_field()) {
      if     (strstr(msg_field, "OFF"))   cs_sync = "OFF";
      else if(strstr(msg_field, "FRON"))  cs_sync = "FRONT";
      else if(strstr(msg_field, "REAR"))  cs_sync = "REAR";
      have_cs_sync = 1;
   }
}

void parse_cs_standby() 
{ 
   if(get_msg_field()) {
      cs_standby = (int) atof(msg_field); 
      have_cs_standby = 1;
   }
}

void parse_cs_supply() 
{
   if(get_msg_field()) {
      if     (strstr(msg_field, "AC"))   cs_supply = "AC";
      else if(strstr(msg_field, "DC"))   cs_supply = "DC";
      else if(strstr(msg_field, "BATT")) cs_supply = "BATT";
      else if(strstr(msg_field, "LOW"))  cs_supply = "LOW";
      else                               cs_supply = "UNKN";
      have_cs_supply = 1;
   }
}

void parse_cs_temp() 
{
   if(get_msg_field()) {
      cs_temp = atof(msg_field); 
      have_cs_temp = 1;

      temperature = (float) cs_temp;
      have_temperature = 113;
   }
}

void parse_cs_coven() 
{ 
   if(get_msg_field()) {
      cs_coven = atof(msg_field); 
      have_cs_coven = 1;
   }
}

void parse_cs_emul() 
{
   if(get_msg_field()) {
      cs_emul = atof(msg_field); 
      have_cs_emul = 1;
      osc_offset = cs_emul;
      have_osc_offset = 68;
   }
}

void parse_cs_hwi() 
{ 
   if(get_msg_field()) {
      cs_hwi = atof(msg_field); 
      have_cs_hwi = 1;
   }
}

void parse_cs_msp() 
{ 
   if(get_msg_field()) {
      cs_msp = atof(msg_field); 
      have_cs_msp = 1;
   }
}

void parse_cs_pll() 
{ 
   if(get_msg_field()) {
      cs_pll_dro = atof(msg_field); 
      have_cs_pll |= 0x01;
   }
   if(get_msg_field()) {
      cs_pll_saw = atof(msg_field); 
      have_cs_pll |= 0x02;
   }
   if(get_msg_field()) {
      cs_pll_87 = atof(msg_field); 
      have_cs_pll |= 0x04;
   }
   if(get_msg_field()) {
      cs_pll_up = atof(msg_field); 
      have_cs_pll |= 0x08;
   }
}

void parse_cs_qoven() 
{
   if(get_msg_field()) {   // oscillator oven voltage monitor
      cs_qoven = atof(msg_field); 
      have_cs_qoven = 1;
   }
}

void parse_cs_freq1() 
{
   if(get_msg_field()) {
      cs_freq1 = atof(msg_field); 
      have_cs_freq1 = 1;
   }
}

void parse_cs_freq2() 
{
   if(get_msg_field()) {
      cs_freq2 = atof(msg_field); 
      have_cs_freq2 = 1;
   }
}

void parse_cs_ster() 
{
   if(get_msg_field()) {
      cs_ster = atof(msg_field); 
      have_cs_ster = 1;
   }
}

void parse_cs_disp() 
{
   if(get_msg_field()) {
      cs_disp = (int) atof(msg_field); 
      have_cs_disp = 1;
   }
}

void parse_cs_remote() 
{
   if(get_msg_field()) {
      cs_remote = (int) atof(msg_field); 
      have_cs_remote = 1;
   }
}

void parse_cs_leapstat()
{
int leap;


   if(get_msg_field()) {
      if     (strstr(msg_field, "1")) leap = 1;
      else if(strstr(msg_field, "ON")) leap = 1;
      else leap = 0;
      cs_leap_state = leap;
      have_cs_leapstate = 1;

      if(leap) {
         minor_alarms |= MINOR_LEAP_PEND;
      }
      else { 
         minor_alarms &= (~MINOR_LEAP_PEND);
      }
      have_leap_info = 33;
   }
}

void parse_cs_leapdur()
{
   if(get_msg_field()) {
      cs_leapdur = (int) atof(msg_field);
      have_cs_leapdur = 33;
   }
}

void parse_cs_leapmjd()
{
   if(get_msg_field()) {
      cs_leapmjd = atof(msg_field);
      have_cs_leapmjd = 33;
      jd_leap = (cs_leapmjd + JD_MJD) + jtime(23,59,59,0.0);
      calc_jd_leap(57);
   }
}

void parse_cs_lamp()
{
   if(get_msg_field()) {
      if(strstr(msg_field, "OFF")) cs_cont = 0;
      else if(strstr(msg_field, "ENAB")) cs_cont = 1;
      else if(strstr(msg_field, "ON")) cs_cont = 2;
      have_cs_cont = 1;
   }
}

void parse_cs_logcount()
{
   if(get_msg_field()) {
      cs_log_count = atoi(msg_field);
      have_cs_logcount = 1;
   }
}

void parse_cs_loginfo()
{
int log_id;
int i;

   log_id = (-1);
   if(get_msg_field()) {
      have_cs_loginfo = 1;
      log_id = atoi(&msg_field[4]);
   }
   if(get_msg_field()) {
      msg_field[LOG_MSG_LEN] = 0;
      i = cs_log_count - log_id - 1;
i = log_id;
      if((log_id >= 0) && (i >= 0) && (i < MAX_CS_LOGS)) {
         sprintf(out, "%3d: %s", log_id,msg_field);
         strcpy(cs_log_msg[i], out);
      }
   }
}

void parse_cs_volt() 
{
   if(get_msg_field()) {
      cs_volt1 = atof(msg_field); 
      have_cs_volt |= 0x01;
   }
   if(get_msg_field()) {
      cs_volt2 = atof(msg_field); 
      have_cs_volt |= 0x02;
   }
   if(get_msg_field()) {
      cs_volt3 = atof(msg_field); 
      have_cs_volt |= 0x04;
   }
   cs_volt_avg = (cs_volt1 + cs_volt2 + cs_volt3) / 3.0;
}


void decode_cs_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;

   // get the response from the receiver and pass it to (HOPEFULLY) the routine
   // that expects it...

   strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode cs msg %d:%s\n", cs_msg_id, nmea_msg);

   if((nmea_msg[0] == 'E') && (nmea_msg[1] == '-') && isdigit(nmea_msg[2])) {  // message returned error
      queue_cs_cmd("*CLS", SCPI_CLS_MSG);  // reset the error
      cs_msg_id = 0;
      poll_next_cs();
      return;
   }
   else if((nmea_msg[0] == 'E') && (nmea_msg[1] == '+') && isdigit(nmea_msg[2])) {  // message returned error
      queue_cs_cmd("*CLS", SCPI_CLS_MSG);  // reset the error
      cs_msg_id = 0;
      poll_next_cs();
      return;
   }
   else if((nmea_msg[0] == 'S') && (nmea_msg[1] == 'C') && (nmea_msg[2] == 'P') && (nmea_msg[3] == 'I')) {  // message has no response to process
      cs_msg_id = 0;
      poll_next_cs();
      return;
   }

   if(cs_msg_id == 0) {  // get the echoed command and set the message id
if(debug_file) fprintf(debug_file, "response to:%s (status msg:%d) is next\n", nmea_msg, scpi_status);
      if     (strstr(nmea_msg, "PTIM:TIME?"))       cs_msg_id = CS_TIME_MSG;
      else if(strstr(nmea_msg, "PTIM:MJD?"))        cs_msg_id = CS_MJD_MSG;
      else if(strstr(nmea_msg, "DIAG:CBTS?"))       cs_msg_id = CS_CBTID_MSG;
      else if(strstr(nmea_msg, "DIAG:CONT:STAT?"))  cs_msg_id = CS_LAMP_MSG;
      else if(strstr(nmea_msg, "DIAG:CURR:BEAM?"))  cs_msg_id = CS_BEAM_MSG;
      else if(strstr(nmea_msg, "DIAG:CURR:CFI?"))   cs_msg_id = CS_CFIELD_MSG;
      else if(strstr(nmea_msg, "DIAG:CURR:PUMP?"))  cs_msg_id = CS_PUMP_MSG;
      else if(strstr(nmea_msg, "DIAG:GAIN?"))       cs_msg_id = CS_GAIN_MSG;
      else if(strstr(nmea_msg, "DIAG:RFAM?"))       cs_msg_id = CS_RFAM_MSG;
      else if(strstr(nmea_msg, "DIAG:STAT:GLOB?"))  cs_msg_id = CS_GLOB_MSG;
      else if(strstr(nmea_msg, "DIAG:STAT:SUPP?"))  cs_msg_id = CS_SUPPLY_MSG;
      else if(strstr(nmea_msg, "DIAG:TEMP?"))       cs_msg_id = CS_TEMP_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:COV?"))   cs_msg_id = CS_COVEN_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:EMUL?"))  cs_msg_id = CS_EMUL_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:HWI?"))   cs_msg_id = CS_HWI_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:MSP?"))   cs_msg_id = CS_MSP_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:PLL?"))   cs_msg_id = CS_PLL_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:ROSC?"))  cs_msg_id = CS_QOVEN_MSG;
      else if(strstr(nmea_msg, "DIAG:VOLT:SUPP?"))  cs_msg_id = CS_VOLT_MSG;
      else if(strstr(nmea_msg, "DIAG:LOG:COUN?"))   cs_msg_id = CS_LOGCOUNT_MSG;
      else if(strstr(nmea_msg, "DIAG:TEST?"))       cs_msg_id = SCPI_TEST_MSG;
      else if(strstr(nmea_msg, "DIAG:LOG?"))        cs_msg_id = CS_LOGINFO_MSG;
      else if(strstr(nmea_msg, "PTIM:SYNC?"))       cs_msg_id = CS_SYNC_MSG;
      else if(strstr(nmea_msg, "PTIM:STAN?"))       cs_msg_id = CS_STANDBY_MSG;
      else if(strstr(nmea_msg, "PTIM:SLEW?"))       cs_msg_id = CS_SLEW_MSG;   // !!!! HP5071A does not let us query this setting
      else if(strstr(nmea_msg, "PTIM:LEAP:STAT?"))  cs_msg_id = CS_LEAPSTAT_MSG;
      else if(strstr(nmea_msg, "PTIM:LEAP:DUR?"))   cs_msg_id = CS_LEAPDUR_MSG;
      else if(strstr(nmea_msg, "PTIM:LEAP:MJD?"))   cs_msg_id = CS_LEAPMJD_MSG;
      else if(strstr(nmea_msg, "ROSC:FREQ1?"))      cs_msg_id = CS_FREQ1_MSG;
      else if(strstr(nmea_msg, "ROSC:FREQ2?"))      cs_msg_id = CS_FREQ2_MSG;
      else if(strstr(nmea_msg, "ROSC:STE?"))        cs_msg_id = CS_STER_MSG;
      else if(strstr(nmea_msg, "ROSC:CONT?"))       cs_msg_id = SCPI_EFC_MSG;
      else if(strstr(nmea_msg, "DISP:ENAB?"))       cs_msg_id = CS_DISP_MSG;
      else if(strstr(nmea_msg, "SYST:REM?"))        cs_msg_id = CS_REM_MSG;
      else if(strstr(nmea_msg, "*IDN?"))            cs_msg_id = SCPI_ID_MSG;
      else if(strstr(nmea_msg, "*CLS"))             cs_msg_id = SCPI_CLS_MSG;

      return;
   }

if(debug_file) fprintf(debug_file, "cs %d response:%s\n", cs_msg_id, nmea_msg);
   msg_col = 0;
   if     (cs_msg_id == CS_TIME_MSG)     parse_cs_time();
   else if(cs_msg_id == CS_MJD_MSG)      parse_cs_mjd();
   else if(cs_msg_id == CS_CBTID_MSG)    parse_cs_cbtid();
   else if(cs_msg_id == CS_BEAM_MSG)     parse_cs_beam();
   else if(cs_msg_id == CS_CFIELD_MSG)   parse_cs_cfield();
   else if(cs_msg_id == CS_PUMP_MSG)     parse_cs_pump();
   else if(cs_msg_id == CS_GAIN_MSG)     parse_cs_gain();
   else if(cs_msg_id == CS_RFAM_MSG)     parse_cs_rfam();
   else if(cs_msg_id == CS_GLOB_MSG)     parse_cs_glob();
   else if(cs_msg_id == CS_SUPPLY_MSG)   parse_cs_supply();
   else if(cs_msg_id == CS_TEMP_MSG)     parse_cs_temp();
   else if(cs_msg_id == CS_COVEN_MSG)    parse_cs_coven();
   else if(cs_msg_id == CS_QOVEN_MSG)    parse_cs_qoven();
   else if(cs_msg_id == CS_EMUL_MSG)     parse_cs_emul();
   else if(cs_msg_id == CS_HWI_MSG)      parse_cs_hwi();
   else if(cs_msg_id == CS_MSP_MSG)      parse_cs_msp();
   else if(cs_msg_id == CS_PLL_MSG)      parse_cs_pll();
   else if(cs_msg_id == CS_VOLT_MSG)     parse_cs_volt();
   else if(cs_msg_id == CS_FREQ1_MSG)    parse_cs_freq1();
   else if(cs_msg_id == CS_FREQ2_MSG)    parse_cs_freq2();
   else if(cs_msg_id == CS_STER_MSG)     parse_cs_ster();
   else if(cs_msg_id == CS_SYNC_MSG)     parse_cs_sync();
   else if(cs_msg_id == CS_STANDBY_MSG)  parse_cs_standby();
   else if(cs_msg_id == CS_DISP_MSG)     parse_cs_disp();
   else if(cs_msg_id == CS_REM_MSG)      parse_cs_remote();
   else if(cs_msg_id == CS_LEAPSTAT_MSG) parse_cs_leapstat();
   else if(cs_msg_id == CS_LEAPDUR_MSG)  parse_cs_leapdur();
   else if(cs_msg_id == CS_LEAPMJD_MSG)  parse_cs_leapmjd();
   else if(cs_msg_id == CS_SLEW_MSG)     parse_cs_slew();   // !!!! HP5071A does not let us query this setting
   else if(cs_msg_id == CS_LOGCOUNT_MSG) parse_cs_logcount();
   else if(cs_msg_id == CS_LOGINFO_MSG)  parse_cs_loginfo();
   else if(cs_msg_id == CS_LAMP_MSG)     parse_cs_lamp();
   else if(cs_msg_id == SCPI_ID_MSG)     parse_scpi_id();
   else if(cs_msg_id == SCPI_TEST_MSG)   parse_scpi_test();
   else if(cs_msg_id == SCPI_EFC_MSG)    parse_scpi_efc();

   poll_next_cs();
   cs_msg_id = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}

void set_cs_disp(int mode)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      if(mode) queue_cs_cmd("DISP:ENAB ON", CS_DISP_MSG);
      else     queue_cs_cmd("DISP:ENAB OFF", CS_DISP_MSG);
      restore_cs_remote();
      queue_cs_cmd("DISP:ENAB?", CS_DISP_MSG);
   }
}

void set_cs_leap(double jd, int dur)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      if(((dur != 59) && (dur != 61)) || (jd == 0.0)) {
         queue_cs_cmd(":PTIM:LEAP:STAT OFF", CS_LEAPSTAT_MSG);
      }
      else {
         sprintf(out, ":PTIM:LEAP:MJD %d", (int) (jd + jtime(0,0,1, 0.0)));
         queue_cs_cmd(out, CS_LEAPMJD_MSG);

         sprintf(out, ":PTIM:LEAP:DUR %d", dur);  
         queue_cs_cmd(out, CS_LEAPDUR_MSG); 

         queue_cs_cmd(":PTIM:LEAP:STAT ON", CS_LEAPSTAT_MSG);
      }

      restore_cs_remote();

      queue_cs_cmd(":PTIM:LEAP:STAT?", CS_LEAPSTAT_MSG);
      queue_cs_cmd(":PTIM:LEAP:DUR?",  CS_LEAPDUR_MSG);
      queue_cs_cmd(":PTIM:LEAP:MJD?", CS_LEAPMJD_MSG);
   }
}

void set_cs_freq(int chan, double freq)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      if(chan == 1) {
         set_cs_remote(1);
         sprintf(out, ":ROSC:FREQ%d %g", chan, freq);
         queue_cs_cmd(out, CS_FREQ1_MSG);
         restore_cs_remote();

         sprintf(out, ":ROSC:FREQ%d?", chan);
         queue_cs_cmd(out, CS_FREQ1_MSG);
      }
      else if(chan == 2) {
         set_cs_remote(1);
         sprintf(out, ":ROSC:FREQ%d %g", chan, freq);
         queue_cs_cmd(out, CS_FREQ2_MSG);
         restore_cs_remote();

         sprintf(out, ":ROSC:FREQ%d?", chan);
         queue_cs_cmd(out, CS_FREQ2_MSG);
      }
   }
}

void set_cs_remote(int mode)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      if(mode) queue_cs_cmd("SYST:REM ON", CS_REM_MSG);
      else     queue_cs_cmd("SYST:REM OFF", CS_REM_MSG);
      queue_cs_cmd("SYST:REM?", CS_REM_MSG);
   }
}

void set_cs_slew(double val)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      sprintf(out, ":PTIM:SLEW %g", val);
      queue_cs_cmd(out, CS_SLEW_MSG);
      restore_cs_remote();
   }
}

void set_cs_standby(int mode)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      if(mode) queue_cs_cmd(":PTIM:STAN 1", CS_STANDBY_MSG);
      else     queue_cs_cmd(":PTIM:STAN 0", CS_STANDBY_MSG);
      restore_cs_remote();
   }
}

void set_cs_ster(double offset)
{
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      sprintf(out, ":ROSC:STE %g", offset);
      queue_cs_cmd(out, CS_STER_MSG);
      queue_cs_cmd("ROSC:STE?", CS_STER_MSG);
      restore_cs_remote();
   }
}

void set_cs_sync(char *s)
{
   // OFF FRONT REAR
   if(read_only) return;

   if(s == 0) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      sprintf(out, ":PTIM:SYNC %s", s);
      queue_cs_cmd(out, CS_SYNC_MSG);
      restore_cs_remote();
      queue_cs_cmd(":PTIM:SYNC?", CS_SYNC_MSG);
   }
}

void set_cs_time(char mode)
{
double mjd;

   // sets the H5071 date and time from the system clock.
   // The 5071A must be in REMOTE mode for this to work
   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      need_cs_timeset = 0;
      get_clock_time();   // get system clock time in UTC

      if(mode == 'L') {  // set to local (displayed) time
         adjust_tz(987);
         clk_year = pri_year;
         clk_month = pri_month;
         clk_day = pri_day;
         clk_hours = pri_hours;
         clk_minutes = pri_minutes;
         clk_seconds = pri_seconds;
         clk_frac = pri_frac;
      }
      else if(mode == 'U') {  // set to UTC time
      }
      else return;

      mjd = jdate(clk_year,clk_month,clk_day) - JD_MJD;

      sprintf(out, "PTIM:TIME %d,%d,%d", clk_hours,clk_minutes,clk_seconds);
      send_polled_cmd(out, CS_TIME_MSG);

      sprintf(out, "PTIM:MJD %d", (int) (mjd+0.50));
      send_polled_cmd(out, CS_MJD_MSG);

      BEEP(511);
   }
}

void clear_cs_log()
{
int i;

   if(read_only) return;

   if(rcvr_type == CS_RCVR) {
      set_cs_remote(1);
      queue_cs_cmd("DIAG:LOG:CLE", CS_CLEARLOG_MSG);
      restore_cs_remote();

      queue_cs_cmd("DIAG:LOG:COUN?", CS_LOGCOUNT_MSG);
      cs_log_count = 0;
      for(i=0; i<MAX_CS_LOGS; i++) {
         cs_log_msg[i][0] = 0;
      }
      need_redraw = 7865;
   }
}


//
//
//   TAIP receiver stuff
//
//


void send_taip_start(char *cmd)
{
   // start a TAIP message
   if(log_file && (log_stream & LOG_PACKET_START)) {
      if(cmd) fprintf(log_file, "\nSend taip start: %s\n", cmd);
      else    fprintf(log_file, "\nSend taip start: >\n");
   }

   eom_flag = 0;
   nmea_tx_cksum = 0;
   send_byte('>');
   if(cmd) send_nmea_string(cmd, 0);

}

void send_taip_end(int do_cksum)
{
char cksum[10];

   // end a TAIP message

   if(do_cksum) {
      send_byte(';');
      send_byte('*');

      sprintf(cksum, "%02X", (nmea_tx_cksum & 0xFF));
      sendout(RCVR_PORT, cksum[0], ADD_CHAR);
      sendout(RCVR_PORT, cksum[1], ADD_CHAR);
   }
   sendout(RCVR_PORT, '<',  ADD_CHAR);
   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);
   if(sim_file == 0) Sleep(50);
}

void send_taip_cmd(char *cmd)
{
   if(cmd == 0) return;
   send_taip_start(cmd);
   send_taip_end(1);     // add cksum
}

void send_taip_id(int id)
{
char s[32];

   // send a TAIP device id

   if(id < 0) id = 0-id;
   id = (id % 10000);

   sprintf(s, ";ID=%04d", id);
   send_nmea_string(s, 0);
}


void parse_taip_time()
{
int sec;
int i;
int source;
int count;

   if(get_fixed_field(2)) pri_hours = hours = atoi(msg_field);
   if(get_fixed_field(2)) pri_minutes = minutes = atoi(msg_field);
   if(get_fixed_field(5)) {
      sec = atoi(msg_field);
      pri_seconds = seconds = sec/1000;
      pri_frac = ((double) (sec % 1000)) / 1000.0;
   }

   if(get_fixed_field(2)) pri_day = day = atoi(msg_field);
   if(get_fixed_field(2)) pri_month = month = atoi(msg_field);
   if(get_fixed_field(4)) pri_year = year = atoi(msg_field);

   if(get_fixed_field(2)) {
      i = atoi(msg_field);
      if(!user_set_utc_ofs) utc_offset = i;
      check_utc_ofs(33);
   }

   if(get_fixed_field(1)) source = atoi(msg_field);
   if(get_fixed_field(2)) count = atoi(msg_field);

   get_fixed_field(1);  // gps/utc
   get_fixed_field(5);  // reserved

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   update_gps_screen(667);
}


void ignore_taip()
{
}


void parse_taip_nav()
{
int num_sv;
int prn;
int mode;
u08 iode;
float az;

   get_fixed_field(8);  // GPS time
   if(get_fixed_field(10)) {
      lat = atof(msg_field) / 1.0E7 * (PI/180.0);
   }
   if(get_fixed_field(11)) {
      lon = atof(msg_field) / 1.0E7 * (PI/180.0);
   }
   if(get_fixed_field(9)) {
      alt = (atof(msg_field) / 1.0E2) / FEET_PER_METER;
   }

   if(get_fixed_field(4)) {
      speed = (atof(msg_field) / 10.0);  // mph
      have_speed = 55;
   }
   if(get_fixed_field(5)) {
   }
   if(get_fixed_field(4)) {
      heading = (atof(msg_field) / 10.0);  // mph
      have_heading = 55;
   }

   if(get_fixed_field(2)) {  // sat prn's and iode
      reset_sat_tracking();
      num_sv = atoi(msg_field);
      while(num_sv-- > 0) {
         get_fixed_field(2);
         prn = atoi(msg_field);
         iode = (u08) get_fixed_field(2);        // iode

         if((prn >= 1) && (prn <= MAX_PRN)) {   // we fake a lot of this
            sat[prn].level_msg = 1;
            az = (float) (prn*10);
            set_sat_azel(prn, az, (float) 30.0);
            sat[prn].sig_level = (float) 40.0;
            sat[prn].tracking = prn;
            sat[prn].iode = iode;
            have_sat_azel = 33;
            level_type = "SNR";
            have_snr |= rinex_gnss(prn);

            record_sig_levels(prn);
         }
      }
   }

   get_fixed_field(10);  // reserved

   if(get_fixed_field(1)) {  // nav source
      mode = atoi(msg_field);
      if     (mode == 0) rcvr_mode = RCVR_MODE_2D;
      else if(mode == 1) rcvr_mode = RCVR_MODE_3D;
      else if(mode == 2) rcvr_mode = RCVR_MODE_DGPS;
      else if(mode == 3) rcvr_mode = RCVR_MODE_DGPS;
      else               rcvr_mode = RCVR_MODE_UNKNOWN;
   }

   if(get_fixed_field(1)) {  // age
   }
}


void parse_taip_id()
{
   if(get_fixed_field(4)) {
      taip_id = atoi(nmea_msg);
   }
}

void parse_taip_status()
{
   get_fixed_field(1);
   if(get_fixed_field(1)) {  // tracking mode
      have_gps_status = 33;
      if     (msg_field[0] == '0') gps_status = GPS_FIXES;
      else if(msg_field[0] == '1') gps_status = GPS_NO_TIME;
      else if(msg_field[0] == '3') gps_status = GPS_PDOP_HIGH;
      else if(msg_field[0] == '8') gps_status = GPS_NO_SATS;
      else if(msg_field[0] == '9') gps_status = GPS_ONE_SAT;
      else if(msg_field[0] == 'A') gps_status = GPS_TWO_SATS;
      else if(msg_field[0] == 'B') gps_status = GPS_THREE_SATS;
      else if(msg_field[0] == 'C') gps_status = GPS_SAT_UNAVAIL;
      else                         gps_status = GPS_UNK_STATUS;
   }

   if(get_fixed_field(1)) {  // status nibble 1 - antenna
      if(msg_field[0] == '0')  minor_alarms &= (~(MINOR_ANT_NO_PWR)); 
      else                     minor_alarms |= (MINOR_ANT_NO_PWR);
      have_antenna = 33;
   }
   if(get_fixed_field(1)) {  // status nibble 2 - backup battery
   }

   if(get_fixed_field(2)) {  // machine id      - not used
   }

   if(get_fixed_field(1)) {  // status nibble 3 - not used
   }

   if(get_fixed_field(1)) {  // status nibble 4 - almanac / RTCC
      minor_alarms &= (~MINOR_ALMANAC);
      if     (msg_field[0] == '8')  minor_alarms |= (MINOR_ALMANAC); 
      else if(msg_field[0] == 'A')  minor_alarms |= (MINOR_ALMANAC); 
      have_almanac = 1;
   }

   if(get_fixed_field(2)) {  // reseved         - not used
   }
}


void parse_taip_version()
{
   taip_product[0] = 0;
   taip_version[0] = 0; 
   taip_core[0] = 0; 
   taip_copr[0] = 0; 

   if(get_scpi_delim(';')) {  // product name
      strcpy(taip_product, msg_field);
   }
   if(get_scpi_delim(';')) {  // version
      strcpy(taip_version, msg_field);
   }
   if(get_scpi_delim(';')) {  // core
      strcpy(taip_core, msg_field);
   }
   if(get_scpi_delim(';')) {  // copright
      strcpy(taip_copr, msg_field);
   }

   have_info |= ALL_ID_INFO;
}


void decode_taip_msg()
{
char c;
int i;

   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   msg_col = 0;      // index of next char to get from nmea buffer
   get_fixed_field(3); // get the TAIP message type 
   if     (!strcmp(msg_field, "RAL")) ignore_taip();        // altitude up
   else if(!strcmp(msg_field, "RAP")) ignore_taip();        // set port config
   else if(!strcmp(msg_field, "RCP")) ignore_taip();        // compact position
   else if(!strcmp(msg_field, "RDC")) ignore_taip();        // set diff corrs
   else if(!strcmp(msg_field, "RDD")) ignore_taip();        // set delta diffs
   else if(!strcmp(msg_field, "RID")) parse_taip_id();      // set/get unit id
   else if(!strcmp(msg_field, "RIP")) ignore_taip();        // set initial posn
   else if(!strcmp(msg_field, "RLN")) parse_taip_nav();     // long nav msg
   else if(!strcmp(msg_field, "RPR")) ignore_taip();        // set protcol (unsupported)
   else if(!strcmp(msg_field, "RPT")) ignore_taip();        // set port config 
   else if(!strcmp(msg_field, "RPV")) ignore_taip();        // position/velocity
   else if(!strcmp(msg_field, "RRM")) ignore_taip();        // set reporting mode 
   else if(!strcmp(msg_field, "RRT")) ignore_taip();        // reset
   else if(!strcmp(msg_field, "RST")) parse_taip_status();  // status
   else if(!strcmp(msg_field, "RTM")) parse_taip_time();    // time/date
   else if(!strcmp(msg_field, "RVR")) parse_taip_version(); // receiver id
   else                                ignore_taip();

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   
   saw_rcvr_msg = 1;
}


void get_taip_message()
{
u08 c;

   // This routine buffers up an incoming TAIP message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == '>') {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      nmea_msg_cksum = 0;  // the checksum in the message
      nmea_vfy_cksum = 0;  // the calculated message checksum
      nmea_vfy_cksum ^= c;
      return;
   }
   else if(tsip_sync == 1) { // '>' has been seen, now build the message
      if((c == '<') || (c == 0x0D) || (c == 0x0A)) goto taip_end;  // message has no checksum

      if(c == '*') {
         nmea_vfy_cksum ^= c;
         tsip_sync = 2;  // message checksum follows
      }
      else if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         nmea_vfy_cksum ^= c;
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 2) {  // getting message checksum chars
      if((c == '<') || (c == 0x0D) || (c == 0x0A)) goto taip_end;

      if     ((c >= '0') && (c <= '9')) nmea_msg_cksum = (nmea_msg_cksum << 4) | (c-'0');
      else if((c >= 'A') && (c <= 'F')) nmea_msg_cksum = (nmea_msg_cksum << 4) | ((c-'A')+10);
      else goto rst_msg;
   }
   else if(tsip_sync == 3) {  // end of message
      taip_end:
      if((tsip_sync == 2) && (nmea_vfy_cksum != nmea_msg_cksum)) { // checksum error
         tsip_error |= CKSUM_ERROR;
         goto rst_msg;
      }
      decode_taip_msg(); // message checksum matches, process the message
      packet_end = 1;
      tsip_wptr = 0;     // prepare for next message
      tsip_sync = 0;
      venus_nmea = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      nmea_vfy_cksum = nmea_msg_cksum = 0; // init received message checksum
      venus_nmea = 0;
   }
}




//
//
//  TymServe 2000 receiver stuff
//
//

void decode_tserve_msg()
{
int i;
char c;
int doy;
int hh,mm,ss;
int q;
double jd;
int last_tick = 999;

   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }
   strupr(nmea_msg);
if(debug_file) fprintf(debug_file, "{%s}\n", nmea_msg);

   doy = 0;
   hh = mm = ss = 0;
   q = 0;

   msg_col = 0;
   if(get_msg_field()) {
      doy = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {
      hh = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {
      mm = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {
      time_flags &= (~TFLAGS_INVALID);
      discipline_mode = DIS_MODE_NORMAL;

      ss = atoi(msg_field);
if(debug_file) fprintf(debug_file, "  %03d:%02d:%02d:%02d  %s\n", doy,hh,mm,ss, msg_field);

      if(strchr(msg_field, 'X')) {  // no time avail
         time_flags |= TFLAGS_INVALID;
      }
      else if(strchr(msg_field, 'F')) {  // flywheeling
         discipline_mode = DIS_MODE_AUTO_HOLD;
      }
      else {
      }
   }
   else return;

   get_clock_time();   // in UTC
   jd = jdate(clk_year, 1, 1) + (double) (doy) - 1.0;
   jd += jtime(hh,mm,ss, 0.0);

   set_gregorian_time(jd);  // convert julian date to gregorian

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }
   
   if(last_tick != ss) {
      last_tick = ss;
      update_gps_screen(1555);
   }
   saw_rcvr_msg = 1;
}


void get_tserve_message()
{
u08 c;

   // This routine buffers up an incoming TSERVE message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '$'
      if(c == 0x01) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // '>' has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A)) goto tserve_end;  // message has no checksum

      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync) {  // end of message
      tserve_end:
      decode_tserve_msg(); 
      packet_end = 1;
      tsip_wptr = 0;     // prepare for next message
      tsip_rptr = 0;
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_rptr = 0;
      tsip_sync = 0;
   }
}


//
//
//  Spectrum TM4 receiver stuff
//
//

int tm4_gps;


void parse_tm4_ack()
{
   log_packet_id("ack");
}


void parse_tm4_time()
{
   log_packet_id("time/date");

   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%04d", &pri_month,&pri_day,&pri_year);
   }
   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%02d", &pri_hours,&pri_minutes,&pri_seconds);
      pri_frac = 0.0;
   }

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   update_gps_screen(5564);
}


void parse_tm4_lla(int enhanced)
{
double val;
double sign;
int i;

   log_packet_id("position");
   if(enhanced) have_tm4_enhanced = 1; 
   else if(have_tm4_enhanced) return;  // ignore low res stuff

   val = 0.0;
   sign = 1.0;
   if(get_msg_field()) {  // lat
      val = atof(msg_field);
   }
   if(get_msg_field()) {
      if(msg_field[0] == 'S') sign = (-1.0);
      lat = ((double) (int) val) / 100.0;   // degrees
      val = val - (lat * 100.0);            // minutes
      val /= 60.0;
      lat += val;
      lat *= sign;
      lat = lat * PI / 180.0;
   }

   val = 0.0;
   sign = 1.0;
   if(get_msg_field()) {  // lon
      val = atof(msg_field);
   }
   if(get_msg_field()) {
      if(msg_field[0] == 'W') sign = (-1.0);
      lon = ((double) (int) val) / 100.0;   // degrees
      val = val - (lat * 100.0);            // minutes
      val /= 60.0;
      lon += val;
      lon *= sign;
      lon = lon * PI / 180.0;
   }

   if(enhanced) {
      if(get_msg_field()) {
         alt = atof(msg_field);
      }
      get_msg_field(); // 'M' for meters
   }

   if(get_msg_field()) { // 0=no gps   1=gps avail;
      tm4_gps = atoi(msg_field);
   }

   if(get_msg_field()) { // sat count
      if(msg_field[0] == 'C') i = 12;
      else if(msg_field[0] == 'B') i = 11;
      else if(msg_field[0] == 'A') i = 10;
      else i = atoi(msg_field);
      sat_count = i;
      config_sat_count(sat_count);
      have_count = 444;
   }

   if(enhanced) {
      if(get_msg_field()) {
         hdop = (float) atof(msg_field);
         have_dops |= HDOP;
      }

      if(get_msg_field()) {
         speed = atof(msg_field);
         have_speed = 444;
      }

      if(get_msg_field()) {
         heading = atof(msg_field);
         have_heading = 444;
      }
   }
}


void parse_tm4_alt()
{
   log_packet_id("altitude");
   if(have_tm4_enhanced) return;

   if(get_msg_field()) {
      alt = atof(msg_field);
   }

   get_msg_field(); // 'M' for meters
}



void parse_tm4_elmask()
{
int i;
int datum;

   log_packet_id("elmask/datum");

   if(get_msg_field()) {
      i = atoi(msg_field);
      if     (i == 0) i = 5;
      else if(i == 1) i = 15;
      else if(i == 2) i = 20;
      else i = 0;
      if((i > 0) && (i < 90)) {
         el_mask = (float) i;
         have_el_mask = 444;
      }
   }

   if(get_msg_field()) {
      datum = atoi(&msg_field[1]);
      have_datum = 444;
   }
}


void parse_tm4_cable()
{
   log_packet_id("cable delay");

   if(get_msg_field()) {
      cable_delay = atof(msg_field);
      cable_delay /= 1.0E9;
      have_cable_delay = 444;
   }
}


void parse_tm4_tmode()
{
int i;

   log_packet_id("timing mode");

   if(get_msg_field()) {
      i = atoi(msg_field);
      minor_alarms &= (~MINOR_SURVEY);
      if(i == 0) {
         if(tm4_gps) rcvr_mode = RCVR_MODE_3D;
         else        rcvr_mode = RCVR_MODE_NO_SATS;
      }
      else if(i == 1) {
         rcvr_mode = RCVR_MODE_HOLD;
      }
      else if(i == 3) {
         rcvr_mode = RCVR_MODE_SURVEY;
         minor_alarms |= MINOR_SURVEY;
      }
      else {
         rcvr_mode = RCVR_MODE_UNKNOWN;
      }
   }
}


void parse_tm4_dop()
{
int i;

   log_packet_id("dop/almanac");

   if(get_msg_field()) {  // GQ
      i = atoi(msg_field);
      if     (i == 9) pdop = 1.0;
      else if(i == 8) pdop = 3.0;
      else if(i == 7) pdop = 4.0;
      else if(i == 6) pdop = 5.0;
      else if(i == 5) pdop = 6.0;
      else if(i == 4) pdop = 8.0;
      else if(i == 3) pdop = 10.0;
      else if(i == 2) pdop = 15.0;
      else if(i == 1) pdop = 25.0;
      else if(i == 0) pdop = 50.0;
      have_dops |= PDOP;
   }

   if(get_msg_field()) {  // alm status
      i = atoi(msg_field);
      if(i == 0) minor_alarms &= (~MINOR_ALMANAC);
      else       minor_alarms |= MINOR_ALMANAC;
      have_almanac = 444;
   }
}


void parse_tm4_mux1()
{
   log_packet_id("mux1 status");

   if(get_msg_field()) {  // time port baud
      tm4_time_baud = atoi(msg_field);
      have_tm4_time_baud = 1;
   }

   if(get_msg_field()) {  // output type
      tm4_code1 = atoi(msg_field);
      if(tm4_code1 == 7) {
         pps_enabled = 1;
      }
      else pps_enabled = 0;

      have_tm4_code |= 0x01;
   }
}


void parse_tm4_validity()
{
int i;

   log_packet_id("time validity");

   if(get_msg_field()) {
      i = atoi(msg_field);
      if(i == 1) time_flags &= (~TFLAGS_INVALID);
      else if(i == 0) time_flags |= TFLAGS_INVALID;
   }

}


void parse_tm4_ett()
{
int ett_month,ett_day,ett_year;
int ett_hours,ett_minutes,ett_seconds;
double ett_frac;

   log_packet_id("time tag");

   ett_jd = 0.0;
   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%04d", &ett_month,&ett_day,&ett_year);
      ett_jd = jdate(ett_year,ett_month,ett_day);
   }
   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%02d%lf", &ett_hours,&ett_minutes,&ett_seconds, &ett_frac);
      ett_jd += jtime(ett_hours,ett_minutes,ett_seconds,ett_frac);
      ++have_tm4_ett_jd;
   }

}


void parse_tm4_dmode()
{
int i;

   log_packet_id("discipline mode");

   if(get_msg_field()) {
      i = atoi(msg_field);
      if     (i == 1) discipline_mode = DIS_MODE_WARMUP;
      else if(i == 2) discipline_mode = DIS_MODE_RECOVERY;
      else if(i == 3) discipline_mode = DIS_MODE_AUTO_HOLD;
      else if(i == 4) discipline_mode = DIS_MODE_NORMAL;
      else if(i == 5) discipline_mode = DIS_MODE_AUTO_HOLD;
      else            discipline_mode = DIS_MODE_UNKNOWN;
   }

}


void parse_tm4_alarm()
{
int i;

   log_packet_id("alarm status");

   if(get_msg_field()) {      // coast (holdover)
      i = atoi(msg_field);
   }


   if(get_msg_field()) {      // antenna
      i = atoi(msg_field);
      if(i) minor_alarms |= MINOR_ANT_NO_PWR;
      else  minor_alarms &= (~MINOR_ANT_NO_PWR);
      have_antenna = 444;
   }


   if(get_msg_field()) {      // OSC output
      i = atoi(msg_field);
      if(i == 0) critical_alarms &= (~CRIT_OCXO);
      else       critical_alarms |= (CRIT_OCXO);
      have_critical_alarms = 444;
   }
}


void parse_tm4_id()
{
   log_packet_id("id info");

   if(get_msg_field()) { // .obj
      msg_field[32] = 0;
      strcpy(tm4_obj, msg_field);
   }

   if(get_msg_field()) { // .hex
      msg_field[32] = 0;
      strcpy(tm4_hex, msg_field);
   }

   if(get_msg_field()) { // hex string
      msg_field[32] = 0;
      strcpy(tm4_string, msg_field);
   }

   if(get_msg_field()) { // version?
      msg_field[32] = 0;
      strcpy(tm4_id, msg_field);
   }

   have_info |= ALL_ID_INFO;
}


void parse_tm4_mux2()
{
   log_packet_id("mux2 status");

   if(get_msg_field()) {  // output type
      tm4_code2 = atoi(msg_field);
      have_tm4_code |= 0x02;
   }
}


void parse_tm4_sats()
{
int i;
int prn;
int w,x,y;
int z;
float sig;

   log_packet_id("sat info");
   reset_sat_tracking();

   for(i=0; i<12; i++) { 
      prn = w = x = y = 0;
      sig = 0.0F;
      if(get_msg_field()) {
         prn = atoi(msg_field);
         if((prn >= 1) && (prn < MAX_PRN)) ;
         else prn = 0;
      }

      if(get_msg_field()) {  // 0=included   1=not included
         w = atoi(msg_field);
         if(w == 0) sat[prn].tracking = (-1);
      }

      if(get_msg_field()) {  // tracking status A=acquiring S=searching  0..9=sig leve;
         if(isdigit(msg_field[0])) {  // sig level
            x = atoi(msg_field);
            if     (x == 9) sig = 45.0F;
            else if(x == 8) sig = 44.0F;
            else if(x == 7) sig = 43.0F;
            else if(x == 6) sig = 42.0F;
            else if(x == 5) sig = 41.0F;
            else if(x == 4) sig = 40.0F;
            else if(x == 3) sig = 39.0F;
            else if(x == 2) sig = 38.0F;
            else if(x == 1) sig = 37.0F;
            else if(x == 0) sig = 26.0F;
            sat[prn].tracking = 1;
            sat[prn].sig_level = sig;
            sat[prn].level_msg = 444;
         }
         else { // A=acquiring  S=searching
            x = msg_field[0];
         }
      }
      if(get_msg_field()) {  // ephemeris status
         y = atoi(msg_field);
      }
   }

   if(get_msg_field()) {  // receiver status
      // 2=sky search
      // 3=almanac collect
      // 4=ephemeris collect
      // 5=acquisition
      // 6=positioning
      z = atoi(msg_field);
   }

   level_type = "dBc";
}


void parse_tm4_time_format()
{
   log_packet_id("time output format");

   if(get_msg_field()) {  // time output type
      ett_time_format = atoi(msg_field);
      have_ett_time_format = 1;
   }
}


void parse_tm4_code_format()
{
   log_packet_id("time code format");

   if(get_msg_field()) {  // code format
      ett_code_format = atoi(msg_field);
      have_ett_code_format = 1;
   }
}


void parse_tm4_ett_enable()
{
   log_packet_id("ETT enabled state");

   if(get_msg_field()) {  // ETT enabled state
      ett_enable = atoi(msg_field);
      have_tm4_ett_enable = 1;
   }

   if(get_msg_field()) {  // polarity
      ett_polarity = msg_field[0];
      have_ett_polarity = 1;
   }
}


void parse_tm4_speed()
{
   log_packet_id("speed/heading");
   if(have_tm4_enhanced) return;

    if(get_msg_field()) {
       speed = atof(msg_field);
       have_speed = 444;
    }

    if(get_msg_field()) {
       heading = atof(msg_field);
       have_heading = 444;
    }
}


void parse_tm4_pop(int type)
{
int pop_month,pop_day,pop_year;
int pop_hours,pop_minutes,pop_seconds;
double pop_frac;

   log_packet_id("POP/ETT");

   pop_jd = 0.0;

   if(get_msg_field()) {
      tm4_pop_mode = atoi(msg_field);
      have_tm4_pop_mode = 1;
   }

   if(get_msg_field()) {
      tm4_pop_polarity = msg_field[0];
      have_tm4_pop_polarity = 1;
   }

   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%04d", &pop_month,&pop_day,&pop_year);
      pop_jd = jdate(pop_year,pop_month,pop_day);
   }
   if(get_msg_field()) {
      sscanf(msg_field, "%02d%02d%02d%lf", &pop_hours,&pop_minutes,&pop_seconds, &pop_frac);
      pop_jd += jtime(pop_hours,pop_minutes,pop_seconds,pop_frac);
      ++have_tm4_pop_jd;
   }


   if(get_msg_field()) {
      tm4_repeat = atoi(msg_field);
      have_tm4_repeat = 1;
   }

   if(type == 74) {  // simultaneous POP/ETT device
      if(get_msg_field()) {
         tm4_width = atoi(msg_field);
         have_tm4_width = 1;
      }
   }
}


void parse_tm4_utc()
{
int i;

   log_packet_id("UTC offset");

   if(get_msg_field()) {  // 0=GPS time  1=UTC time
      i = atoi(msg_field);
   }
   if(get_msg_field()) {  // 0=no utc_offset  1=utc_offset valid
      i = atoi(msg_field);
   }

   if(get_msg_field()) { 
      i = atoi(msg_field);
      if(i) {
         if(!user_set_utc_ofs) {
            utc_offset = i;
            have_utc_ofs = (444);
         }
         check_utc_ofs(444);
      }
   }
}


void parse_tm4_coast()
{
int hh,mm,ss;

   log_packet_id("coast time");

   hh = mm = ss = 0;
   if(get_msg_field()) {  // hhhhmmss
      sscanf(msg_field, "%04d%02d%02d", &hh,&mm,&ss);
      holdover = (hh*3600 + mm*60 + ss);
   }

   if(get_msg_field()) {  // undocumented 8 chars
   }
   if(get_msg_field()) {  // undocumented 8 chars 
   }
   if(get_msg_field()) {  // undocumented 8 chars 
   }
   if(get_msg_field()) {  // undocumented value (2)
   }
}


void parse_tm4_lock(int id)
{
   sprintf(out, "lock status: #%d", id);
   log_packet_id(out);

   if(get_msg_field()) {
      tm4_lock = (-1);
      if(isdigit(msg_field[0])) tm4_lock = atoi(msg_field);
      have_tm4_lock = id;
   }
}


void parse_tm4_options()
{
   log_packet_id("option settings");

   if(get_msg_field()) {  // antenna alarm enable
      tm4_antenna = atoi(msg_field);
      have_tm4_antenna = 1;
   }

   if(get_msg_field()) {  // PPS source
      tm4_pps_source = atoi(msg_field);
      have_tm4_pps_source = 1;
   }

   if(get_msg_field()) {  // reserved
   }

   if(get_msg_field()) {  // reserved 
   }

   if(get_msg_field()) {  // reserved 
   }

   if(get_msg_field()) {  // reserved
   }
}





void parse_tm4_unkn(char *id)
{
   if(id) sprintf(out, "unknown msg: #%s", id);
   else   sprintf(out, "unknown message!");
   log_packet_id(out);
}


void decode_tm4_msg()
{
int i;
u08 c;

   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   msg_col = 0;      // index of next char to get from nmea buffer
   get_msg_field();  // get the TM4 message type 

   if     (strstr(msg_field, "50")) parse_tm4_ack();           // ack
   else if(strstr(msg_field, "51")) parse_tm4_time();          // date and time
   else if(strstr(msg_field, "52")) parse_tm4_lla(0);          // position
   else if(strstr(msg_field, "53")) parse_tm4_alt();           // altitude
   else if(strstr(msg_field, "55")) parse_tm4_elmask();        // mask angle and datum
   else if(strstr(msg_field, "56")) parse_tm4_cable();         // cable delay
   else if(strstr(msg_field, "57")) parse_tm4_tmode();         // timing mode
   else if(strstr(msg_field, "59")) parse_tm4_dop();           // DOP and almanac status
   else if(strstr(msg_field, "60")) parse_tm4_mux1();          // mux1 status
   else if(strstr(msg_field, "61")) parse_tm4_validity();      // time validity
   else if(strstr(msg_field, "62")) parse_tm4_ett();           // event time tag
   else if(strstr(msg_field, "63")) parse_tm4_pop(63);         // POP/ETT status
   else if(strstr(msg_field, "64")) parse_tm4_dmode();         // discipline mode
   else if(strstr(msg_field, "65")) parse_tm4_alarm();         // alarm status
   else if(strstr(msg_field, "66")) parse_tm4_id();            // * id info
   else if(strstr(msg_field, "68")) parse_tm4_mux2();          // mux2 status
   else if(strstr(msg_field, "69")) parse_tm4_sats();          // sat status
   else if(strstr(msg_field, "70")) parse_tm4_time_format();   // serial time format
   else if(strstr(msg_field, "71")) parse_tm4_code_format();   // time code format
   else if(strstr(msg_field, "73")) parse_tm4_ett_enable();    // ETT params
   else if(strstr(msg_field, "74")) parse_tm4_pop(74);         // POP params
   else if(strstr(msg_field, "75")) parse_tm4_speed();         // speed/heading
   else if(strstr(msg_field, "76")) parse_tm4_lla(1);          // enhanced NMEA info
   else if(strstr(msg_field, "77")) parse_tm4_lock(77);        // phase loc status (early units)
   else if(strstr(msg_field, "78")) parse_tm4_options();       // option values
   else if(strstr(msg_field, "79")) parse_tm4_coast();         // coast time
   else if(strstr(msg_field, "80")) parse_tm4_lock(80);        // phase lock status
   else if(strstr(msg_field, "81")) parse_tm4_utc();           // UTC info
   else if(strstr(msg_field, "82")) parse_tm4_unkn(msg_field); // * unknown message (6 vals)
   else                             parse_tm4_unkn(msg_field); // unknown message

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   
   saw_rcvr_msg = 1;
}


void get_tm4_message()
{
u08 c;

   // This routine buffers up an incoming Spectrum TM4 message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_nmea_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '#'
      if(c == '#') {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // '#' has been seen, now build the message
      if(c == 0x0D) {
         tsip_sync = 2;
         return;
      }

      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
         tsip_buf[tsip_wptr] = 0;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 2) {  // 0x0A end of message
      decode_tm4_msg(); 
      packet_end = 1;
      tsip_wptr = 0;     // prepare for next message
      tsip_rptr = 0;
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_rptr = 0;
      tsip_sync = 0;
   }
}



//
//
//  Acron Zeit receiver stuff
//
//

void send_acron_byte(u08 c)
{
   // send string to the serial port...  send each char to the serial port
   // wait for ACRON_RCVR to echo input char, eat it, then wait 
   // at least 10 msecs
//if(debug_file) fprintf(debug_file, "send:%02X\n", c);

   sendout(RCVR_PORT, c, EOM);

   while(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {  // wait for char to echo
      check_com_timer(RCVR_PORT);
      if(com[RCVR_PORT].com_data_lost) return;
   }

   c = get_com_char();  // eat that pesky echoed character
//if(debug_file) fprintf(debug_file, "eat:%02X\n", c);
   if(sim_file == 0) Sleep(20);
}

void send_acron_cmd(char *s)
{
int i, j;

   if(s == 0) return;
   
   j = strlen(s);
   if(j) this_acron_cmd = toupper(s[j-1]);
   else  this_acron_cmd = 0;
//if(debug_file) fprintf(debug_file, "send acron cmd:[%s]  len:%d  cmd:%c\n", s, j, this_acron_cmd);

   for(i=0; i<j; i++) {
      send_acron_byte((u08) s[i]);
   }

   send_acron_byte((u08) 0x0D);

//if(debug_file) fprintf(debug_file, "this_acron_cmd: %c\n", this_acron_cmd);

   if(FAKE_ACRON_RCVR) {
      if(this_acron_cmd == 'O') {
         get_clock_time();   // get system clock time in UTC
         sprintf(out, "%02d%02d%02d6%02d%02d%02d47\r", clk_hours,clk_minutes,clk_seconds,
         clk_day,clk_month,clk_year-2000);
         strcpy((char *) &com[RCVR_PORT].rcv_buffer[0], (char *) out);
         com[RCVR_PORT].next_rcv_byte = 0;
         com[RCVR_PORT].rcv_byte_count = 16;
      }
      else if(this_acron_cmd == 'G') {
         sprintf(out, "1%c\r", '0'+(pri_minutes%6));
         strcpy((char *) &com[RCVR_PORT].rcv_buffer[0], (char *) out);
         com[RCVR_PORT].next_rcv_byte = 0;
         com[RCVR_PORT].rcv_byte_count = 3;
      }
      else if(this_acron_cmd == 'H') {  // receiver sync request
      }
   }
}


void init_acron_time()
{
   // set UTC mode, leap year flag
   // clear leap second and dst flags

   get_clock_time();
   if(leap_year(clk_year)) {
      send_acron_cmd("88c");
   }
   else {
      send_acron_cmd("80c");
   }
}


void parse_acron_time()
{
int dow;
int leap;
int status;
static int last_sec = 99;

   msg_col = 0;

   get_fixed_field(2);
   hours = pri_hours = atoi(msg_field);
   get_fixed_field(2);
   minutes = pri_minutes = atoi(msg_field);
   get_fixed_field(2);
   seconds = pri_seconds = atoi(msg_field);
   pri_frac = 0.0;

   get_fixed_field(1);
   dow = atoi(msg_field);

   get_fixed_field(2);
   day = pri_day = atoi(msg_field);
   get_fixed_field(2);
   month = pri_month = atoi(msg_field);
   get_fixed_field(2);
   year = pri_year = atoi(msg_field) + 2000;

if(debug_file) fprintf(debug_file, "acron time(%s) -> %02d/%02d/%02d %02d:%02d:%02d\n", nmea_msg, year,month,day,hours,minutes,seconds);

   get_fixed_field(1);
   leap = atoi(msg_field);

   if(leap & 0x04) {  // leap pending
      minor_alarms |= MINOR_LEAP_PEND;
   }
   else {
      minor_alarms &= (~MINOR_LEAP_PEND);
   }
   have_leap_info = 33;

   get_fixed_field(1);
   status = atoi(msg_field);

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   if(FAKE_ACRON_RCVR && (seconds == last_sec)) {
   }
   else {
      last_sec = seconds;
      update_gps_screen(1556);
   }
if(debug_file) {
   gregorian(0, jd_local);
if(debug_file) fprintf(debug_file, "local: %02d/%02d/%02d %02d:%02d:%02d %f\n", g_year,g_month,g_day,g_hours,g_minutes,g_seconds, g_frac);
}
}


void parse_acron_atime()
{
int doy;
int tz;
double jd;
int last_tick = 999;
   // asynchronous time request (12 byte response)
if(debug_file) fprintf(debug_file, "acron atime:%s\n", nmea_msg);

   msg_col = 0;

   get_fixed_field(2);
   hours = pri_hours = atoi(msg_field);
   get_fixed_field(2);
   minutes = pri_minutes = atoi(msg_field);
   get_fixed_field(2);
   seconds = pri_seconds = atoi(msg_field);

   get_fixed_field(3);       // day of year  (does this start a 1?)
   doy = atoi(msg_field);

   get_fixed_field(2);
   year = pri_year = atoi(msg_field) + 2000;

   get_fixed_field(1);
   tz = atoi(msg_field);

return;

   jd = jdate(year, 1, 1) + (double) (doy) - 1.0;
   jd += jtime(hours,minutes,seconds, 0.0);

   set_gregorian_time(jd);  // convert julian date to gregorian

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }
   
   if(last_tick != seconds) {
      last_tick = seconds;
      update_gps_screen(1555);
   }
}


double bearing(double lat2,double lon2, double lat1,double lon1)
{
double dLon;
double x,y;
double brng;

   lat1 *= (PI/180.0);  // convert to radians
   lat2 *= (PI/180.0);
   lon1 *= (PI/180.0);  // convert to radians
   lon2 *= (PI/180.0);
   dLon = (lon2 - lon1);

   y = sin(dLon) * cos(lat2);
   x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);

   brng = atan2(y, x) * 180.0/PI;
   if(brng < 0.0) brng += 360.0;
// brng = fmod(brng+360.0, 360.0);
// brng = 360.0 - brng; // count degrees counter-clockwise - remove to make clockwise

   return brng;
}


void parse_acron_status()
{
int status;
int quality;
int prn;
double el;
double angle;

if(debug_file) fprintf(debug_file, "acron status:%s\n", nmea_msg);
   if(nmea_msg[0] == 0) return;

   status = nmea_msg[0];
   if(status & 0x01) {  // reception attempt in progress
   }
   if(status & 0x02) {  // port P51
   }
   
   level_type = "SNR";
   if(nmea_msg[1]) {    // signal quality
      quality = nmea_msg[1];
      quality &= 0x07;  // 5=good  <3=very poor  0=between reception trys

      if     (quality == 0) quality = 0;
      else if(quality == 1) quality = 30;
      else if(quality == 2) quality = 35;
      else if(quality == 3) quality = 40;
      else if(quality == 4) quality = 45;
      else if(quality >= 5) quality = 50;
      if(quality > 50) quality = 50;

      if(lat || lon) {  // az/el is bearing to Ft Collins WWVB site
         angle = bearing(WWVB_LAT,WWVB_LON, lat*180.0/PI,lon*180.0/PI);
         el = 1.0;
      }
      else {
         angle = 1.0;
         el = 89.0;
      }

      prn = 1;    // fake single sat at az=1 el=89
      sat[prn].level_msg = 111;
      set_sat_azel(prn, (float) angle, (float) el);
      sat[prn].sig_level = (float) quality;
      if(quality > 0) sat[prn].tracking = prn;
      else            sat[prn].tracking = (-1);
      have_sat_azel = 2;
      have_snr |= rinex_gnss(prn);

      record_sig_levels(prn);

      sat_count = 1;
      config_sat_count(sat_count);
if(debug_file) fprintf(debug_file, "status:%d quality:%d\n", quality, status);
   }
}


void poll_next_acron()
{
   if(1 && (pri_seconds == SCPI_STATUS_SECOND)) { // request status
      if(need_acron_sync) {
         need_acron_sync = 0;
         send_acron_cmd("h");  // user wants a reception attempt
         if(sim_file == 0) Sleep(500);
      }

      send_acron_cmd("g");   // get receiver status
      ++pri_seconds;
      ++seconds;
   }
   else if(0 && (this_acron_cmd == 'G')) {
      send_acron_cmd("i");  // async world time / time zone info
   }
   else send_acron_cmd("o");  // time
}


void decode_acron_msg()
{
char c;
int i;

   start_msg_decode(0);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   tsip_wptr = tsip_rptr = 0;
   tsip_sync = 0;


  // get the response from the reciver and pass it to (HOPEFULLY) the routine
  // that expects it...

  strupr(nmea_msg);

if(debug_file) fprintf(debug_file, "Decode msg %c:[%s]\n", this_acron_cmd, nmea_msg);

   if     (this_acron_cmd == 'O') parse_acron_time();   // parse answer to last command we sent
   else if(this_acron_cmd == 'G') parse_acron_status(); // status
   else if(this_acron_cmd == 'I') parse_acron_atime();  // asynchronous time request (has time zone setting)

   poll_next_acron();

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_acron_message()
{
u08 c;

   // This routine buffers up an incoming ACRON ZEIT message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_acron_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   c &= 0x7F;           // remove parity bit

   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message
      tsip_sync = 1;
      get_sync_time();
      tsip_wptr = 0;
      tsip_rptr = 0;
      goto get_acron;
   }
   else if(tsip_sync == 1) { // '$' has been seen, now build the message
      get_acron:
      if(c == 0x0D) goto acron_end;  // message has no checksum

      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 3) {  // end of message
      acron_end:
      decode_acron_msg(); // process the message
      packet_end = 1;
      tsip_wptr = 0;      // prepare for next message
      tsip_sync = 0;
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
   }
}




//
//
//   GPSD receiver stuff
//
//


char json_delim;
char gpsd_cmd[NMEA_MSG_SIZE+2];


void enable_gpsd()
{
   if(gpsd_device[0]) {
      sprintf(out, "?WATCH={\"enable\":true,\"json\":true,\"pps\":true,\"devicename\":\"%s\"}", gpsd_device);
   }
   else {
      sprintf(out, "?WATCH={\"enable\":true,\"json\":true,\"pps\":true}");
   }
   send_nmea_string(out, 0);
//    send_byte(0x0D);
   eom_flag = EOM;
   send_byte(0x0A);
   eom_flag = ADD_CHAR;
}


char *get_json_field(char *s)
{
int i;
char c;
int quote;

   // gets the next item from a JSON message

   i = 0;
   msg_field[i] = 0;
   quote = 0;
   json_delim = 0;
   if(s == 0) return 0;

  
if(*s == '{') {
   ++s;
   msg_field[0] = 0;
   return s;
}
if(*s == '[') {
   ++s;
   msg_field[0] = 0;
   return s;
}
  

   while(i < (NMEA_MSG_SIZE-2)) {
      c = *s++;
      if(c == 0) return 0;

      if(quote == 0) {
         if(c == ' ') continue;    // ignore white space
         if(c == '\t') continue;
         if(c == 0x0D) continue;
         if(c == 0x0A) continue;
         if(c == '[') {
//if(*s != '{') continue;
//            continue;
         }
         if(c == ']') continue;
         if(c == '{') continue;
         if(c == '}') continue;

         if(c == ':') {
            json_delim = c;
            break;
         }
         else if(c == '}') {
            json_delim = c;
            break;
         }
         else if(c == ',') {
            json_delim = c;
            break;
         }
         else if(c == '[') {
            json_delim = c;
            break;
         }
else if(c == '{') {
   json_delim = c;
   break;
}
         else if(c == ']') {
            json_delim = c;
            break;
         }
      }

      msg_field[i++] = c;  // add char to field
      msg_field[i] = 0;

      if(c == '"') {
         if(quote) {    // end of quoted string
            quote = 0;
         }
         else {         // start of quoted string
            quote = 1;
         }
      }
   }

   if(s) strupr(s);
   return s;
}

void log_gpsd_cmd()
{
   // write debug/trace info to the debug log file

   if(debug_file == 0) return;  

   fprintf(debug_file, "%s  ", gpsd_cmd);
   fprintf(debug_file, "%s\n", msg_field);
}

char time_field[32];
int time_ptr;

void get_time_field(int n)
{
int i;

   // get a fixed length sub-field from a sting - used to decode the date/time
   // string.

   i = 0;
   while(n--) {
      time_field[i++] = msg_field[time_ptr++];
      time_field[i] = 0;
   }
}

void parse_gpsd_tpv(char *s)
{
int i;
int old_yy;
int old_mm;
int old_dd;
int old_hh;
int old_min;
int old_sec;
double old_frac;

   // decode the TPV message - used to get the time, lat, lon, and altitude
   // info.  This message is used to drive the display... without it nothing
   // gets done.


   old_yy = year;      // used to skip duplicate time stamps
   old_mm = month;
   old_dd = day;
   old_hh = hours;
   old_min = minutes;
   old_sec = seconds;
   old_frac = raw_frac;

   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"TIME\"")) {
         time_ptr = 1;

         get_time_field(4);
         year = atoi(time_field);
         get_time_field(1);

         get_time_field(2);
         month = atoi(time_field);
         get_time_field(1);

         get_time_field(2);
         day = atoi(time_field);
         get_time_field(1);        // eat the 'T'

         get_time_field(2);
         hours = atoi(time_field);
         get_time_field(1);        // eat the ':'

         get_time_field(2);
         minutes = atoi(time_field);
         get_time_field(1);        // eat the ':'

         get_time_field(2);
         seconds = atoi(time_field);
         get_time_field(1);        // eat the 'Z'

         get_time_field(4);
         raw_frac = atof(time_field);
         get_time_field(1);        // eat the ':'

         pri_year = year;
         pri_month = month;
         pri_day = day;
         pri_hours = hours;
         pri_minutes = minutes;
         pri_seconds = seconds;
         pri_frac = raw_frac;

//gggg
if(debug_file) fprintf(debug_file, "nema_field:%s\n", msg_field);
if(debug_file) fprintf(debug_file, "time:%04d-%02d-%02d  %02d:%02d:%02d %f\n", 
year,month,day, hours,minutes,seconds,raw_frac);

         time_flags |= TFLAGS_UTC;  // UTC based time
      }
      else if(!strcmp(gpsd_cmd, "\"LAT\"")) {
         lat = atof(msg_field) * PI / 180.0;
      }
      else if(!strcmp(gpsd_cmd, "\"LON\"")) {
         lon = atof(msg_field) * PI / 180.0;
      }
      else if(!strcmp(gpsd_cmd, "\"ALT\"")) {
         alt = atof(msg_field);
      }
      else if(!strcmp(gpsd_cmd, "\"TRACK\"")) {
         heading = atof(msg_field);
         have_heading = 20;
      }
      else if(!strcmp(gpsd_cmd, "\"SPEED\"")) {
         speed = atof(msg_field);
         have_speed = 20;
      }
      else if(!strcmp(gpsd_cmd, "\"MODE\"")) {
         i = atoi(msg_field);
         if     (i == 3) rcvr_mode = RCVR_MODE_3D;
         else if(i == 2) rcvr_mode = RCVR_MODE_2D;
         else if(i == 1) rcvr_mode = RCVR_MODE_ACQUIRE;
         else            rcvr_mode = RCVR_MODE_UNKNOWN;
      }
   }


   if(old_yy != year) ;            // gpsd can generate duplicate time stamps
   else if(old_mm != month) ;
   else if(old_dd != day) ;
   else if(old_hh != hours) ;
   else if(old_min != minutes) ;
   else if(old_sec != seconds) ;
   else return;

   update_gps_screen(1008);
}

void parse_gpsd_sky(char *s)
{
int saw_sats;
int prn;
float az, el;

   // decode the SKY message - used to display satellite position and signal
   // level data

   have_dops = 0;
   prn = 0;
   saw_sats = 0;
   level_type = "SNR";

   az = el = (999.0F);
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"GDOP\"")) {
         gdop = (float) atof(msg_field);
         have_dops |= GDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"HDOP\"")) {
         hdop = (float) atof(msg_field);
         have_dops |= HDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"PDOP\"")) {
         pdop = (float) atof(msg_field);
         have_dops |= PDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"TDOP\"")) {
         tdop = (float) atof(msg_field);
         have_dops |= TDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"VDOP\"")) {
         vdop = (float) atof(msg_field);
         have_dops |= VDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"XDOP\"")) {
         xdop = (float) atof(msg_field);
         have_dops |= XDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"YDOP\"")) {
         ydop = (float) atof(msg_field);
         have_dops |= YDOP;
      }
      else if(!strcmp(gpsd_cmd, "\"SATELLITES\"")) {
         saw_sats = 0;
         reset_sat_tracking();
      }
      else if(!strcmp(gpsd_cmd, "\"PRN\"")) {
         prn = atoi(msg_field);
         if(prn <= 0) prn = 0;
         else if(prn > MAX_PRN) prn = 0; 
         else ++saw_sats;
      }
      else if(!strcmp(gpsd_cmd, "\"EL\"")) {   
         el = (float) atof(msg_field);
         have_sat_azel = 21;
      }
      else if(!strcmp(gpsd_cmd, "\"AZ\"")) {
         az = (float) atoi(msg_field);
         have_sat_azel = 20;
      }
      else if(!strcmp(gpsd_cmd, "\"SS\"")) {
         sat[prn].sig_level = (float) atof(msg_field);
         sat[prn].level_msg = 55;
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);
      }
      else if(!strcmp(gpsd_cmd, "\"USED\"")) {
         if(!strcmp(msg_field, "TRUE")) sat[prn].tracking = 1;
         else                            sat[prn].tracking = (-1);
      }

   }

   if((az < 999.0F) && (el < 999.0F)) {
      set_sat_azel(prn, (float) az, (float) el);
   }

   sat_count = saw_sats;
   have_count = 7;
if(debug_file) fprintf(debug_file, "sat count:%d\n", sat_count);
   config_sat_count(saw_sats);
}

void show_gpsd_msg(char *s)
{
   // used for debug logging
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();
   }
}

void parse_gpsd_pps(char *s, int type)
{
double clock_sec, clock_nsec;
double real_sec, real_nsec;
double precision;

   // decode the PPS message - used to get info for the PPS plot

   saw_gpsd_pps |= type;
   if((saw_gpsd_pps & 0x01) && (type & 0x02)) { // pps takes priority over toff
      return;
   }
   pps_enabled = 1;
   have_pps_enable = 11;

   precision = 0;  // NTP precision
   clock_sec = real_sec = 0.0;
   clock_nsec = real_nsec = 0.0;

   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"CLOCK_SEC\"")) {
         clock_sec = atof(msg_field);
      }
      else if(!strcmp(gpsd_cmd, "\"CLOCK_NSEC\"")) { 
         clock_nsec = atof(msg_field)*1.0E-9;
      }
      else if(!strcmp(gpsd_cmd, "\"REAL_SEC\"")) { 
         real_sec = atof(msg_field);
      }
      else if(!strcmp(gpsd_cmd, "\"REAL_NSEC\"")) { 
         real_nsec = atof(msg_field)*1.0E-9;
      }
      else if(!strcmp(gpsd_cmd, "\"PRECISION\"")) { // ntp style power of two seconds
         saw_gpsd_pre = 1;
         precision = atof(msg_field);
         precision = pow(2.0, precision);
      }
   }

   pps_offset = (clock_sec - real_sec);
   have_pps_offset = 8;
   have_rcvr_pps = 8;
   pps_offset += (clock_nsec - real_nsec);
   pps_offset *= 1.0E9;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);
if(debug_file) fprintf(debug_file, "pps offset:%.10f", pps_offset);

}

void parse_gpsd_osc(char *s)
{
int saw_run;
int running;
int saw_ref;
int ref;
int saw_dis;
int dis;
int saw_pps;
double pps;

   // decode the OSC message - used to display GPSDO related info

   saw_run = saw_ref = saw_dis = saw_pps = 0;
   running = ref = dis = 0;
   pps = 0.0;
   saw_gpsdo = 1;
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"RUNNING\"")) {  // warming up
         if(!strcmp(msg_field, "TRUE")) {
            running = 1;
         }
         else {
            running = 0;
         }
         saw_run = 1;
      }
      else if(!strcmp(gpsd_cmd, "\"REFERENCE\"")) {   // pps active
         if(!strcmp(msg_field, "TRUE")) ref = 1;
         else                            ref = 0;
         saw_ref = 1;
      }
      else if(!strcmp(gpsd_cmd, "\"DISCIPLINED\"")) { // being disciplined
         if(!strcmp(msg_field, "TRUE")) dis = 1;
         else                            dis = 0;
         saw_dis = 1;
      }
      else if(!strcmp(gpsd_cmd, "\"DELTA\"")) {  // ns of err
         pps = atof(msg_field);
         osc_offset = pps;
         have_osc_offset = 8;
         have_rcvr_osc = 8;
// adadad         if(jitter_adev == 0) do_osc_adev(osc_offset);
         saw_pps = 1;
      }
   }

   if(saw_run && (running == 0))  discipline_mode = DIS_MODE_POWERUP;      // power up init
   else if(saw_dis && (dis == 0)) discipline_mode = DIS_MODE_MANUAL_HOLD;  // PPS OFF -> holdover
   else if(saw_ref && (ref == 0)) discipline_mode = DIS_MODE_RECOVERY;     // PPS OFF -> holdover
   else                           discipline_mode = DIS_MODE_NORMAL;
}

void parse_gpsd_version(char *s)
{
int i;

   // decode the VERSION message - used to display the version info

   saw_version |= 0x0200;
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"PROTO_MAJOR\"")) {
         gpsd_major = atoi(msg_field);
      }
      else if(!strcmp(gpsd_cmd, "\"PROTO_MINOR\"")) {
         gpsd_minor = atoi(msg_field);
      }
      else if(!strcmp(gpsd_cmd, "\"RELEASE\"")) {
         msg_field[17] = 0;
         gpsd_release[0] = 0;
         i = strlen(msg_field);
         if(i) {
            strcpy(gpsd_release, &msg_field[1]);
            i = strlen(gpsd_release);
            if(i) gpsd_release[i-1] = 0;
         }
         have_info |= (PRODN_PARAMS | MANUF_PARAMS);
      }
   }
}

void parse_gpsd_devices(char *s)
{
int i;

   // decode the DEVICES message - we just use the driver name field

   saw_version |= 0x0400;
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"DRIVER\"")) {
         i = strlen(msg_field);
if(debug_file) fprintf(debug_file, "driver:%s -> ", msg_field);
         if(i) msg_field[i-1] = 0;
if(debug_file) fprintf(debug_file, "%s\n", msg_field);
         show_gpsd_driver();
         have_info |= VERSION_INFO;
      }
   }
}


void parse_gpsd_att(char *s)
{
   // decode the ATT message - we just use the temperature field

   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!strcmp(gpsd_cmd, "\"TEMPERATURE\"")) {
         temperature = (float) atof(msg_field);
         have_temperature = 114;
      }
   }
}


void parse_gpsd_rtcm2(char *s)
{
   // decode the RTCM2 message - we just use the leapsecs field

   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();

      if(!user_set_utc_ofs && !strcmp(gpsd_cmd, "\"LEAPSECS\"")) {
         utc_offset = atoi(msg_field);
         check_utc_ofs(11);
      }
      else if(!strcmp(gpsd_cmd, "\"WEEK\"")) {
         gps_week = atoi(msg_field); 
         faked_tow = 0;
         if(have_week == 0) need_redraw = 2056;
         have_week = 10;
      }
   }
}


void parse_gpsd_watch(char *s)
{
   // decode the WATCH message - we just thow it away
   while(s) {
      s = get_json_field(s);
      strcpy(gpsd_cmd, msg_field);
      if(gpsd_cmd[0] == 0) continue; 

      s = get_json_field(s);
log_gpsd_cmd();
   }
}


void decode_gpsd_msg()
{
char *s;

   // this routine looks at the GPSD message header and dispatches a call to
   // decode the data in the message and act on it.
   start_msg_decode(1); // gggggg
   
   s = strstr((char *) tsip_buf, "\"class\":");
   if(s == 0) return;

   s = get_json_field(s);     // get the class keyword
   if(json_delim != ':') return;  // no class
   s = get_json_field(s);     // get the message type

   strupr(msg_field);
if(debug_file) fprintf(debug_file, "\n\nMessage: %s (%c)\n\n", msg_field, json_delim);
   if     (!strcmp(msg_field, "\"TPV\""))     parse_gpsd_tpv(s);
   else if(!strcmp(msg_field, "\"SKY\""))     parse_gpsd_sky(s);
   else if(!strcmp(msg_field, "\"PPS\""))     parse_gpsd_pps(s, 0x01);
   else if(!strcmp(msg_field, "\"TOFF\""))    parse_gpsd_pps(s, 0x02);
   else if(!strcmp(msg_field, "\"OSC\""))     parse_gpsd_osc(s);
   else if(!strcmp(msg_field, "\"ATT\""))     parse_gpsd_att(s);
   else if(!strcmp(msg_field, "\"RTCM2\""))   parse_gpsd_rtcm2(s);
   else if(!strcmp(msg_field, "\"VERSION\"")) parse_gpsd_version(s);
   else if(!strcmp(msg_field, "\"DEVICES\"")) parse_gpsd_devices(s);
   else if(!strcmp(msg_field, "\"DEVICE\""))  parse_gpsd_devices(s);
   else if(!strcmp(msg_field, "\"WATCH\""))   parse_gpsd_watch(s);
   else                                       show_gpsd_msg(s);

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


#define MAX_GPSD_LEN 1536

void get_gpsd_message()
{
u08 c;
static int paren_level = 0;

   // This routine buffers up an incoming GPSD JSON message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_gpsd_msg()

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {    // syncing to start of message, search for a '{'
      tsip_rptr = 0;
      tsip_wptr = 0;
      tsip_buf[tsip_wptr] = 0;
      if(c == '{') {
         get_sync_time();
         ++tsip_sync;
         tsip_buf[tsip_wptr++] = (u08) c;
         tsip_buf[tsip_wptr] = 0;
         paren_level = 1;
      }
      return;
   }
   else if(tsip_sync == 1) { // '"' has been seen
      if(c == '"') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 2) { // 'c' has been seen
      if(c == 'c') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 3) { // 'l' has been seen
      if(c == 'l') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 4) { // 'a' has been seen
      if(c == 'a') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 5) { // 's' has been seen
      if(c == 's') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 6) { // 's' has been seen - time to start building the full message
      if(c == 's') ++tsip_sync; 
      else goto rst_msg;
      tsip_buf[tsip_wptr++] = (u08) c;
      tsip_buf[tsip_wptr] = 0;
   }
   else if(tsip_sync == 7) {  // adding chars to the message
      if(tsip_wptr > MAX_GPSD_LEN) goto rst_msg; // message too long (max JSON is 1536 chars)
      if((c == 0x0D) || (c == 0x0A)) {
         decode_gpsd_msg();
         packet_end = 1;
         tsip_wptr = 0;     // prepare for next message
         tsip_sync = 0;
      }
      else {
         tsip_buf[tsip_wptr++] = (u08) c;
         tsip_buf[tsip_wptr] = 0;
      }
   }
   else {     // should never happen, prepare for next message
      rst_msg:
      tsip_wptr = 0;
      tsip_sync = 0;
      paren_level = 0;
   }
}



//
//
//  NVS receiver stuff
//
//

void parse_nvs_speed()
{
   log_packet_id("nvs_speed");

   heading = tsip_single();
   speed = tsip_single() * 0.2777778; // km/hr -> m/sec
   tsip_dword();  // time stamp

   have_heading = 12;
   have_speed = 12;
}

void parse_nvs_test()
{
u08 subcode;
   // 0x43 packet

   log_packet_id("nvs_test");
   subcode = tsip_byte();
   if(subcode == 2) {
      nvs_test = tsip_byte();
      tsip_dword();

      minor_alarms &= (~MINOR_ANT_NO_PWR);
      if((nvs_test & 0xC0) == 0xC0) minor_alarms |= MINOR_ANT_SHORT; // short
      else if((nvs_test & 0xC0) == 0x80) minor_alarms |= MINOR_ANT_OPEN; // open
      else if((nvs_test & 0xC0) == 0x00) ; // OK
      else minor_alarms |= MINOR_ANT_NO_PWR; // unknown
      have_antenna = 1;

      if(!have_critical_alarms) need_redraw = 7709;
      have_critical_alarms = 9;

      if(nvs_test & 0x30) {  // gps(0x10) / glonass(0x20) failure
         critical_alarms |= CRIT_GPS;
      }
      else {
         critical_alarms &= (~CRIT_GPS);
      }
   }
}


void parse_nvs_date()
{
u32 tow;
u08 dd,mm;
u16 yy;
u08 tz_hh,tz_mm;
double delta;

   // 0x46 packet
   log_packet_id("nvs_date");

   tow = tsip_dword();
   dd = tsip_byte();
   mm = tsip_byte();
   yy = tsip_word();
   tz_hh = tsip_byte();
   tz_mm = tsip_byte();

   delta = nvs_msecs - ((double)tow*1000.0);

//sprintf(debug_text2, "%04d/%02d/%02d  tz:%02d:%02d  tow:%d  msecs:%f  delta:%f", 
//yy,mm,dd, tz_hh,tz_mm, tow,nvs_msecs, delta);
}

void parse_nvs_disable()
{
int i;
u08 sys;
int prn;
u08 flag;

   // 0x47 packet
   log_packet_id("nvs_disable");

   for(i=0; i<32+24; i++) {
      sys = tsip_byte();
      prn = tsip_byte();
      flag = tsip_byte();

      if(sys == 1) ;
      else if(sys == 2) prn += NVS_GLONASS_PRN;
      else continue;

      if(flag == 1) ;     // enabled
      else if(flag == 2); // disabled
      else continue;

      if((prn >= 1) && (prn <= MAX_PRN)) {
         flag -= 1;
         sat[prn].disabled = flag;
         if(prn <= 32) {  // gps sats
            if(flag) sats_enabled &= (~(1 << (prn-1)));
            else     sats_enabled |= (1 << (prn-1));
         }
      }
   }
}

void parse_nvs_iono()
{
float a0,a1,a2,a3;
float b0,b1,b2,b3;
u08 reliability;

   log_packet_id("nvs_iono");

   // 0x4A packet - ionosphere data
   a0 = tsip_single();
   a1 = tsip_single();
   a2 = tsip_single();
   a3 = tsip_single();
   b0 = tsip_single();
   b1 = tsip_single();
   b2 = tsip_single();
   b3 = tsip_single();
   reliability = tsip_byte();
}

void parse_nvs_gnss_timescale()
{
double a0, a1;
int tow;
int wnt;
int ls;
int wnf;
int dn;
int lsf;
int this_dn;
int wraps;

   log_packet_id("nvs_timescale");

   // 0x4B packet - calculate pending leapsecond info
   a1 = tsip_double();
   a0 = tsip_double();
   tow = tsip_dword();

   wnt = tsip_word();
   ls = (int) (s16) tsip_word();
   wnf = tsip_word();  // gps week
   dn = tsip_word();
   lsf = (int) (s16) tsip_word();

   this_dn = tow / (24*60*60);
   wraps = gps_week / 1024;
///sprintf(debug_text, "gps_week:%d wraps:%d wnt:%d ls:%d wnf:%d dn:%d lsf:%d this_dn:%d", 
///gps_week, wraps, wnt, ls, wnf, dn, lsf, this_dn);
// wnf += (wraps * 1024);

   // we ignore the rest of this message

   minor_alarms &= (~MINOR_LEAP_PEND);
   leap_days = (-1);
   have_leap_days = 0;
   if(ls != lsf) {
      minor_alarms |= MINOR_LEAP_PEND;
      calc_leap_days(wnf+(gps_week/256)*256, dn, 555);
      have_leap_info = 22;
   }
   have_leap_info = 22;
}

void parse_nvs_config()
{
u08 nav_sys;

   // 0x51 packet
   log_packet_id("nvs_config");

   nav_sys = tsip_byte();
   tsip_byte();    // rsvd
   tsip_byte();    // coord sys
   el_mask = (float) (s08) tsip_byte();
   amu_mask = (float) tsip_byte();
   tsip_word();    // max rms error
   nvs_filter = tsip_single();  // filtration degree

   have_el_mask = 1;
   have_amu = 1;

   // nav system:
   //  0=GPS+GLONASS
   //  1=GPS
   //  2=GLONASS
   //  3=Galileo
   // 10=GPS+GLONASS+SBAS
   // 11=GPS+SBAS
   // 12=GLONASS+SBAS
   have_gnss_mask = 3;
   if     (nav_sys == 0)  gnss_mask = (GPS | GLONASS);
   else if(nav_sys == 1)  gnss_mask = (GPS);
   else if(nav_sys == 2)  gnss_mask = (GLONASS);
   else if(nav_sys == 3)  gnss_mask = (GALILEO);
   else if(nav_sys == 10) gnss_mask = (GPS | GLONASS | SBAS);
   else if(nav_sys == 11) gnss_mask = (GPS | SBAS);
   else if(nav_sys == 12) gnss_mask = (GLONASS | SBAS);
   else if(nav_sys == 13) gnss_mask = (GALILEO | SBAS);
   else have_gnss_mask = 0;
// sprintf(plot_title, "nav sys:%d", nav_sys); //qqqqqqqqq
}


void parse_nvs_sats()
{
u08 sat_sys;
int prn;
u08 slot;
u08 el;
s16 az;
u08 snr;

   // 0x52 packet
   log_packet_id("nvs_sats");

   for(prn=1; prn<=MAX_PRN; prn++) {  // reset tracking info
      sat[prn].level_msg = 0;
      sat[prn].tracking = 0;
   }

   sat_count = 0;
   while(tsip_rptr < (tsip_wptr-0)) {
      sat_sys = tsip_byte();
      prn = (int) tsip_byte();
      slot = tsip_byte();
      el = tsip_byte();
      az = (s16) tsip_word();
      snr = tsip_byte();

      if(sat_sys == 2) prn += NVS_GLONASS_PRN;

      if((prn >= 1) && (prn <= MAX_PRN)) {
         sat[prn].level_msg = 77;
         if(snr) sat[prn].tracking = 1;
         else    sat[prn].tracking = (-1);
         sat[prn].sig_level = (float) snr;
         set_sat_azel(prn, (float) az, (float) el);
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);
         ++sat_count;
         have_count = 222;
      }
   }

   level_type = "SNR";
   config_sat_count(sat_count); 
}


void parse_nvs_mode()
{
u08 mode;
double delay;
int avg_time;

   // 0x55 packet
   log_packet_id("nvs_mode");

   mode = tsip_byte();
   delay = tsip_double();
   avg_time = (int) tsip_word();

   if(mode == 0) {
      if(nvs_traim & 0x04) rcvr_mode = RCVR_MODE_3D;
      else                 rcvr_mode = RCVR_MODE_2D_3D;
   }
   else if(mode == 1) rcvr_mode = RCVR_MODE_HOLD;
   else if(mode == 2) rcvr_mode = RCVR_MODE_SURVEY;
   else               rcvr_mode = RCVR_MODE_UNKNOWN;

   if(mode == 2) {
      minor_alarms |= MINOR_SURVEY;
      do_survey = avg_time;
      survey_why = 33;
   }
   else {
      minor_alarms &= (~MINOR_SURVEY);
      if(precision_survey == 0) {
         do_survey = 0;
         survey_why = (-333);
      }
   }
}


void parse_nvs_dops()
{
int gps_count;
int glonass_count;

   // 0x60 packet
   log_packet_id("nvs_dops");

   gps_count = tsip_byte();
   glonass_count = tsip_byte();
   hdop = tsip_single();
   vdop = tsip_single();
   have_dops |= (HDOP | VDOP);
}


void parse_nvs_pvtdops()
{
   // 0x61 packet
   log_packet_id("nvs_pvtdops");

   hdop = tsip_single();
   vdop = tsip_single();
   tdop = tsip_single();
   // we ignore the rest of this message
   have_dops |= (HDOP | VDOP | TDOP);
}


void parse_nvs_version()
{
int i;

   // 0x70 packet
   log_packet_id("nvs_version");

   nvs_chans = tsip_byte();
   for(i=0; i<21; i++) {  // version string
      nvs_id[i] = tsip_byte();
      nvs_id[i+1] = 0;
   }
   nvs_sn = tsip_dword();

   for(i=0; i<21; i++) {  // version string
      nvs_id2[i] = tsip_byte();
      nvs_id2[i+1] = 0;
   }
   nvs_sn2 = tsip_dword();

   for(i=0; i<21; i++) {  // version string
      nvs_id3[i] = tsip_byte();
      nvs_id3[i+1] = 0;
   }
   nvs_sn3 = tsip_dword();

   saw_version |= 0x2000;
   have_info |= ALL_ID_INFO;

   // we ignore the rest of this message
}



void parse_nvs_time()
{
double msecs;
u08 scale;
int week;
int i;
double gen_dev;
double time_dev;

   // 0x72 packet
   log_packet_id("nvs_time");

   nvs_msecs = msecs = tsip_fp80(); //  - 67108864.0;  // qqqqqqqqqqqqqq - 67....
   week = (int) (s16) tsip_word();
   scale = tsip_byte();
   gen_dev = tsip_double();   // ref gen deviation
   time_dev = tsip_double();  // sawtooth
   i = (int) (s16) tsip_word();
   if(!user_set_utc_ofs) {
      utc_offset = i;
      check_utc_ofs(12);
   }

   tsip_byte();
   tsip_word();

   dac_voltage = (float) time_dev;
   have_sawtooth = 6666;
}


void parse_nvs_survey()
{
u08 mode;
double delay;
int avg_time;

   // 0x73 packet
   log_packet_id("nvs_survey");

   mode = tsip_byte();
   delay = tsip_double();
   avg_time = (int) tsip_word();

   if(mode == 0) {
      if(nvs_traim & 0x04) rcvr_mode = RCVR_MODE_3D;
      else                 rcvr_mode = RCVR_MODE_2D_3D;
   }
   else if(mode == 1) rcvr_mode = RCVR_MODE_HOLD;
   else if(mode == 2) rcvr_mode = RCVR_MODE_SURVEY;
   else               rcvr_mode = RCVR_MODE_UNKNOWN;

   if(mode == 2) {
      minor_alarms |= MINOR_SURVEY;
      do_survey = avg_time;
      survey_why = 33;
   }
   else {
      minor_alarms &= (~MINOR_SURVEY);
      if(precision_survey == 0) {
         do_survey = 0;
         survey_why = (-334);
      }
   }
}



void parse_nvs_timescale()
{
double scale_shift;
u08 flags;
int gps_flags;
int glo_flags;

   // !!!! qqqqq do we need anything from here?
   // 0x74 packet
   log_packet_id("nvs_timescale");

   scale_shift = tsip_fp80();
   tsip_fp80();
   tsip_fp80();
   tsip_fp80();
   tsip_fp80();
   flags = tsip_byte();

   gps_flags = glo_flags = TFLAGS_NULL;
   if(!have_gnss_mask) {
      gps_flags |= TFLAGS_INVALID;
      glo_flags |= TFLAGS_INVALID;
   }

   if(time_flags & TFLAGS_UTC) {  // UTC time
      if(gnss_mask & GPS) {
         if((flags & 0x04) == 0) gps_flags |= TFLAGS_INVALID;
      }
      if(gnss_mask & GLONASS) {
         if((flags & 0x08) == 0) glo_flags |= TFLAGS_INVALID;
      }
   }
   else { // GPS time
      if(gnss_mask & GPS) {
         if((flags & 0x01) == 0) gps_flags |= TFLAGS_INVALID;
      }
      if(gnss_mask & GLONASS) {
         if((flags & 0x02) == 0) glo_flags |= TFLAGS_INVALID;
      }
   }
   if((gnss_mask & GPS) && (gnss_mask & GLONASS)) {  // see if we have valid time from at least one system
      if(gps_flags == 0) glo_flags = TFLAGS_NULL;  // we have GPS time
      if(glo_flags == 0) gps_flags = TFLAGS_NULL;  // we have GLONASS time
   }


   time_flags &= (~TFLAGS_INVALID);
   time_flags |= (gps_flags | glo_flags);
//sprintf(plot_title, "shift:%.10f  flags:%02X  tflags:%04X  gnss:%04X  have_utc:%d", 
//scale_shift, flags, time_flags, gnss_mask, have_utc_ofs);
}

int fix_nvs_week(int week)
{
   // adjust week for rollover

   week += 1024;
   if(year > 2019) week += 1024;
   else if(year == 2019) {
      if(month > 4) week += 1024;
      else if((month == 4) && (day >= 6)) week += 1024;
   }

   return week;
}

void parse_nvs_pvt()
{
u08 status;
double msecs;
int week;
double lat_speed;
double lon_speed;
double alt_speed;
double gen_dev;
double jd;

   // 0x88 packet
   log_packet_id("nvs_pvt");

   lat = tsip_double();
   lon = tsip_double();
   alt = tsip_double();

   tsip_single(); // RMS posn err
   msecs = tsip_fp80();       // time stamp msecs
   week = tsip_word();        // gps week
   lat_speed = tsip_double(); // lat speed
   lon_speed = tsip_double(); // lon speed
   alt_speed = tsip_double(); // alt speed
   gen_dev = (double) tsip_single(); // ref gen deviation (msecs/sec)
   status = tsip_byte();  // !!!! has 2D flag qqqqqq

   pps_offset = gen_dev * 1.0E6; 
   have_pps_offset = 2;
   have_rcvr_pps = 2;
   faked_tow = 0;
//adadad   if(jitter_adev == 0) do_pps_adev(pps_offset);

   if(week >= 0) {
      gps_week = fix_nvs_week(week);
      if(have_week == 0) need_redraw = 2007;
      have_week = 222;
   }

   pri_tow = tow = this_tow = (int) (msecs / 1000.0);
   if(have_tow == 0) need_redraw = 2008;
   have_tow = 222;
   survey_tow = tow;


   jd = msecs / 1000.0;
   
   jd /= (24.0*60.0*60.0);
   jd += jdate(1999,8,22);
   jd += (week * 7.0);

   set_gregorian_time(jd);

   if(timing_mode == TMODE_GPS) {  // we want UTC time - convert gps time to utc
      utc_to_gps();
   }

   update_gps_screen(1222); 
}


void parse_nvs_used()
{
   // !!!! qqqqq do we need anything from here?
   // 0x93 packet
   log_packet_id("nvs_used");
}


void parse_nvs_rcvr_config()
{
u08 sub_code;
u16 flags;
u08 keep;
u08 scale;
float rate;

   // 0xE7 packet

   sub_code = tsip_byte();
   if(sub_code == 0x02) {
      log_packet_id("nav rate");
      rate = (float) tsip_byte();
      if(!pause_data) {
         nav_rate = rate;
         have_nav_rate = 3;
      }
   }
   else if(sub_code == 0x04) {  // solution filtration factor
      log_packet_id("solution filtration");
      nvs_filter = tsip_single();
   }
   else if(sub_code == 0x05) {  // pps info
      log_packet_id("pps info");
      flags = tsip_byte();
      keep = tsip_byte();
      nvs_pps_width = tsip_dword();

      if(flags & 0x08) pps_polarity = 0; // positive
      else             pps_polarity = 1; // inverted
      have_pps_polarity = 1;
      have_pps_freq = 0x01;

      if(nvs_pps_width) {
         last_nvs_pps_width = nvs_pps_width;
         pps_enabled = 1;
      }
      else pps_enabled = 0;
      have_pps_enable = 20;

      scale = flags & 0xF0;
      if((scale == 0x10) || (scale == 0x20)) {  // GPS/GLONASS time
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else if((scale == 0x30) || (scale == 0x40)) {  // UTC
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
      have_rcvr_tmode = 1;
//sprintf(plot_title, "pps flags:%02X  keep:%02X  width:%d", flags,keep,nvs_pps_width);  // qqqqqqqqqqqqqq
   }
   else if(sub_code == 0x06) {  // cable delay
      log_packet_id("cable delay");
      cable_delay = tsip_double() / 1.0E6;
//    if(have_cable_delay == 0) need_redraw = 2237;
      have_cable_delay = 1;
   }
   else if(sub_code == 0x07) {  // TRAIM mode, 2D OK, single sat OK
      log_packet_id("traim mode");
      flags = tsip_word();
      nvs_traim = flags;
      traim_mode = flags & 0x03;
      have_traim = 1;
   }
   else {
      log_packet_id("unsupported config subcode");
   }
}


void parse_nvs_raw()
{
double tow;
int week;
double gps_shift;
double glonass_shift;
int corr;
u08 type;
int prn;
u08 glonass_carrier;
u08 snr;
double phase;
double range;
double doppler;
u08 flags;
u08 rsvd;
int lli;
int xtow;
double meas_tow;

   // 0xF5 packet
   log_packet_id("nvs_raw");

   tow = tsip_double() / 1000.0;   // in seconds
   week = tsip_word();
   week = fix_nvs_week(week); 

   meas_tow = ((double) tow);         // this is in UTC... bastards!!!
   meas_tow += (double) utc_offset;   // convert to GPS time
   xtow = (int) (meas_tow*nav_rate+0.01);  // raw Hz //rtk3   raw Hz

   if(1) {  // this might cause time stamp faults in CSRS-PPP  rnx3
      if(xtow % (int) ((double)raw_msg_rate*nav_rate)) return;

      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }
   else {
      obs_tow = meas_tow;
      jd_obs = GPS_EPOCH + ((double) week * 7.0) + jtime(0,0,0,meas_tow);
   }

   gps_shift = tsip_double();
   glonass_shift = tsip_double();
   corr = (int) (s08) tsip_byte();

   while(tsip_rptr < tsip_wptr) {
      type = tsip_byte();
      prn = tsip_byte();
      glonass_carrier = tsip_byte();
      snr = tsip_byte();
      phase = tsip_double();
      range = tsip_double();    // msecs
      doppler = tsip_double();
      flags = tsip_byte();
      rsvd = tsip_byte();

      if(type == 0x01) prn += NVS_GLONASS_PRN;
      else if(type == 0x02) prn += 0;
      else {
         continue;
      }
      if(prn < 0) continue;
      if(prn > MAX_PRN) continue;

      range /= 1000.0;  // pseudorange now in seconds
      range *= (LIGHTSPEED*1000.0);  // now in meters

      sat[prn].code_phase = phase;
      sat[prn].doppler = doppler;
      sat[prn].range = range;

      lli = 0x00;
      if((flags & 0x01) == 0) lli |= 0x80;  // no gignal
      if((flags & 0x02) == 0) lli |= 0x80;  // no doppler/pseudorange
      if((flags & 0x08) == 0) lli |= 0x80;  // no carrier phase

      sat[prn].ca_lli = lli;
      sat[prn].l1_lli = 0;
      sat[prn].l2_lli = 0;

      if(doppler) {
         have_doppler |= rinex_gnss(prn);
      }
      if(phase) {
         have_phase |= rinex_gnss(prn); 
      }
      if(range) {
         have_range |= rinex_gnss(prn); 
      }
   }
}

void parse_nvs_ephem()
{
   // 0xF5 packet  // !!!! requested by 0xF4, we need to parse this out
   log_packet_id("nvs_ephem");
}


void decode_nvs_message()
{
u08 id;

   flush_debug();

   msg_fault = 0x00;
   tsip_rptr = 0;
   id = get_next_tsip();

   subcode = 0x00;
   first_msg = 0;
   last_msg = msg_id;
   ++wakeup_tsip_msg; // we have seen a TSIP message
   tsip_error = 0;    // this flag gets set if we see something wrong in a message
   early_end = 0;
   new_packet(0);

   if     (id == 0x41) parse_nvs_speed();
   else if(id == 0x43) parse_nvs_test();
   else if(id == 0x46) parse_nvs_date();
   else if(id == 0x47) parse_nvs_disable();
   else if(id == 0x4A) parse_nvs_iono();
   else if(id == 0x4B) parse_nvs_gnss_timescale();
   else if(id == 0x51) parse_nvs_config();
   else if(id == 0x52) parse_nvs_sats();
   else if(id == 0x55) parse_nvs_mode();
   else if(id == 0x60) parse_nvs_dops();
   else if(id == 0x61) parse_nvs_pvtdops();
   else if(id == 0x70) parse_nvs_version();
   else if(id == 0x72) parse_nvs_time();
   else if(id == 0x73) parse_nvs_survey();
   else if(id == 0x74) parse_nvs_timescale();
   else if(id == 0x88) parse_nvs_pvt();
   else if(id == 0x93) parse_nvs_used();
   else if(id == 0xE7) parse_nvs_rcvr_config();
   else if(id == 0xF5) parse_nvs_raw();
   else if(id == 0xF7) parse_nvs_ephem();

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_nvs_message()
{
u08 c;

   // this routine buffers up an incoming TSIP message and then parses it
   // when it is complete.

   if(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
      check_com_timer(RCVR_PORT);
      return;
   }
   else {
      reset_com_timer(RCVR_PORT);
   }

   c = get_com_char();
   if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
      com[RCVR_PORT].rcv_error = 0;
//!!!!!qqqq    goto rst_msg;
   }

   if(tsip_sync == 0) {         // syncing to start of message, search for a DLE
      if(c == DLE) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      nvs_rx_crc = 0;
      return;
   }
   else if(tsip_sync == 1) {    // DLE had been seen, now checking next byte
      if(c == DLE) {            // DLE DLE is a 0x10 data byte
         goto rst_msg;
      }
      else if(c == ETX) {       // DLE ETX is end-of-message
         goto rst_msg;          // ... should never happen here
      }
      else {                    // DLE xx is message start
         tsip_sync = 2;         // ... so accumulate the message
         if(tsip_wptr < MAX_TSIP) {
            tsip_buf[tsip_wptr++] = c;
            nvs_rx_crc = calc_nvs_crc(nvs_rx_crc, c);
         }
         else {                 // buffer overlow
            tsip_error |= OVFL_ERROR;
            goto rst_msg;
         }
      }
   }
   else if(tsip_sync == 2) {    // buffer up the message
      if(c == DLE) tsip_sync = 3;
      else if(tsip_wptr < MAX_TSIP) {
         nvs_rx_crc = calc_nvs_crc(nvs_rx_crc, c);
         tsip_buf[tsip_wptr++] = c;
      }
      else {
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else if(tsip_sync == 3) {   // last char was a DLE
      if(c == ETX) {           // DLE ETX is end-of-message
         decode_nvs_message(); // so process the buffered message
         packet_end = 1;

         rst_msg:
         tsip_wptr = 0;
         tsip_sync = 0;
      }
      else if(c == 0xFF) {   // DLE 0xFF is start of CRC
         tsip_sync = 4;
      }
      else {                   // DLE DLE is a DLE data byte and DLE xx is message ID
         nvs_rx_crc = calc_nvs_crc(nvs_rx_crc, DLE);
         nvs_rx_crc = calc_nvs_crc(nvs_rx_crc, c);
         if(tsip_wptr < MAX_TSIP) {  // so add it to the message buffer
            tsip_buf[tsip_wptr++] = c;
         }
         else {
            tsip_error |= OVFL_ERROR;
            goto rst_msg;
         }
         tsip_sync = 2;
      }
   }
   else if(tsip_sync == 4) {  // first byte of message CRC
      nvs_msg_crc = c;
      ++tsip_sync;
   }
   else if(tsip_sync == 5) {  // second byte of message CRC
      nvs_msg_crc = (c * 256) + nvs_msg_crc;
      if(nvs_msg_crc == nvs_rx_crc) {
         decode_nvs_message();
         packet_end = 1;
      }
      else {
         tsip_error |= CKSUM_ERROR;
      }
      goto rst_msg;
   }
   else {     // should never happen
      goto rst_msg;
   }
}


//
//
//  Zyfer Nanosync 380 stuff
//
//

void send_zyfer_cmd(char *s)
{
   if(s == 0) return;

   send_nmea_cmd(&s[1]);
}

void parse_zy_antd()
{
   // cable delay
   log_packet_id("cable delay");

   if(get_msg_field()) {
      cable_delay = atof(msg_field) / 1.0E9;
      have_cable_delay = 62;
   }
}

void parse_zy_alrm()
{
int val;
int survey;

   // alarms
   log_packet_id("alarms");

   if(get_msg_field()) {
      val = atohex(msg_field);
      survey = (minor_alarms & (~MINOR_SURVEY));
      minor_alarms = 0x0000;
      critical_alarms = 0x0000;

      if(val & 0x0100) minor_alarms |= MINOR_OSC_AGE;
      if(val & 0x0200) critical_alarms |= CRIT_OCXO;
      if(val & 0x0010) critical_alarms |= CRIT_FPGA;
      if(val & 0x0020) minor_alarms |= MINOR_EEPROM;
      if(val & 0x0040) critical_alarms |= CRIT_GPS;
      if(val & 0x0080) minor_alarms |= MINOR_OSC_AGE;
      if(val & 0x0001) minor_alarms |= MINOR_NO_TRACK;
      if(val & 0x0002) minor_alarms |= (MINOR_ANT_NO_PWR);
      if(val & 0x0004) minor_alarms |= MINOR_OSC_CTRL;   // !!!!! TFOM
      if(val & 0x0008) critical_alarms |= CRIT_RAM;
      minor_alarms |= survey;
      have_antenna = 1;
   }
}

void parse_zy_azel()
{
int prn;
double az,el;

   // satellite positions
   log_packet_id("sat info");

   reset_sat_tracking();

   while(1) {
      if(get_msg_field()) prn = atoi(msg_field);
      else break;

      if(get_msg_field()) el = atof(msg_field);
      else break;

      if(get_msg_field()) az = atof(msg_field);
      else break;

      if((prn >= 1) && (prn <= 32)) { 
         set_sat_azel(prn, (float) az, (float) el);
         if(az && el && sat[prn].sig_level) {
            sat[prn].level_msg = 52;
            sat[prn].visible = 1;
            have_snr |= rinex_gnss(prn);
         }
         else sat[prn].visible = 0;

         if(az && el) sat[prn].tracking = prn;
         else         sat[prn].tracking = (-1);
         have_sat_azel = 2;
         level_type = "dBc";
      }
   }
}


void parse_zy_sigq()
{
int prn;
double snr;
int mode;

   // signal quality
   log_packet_id("signal quality");

   while(1) {
      if(get_msg_field()) prn = atoi(msg_field);
      else break;

      if(get_msg_field()) snr = (atof(msg_field) * 2.500) + 25.0;
      else break;

      if(get_msg_field()) mode = atoi(msg_field);
      else break;

      if((prn >= 1) && (prn <= 32)) { 
         sat[prn].sig_level = (float) snr;
         record_sig_levels(prn);
      }
   }
}

void parse_zy_dacv()
{
double val;

   // dac voltage
   log_packet_id("dac voltage");

   if(get_msg_field()) {
      val = atof(msg_field);
      dac_voltage = (DATA_SIZE) (((val - 32768.0) / 32768.0) * 100.0);
      have_dac = 62;
   }
}

void parse_zy_drft()
{
   // osc drift
   log_packet_id("osc drift");

   if(get_msg_field()) {
      zyfer_drift = (DATA_SIZE) (atof(msg_field)*1.0E9);
      have_zyfer_drift = 1;
   }
}

void parse_zy_efer()
{
double efer;

   // osc freq error
   log_packet_id("freq error");

   if(get_msg_field()) {
      efer = atof(msg_field);
      osc_offset = (DATA_SIZE) ((efer * 1.0E9)*1000.0);
      have_osc_offset = 66;
      have_rcvr_osc = 66;
   }
}

void parse_zy_essd()
{
   // estimator of tdev
   log_packet_id("tdev estimate");

   if(get_msg_field()) {
      zyfer_tdev = (DATA_SIZE) (atof(msg_field)*1.0E9);
      have_zyfer_tdev = 1;
   }
}

void parse_zy_essn()
{
   // undocumented - incrementing counter
   log_packet_id("essn");

   if(get_msg_field()) {
      zyfer_essn = (DATA_SIZE) atof(msg_field);
      have_zyfer_essn = 1;
   }
}

void parse_zy_estp()
{
double estp;

   // undocumented
   log_packet_id("estp");

   if(get_msg_field()) {
      estp = atof(msg_field)*1.0E9;
   }
}

void parse_zy_fsel()
{
int rate;

   // PPS pulse freq
   log_packet_id("pps freq");

   if(get_msg_field()) {
      rate = atoi(msg_field);
   }
}

void parse_zy_gdop()
{
   // undocumented GDOP command
   log_packet_id("gdop");

   if(get_msg_field()) {
      gdop = (DATA_SIZE) atof(msg_field);
      have_dops |= GDOP;
   }
}

void parse_zy_hefe()
{

   // undocumented (holdover estimated freq error?)
   log_packet_id("holdover freq error");

   if(get_msg_field()) {
      zyfer_hefe = atof(msg_field)*1.0E9;
      have_zyfer_hefe = 1;
   }
}

void parse_zy_hest()
{
   // undocumented (holdover estimated ?) 
   log_packet_id("hest");

   if(get_msg_field()) {
      zyfer_hest = atof(msg_field)*1.0E6;
   }
}

void parse_zy_hete()
{
   // undocumented  (holdover estimated time error?)
   log_packet_id("holdover estimated time error");

   if(get_msg_field()) {
      zyfer_hete = atof(msg_field)*1.0E9;
   }
}

void parse_zy_hint()
{
   // holdover integrity
   log_packet_id("holdover integrity");

   zy_hflag = 2;
   zy_pll_bad = zy_gps_bad = zy_fix_bad = zy_bias_bad = (2);

   if(get_msg_field()) zy_hflag = atoi(msg_field);

   if(get_msg_field()) zy_pll_bad = atoi(msg_field);  // holdover reason
   if(get_msg_field()) zy_gps_bad = atoi(msg_field);
   if(get_msg_field()) zy_fix_bad = atoi(msg_field);
   if(get_msg_field()) zy_bias_bad = atoi(msg_field);

   have_zyfer_hint = 1;
   have_gps_status = 0;
}

void parse_zy_leap()
{
int p, f;

   // utc and leapsecond info
   log_packet_id("leapsecond info");

   p = f = 0;
   if(get_msg_field()) p = atoi(msg_field);
   if(get_msg_field()) f = atoi(msg_field);

   if(p) {
      if(!user_set_utc_ofs) utc_offset = p;
      check_utc_ofs(33);
   }

   minor_alarms &= (~MINOR_LEAP_PEND);
   if(p != f) {  // leap pending
      minor_alarms |= MINOR_LEAP_PEND;
   }
   have_leap_info = 33;
}

void parse_zy_mang()
{
double el_val;

   // elevation mask
   log_packet_id("elevation mask");

   if(get_msg_field()) {
      el_val = atof(msg_field);
      if((el_val >= 0.0) && (el_val <= 90.0)) {
         el_mask = (float) el_val;
         have_el_mask = 1;
      }
   }
}

void parse_zy_ntlc()
{
u32 val;
   // not time locked (holdover) count
   log_packet_id("not time locked");

   if(get_msg_field()) {
      val = (u32) atoi(msg_field);
      if(val) holdover = val;
   }
}

void parse_zy_ofst()
{
   // PPS output delay
   log_packet_id("pps delay");

   if(get_msg_field()) {  // PPS output delay
      pps1_delay = atof(msg_field) / 1.0E9;
      have_pps_delay |= 0x01;
   }
}

void parse_zy_pavg()
{
double val;

   // position averaging
   log_packet_id("position averaging");

   val = 0.0;
   if(get_msg_field()) val = atof(msg_field);
   else return;

   if(get_msg_field()) val += atof(msg_field)/ 60.0;
   else return;

   if(get_msg_field()) {
      if(msg_field[0] == 'N') ;
      else if(msg_field[0] == 'S') val = 0.0 - val;
      else return;
      lat = val * PI / 180.0;
   }
   else return;

   val = 0.0;
   if(get_msg_field()) val = atof(msg_field);
   else return;

   if(get_msg_field()) val += atof(msg_field)/ 60.0;
   else return;

   if(get_msg_field()) {
      if(msg_field[0] == 'E') ;
      else if(msg_field[0] == 'W') val = 0.0 - val;
      else return;
      lon = val * PI / 180.0;
   }
   else return;

   if(get_msg_field()) {
      alt = atof(msg_field);
   }
   else return;

   if(get_msg_field()) {  // averaging count
      val = atoi(msg_field);
      survey_progress = (int) (val / 3600.0 * 100.0);
      have_progress = 8;
   }
}

void parse_zy_vers()
{
   // version info
   log_packet_id("version info");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_app_vers, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_app_date, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_gps, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_app_prog, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_option, msg_field);
   }

   have_info |= VERSION_INFO;
}

void parse_zy_mani()
{
   // mfg info
   log_packet_id("mfg info");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_mfgid, msg_field);
   }

   have_info |= MFG_INFO;
}

void parse_zy_prid()
{
   // product id
   log_packet_id("product id");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_id, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_prod, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_sn, msg_field);
   }

   have_info |= MANUF_PARAMS;
}


void parse_zy_unid()
{
   // unit id
   log_packet_id("unit id");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_pn, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_rev, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_date, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_sn, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_fw, msg_field);
   }

   have_info |= PRODN_PARAMS;
}

void parse_zy_pulp()
{
   // pps polarity
   log_packet_id("pps polarity");

   if(get_msg_field()) {
      if(msg_field[0] == '+') pps_polarity = 0;
      else if(msg_field[0] == '-') pps_polarity = 1;
      else return;
      have_pps_polarity = 1;
   }
}

void parse_zy_pulr()
{
int rate;

   // PPS pulse rate
   log_packet_id("pps rate");

   if(get_msg_field()) {
      rate = atoi(msg_field);
      if(rate == 1) pps_rate = RATE_1PPS;
      else if(rate == 2) pps_rate = RATE_PP2S;
      else return;
      have_pps_rate = 33;
   }
}

void parse_zy_pulw()
{
double width;

   // PPS pulse width
   log_packet_id("pps width");

   if(get_msg_field()) {
      width = atof(msg_field);
      zyfer_pps_width = width;
      if(width == (-2.0)) width = 20.0E-6;
      else if(width == (-1.0)) width = 10.0E-6;
      else width /= 1000.0;
      have_pps_duty = 0x01;
   }
}

void parse_zy_rsah()
{
int prn;
int c;

   // sat health
   log_packet_id("sat health");

   if(get_msg_field()) {
      reset_sat_health();
      for(prn=1; prn<=32; prn++) {
         c = msg_field[prn-1];
         if(c == 0) break;
         if(c == '0') sat[prn].health_flag = 1;      // unhealthy
         else if(c == '1') sat[prn].health_flag = 2; // healthy
         else continue;
      }
   }
}


void parse_zy_sslt()
{
u32 val;
int prn;
int c;

   // satellite enables
   log_packet_id("sat enables");

   val = 0;
   if(get_msg_field()) {
      for(prn=1; prn<=32; prn++) {
         c = msg_field[prn-1];
         if(c == 0) break;
         if(c == '0') sat[prn].disabled = 0;
         else if(c == '1') sat[prn].disabled = 1;
         else continue;
         if(!sat[prn].disabled) val |= 1 << (prn-1);
      }
      sats_enabled = val;
   }
}

void parse_zy_stat()
{
int sats;
int hex1,hex2,hex3;

   // status
   log_packet_id("status");

   if(get_msg_field()) sats = atoi(msg_field);
   else return;

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(zy_osc_type, msg_field);
   }
   else return;

   if(get_msg_field()) hex1 = atohex(msg_field);
   else return;
   if(get_msg_field()) hex2 = atohex(msg_field);
   else return;
   if(get_msg_field()) hex3 = atohex(msg_field);
   else return;
}

void parse_zy_temp()
{
   // temperature
   log_packet_id("temperature");

   if(get_msg_field()) {
      temperature = (DATA_SIZE) atof(msg_field);
      have_temperature = 115;
   }
}

void parse_zy_timd()
{
double timd;

   // gps/pps time difference
   log_packet_id("time difference");

   if(get_msg_field()) {
      timd = atof(msg_field);// / 1.0E9;
      pps_offset = timd;
      have_pps_offset = 66;
      have_rcvr_pps = 66;
   }
}

void parse_zy_timi()
{
double timi;

   // undocumented  (time interval?)
   log_packet_id("time interval");

   if(get_msg_field()) {
      timi = atof(msg_field);// / 1.0E9;
      pps_offset = timi;
      have_pps_offset = 69;
      have_rcvr_pps = 69;
   }
}

void parse_zy_time()
{
int doy;
int yy;
int hh,mm,ss;
int tmode, op_mode;
double jd;

   // time, date, tfom, discipline mode
   log_packet_id("time");

   pps_enabled = 1;
   yy = doy = hh = mm = ss = 0;
   tmode = op_mode = 0;

   if(get_msg_field()) yy = atoi(msg_field);
   if(get_msg_field()) doy = atoi(msg_field);

   if(get_msg_field()) hh = atoi(msg_field);
   if(get_msg_field()) mm = atoi(msg_field);
   if(get_msg_field()) ss= atoi(msg_field);

   if(get_msg_field()) {
      tmode = atoi(msg_field);
      if((tmode == 1) || (tmode == 4)) { 
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else if((tmode == 2) || (tmode == 3)) {  // utc time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
   }

   if(get_msg_field()) {
      tfom = atoi(msg_field);
      have_tfom = 4;
   }

   if(get_msg_field()) {
      op_mode = atoi(msg_field);
      if     (op_mode == 0) discipline_mode = DIS_MODE_WARMUP;
      else if(op_mode == 1) discipline_mode = DIS_MODE_NORMAL;
      else if(op_mode == 2) discipline_mode = DIS_MODE_AUTO_HOLD;
      else if(op_mode == 3) discipline_mode = DIS_MODE_RECOVERY;
      else if(op_mode == 5) discipline_mode = DIS_MODE_LEARNING;
      else                  discipline_mode = DIS_MODE_UNKNOWN;
   }

   jd = jdate(yy, 1, 1) + (double) (doy-1) + jtime(hh,mm,ss,0.0);
   set_gregorian_time(jd);

   update_gps_screen(8787);
}

void parse_zy_timm()
{
int tmode;

   // timing mode
   log_packet_id("timing mode");

   if(get_msg_field()) {
      tmode = atoi(msg_field);
      if((tmode == 1) || (tmode == 4)) { 
         time_flags &= (~TFLAGS_UTC);
         timing_mode = TMODE_GPS;
         have_timing_mode = 1;
      }
      else if((tmode == 2) || (tmode == 3)) {  // utc time
         time_flags |= (TFLAGS_UTC);
         timing_mode = TMODE_UTC;
         have_timing_mode = 1;
      }
   }
}

void parse_zy_trmo()
{
char trmo;

   // surveying / position hold mode
   log_packet_id("survey info");

   if(get_msg_field()) {
      trmo = msg_field[0];  // P=position average mode   K=known position
      if(trmo == 'P') {
         minor_alarms |= MINOR_SURVEY;
         rcvr_mode = RCVR_MODE_SURVEY;
      }
      else if(trmo == 'K') {
         minor_alarms &= (~MINOR_SURVEY);
         rcvr_mode = RCVR_MODE_HOLD;
      }
   }
}


void decode_zyfer_message()
{
char c;
int i;
static int row = 0;

   venus_nmea = 0;
   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   msg_col = 0;     // index of next char to get from nmea buffer
   get_msg_field(); // get the NMEA message type 

   if     (!strcmp(msg_field, "ALRM")) parse_zy_alrm();
   else if(!strcmp(msg_field, "ANTD")) parse_zy_antd();    // unsl 10
   else if(!strcmp(msg_field, "AZEL")) parse_zy_azel();    // unsl 2
   else if(!strcmp(msg_field, "DACV")) parse_zy_dacv();    // unsl 1
   else if(!strcmp(msg_field, "DRFT")) parse_zy_drft();
   else if(!strcmp(msg_field, "EFER")) parse_zy_efer();    // unsl 1
   else if(!strcmp(msg_field, "ESSD")) parse_zy_essd();    // unsl 1
   else if(!strcmp(msg_field, "ESSN")) parse_zy_essn();    // * unsl 1
   else if(!strcmp(msg_field, "ESTP")) parse_zy_estp();    // * unsl 30
   else if(!strcmp(msg_field, "FACTORYRESET")) ;
   else if(!strcmp(msg_field, "FSEL")) parse_zy_fsel();
   else if(!strcmp(msg_field, "GDOP")) parse_zy_gdop();    // * unsl 2
   else if(!strcmp(msg_field, "HEFE")) parse_zy_hefe();    // * unsl 30
   else if(!strcmp(msg_field, "HEST")) parse_zy_hest();    // * unsl 30
   else if(!strcmp(msg_field, "HETE")) parse_zy_hete();    // * unsl 30
   else if(!strcmp(msg_field, "HINT")) parse_zy_hint();    // unsl 30
   else if(!strcmp(msg_field, "LEAP")) parse_zy_leap();    // unsl 30
   else if(!strcmp(msg_field, "MANG")) parse_zy_mang();
   else if(!strcmp(msg_field, "MANI")) parse_zy_mani();
   else if(!strcmp(msg_field, "NTLC")) parse_zy_ntlc();    // unsl 30
   else if(!strcmp(msg_field, "OFST")) parse_zy_ofst();
   else if(!strcmp(msg_field, "PAVG")) parse_zy_pavg();    // unsl 1
   else if(!strcmp(msg_field, "PCTL")) ;                   // for option board
   else if(!strcmp(msg_field, "PRESET1")) ;
   else if(!strcmp(msg_field, "PRESET2")) ;
   else if(!strcmp(msg_field, "PRESET3")) ;
   else if(!strcmp(msg_field, "PRID")) parse_zy_prid();
   else if(!strcmp(msg_field, "PULE")) ;
   else if(!strcmp(msg_field, "PULP")) parse_zy_pulp();
   else if(!strcmp(msg_field, "PULR")) parse_zy_pulr();
   else if(!strcmp(msg_field, "PULW")) parse_zy_pulw();
   else if(!strcmp(msg_field, "PUTD")) ;                   // unsl 1
   else if(!strcmp(msg_field, "RSAH")) parse_zy_rsah();    // unsl 2
   else if(!strcmp(msg_field, "RSEL")) ;                   // for option board
   else if(!strcmp(msg_field, "RSTG")) ;
   else if(!strcmp(msg_field, "SIGQ")) parse_zy_sigq();    // unsl 1
   else if(!strcmp(msg_field, "SPOS")) ;
   else if(!strcmp(msg_field, "SSLT")) parse_zy_sslt();    // unsl 30
   else if(!strcmp(msg_field, "STAT")) parse_zy_stat();    // unsl 2
   else if(!strcmp(msg_field, "STIM")) ;                   // unsl 1
   else if(!strcmp(msg_field, "TCOD")) ;
   else if(!strcmp(msg_field, "TEMP")) parse_zy_temp();    // unsl 5
   else if(!strcmp(msg_field, "TIMD")) parse_zy_timd();    // unsl 2
   else if(!strcmp(msg_field, "TIME")) parse_zy_time();    // unsl 1
   else if(!strcmp(msg_field, "TIMI")) parse_zy_timi();    // * unsl 10
   else if(!strcmp(msg_field, "TIMM")) parse_zy_timm();
   else if(!strcmp(msg_field, "TRMO")) parse_zy_trmo();    // unsl 10
   else if(!strcmp(msg_field, "UNID")) parse_zy_unid();
   else if(!strcmp(msg_field, "UNSL")) ;
   else if(!strcmp(msg_field, "VERS")) parse_zy_vers();
   else last_was_gsv = 0;

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
   return;
}


//
//
//  TruePosition receiver stuff
//
//  

void send_true_cmd(char *s)
{
int i, j;

   if(s == 0) return;

   if(s[0] != '$') {
      sendout(RCVR_PORT, '$', ADD_CHAR);
   }

   j = strlen(s);
   for(i=0; i<j; i++) send_byte((u08) s[i]);

   sendout(RCVR_PORT, 0x0D, ADD_CHAR);
   sendout(RCVR_PORT, 0x0A, EOM);

   if(sim_file == 0) Sleep(50);
}

void train_true_ocxo()
{
   // causes device to learn the OCXO EFC tuning characteristics
   send_true_cmd("$TRAINOCXO");
   Sleep(5000);
   send_true_cmd("$PROCEED");
}


void parse_true_clock()
{
double jd;
int utc;

   log_packet_id("clock");

   if(get_msg_field()) jd = atof(msg_field);
   else return;

   if(get_msg_field()) utc = atoi(msg_field);
   else return;

   if(get_msg_field()) {
      tfom = atoi(msg_field);
      have_tfom = 1;
   }
   else return;

   jd /= (24.0*60.0*60.0);
   jd += GPS_EPOCH;

   if(!user_set_utc_ofs && utc) utc_offset = (int) utc;
   check_utc_ofs(33);

   set_gregorian_time(jd);
   if(time_flags & TFLAGS_UTC) {
      gps_to_utc();
   }

   update_gps_screen(4387);
}

void parse_true_extstatus()
{
   log_packet_id("extstatus");

   if(get_msg_field()) {  // position questionable?  0=normal  1=survey?
   }
   else return;

   if(get_msg_field()) {  // sat count related?
   }
   else return;

   if(get_msg_field()) {  // seems to be related to operating mode 
      true_eval = atof(msg_field);  // ,,, much noisier during survey, 
                                    // ... stable in position hold mode
                                    // ... might be 1PPS or osc error related
      have_true_eval = 1;
   }
   else return;

   if(get_msg_field()) {
      temperature = (DATA_SIZE) atof(msg_field);
      if(temperature && (have_temperature == 0)) {
         new_queue(RESET_ALL_QUEUES, 6543); // clear the queues so temp scales nicely
         have_temperature = 116;
      }
   }
   else return;

   if(get_msg_field()) {  // ?
   }
   else return;
}

void parse_true_geta()
{
   // attenuator
   log_packet_id("geta");

   if(get_msg_field()) {
      atten_val = atof(msg_field);
      have_atten = 1;
   }
}

void parse_true_getp()
{
   // get "pot" values
   log_packet_id("getp");

   if(get_msg_field()) {  // integer
      true_pot1 = atoi(msg_field);
      have_true_pot |= 0x01;
   }
   if(get_msg_field()) {  // integer
      true_pot2 = atoi(msg_field);
      have_true_pot |= 0x02;
   }
}

void parse_true_getdelay()
{
   log_packet_id("getdelay");

   if(get_msg_field()) {
      cable_delay = atof(msg_field) / 1.0E9;
      have_cable_delay = 444;
   }
}

void parse_true_getbdelay()
{
   log_packet_id("getbdelay");

   if(get_msg_field()) {
      pps1_delay = atof(msg_field) / 1.0E9;
      have_pps_delay |= 0x01;
   }
}

void parse_true_ppsdbg()
{
   log_packet_id("ppsdbg");

   get_msg_field();  // GPS time
   get_msg_field();  // Status - 0
   if(get_msg_field()) { // 32.42914e3   // EFC?
      dac_voltage = (DATA_SIZE) (atof(msg_field) * 4.096 / 65536.0);  // EFC DAC
      if(dac_voltage && (have_dac == 0)) {
         new_queue(RESET_ALL_QUEUES, 6544); // clear the queues so dac scales nicely
         have_dac = 66;
      }
   }
   get_msg_field();  // 0, -3, -2, -1

   if(get_msg_field()) {
//    dac_voltage = (DATA_SIZE) atof(msg_field);  // sawtooth?
//    have_sawtooth = 1;
   }

   get_msg_field();  // 0, 2
   get_msg_field();  // 0,1,3

   if(get_msg_field()) {  // temperature
//    temperature = (DATA_SIZE) atof(msg_field);
//    have_temperature = 117;
   }
}

void parse_true_kaldbg()
{
   log_packet_id("kaldbg");

   if(get_msg_field()) {} ;  // Unix time
   if(get_msg_field()) {} ;  // -0.32
   if(get_msg_field()) {} ;  // PPS related - 31.42890e3
   if(get_msg_field()) {} ;  // -0.336e-3
   if(get_msg_field()) {} ;  // 0.291      // smoothed phase error in approx 6.5 ns steps
   if(get_msg_field()) {} ;  // 0
   if(get_msg_field()) {} ;  // 0
}

void parse_true_scale()
{
   log_packet_id("scalefactor");

   if(get_msg_field()) {
      true_scalefactor = atof(msg_field);
      have_true_scale = 1;
   }
}


void parse_true_getpos(int survey)
{
double msl_adj;
long val, secs;

   log_packet_id("getpos");

   if(get_msg_field()) {
      lat = atof(msg_field) / 1.0E6;
      lat = lat * PI / 180.0;
   }
   else return;

   if(get_msg_field()) {
      lon = atof(msg_field) / 1.0E6;
      lon = lon * PI / 180.0;
   }
   else return;

   if(get_msg_field()) {
      alt = atof(msg_field);
   }
   else return;

   if(get_msg_field()) {  // add to alt to get WGS84?
      msl_adj = atof(msg_field);
   }
   else return;

   if(get_msg_field()) {  // survey progress
      if(survey) {  // process $SURVEY message
         val = secs = (long) atoi(msg_field);  // seconds remaining
         val = (do_survey * 3600L) - val;       // seconds completed
         survey_secs = (int) secs;

         if(secs) {
            minor_alarms |= MINOR_SURVEY;
            rcvr_mode = RCVR_MODE_SURVEY;
            survey_progress = (-1);
            have_progress = 9;
         }
         else {
            minor_alarms &= (~MINOR_SURVEY);
            rcvr_mode = RCVR_MODE_HOLD;
            survey_progress = (100);
            have_progress = 10;
         }
      }
      else {  // process $GETPOS message
         val = atoi(msg_field);  // 0=hold  3=survey?
         if(val == 0) {
            minor_alarms &= (~MINOR_SURVEY);
            rcvr_mode = RCVR_MODE_HOLD;
            survey_progress = (100);
            have_progress = 11;
         }
      }
   }
   else return;
}

void parse_true_getver()
{
   log_packet_id("getver");

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(tp_sw, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(tp_boot, msg_field);
      if(strstr(msg_field, "BOOT")) {
         send_true_cmd("$PROCEED");  // get out of boot mode
      }
   }

   if(get_msg_field()) {  // FPGA version
      msg_field[32] = 0;
      strcpy(tp_num1, msg_field);
   }

   if(get_msg_field()) {  // software checmsum
      msg_field[32] = 0;
      strcpy(tp_num2, msg_field);
   }

   if(get_msg_field()) {  // FPGA checksum
      msg_field[32] = 0;
      strcpy(tp_num3, msg_field);
   }

   if(get_msg_field()) {
      msg_field[32] = 0;
      strcpy(tp_sn, msg_field);
   }

   have_info |= ALL_ID_INFO;
}

void parse_true_sat()
{
int prn;
double az, el, sig;

   log_packet_id("sat info");

   if(get_msg_field()) {  // receiver channel
   }
   else return;

   if(get_msg_field()) {
      prn = atoi(msg_field);
      if(prn < 1) return;
      else if(prn > 255) return;
   }
   else return;

   az = el = 999.0;
   if(get_msg_field()) {
      el = atof(msg_field);
   }
   else return;
   if(get_msg_field()) {
      az = atof(msg_field);
   }
   else return;
   if((az < 999.0) && (el < 999.0)) {
      set_sat_azel(prn, (float) az, (float) el);
   }

   if(get_msg_field()) {
      sig = atof(msg_field);
      if(sig) {
         sat[prn].tracking = prn;
         sat[prn].level_msg = 55;
         sat[prn].sig_level = (float) sig;
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);
      }
      else {
         sat[prn].level_msg = 0;
         sat[prn].tracking = 0;
      }
   }
   else return;

   level_type = "dBc";
}

void parse_true_wsat()
{
int prn;
double az, el, sig;

   log_packet_id("wsat info");

   if(get_msg_field()) {  // receiver channel
   }
   else return;

   if(get_msg_field()) {
      prn = atoi(msg_field);
      if(prn < 1) return;
      else if(prn > 255) return;
   }
   else return;

   az = el = 999.0;
   if(get_msg_field()) {
      az = atof(msg_field);
   }
   else return;
   if(get_msg_field()) {
      el = atof(msg_field);
   }
   else return;
   if((az < 999.0) && (el < 999.0)) {
      set_sat_azel(prn, (float) az, (float) el);
   }

   if(get_msg_field()) {
      sig = atof(msg_field);
      if(sig) {
         sat[prn].tracking = prn;
         sat[prn].level_msg = 55;
         sat[prn].sig_level = (float) sig;
         have_snr |= rinex_gnss(prn);
         record_sig_levels(prn);
      }
      else {
         sat[prn].level_msg = 0;
         sat[prn].tracking = 0;
      }
   }
   else return;

   level_type = "dBc";
}

void parse_true_set1pps()
{
   // $SET1PPS
   log_packet_id("set1pps");
}

void parse_true_status()
{
u32 ho;
int val;

   log_packet_id("status");

   if(get_msg_field()) {  // 10MHz
      val = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {  // 1PPS
      val = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {  // antenna          
      val = atoi(msg_field);
      if(val) minor_alarms |= (MINOR_ANT_NO_PWR);
      else    minor_alarms &= (~MINOR_ANT_NO_PWR);
      have_antenna = 56;
   }
   else return;

   if(get_msg_field()) {  // holdover duration
      ho = (u32) atoi(msg_field);
      if(ho) holdover = ho;
   }
   else return;

   if(get_msg_field()) {  // num sats
      val = atoi(msg_field);
   }
   else return;

   if(get_msg_field()) {  // state
      val = atoi(msg_field);
      if     (val == 0) discipline_mode = DIS_MODE_NORMAL;
      else if(val == 1) discipline_mode = DIS_MODE_ACQUIRE;     // acquiring
      else if(val == 2) discipline_mode = DIS_MODE_POWERUP;
      else if(val == 3) discipline_mode = DIS_MODE_AUTO_HOLD;
      else if(val == 4) discipline_mode = DIS_MODE_MANUAL_HOLD;
      else if(val == 5) discipline_mode = DIS_MODE_SOFT_HOLD;
      else if(val == 6) discipline_mode = DIS_MODE_NO_GPS;      // no gps
      else if(val == 7) discipline_mode = DIS_MODE_LEARNING;    // training OCXO
      else if(1 || ((val >= 8) && (val <= 17))) {
         true_wait = val;
         discipline_mode = DIS_MODE_WAIT;
      }
      else discipline_mode = DIS_MODE_UNKNOWN;

      true_debug = atoi(msg_field);
      have_true_debug = 1;
      have_ffom = 1;
   }
   else return;

}


void parse_true_update()
{
   // $UPDATE FLASH
   log_packet_id("update flash");
}

void parse_true_discard()
{
   log_packet_id("discard");
}

void parse_true_esn()
{
   log_packet_id("esn");
}

void parse_true_leave()
{
   log_packet_id("leave");
}

void parse_true_spiw()
{
   // write SPI bus?
   log_packet_id("spiw");
}

void parse_true_traim()
{
   log_packet_id("traim");
}



void decode_true_message()
{
char c;
int i;
static int row = 0;

   venus_nmea = 0;
   start_msg_decode(1);

   nmea_msg[0] = 0;
   for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to nmea buffer
      c = tsip_byte();
      nmea_msg[i] = c;
      nmea_msg[i+1] = 0;
      if(i >= ((int)sizeof(nmea_msg)-12)) break;
   }

   msg_col = 0;     // index of next char to get from nmea_msg buffer
   get_msg_field(); // get the NMEA message type 

   if     (!strcmp(msg_field, "CLOCK"))          parse_true_clock();
   else if(!strcmp(msg_field, "DISCARD"))        parse_true_discard();
   else if(!strcmp(msg_field, "ESN"))            parse_true_esn();
   else if(!strcmp(msg_field, "EXTSTATUS"))      parse_true_extstatus();
   else if(!strcmp(msg_field, "GETA"))           parse_true_geta();
   else if(!strcmp(msg_field, "GETBDELAY"))      parse_true_getbdelay();
   else if(!strcmp(msg_field, "GETDELAY"))       parse_true_getdelay();
   else if(!strcmp(msg_field, "GETPOS"))         parse_true_getpos(0);
   else if(!strcmp(msg_field, "GETP"))           parse_true_getp();
   else if(!strcmp(msg_field, "GETSCALEFACTOR")) parse_true_scale();
   else if(!strcmp(msg_field, "GETVER"))         parse_true_getver();
   else if(!strcmp(msg_field, "KALDBG"))         parse_true_kaldbg();
   else if(!strcmp(msg_field, "LEAVE"))          parse_true_leave();
   else if(!strcmp(msg_field, "PPSDBG"))         parse_true_ppsdbg();
   else if(!strcmp(msg_field, "PROCEED")) ;
   else if(!strcmp(msg_field, "SAT"))            parse_true_sat();
   else if(!strcmp(msg_field, "SET1PPS"))        parse_true_set1pps();
   else if(!strcmp(msg_field, "SPIW"))           parse_true_spiw();
   else if(!strcmp(msg_field, "STATUS"))         parse_true_status();
   else if(!strcmp(msg_field, "SURVEY"))         parse_true_getpos(1);
   else if(!strcmp(msg_field, "TRAIM"))          parse_true_traim();
   else if(!strcmp(msg_field, "UPDATE"))         parse_true_update();
   else if(!strcmp(msg_field, "WSAT"))           parse_true_wsat();
   else if(debug_file) {
      fprintf(debug_file, "Unknown message:%s\n", nmea_msg);
   }

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
   return;
}


//
//
// External environmental sensor receiver stuff
//
//

int enviro_port_open()
{
   // returns true if the THERMO auxiliary data port is open
   // Also, set the temperature plot id to upper case if so.

   if(com[THERMO_PORT].process_com && (com[THERMO_PORT].com_running > 0)) {
//    plot[TEMP].plot_id = "TEMP";
      return 1;
   }
   else {
//    plot[TEMP].plot_id = "Temp";
      return 0;
   }
}

int enviro_mode()
{
int i;

   // returns true if external envidonmental sensor in use
   
   i = 0x00;
   if(rcvr_type == THERMO_RCVR) i |= 0x01;
   if(enviro_port_open()) i |= 0x02;
// if(com[THERMO_PORT].port_used > 0) i |= 0x04;  //lfs
   if(sim_file_read && (com[THERMO_PORT].port_used)) i |= 0x80;
   return i;
}

int two_enviro_mode()
{
   // returns true if there is a environmental sensor thermometer on the main 
   // receiver port and on the auxiliary ENVIRO_PORT  - Heather does not 
   // currently support this.

   if((rcvr_type == THERMO_RCVR) && enviro_port_open()) return 1;
   return 0;
}


int get_enviro_field()
{
char c;
int i;

   // extract the next field from a sensorr message.  Fields are separated
   // by commas, spaces, or tabs.

   enviro_field[0] = 0;
   if(enviro_msg[enviro_col] == 0) return 0;  // at end-of-message

   i = 0;
   while(enviro_col < (int)sizeof(enviro_msg)) {   // get next field from the thermometer message
      c = enviro_msg[enviro_col];
      if(c == 0) {  // reached end-of-message
         break;
      }
      else if(c == ' ') {  // skip leading spaces, end field on a space
         ++enviro_col;
         if(i) break;
      }
      else if(c == '\t') {  // skip leading spaces, end field on a tab
         ++enviro_col;
         if(i) break;
      }
      else if(c == ',') {  // skip leading spaces, end field on a comma
         ++enviro_col;
         if(i) break;
      }
      else {        // add char to extracted field
         enviro_field[i++] = c;
         enviro_field[i] = 0;
         ++enviro_col;
      }
   }

   return enviro_field[0];
}


int parse_humidity()
{
   if(is_numeric(enviro_field)) {
      humidity = (DATA_SIZE) atof(enviro_field);
      have_humidity = 900;
   }
   else return 0;

   return 1;
}

int parse_pressure()
{
   if(is_numeric(enviro_field)) {
      pressure = (DATA_SIZE) atof(enviro_field);
      have_pressure = 900;
   }
   else return 0;

   return 1;
}

int parse_temp0()
{
   // optional room temperature reading
   if(is_numeric(enviro_field)) {
      tc0 = (DATA_SIZE) atof(enviro_field);
      have_temperature0 = 900;
   }
   else return 0;

   return 1;
}

int parse_temp1()
{
   // remote temperature sensor 1
   if(is_numeric(enviro_field)) {
      tc1 = (DATA_SIZE) atof(enviro_field);
      have_temperature1 = 900;
   }
   else return 0;

   return 1;
}


int parse_temp2()
{
   // remote temperature sensor 2
   if(is_numeric(enviro_field)) {
      tc2 = (DATA_SIZE) atof(enviro_field);
      have_temperature2 = 900;
   }
   else return 0;

   return 1;
}


int parse_adc1()
{
   // remote environmenal sensor ADC channal 1
   if(is_numeric(enviro_field)) {
      adc1 = (DATA_SIZE) atof(enviro_field);
      have_adc1 = 900;
   }
   else return 0;

   return 1;
}


int parse_adc2()
{
   // remote environmenal sensor ADC channal 2
   if(is_numeric(enviro_field)) {
      adc2 = (DATA_SIZE) atof(enviro_field);
      have_adc2 = 900;
   }
   else return 0;

   return 1;
}


int parse_adc3()
{
   // remote environmenal sensor ADC channal 3
   if(is_numeric(enviro_field)) {
      adc3 = (DATA_SIZE) atof(enviro_field);
      have_adc3 = 900;
   }
   else return 0;

   return 1;
}

int parse_adc4()
{
   // remote environmental sensor ADC channel 4
   if(is_numeric(enviro_field)) {
      adc4 = (DATA_SIZE) atof(enviro_field);
      have_adc4 = 900;
   }
   else return 0;

   return 1;
}


int parse_dp()
{
   // dew point
   if(is_numeric(enviro_field)) {
      dew_pt = (DATA_SIZE) (atof(enviro_field));
      have_dp = 900;
   }
   else return 0;

   return 1;
}

int parse_rtemp()
{
   // remote temperature
   if(is_numeric(enviro_field)) {
      rem_temp = (DATA_SIZE) (atof(enviro_field));
      have_rem_temp = 900;
   }
   else return 0;

   return 1;
}

int parse_lux()
{
   // lux light sensor
   if(is_numeric(enviro_field)) {
      lux = (DATA_SIZE) (atof(enviro_field));
      have_lux = 900;
   }
   else return 0;

   return 1;
}

int parse_ref_baro_alt()
{
   // reference altitude
   if(is_numeric(enviro_field)) {
      ref_baro_alt = (DATA_SIZE) (atof(enviro_field));
      have_ref_baro_alt = 900;
   }
   else return 0;

   return 1;
}

int parse_lfs_counter()
{
   // counter / frequency
   if(is_numeric(enviro_field)) {
      lfs_counter = (DATA_SIZE) (atof(enviro_field));
      have_lfs_counter = 900;
   }
   else return 0;

   return 1;
}

int parse_lfs_emis()
{
   // IR sensor emssivity
   if(is_numeric(enviro_field)) {
      emis1 = (DATA_SIZE) (atof(enviro_field));
      have_lfs_emis = 900;
   }
   else return 0;

   return 1;
}


void save_temp1()
{
   // if the enviro sensor is the main receiver or the GPS device does not
   // report temperatures, store the main temp sensor reading in the regular 
   // temperature variable/plot (GT plot).

   if(rcvr_type == THERMO_RCVR) {
      temperature = tc1;
      have_temperature = 900;
   }
   else if(have_temperature == 0) {
      temperature = tc1;
   }
}


int next_enviro_poll()
{
int i;

   // find the next reading that we can poll for

   for(i=0; i<NUM_SENSORS; i++) { 
      if(last_enviro == 0) next_enviro = ENV_TEMP1;
      else if(next_enviro == 0) next_enviro = ENV_TEMP1;
      else next_enviro <<= 1;
      if(next_enviro & (0x0001 << NUM_SENSORS)) next_enviro = ENV_TEMP1;

      if(next_enviro & enviro_sensors) {  // the device supports this reading
         return next_enviro;
      }
   }

   next_enviro = 0;     // device has no known supported readings
   return next_enviro;
}

int set_lfs_type()
{
   enviro_field[UNIT_LEN] = 0;
   strcpy(enviro_dev, enviro_field);
   have_info |= (MANUF_PARAMS | PRODN_PARAMS | VERSION_INFO);

   if(strstr(enviro_field, "LFS104A")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_TEMP2 | ENV_DP | ENV_LUX | ENV_REFALT);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS104B")) {  // LFS104BW
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_TEMP2 | ENV_HUMID | ENV_PRESS | ENV_EMIS);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS108A")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_RTEMP);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS108B")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_TEMP2 | ENV_DP);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS108C")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_TEMP2 | ENV_HUMID);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS108D")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_TEMP2 | ENV_HUMID);
      enviro_type = LFS_ENVIRO;
   }
   else if(strstr(enviro_field, "LFS108E")) { 
      enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_COUNT);
      enviro_type = LFS_ENVIRO;
   }
   else return 0;

   return 1;
}

void detect_enviro_type()
{
   // figure up the sensor type and what readings it can do

   enviro_sensors = ENV_TEMP1;   // assume everybody does temperature
   if(strstr(enviro_field, "$PLHEN")) {  // custom Heather BME280 + two thermistors
      enviro_sensors = (ENV_TEMP1 | ENV_TEMP2 | ENV_HUMID | ENV_PRESS);
      enviro_type = HEATHER_ENVIRO;
   }
   else if(strstr(enviro_field, "USB-")) {   // dogratian.com USB devices
      enviro_field[UNIT_LEN] = 0;
      strcpy(enviro_dev, enviro_field);
      have_info |= (MANUF_PARAMS | PRODN_PARAMS | VERSION_INFO);

      if(strstr(enviro_field, "PA")) {  // see what measurements it does
         enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_HUMID | ENV_PRESS);
         enviro_type = DOG_ENVIRO;
      }
      else if(strstr(enviro_field, "SHT")) {
         enviro_sensors = (ENV_SN | ENV_TEMP1 | ENV_HUMID);
         enviro_type = DOG_ENVIRO;
      }
      else if(strstr(enviro_field, "LM75")) {
         enviro_sensors = (ENV_SN | ENV_TEMP1);
         enviro_type = DOG_ENVIRO;
      }
   }
   else if(strstr(enviro_field, "LFS10")) {
      set_lfs_type();
   }

   next_enviro = 0;  // start the polling cycle
}


void decode_dog_enviro(unsigned port, int i)
{
   // decode dogtaian.com values then poll for the next reading

   if(i) {
      if(last_enviro == ENV_ID) {  // device ID
         goto poll_next_dog_enviro;
      }
      else if(last_enviro == ENV_SN) {
         enviro_field[UNIT_LEN] = 0;
         have_info |= MFG_INFO;
         strcpy(enviro_sn, enviro_field);
      }
      else if(last_enviro == ENV_HUMID) {
         parse_humidity();
if(humidity > 110.0) {
   last_enviro = 0;
   drain_port(port);
}
      }
      else if(last_enviro == ENV_PRESS) {
         parse_pressure();
         pressure /= 100.0;    // convert to millibars
if(pressure < 200.0) {
   last_enviro = 0;
   drain_port(port);
}
      }
      else if(last_enviro == ENV_TEMP1) {
         parse_temp1();
if(tc1 > 100.0) {
   last_enviro = 0;
   drain_port(port);
}
         save_temp1();
      }
      else {  // unknown reading type
         last_enviro = 0;
      }
   }
   else last_enviro = 0;

   poll_next_dog_enviro: // get the next reading
   next_enviro_poll();   // get what reading type to request

   if(next_enviro & ENV_HUMID) {
      send_enviro_cmd("GH\r", port);
      last_enviro = ENV_HUMID;
   }
   else if(next_enviro & ENV_PRESS) {
      send_enviro_cmd("GP\r", port);
      last_enviro = ENV_PRESS;
   }
   else if(next_enviro & ENV_TEMP1) {
      send_enviro_cmd("GT\r", port);
      last_enviro = ENV_TEMP1;
   }
   else if(next_enviro & ENV_SN) {
      send_enviro_cmd("GN\r", port);
      last_enviro = ENV_SN;
   }
   else {  // should never happen
      send_enviro_cmd("GT\r", port);
      last_enviro = ENV_TEMP1;
   }
}

int lfs_fault;

void decode_lfs_enviro(unsigned port, int i)
{
   // decode LFS sensor values then poll for the next reading

// if(debug_file) fprintf(debug_file, "decoding enviro:%d  last:%04X  fault:%d\n", i,last_enviro, lfs_fault); //lfs
   if(lfs_fault) {
   }
   else if(i) {
      if(last_enviro == ENV_ID) {  // device ID
         goto poll_next_lfs_enviro; 
      }
      else if(last_enviro == ENV_SN) {
         enviro_field[UNIT_LEN] = 0;
         strcpy(enviro_sn, enviro_field);
         have_info |= MFG_INFO;
      }
      else if(last_enviro == ENV_TEMP1) {  // themrometer
         parse_temp1();
         tc1 /= 10.0;
         tc1 = (DATA_SIZE) (((double) tc1 - 32.0) * 5.0 / 9.0);
if(tc1 > 100.0) {
   last_enviro = 0;
   drain_port(port);
}
         save_temp1();
      }
      else if(last_enviro == ENV_HUMID) {  // humidity
         parse_humidity();
         humidity /= 10.0;
if(humidity > 110.0) {
   last_enviro = 0;
   drain_port(port);
}
      }
      else if((last_enviro == ENV_TEMP2) || (last_enviro == ENV_RTEMP)) {  // IR or remote thermometer
         parse_temp2();
         tc2 /= 10.0;
         tc2 = (DATA_SIZE) (((double) tc2 - 32.0) * 5.0 / 9.0);
if(tc2 > 100.0) {
   last_enviro = 0;
   drain_port(port);
}
      }
      else if(last_enviro == ENV_PRESS) {  // pressure
         parse_pressure();
         pressure /= 10.0;
if(pressure < 200.0) {
   last_enviro = 0;
   drain_port(port);
}
      }
      else if(last_enviro == ENV_DP) {     // dew point
         parse_dp();
         dew_pt /= 10.0;
      }
      else if(last_enviro == ENV_RTEMP) {  // remote temperature - !!!! handled above as temp2
         parse_rtemp();
         rem_temp /= 10.0;
         rem_temp = (DATA_SIZE) (((double) rem_temp - 32.0) * 5.0 / 9.0);
      }
      else if(last_enviro == ENV_LUX) {    // light sensor
         parse_lux();
         lux /= 10.0;
      }
      else if(last_enviro == ENV_REFALT) { // reference altitude
         parse_ref_baro_alt();
         ref_baro_alt /= 10.0;
      }
      else if(last_enviro == ENV_COUNT) {  // counter / freq
         parse_lfs_counter();
         lfs_counter /= 10.0;
      }
      else if(last_enviro == ENV_EMIS) {   // IR sensor emissivity
         parse_lfs_emis();
         emis1 /= 100.0;
      }
      else {
         last_enviro = 0;
      }
   }
   else last_enviro = 0;

   poll_next_lfs_enviro: // get the next reading 
// if(debug_file) fprintf(debug_file, "polling next enviro:%d  last:%04X  next:%04X\n", i,last_enviro,next_enviro); //lfs
   next_enviro_poll();   // get the reading type to poll for
   lfs_fault = 0;
// if(debug_file) fprintf(debug_file, "polling next enviro::%d  last:%04X  next:%04X\n", i,last_enviro, next_enviro); //lfs

   if(next_enviro & ENV_TEMP1) {  // get temp1
      send_enviro_cmd("GET1\r", port);
      last_enviro = ENV_TEMP1;
   }
   else if(next_enviro & ENV_HUMID) { // get humidity
      send_enviro_cmd("GET2\r", port);
      last_enviro = ENV_HUMID;
   }
   else if(next_enviro & ENV_TEMP2) {  // get temp2 - IR
      send_enviro_cmd("GET3\r", port); 
      last_enviro = ENV_TEMP2;
   }
   else if(next_enviro & ENV_PRESS) {  // get baro 
      send_enviro_cmd("GET4\r", port);
      last_enviro = ENV_PRESS;
   }
   else if(next_enviro & ENV_COUNT) {  // get count/freq
      send_enviro_cmd("GET6\r", port);
      last_enviro = ENV_COUNT;
   }
   else if(next_enviro & ENV_DP) {  // get dew point
      send_enviro_cmd("GET7\r", port);
      last_enviro = ENV_DP;
   }
   else if(next_enviro & ENV_EMIS) {  // get emissivity setting
      send_enviro_cmd("GEMIS\r", port);
      last_enviro = ENV_EMIS;
   }
   else if(next_enviro & ENV_LUX) {  // get lux level
      send_enviro_cmd("GET9\r", port);
      last_enviro = ENV_LUX;
   }
   else if(next_enviro & ENV_REFALT) {  // get reference altitude
      send_enviro_cmd("GETA1\r", port);
      last_enviro = ENV_REFALT;
   }
   else if(next_enviro & ENV_RTEMP) {  // get remote temp
      send_enviro_cmd("GETr1\r", port);
      last_enviro = ENV_RTEMP;
   }
   else if(next_enviro & ENV_SN) {  // get serial number
      send_enviro_cmd("GETSN\r", port);
      last_enviro = ENV_SN;
   }
   else {  // unknown last request
      send_enviro_cmd("GET1\r", port);  // should never happen - get temp1
      last_enviro = ENV_TEMP1;
   }
}


void decode_heather_enviro(unsigned port, int i)
{
   // decode Heather sensor values.  No need to poll for the next readings

   enviro_type = HEATHER_ENVIRO;
   if(get_enviro_field()) {  // humidity
      parse_humidity();
   }
   if(get_enviro_field()) {  // pressure
      parse_pressure();
   }
   if(get_enviro_field()) {  // BME280 temp sensor (room temp) (not currently used)
      parse_temp0();
   }
   if(get_enviro_field()) {  // thermistor 1
      parse_temp1();
      save_temp1();
   }
   if(get_enviro_field()) {  // thermistor 2
      parse_temp2();
   }
   if(get_enviro_field()) {  // ADC channel 3
//lfs parse_adc3();
   }
   if(get_enviro_field()) {  // ADC channel 4
//lfs parse_adc4();
   }
}


void decode_enviro_msg(unsigned port)
{
int i;
u08 c;
u32 packets;

   // decode messages from environmental sensors and poll for the next reading

   if(rcvr_type == THERMO_RCVR) {
      start_msg_decode(1);
      ++enviro_packets;
   }
   else {
      ++packet_count;
      ++enviro_packets;
   }

#define ENVIRO_RESET_THRESH 20

   if(enviro_packets == ENVIRO_RESET_THRESH) {  // time to automatcially kill off unused plots
      if(have_humidity == 0) plot[HUMIDITY].show_plot = 0;
      if(have_pressure == 0) plot[PRESSURE].show_plot = 0;
      if(have_temperature1 == 0) plot[TEMP1].show_plot = 0;
      if(have_temperature2 == 0) plot[TEMP2].show_plot = 0;

      if((rcvr_type == THERMO_RCVR) || (rcvr_type == TIDE_RCVR)) {
         if(have_adc3 == 0) plot[ADC3].show_plot = 0;
         if(have_adc4 == 0) plot[ADC4].show_plot = 0;
      }
   }
   

   // reset the data queues shortly after startup and we have a full set of
   // readings.  This makes sure we have data from all sensor channels and
   // that plots will scale properly.
   if((enviro_packets == ENVIRO_RESET_THRESH) && (pause_data == 0)) {
      packets = enviro_packets;
      new_queue(RESET_ALL_QUEUES, 103);
      enviro_packets = packets;
   }

   enviro_msg[0] = 0;
   if(port == THERMO_PORT) {
      for(i=0; i<enviro_wptr; i++) {  // copy message from sensor buffer to enviro_msg
         c = enviro_buf[i];
         enviro_msg[i] = c;
         enviro_msg[i+1] = 0;
      }
   }
   else {
      for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to enviro_msg
         c = tsip_buf[i];
         enviro_msg[i] = c;
         enviro_msg[i+1] = 0;
      }
   }

// if(debug_file) fprintf(debug_file, "decode enviro:{%s} last:%04X  msec:%.0f\n", enviro_msg, last_enviro, GetMsecs()); //lfs

   strupr(enviro_msg);

   enviro_col = 0;     // index of next char to get from the sensor buffer

   i = get_enviro_field();
   if(last_enviro == ENV_ID) {  // response to the device ID command
      detect_enviro_type();
   }

// if(debug_file) fprintf(debug_file, "field:{%s}  last:%04X i:%d %c\n", enviro_field,last_enviro,i,i);
if(1 && strstr(enviro_field, "LFS10")) {  //lfs
   set_lfs_type();
   if((last_enviro & ENV_ID) == 0) {  // unexpected ID response seen
      last_enviro = 0x0000;
///lfs lfs_fault = 1;
if(debug_file) fprintf(debug_file, "lfs fault!\n");
BEEP(512); //lfs
   }
   last_enviro = ENV_ID;
}

   if(strstr(enviro_field, "$PLHEN")) {  // custom Heather BME280 + two thermistors
      decode_heather_enviro(port, i);
   }
   else if(enviro_type == DOG_ENVIRO) { // default dogratian.com sensors
      decode_dog_enviro(port, i);
   }
   else if(enviro_type == LFS_ENVIRO) { // LFS104BW
// if(debug_file) fprintf(debug_file, "decode lfs:{%s}  last:%04X\n", enviro_msg, last_enviro); //lfs
      decode_lfs_enviro(port, i);
   }
   else {  // unknown sensor device
      init_enviro(port);
   }

   i = 1;
   if     ((enviro_sensors & ENV_TEMP1) && (have_temperature1 == 0)) i = 0;
   else if((enviro_sensors & ENV_TEMP2) && (have_temperature2 == 0)) i = 0;
   else if((enviro_sensors & ENV_PRESS) && (have_pressure == 0)) i = 0;
   else if((enviro_sensors & ENV_HUMID) && (have_humidity == 0)) i = 0;

   if(i) {  // only start logging if all supported readings are available
      if(rcvr_type == THERMO_RCVR) {  // system clock is driving screen updates
         if(sim_file) {
            get_norcvr_message();  // aaattt update screen 
         }
         else {
            get_norcvr_message();  // aaattt update screen 
         }
      }
   }

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_enviro_message(unsigned port)
{
u08 c;
int i;
static u08 last_c = 0;
static double last_enviro_time = 0.0;

   // This routine is used when the environmental sensor is an "extra" device.
   // This routine buffers up an incoming environmental message.  When the 
   // end of the message is seen, the message is parsed and decoded with 
   // decode_enviro_msg().  Messages can end with 0x0D, 0x0A, or both.

   if(enviro_type == HEATHER_ENVIRO) ;
   else if(GetMsecs() < last_enviro_time) return;  // rate limits requests to minimize useless traffic
   last_enviro_time = GetMsecs() + ENVIRO_RATE;    // 100 cps max input rate

   i = SERIAL_DATA_AVAILABLE(port);
   if(i == 0) {  // no characters available, check for com timeout
      i = check_com_timer(port);
      
      if(i || (i == DATA_LOSS_REINIT)) {
         com[port].com_data_lost = DATA_LOSS_NO_INIT;  // prevents futile re-init attempts
         reset_com_timer(port);
         init_com(port, 107);
////com[port].com_running = 4;
if(com[port].com_running > 0) com[port].process_com = 4;
//lfs com[port].process_com = 4;
BEEP(513);  //lfs
         init_enviro(port);
      }
      return;
   }
   else {
      reset_com_timer(port);
   }

   if(port == RCVR_PORT) {  // sensor is main input decice
      c = get_com_char();
      if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
         com[RCVR_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }
   else {  // sensor is auxiliary input device (/et=)
      c = get_enviro_char();  // aaattt
      if(com[THERMO_PORT].rcv_error) {      // parity/framing/overrun errors
         com[THERMO_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }

   last_c = c;

   if(enviro_sync == 0) {    // syncing to start of message, search for a line feed
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) {
         enviro_sync = 1;
         get_sync_time();
      }
      enviro_wptr = 0;
      enviro_rptr = 0;
      return;
   }
   else if(enviro_sync == 1) { // 0x0A has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) {
         if(enviro_wptr == 0) return; // end-of-line with no data in the message buffer
         goto enviro_end;  // end of message
      }

      if(enviro_wptr < MAX_TSIP) {   // add char to the message buffer
         enviro_buf[enviro_wptr++] = c;
      }
      else {  // buffer overflow, ignore the message
//         enviro_error |= 0x8000;  // aaattt
         goto rst_msg;
      }
   }
   else {  // end of message
      enviro_end:
      if(enviro_wptr) {           // we have a message
         decode_enviro_msg(port); // process the message
         packet_end = 1;
      }

      rst_msg:
      enviro_wptr = 0;     // prepare for next message
      enviro_rptr = 0;
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) enviro_sync = 1;
      else enviro_sync = 0;
   }
}


void get_rcvr_enviro_message(unsigned port)
{
u08 c;
static u08 last_c = 0;
static double last_enviro_time = 0.0;

   // This routine is used when the environmental sensor the main "receiver" device.
   // This routine buffers up an incoming environmental message.  When the 
   // end of the message is seen, the message is parsed and decoded with 
   // decode_enviro_msg().  Messages can end with 0x0D, 0x0A, or both.

   if(enviro_type == HEATHER_ENVIRO) ;
   else if(GetMsecs() < last_enviro_time) return;  // rate limits requests to minimize useless traffic
   last_enviro_time = GetMsecs() + ENVIRO_RATE;    // 100 cps max input rate

   // This routine buffers up an incoming sensor message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_enviro_msg()
   // Messages can end with 0x0D, 0x0A, or both.

   if(SERIAL_DATA_AVAILABLE(port) == 0) {
      check_com_timer(port);
      return;
   }
   else {
      reset_com_timer(port);
   }

   if(port == RCVR_PORT) {  // sensor is main input decice
      c = get_com_char();
      if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
         com[RCVR_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }
   else {  // sensor is auxiliary input device (/et=)
      c = get_enviro_char();  // aaattt
      if(com[port].rcv_error) {      // parity/framing/overrun errors
         com[port].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }

   last_c = c;

   if(tsip_sync == 0) {    // syncing to start of message, search for a line feed
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // 0x0A has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) {
         if(tsip_wptr == 0) return; // end-of-line with no data in the message buffer
         goto tsip_end;  // end of message
      }

      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {  // buffer overflow, ignore the message
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else {  // end of message
      tsip_end:
      if(tsip_wptr) {           // we have a message
         decode_enviro_msg(port); // process the message
         packet_end = 1;
      }

      rst_msg:
      tsip_wptr = 0;     // prepare for next message
      tsip_rptr = 0;
      if((c == 0x0D) || (c == 0x0A) || (c == 0x00)) tsip_sync = 1;
      else tsip_sync = 0;
   }
}


//
//
//   External DAC port
//
//


int dac_port_open()
{
   // returns true if the DAC auxiliary data port is open

   if(com[DAC_PORT].process_com && (com[DAC_PORT].com_running > 0)) return 1;
   return 0;
}

int send_dac_value(double val)
{
unsigned i;

   // send a value to the external DAC port
   if(dac_port_open() == 0) return 0;


   sprintf(out, "%.6f", val);
   sendout(DAC_PORT, '$', ADD_CHAR);
   for(i=0; i<strlen(out); i++) {
      sendout(DAC_PORT, out[i], ADD_CHAR);
   }
   sendout(DAC_PORT, 0x0D, ADD_CHAR);
   sendout(DAC_PORT, 0x0A, EOM);

   return 1;
}



int get_dac_field()
{
char c;
int i;

   // extract the next field from a ADC message.  Fields are separated by
   // spaces or tabs.  

   dac_field[0] = 0;
   if(dac_msg[dac_col] == 0) return 0;  // at end-of-message

   i = 0;
   while(dac_col < (int)sizeof(dac_msg)) {   // get next field from the ADC message
      c = dac_msg[dac_col];
      if(c == 0) {  // reached end-of-message
         break;
      }
      else if(c == ' ') {  // skip leading spaces, end field on a space
         ++dac_col;
         if(i) break;
      }
      else if(c == '\t') {  // skip leading spaces, end field on a tab
         ++dac_col;
         if(i) break;
      }
      else {        // add char to extracted field
         dac_field[i++] = c;
         dac_field[i] = 0;
         ++dac_col;
      }
   }

   return dac_field[0];
}


void decode_dac_msg(unsigned port)
{
int i;
u08 c;
DATA_SIZE val;

// if(rcvr_type == DAC_RCVR) {
   if(0) {
      start_msg_decode(1);
      ++dac_packets;
   }
   else {
      ++packet_count;
      ++dac_packets;
   }

   // reset the data queues shortly after startup.  
//   if((dac_packets == DAC_RESET_THRESH) && (pause_data == 0)) {
//      new_queue(RESET_ALL_QUEUES, 103);
//   }

   dac_msg[0] = 0;
   if(port == DAC_PORT) {
      for(i=0; i<dac_wptr; i++) {  // copy message from ADC buffer to dac_msg
         c = dac_buf[i];
         dac_msg[i] = c;
         dac_msg[i+1] = 0;
      }
   }
   else {
      for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to dac_msg
         c = tsip_buf[i];
         dac_msg[i] = c;
         dac_msg[i+1] = 0;
      }
   }

   strupr(dac_msg);

   dac_col = 0;     // index of next char to get from DAC (actally ADC) buffer
   if(get_dac_field()) {
      if(is_numeric(dac_field)) {
         val = (DATA_SIZE) atof(dac_field);
         // !!!!!!! do something
      }
      else return;
   }

   saw_rcvr_msg = 1;
   return;
}

void get_dac_message(unsigned port)
{
u08 c;
static u08 last_c = 0;

   // This routine buffers up an incoming ADC message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_dac_msg()
   // Messages can end with 0x0D, 0x0A, or both.

   if(SERIAL_DATA_AVAILABLE(port) == 0) {
      check_com_timer(port);
      return;
   }
   else {
      reset_com_timer(port);
   }

   if(port == RCVR_PORT) {  // ADC is main input decice
      c = get_com_char();
      if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
         com[RCVR_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }
   else {  // ADC is auxiliary input device (/et=)
      c = get_dac_char();  // aaattt
      if(com[DAC_PORT].rcv_error) {      // parity/framing/overrun errors
         com[DAC_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }

   last_c = c;

   if(dac_sync == 0) {    // syncing to start of message, search for a line feed
      if((c == 0x0D) || (c == 0x0A)) {
         dac_sync = 1;
         get_sync_time();
      }
      dac_wptr = 0;
      dac_rptr = 0;
      return;
   }
   else if(dac_sync == 1) { // 0x0A has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A)) {
         if(dac_wptr == 0) return; // end-of-line with no data in the message buffer
         goto dac_end;  // end of message
      }

      if(dac_wptr < MAX_TSIP) {   // add char to the message buffer
         dac_buf[dac_wptr++] = c;
      }
      else {  // buffer overflow, ignore the message
//         dac_error |= 0x8000;  // aaattt
         goto rst_msg;
      }
   }
   else {  // end of message
      dac_end:
      if(dac_wptr) {           // we have a message
         decode_dac_msg(port); // process the message
         packet_end = 1;
      }

      rst_msg:
      dac_wptr = 0;     // prepare for next message
      dac_rptr = 0;
      if((c == 0x0D) || (c == 0x0A)) dac_sync = 1;
      else dac_sync = 0;
   }
}


//
//
// TAPR TICC receiver stuff (also supports most generic counters)
//
//

int ticc_port_open()
{
   // returns true if the TICC auxiliary data port is open

   if(ticc_sim_file) return 1;   // simulating TIC data from a file
   if(com[TICC_PORT].process_com && (com[TICC_PORT].com_running > 0)) return 1;
   return 0;
}

int two_ticc_mode()
{
   // returns true if there is a TICC on the main receiver port and
   // on the auxiliary TICC port.

   if((rcvr_type == TICC_RCVR) && ticc_port_open()) return 1;
   return 0;
}


int get_ticc_field()
{
char c;
int i;

   // extract the next field from a TICC message.  Fields are separated by
   // spaces or tabs.  HP counters embed commas in numbers so we don't end
   // fields with commas.

   ticc_field[0] = 0;
   if(ticc_msg[ticc_col] == 0) return 0;  // at end-of-message

   i = 0;
   while(ticc_col < (int)sizeof(ticc_msg)) {   // get next field from the ticc message
      c = ticc_msg[ticc_col];
      if(c == 0) {  // reached end-of-message
         break;
      }
      else if(c == ' ') {  // skip leading spaces, end field on a space
         ++ticc_col;
         if(i) break;
      }
      else if(c == '\t') {  // skip leading spaces, end field on a tab
         ++ticc_col;
         if(i) break;
      }
      else {        // add char to extracted field
         ticc_field[i++] = c;
         ticc_field[i] = 0;
         ++ticc_col;
      }
   }

   return ticc_field[0];
}


char cfg_buf[1024];

int get_ticc_line(unsigned port)
{
unsigned i;
char c;
double t0;

   // get a line from the TICC menu.

   if(port >= NUM_COM_PORTS) return 1;

   i = 0;
   cfg_buf[i] = 0;
   t0 = GetMsecs();
   while(GetMsecs() < (t0 + 1000.0)) {   // !!!! we need a timeout here
      if(SERIAL_DATA_AVAILABLE(port)) {
         c = get_ticc_char();
         if(c == 0x0A) continue;
         if(c == 0x0D) return 0;
         if(i > (sizeof(cfg_buf) - 2)) break;
         cfg_buf[i++] = c;
         cfg_buf[i] = 0;
      }
   }
   return 1;
}

int ishex(char c)
{
   // returns true if 'c' is a valid ascii hex character
   c &= 0xFF;
   if((c >= '0') && (c <= '9')) return 1;
   if((toupper(c) >= 'A') && (toupper(c) <= 'F')) return 1;

   return 0;
}

int pet_data(unsigned char *buf, int k, int check_crlf)
{
int p;

   // returns true if data in buf starting at char k is a valid picpet reading

   if(!isdigit(buf[k+0] & 0xFF)) return 0;
   if(!isdigit(buf[k+1] & 0xFF)) return 0;
   if(buf[k+2] != '.') return 0;

   for(p=3; p<=9; p++) {
      if(isdigit(buf[k+p] & 0xFF) == 0) return 0;
   }
   if(buf[k+10] != ' ') return 0;
   if(ishex(buf[k+11]) == 0) return 0;
   if(ishex(buf[k+12]) == 0) return 0;
   if(check_crlf) {
      if(buf[k+13] != 0x0D) return 0;
      if(buf[k+14] != 0x0A) return 0;
   }
   else {
      if(buf[k+13]) return 0;
   }

   return 1;
}

int lars_data(char *buf)
{
int i;

   // returns true if data in buf looks like it comes from a Lars GPSDO

   i = 0;
   if(strstr(buf, "LARS")) i = 1;
   if(strstr(buf, "HELP+INFO")) i = 2;
   if(strstr(buf, "NO PPS")) i = 3;
   if(strstr(buf, "WARMUP")) i = 10;
   if(strstr(buf, "NOLOCK")) i = 11;
   if(strstr(buf, "LOCKED"))i = 12;
   if((i >= 10) && !strchr(buf, '\t')) return 0;
   return i;
}

void get_ticc_info(unsigned port)
{
int i;
int flag;
char *s;

   // parse the ticc config data from the TICC menu header.

   if(port >= NUM_COM_PORTS) return;

   // !!!!!! do something here   aaaaahhhhh
   i = 0;
   flag = 0;
   while(1) {
      if(get_ticc_line(port)) break;
      strupr(cfg_buf);

// aaaaaahhhhhh aaattt
if(sim_file) ; 
else if(strstr(cfg_buf, "DEFAULT")) flag = 1;    // things that should only occur in TAPR_TYPE output
else if(strstr(cfg_buf, "TAPR")) flag = 2;
else if(strstr(cfg_buf, "TICC")) flag = 3;
else if(strstr(cfg_buf, "ANY CHARACTER")) flag = 4;
else if(strstr(cfg_buf, " CHA")) flag = 4;
else if(strstr(cfg_buf, " CHB")) flag = 5;
else if(strstr(cfg_buf, " CHC")) flag = 6;
else if(strstr(cfg_buf, " CHD")) flag = 7;
else if(strstr(cfg_buf, " TI(A->B)")) flag = 8;
else if(strstr(cfg_buf, " TI(C->D)")) flag = 9;
//sprintf(debug_text2, "<<%s>>  flag:%d  ustt:%d  ticc_type:%c\n", cfg_buf, flag, user_set_ticc_type, ticc_type);

if(1 && cfg_buf[0] && (flag == 0)) {  // see if we are a TAPR TICC, if not assume generic time interval mode
// sprintf(debug_text, "Checking cfgbuf [%s] ustt:%d  petdata:%d", cfg_buf, user_set_ticc_type, pet_data((unsigned char *) &cfg_buf[0], 0, 0));
   if(is_numeric(cfg_buf)) {    // line that starts with a number should be a TICC reading
      if(user_set_ticc_type == 0) {
         if(pet_data((unsigned char *) &cfg_buf[0], 0, 0)) {
            ticc_type = PICPET_TICC;
            user_set_ticc_type = 3;
            if(user_set_ticc_mode == 0) {
               ticc_mode = 'T';
               user_set_ticc_mode = 3;
               have_ticc_mode = 3;
            }
         }
         else if(lars_data(&cfg_buf[0])) {
            ticc_type = LARS_TICC;
            user_set_ticc_type = 13;
            config_rcvr_plots();
            if(user_set_ticc_mode == 0) {
               ticc_mode = 'I';
               user_set_ticc_mode = 13;
               have_ticc_mode = 13;
            }
         }
         else if(strchr(cfg_buf, ',')) ticc_type = HP_TICC;
         else if(strchr(cfg_buf, ':')) ticc_type = HP_TICC;
         else                          ticc_type = COUNTER_TICC;  // generic counter
      }
      have_info |= ALL_ID_INFO;

      if(user_set_ticc_mode == 0) {
         ticc_mode = DEFAULT_TICC_MODE;
      }
//sprintf(debug_text, "cfg_buf [%s]", cfg_buf);
      break;
   }
}

      if(strstr(cfg_buf, "TYPE ANY")) break;  // end of the menu

      s = strchr(cfg_buf, ':');
      if(s) {
         ++s;   // eat the ':'
         if(*s == ' ') ++s;  // eat the ' '
      }

      if(s) {
         if(strstr(cfg_buf, "CAL")) {   // aaaacccc
            ticc_cal = (int) atof(s);
            have_ticc_cal |= 0x01;
            flag = 10;
         }
         else if(strstr(cfg_buf, "COARSE")) {
            ticc_coarse = atof(s);
            have_ticc_coarse |= 0x01;
            flag = 11;
         }
         else if(strstr(cfg_buf, "DILATION")) {   // aaaacccc
            dilat_a = (int) atof(s);
            have_ticc_dilat |= 0x01;
            flag = 12;
            s = strchr(s, ',');
            if(s) {
               ++s;
               if(s[0]) {
                  dilat_b = (int) atof(s+1);
                  have_ticc_dilat |= 0x02;
               }
            }
//sprintf(debug_text3, "dilat %d %d  have:%02X", dilat_a,dilat_b, have_ticc_dilat);
         }
         else if(strstr(cfg_buf, "EDGE")) {   // aaaacccc
            if(s[0]) {
               edge_a = s[0];
               flag = 13;
               have_ticc_edges |= 0x01;
            }
            s = strchr(s, ',');
            if(s) {
               ++s;
               if(s[0] && s[1]) {
                  edge_b = s[1];
                  have_ticc_edges |= 0x02;
                  flag = 14;
               }
            }
//sprintf(debug_text2, "edge %c %c  have:%02X", edge_a,edge_b, have_ticc_edges);
         }
         else if(strstr(cfg_buf, "EEPROM")) {
            ticc_eeprom = (int) atof(s);
            have_ticc_eeprom = 1;
            flag = 15;
            s = strchr(s, ':');
            if(s) {
               if(s[2]) {
                  s[6] = 0;
                  strcpy(ticc_board, &s[2]);
                  have_ticc_board = 1;
               }
            }
            have_info |= ALL_ID_INFO;
//sprintf(debug_text2, "ticc ee:%d  board:%s", ticc_eeprom,ticc_board);
         }
         else if(strstr(cfg_buf, "FUDGE")) {   // aaaacccc
            fudge_a = atof(s);
            have_ticc_fudge |= 0x01;
            flag = 16;
            s = strchr(s, ',');
            if(s) {
               ++s;
               if(s[0]) {
                  fudge_b = (int) atof(s+1);
                  have_ticc_fudge |= 0x02;
               }
            }
//sprintf(debug_text, "fudge %g %g  have:%02X", fudge_a,fudge_b, have_ticc_fudge);
         }
         else if(strstr(cfg_buf, "MEASUREMENT")) {  // aaaacccc - user_set_ticc_mode
            if(user_set_ticc_mode == 0) {
               if     (strstr(s, "TIMESTAMP")) ticc_mode = 'T';
               else if(strstr(s, "TIMELAB"))   ticc_mode = 'L';
               else if(strstr(s, "INTERVAL"))  ticc_mode = 'I';
               else if(strstr(s, "PERIOD"))    ticc_mode = 'P';
               else if(strstr(s, "DEBUG"))     ticc_mode = 'D';
               have_ticc_mode = 1;
            }
            flag = 17;
         }
         else if(strstr(cfg_buf, "SERIAL")) {
            s[8] = 0;
            sprintf(ticc_sn, "%s", s);
            flag = 18;
            have_info |= ALL_ID_INFO;
         }
         else if(strstr(cfg_buf, "SOFTWARE")) {
            s[12] = 0;
            sprintf(ticc_fw, "%s", s);
            flag = 19;
            have_info |= ALL_ID_INFO;
         }
         else if(strstr(cfg_buf, "SPEED")) {
            ticc_speed = atof(s);
            have_ticc_speed |= 0x01;
            flag = 20;
         }
         else if(strstr(cfg_buf, "SYNCMODE")) {
            if(s[0]) {
               ticc_syncmode = s[0];
               have_ticc_syncmode |= 0x01;
            }
            flag = 21;
         }
         else if(strstr(cfg_buf, "TIMEOUT")) {
            if(s[0]) {
               ticc_timeout = atohex(s);
               have_ticc_timeout |= 0x01;
            }
            flag = 22;
         }
         else if(strstr(cfg_buf, "TIME2")) {   // aaaacccc
            time2_a = (int) atof(s);
            have_ticc_time2 |= 0x01;
            flag = 23;
            s = strchr(s, ',');
            if(s) {
               ++s;
               if(s[0]) {
                  time2_b = (int) atof(s+1);
                  have_ticc_time2 |= 0x02;
               }
            }
//sprintf(debug_text3, "time2 %d %d  have:%02X", time2_a,time2_b, have_ticc_time2);
         }
else if(user_set_ticc_mode == 0) {
   if(strstr(cfg_buf, "DEBUG")) {
      ticc_mode = 'D';
      have_ticc_mode = 1;
      flag = 51;
   }
   else if(strstr(cfg_buf, "INTERVAL")) {
      ticc_mode = 'I';
      have_ticc_mode = 1;
      flag = 51;
   }
   else if(strstr(cfg_buf, "PERIOD")) {
      ticc_mode = 'P';
      have_ticc_mode = 1;
      flag = 51;
   }
   else if(strstr(cfg_buf, "TIMESTAMP")) {
      ticc_mode = 'T';
      have_ticc_mode = 1;
      flag = 50;
   }
}
      }
   }
}

void set_ticc_config(unsigned port, char *s)
{
unsigned i;
int old_ticc_mode;
#define TICC_CHAR_WAIT 0    // 60  - possible delay needed after each char sent
#define TICC_MSG_WAIT  300  // 200 - delay needed after a param change command sent (min val that worked was 150)
#define TICC_MENU_WAIT 600  // 1000 - delay after entering menu mode (min val that worked was 300)
#define TICC_EE_WAIT   300  // 200 ok 2000  - delay after sending an EEPROM write command (min value that worked was 100)
                            // warm_reset() and factory_reset() commands have longer delays in them

   // send a config command to the TICC   // aaaaahhhhh
   // if (s == 0) get the TICC configuration from the menu
   if(read_only) return;
   if(ticc_sim_file) return;  //lfs LARS_TICC

   if(port >= NUM_COM_PORTS) return;
   old_ticc_mode = ticc_mode;

   sendout(port, '#', ADD_CHAR);  // break TICC out of the processing loop and get to the menu
   sendout(port, 0, FLUSH_COM);
   Sleep(TICC_MSG_WAIT);     // allow TICC to process the data
   reset_com_timer(port);

   get_ticc_info(port);      // process the ticc menu config header

   sendout(port, '#', ADD_CHAR);  // get to the TICC config menu
   sendout(port, 0, FLUSH_COM);
   Sleep(TICC_MENU_WAIT);
reset_com_timer(port);

   if(s) {   // send the command to the TICC
      for(i=0; i<strlen(s); i++) {  // send command string to the TICC
         sendout(port, s[i], ADD_CHAR);
         if(TICC_CHAR_WAIT) Sleep(TICC_CHAR_WAIT);
      }
      sendout(port, 0x0D, ADD_CHAR);
      sendout(port, 0, FLUSH_COM);
      Sleep(TICC_MSG_WAIT);    // wait for TICC to resend the menu

      sendout(port, 'W', ADD_CHAR); // W)rite changes to TICC EEPROM and exit menu
      sendout(port, 0, FLUSH_COM);
      Sleep(TICC_EE_WAIT);     // we must rate limit EEPROM commands
   }
   else {    // we were just getting the config
      sendout(port, 'Z', ADD_CHAR); // Exit menu without writing to TICC EEPROM
      sendout(port, 0, FLUSH_COM);
      Sleep(TICC_MSG_WAIT);
   }

reset_com_timer(RCVR_PORT);
   drain_port(port);  // flush TICC output
reset_com_timer(RCVR_PORT);

if(s == 0) ; 
else if(dont_reset_queues) ; 
   else {
      ticc_packets = 0;  // causes queues to flush after 10 packets
      new_queue(RESET_ALL_QUEUES, 102);
   }
}

void get_ticc_config(unsigned port)
{
   // get the TICC config from the menus

   if(port >= NUM_COM_PORTS) return;
   set_ticc_config(port, 0);   // get current config from menu header
}



double hp_time(char *s)
{
unsigned i, j;

   // convert an HP formatted time string to a normal number by removing
   // embedded commas.  Returns the time as a double.

   j = 0;
   for(i=0; i<strlen(s); i++) {  // remove commas
      if(s[i] != ',') {
         s[j++] = s[i];
      }
   }
   s[j] = 0;

   return atof(s);
}


double ticc_phase(char *id, int ticc_mode, double val, double last_val)
{
   // convert TICC/counter readings to phase values

   if((ticc_mode == 'T') || (ticc_mode == 'D') || (ticc_mode == 'L')) { // TICC is in a timestamp mode
      if((TS_WRAP_INTERVAL != 0.0) && (timestamp_wrap == 0.0)) {   // limit time stamps to TS_WRAP_INTERVAL (100.0) seconds
         val = fmod(val, TS_WRAP_INTERVAL);
         last_val = fmod(last_val, TS_WRAP_INTERVAL);
      }

      val -= last_val;     // convert consecutive time stamps to time interval
      if(val <= 0.0) {     // time stamps wrapped, adjust the interval
         if(timestamp_wrap == 0.0) val += TS_WRAP_INTERVAL;  // !!!!! what if still negative? 
         else                      val += timestamp_wrap; //       ... looping could take forever on a bogus value
      }
   }
   else if(ticc_mode == 'P') {  // time interval between samples on same channel
   }
   else if(ticc_mode == 'H') {  // phase
   }
   else if(ticc_mode == 'I') {  // time interval between two channels
      val -= last_val;
   }
   else if(ticc_mode == 'F') {  // frequency counter
      if(nominal_cha_freq <= 0.0) nominal_cha_freq = NOMINAL_FREQ;
      val = ((val - nominal_cha_freq) / nominal_cha_freq) * pps_adev_period;
   }

   return val;
}


double tie_to_freq(int id, double val)
{
double nominal_freq;
double period;

   // convert time interval error to frequency

   if(id == PPS) {
      nominal_freq = nominal_cha_freq;
      period = pps_adev_period;
   }
   else if(id == OSC) {
      if(rcvr_type == PRS_RCVR) {  // show PPT as frequency
         return val * 10.0E-6 * 1000.0;
      }
      else {
         nominal_freq = nominal_chb_freq;
         period = osc_adev_period;
      }
   }
   else if(id == SEVEN) {
      nominal_freq = nominal_chc_freq;
      period = chc_adev_period;
   }
   else if(id == EIGHT) {
      nominal_freq = nominal_chd_freq;
      period = chd_adev_period;
   }
   else {
      nominal_freq = NOMINAL_FREQ;
      period = 1.0;
   }
period = 1.0;   // !!!!! TIE is always referenced to 1 Hz

   val = (period - (val/1.0e9)) * nominal_freq;
// val = (period + (val/1.0e9)) * nominal_freq;
val -= nominal_freq;  // frequency difference from nominal
   return val;
}


#define TICC_RESET_THRESH  14    // reset queues after this many packets so time intervals will be OK
#define PHASE_WRAP_THRESH  0.50  // percent of phase wrap interval to trigger a phase unwrap (TVB uses 0.80, Timelab uses 0.50)

void decode_ticc_msg(unsigned port)
{
int i;
u08 c;
char val_field[NMEA_MSG_SIZE+1];   // fields extracted from message buffer come here
double val, v;
double vvv;
double cha_offset, chb_offset;
int have_val;
int have_id;
double dt, adt;       // used to determine time interval counter phase wraps

double time1, time2; // data in the debug message
double clock1;
double cal1, cal2;
double tof;
double pic_count;
static double fudge_val = 0.0;
double delta;
static int tick = 0;
int two_ticcs;
u32 packets;

   if(rcvr_type == TICC_RCVR) {  // TICC is the main receiver type
      start_msg_decode(1);
      ++ticc_packets;
   }
   else {  // TICC is an auxiliary input device
      ++packet_count;
      ++ticc_packets;
   }

   if((two_ticc_mode() && (port == TICC_PORT))) two_ticcs = 1;  // two TICCs in use, convert TICC port channel A/B to C/D
   else two_ticcs = 0;

   // reset the data queues shortly after startup.  This makes sure that time
   // interval values that are generated by subtracting consecutive time stamps 
   // are valid
   if((ticc_packets == TICC_RESET_THRESH) && (pause_data == 0)) {
      packets = ticc_packets;
      dont_reset_phase = 2;  // dont reset time stamp or last vals, reset phase wrap info
      new_queue(RESET_ALL_QUEUES, 103);
      dont_reset_phase = 0;
      ticc_packets = (TICC_RESET_THRESH+1);
   }

   ticc_msg[0] = 0;
   if(port == TICC_PORT) {   // counter on the aux port
      for(i=0; i<ticc_wptr; i++) {  // copy message from ticc buffer to ticc_msg
         c = ticc_buf[i];
         ticc_msg[i] = c;
         ticc_msg[i+1] = 0;
      }
   }
   else {   // counter on the main receiver port
      for(i=0; i<tsip_wptr; i++) {  // copy message from tsip buffer to ticc_msg
         c = tsip_buf[i];
         ticc_msg[i] = c;
         ticc_msg[i+1] = 0;
      }
   }

   strupr(ticc_msg);

   val = 0.0;
   have_val = have_id = 0;

   ticc_col = 0;     // index of next char to get from ticc buffer

   time1 = time2 = 0.0;
   clock1 = 0.0;
   cal1 = cal2 = 0.0;
   tof = 0.0;
   pic_count = 0.0;
   if(ticc_mode == 'D') { // process TICC debug message (for time2 and fudge factor calculations)
      if(get_ticc_field()) { // time1 value
         if(is_numeric(ticc_field)) time1 = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // time2 value
         if(is_numeric(ticc_field)) time2 = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // clock1 value
         if(is_numeric(ticc_field)) clock1 = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // cal1 value
         if(is_numeric(ticc_field)) cal1 = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // cal2 value
         if(is_numeric(ticc_field)) cal2 = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // tof value
         if(is_numeric(ticc_field)) tof = hp_time(ticc_field);
      }
      if(get_ticc_field()) { // PICcount
         if(is_numeric(ticc_field)) pic_count = hp_time(ticc_field);
      }
   }

   if(get_ticc_field()) { // get the timestamp/interval/period/frequency field on the line
      if(ticc_type == LARS_TICC) {  // eat the elapsed time count
         if(is_numeric(ticc_field)) {
            if(get_ticc_field()) {  // get the time interval in nsecs
               if(is_numeric(ticc_field)) {
                  val = v = pps_adev_period + atof(ticc_field) / 1.0E9;
if(ticc_mode == 'I') val = v = atof(ticc_field) / 1.0E9;
                  if(rcvr_type != TICC_RCVR) {
                     lars_pps = (DATA_SIZE) atof(ticc_field);
                     have_lars_pps = 777;
                  }
               }
               else return;
            }
            else return;
         }
         else return;
      }
      else if(is_numeric(ticc_field)) {  // it's a number, assume time stamp/interval
         strcpy(val_field, ticc_field);
         val = v = hp_time(ticc_field);

         if((ticc_type == PICPET_TICC) && pet_clock) { // scale PICPET readings to 10 MHz clock equivalent
//sprintf(debug_text, "pet_clock:%g  wrap:%g", pet_clock, timestamp_wrap);
            if(rcvr_type == TICC_RCVR) {
               val /= pet_clock;
               v /= pet_clock;
            }
            else if(ticc_port_open()) {
               val /= pet_clock;
               v /= pet_clock;
            }
         }

         have_val = 1;
      }
      else return;        // line does not start with a number, ignore it

      if(ticc_type == LARS_TICC) {
         if     (strstr(ticc_msg, "WARMUP")) discipline_mode = DIS_MODE_WARMUP;
         else if(strstr(ticc_msg, "NOLOCK")) discipline_mode = DIS_MODE_AUTO_HOLD;
         else if(strstr(ticc_msg, "LOCKED")) discipline_mode = DIS_MODE_NORMAL;
         else                                discipline_mode = DIS_MODE_UNKNOWN;

         if(get_ticc_field()) {  // get the DAC value
            if(is_numeric(ticc_field)) {
               if(rcvr_type == TICC_RCVR) {
                  dac_voltage = (DATA_SIZE) atof(ticc_field); //  / 65536.0 * 100.0;
                  have_dac = 777;
               }
               else {
                  lars_dac = (DATA_SIZE) atof(ticc_field); //  / 65536.0 * 100.0;
                  have_lars_dac = 777;
               }
            }
         }
         else return;

         if(get_ticc_field()) {  // get the temperature value
            if(is_numeric(ticc_field)) {
               if(rcvr_type == TICC_RCVR) {
                  temperature = (DATA_SIZE) atof(ticc_field);
                  have_temperature = 777;
               }
               else {
                  lars_temp = (DATA_SIZE) atof(ticc_field);
                  have_lars_temp = 777;
               }
            }
         }
         else return;
      }
   }

   if(ticc_type == LARS_TICC) ;
   else if(get_ticc_field()) { // get the channel ID string
      have_id = 1;
      if(two_ticcs) {  // this is the second of two TAPR_TICCs in use, convert TICC port channel A/B to C/D
         if     (!strcmp(ticc_field, "CHA")) strcpy(ticc_field, "CHC");
         else if(!strcmp(ticc_field, "CHB")) strcpy(ticc_field, "CHD");
         else if(!strcmp(ticc_field, "TI(A-B)")) strcpy(ticc_field, "TI(C->D)");
      }
   }


   if(!strncmp(ticc_field, "CHA", 3)) {
      chan_a:
      val = ticc_phase("chA", ticc_mode, val, last_ticc_v1);


      if((ticc_mode == 'T') || (ticc_mode == 'L')) {  // convert time stamp interval to phase difference
         vvv = val;
         pps_tie = (val - pps_adev_period) * 1.0E9;
         val = val - pps_adev_period;
         last_cha_interval = vvv;
      }
      else if(ticc_mode == 'P') {  // convert period to phase difference
         pps_tie = (val - pps_adev_period) * 1.0E9;
         last_cha_interval = val;
         val -= pps_adev_period;
      }
      else {  // interval, debug, freq
         pps_tie = (0.0 - val) * 1.0E9;
         last_cha_interval = val;
      }

      add_mtie_point(CHA_MTIE, (double) pps_tie);

      if((ticc_mode == 'I') || (ticc_mode == 'F')) val -= cha_ref;  // !!! optionally remove offset between channels

      cha_offset = val * 1.0E9;
      if(rcvr_type == TICC_RCVR) pps_offset = cha_offset;

      ++cha_count;

if(0 && raw_file) {  // aaaahhhh
   if(fabs(pps_tie) > 50.0) fprintf(raw_file, "#GLITCH chA=%.6f\n", pps_tie);  // TICC_RATE
}
if(0 && debug_file && (cha_count > 0)) {
   fprintf(debug_file, "%.12f chA\n", val);  // write phase to debug file
}

      if(ticc_mode == 'D') {  // doing time2 / fudge calculations
         cha_time2_sum += time2;
         ++cha_time2_count;

         cha_time2 = (float) time2;   // we use the GPS SPEED plot for the chA TIME2 plot
//       have_speed = 1;
sprintf(debug_text3, "%s sum:%.0f  count:%.0f    avg cha_time2:%.3f", 
ticc_field, cha_time2_sum, cha_time2_count, cha_time2_sum/cha_time2_count);
      }

      if(last_ticc_v1) {
         have_pps_offset = 55;
      }

      last_ticc_v1 = v;
      last_cha_ts = v;
////if(debug_file) fprintf(debug_file, "cha_offset: %.12f\n", cha_offset);
      add_pps_adev_point(cha_offset, 0);

if(ticc_type == LARS_TICC) {  // convert DAC setting to frequency offset
   if(have_lars_dac) val = lars_dac;
   else val = dac_voltage;
   val = (val - lars_initv) * 5.0 / 32768.0;  // convert dac value to volts
   val *= lars_gain;   // default 1 Hz/Volt EFC sensitivity
   val += nominal_chb_freq;   // convert EFC to frequency
   val = ticc_phase("chB", 'F', val, val);
   goto lars_freq;
}
   }
   else if(!strncmp(ticc_field, "CHB", 3)) {  
      chan_b:
      val = ticc_phase("chB", ticc_mode, val, last_ticc_v2);

      lars_freq:
      if((ticc_mode == 'T') || (ticc_mode == 'L')) {  // convert time stamp interval to phase
         vvv = val;
         osc_tie = (val - osc_adev_period) * 1.0E9;
         val = val - osc_adev_period;
         last_chb_interval = vvv;
      }
      else if(ticc_mode == 'P') {  // convert period to phase
         osc_tie = (val - osc_adev_period) * 1.0E9;
         last_chb_interval = val;
         val -= osc_adev_period;
      }
      else {
         osc_tie = (0.0 - val) * 1.0E9;
         last_chb_interval = val;
      }

      add_mtie_point(CHB_MTIE, (double) osc_tie);

      if((ticc_mode == 'I') || (ticc_mode == 'F')) val -= chb_ref;  // !!! optionally remove offset between channels 

      chb_offset = val * 1.0E9;
      if(rcvr_type == TICC_RCVR) osc_offset = chb_offset;

      ++chb_count;

if(0 && raw_file) {  // aaaahhhh
   if(fabs(osc_tie) > 50.0) fprintf(raw_file, "#GLITCH chA=%.6f\n", osc_tie);  // TICC_RATE
}

      if(ticc_mode == 'D') {   // doing time2 calculations
         chb_time2_sum += time2;
         ++chb_time2_count;
         chb_time2 = (float) time2;  // we use HEADING plot for chB TIME2 value
//       have_heading = 1;
sprintf(debug_text2, "%s sum:%.0f  count:%.0f    avg chb_time2:%.3f", 
ticc_field, chb_time2_sum, chb_time2_count, chb_time2_sum/chb_time2_count);
      }

      if(last_ticc_v2) have_osc_offset = 55;

      last_ticc_v2 = v;
      last_chb_ts = v;
      add_osc_adev_point(chb_offset, 0);
   }
   else if(!strncmp(ticc_field, "CHC", 3)) {
      chan_c:
      val = ticc_phase("chC", ticc_mode, val, last_ticc_v3);

      if((ticc_mode == 'T') || (ticc_mode == 'L')) {  // convert time stamp interval to phase
         vvv = val;
         chc_tie = (val - chc_adev_period) * 1.0E9;
         val = val - chc_adev_period;
         last_chc_interval = vvv;
      }
      else if(ticc_mode == 'P') {  // convert period to phase
         chc_tie = (val - chc_adev_period) * 1.0E9;
         last_chc_interval = val;
         val -= chc_adev_period;
      }
      else {
         chc_tie = (0.0 - val) * 1.0E9;
         last_chc_interval = val;
      }

      add_mtie_point(CHC_MTIE, (double) chc_tie);

      if((ticc_mode == 'I') || (ticc_mode == 'F')) val -= chc_ref;  // !!! optionally remove offset between channels 

      chc_offset = val * 1.0E9;

      ++chc_count;

      if(last_ticc_v3) have_chc_offset = 55;
      last_ticc_v3 = v;
      last_chc_ts = v;
      add_chc_adev_point(chc_offset, 0);
   }
   else if(!strncmp(ticc_field, "CHD", 3)) {
      chan_d:
      val = ticc_phase("chD", ticc_mode, val, last_ticc_v4);

      if((ticc_mode == 'T') || (ticc_mode == 'L')) {  // convert time stamp interval to phase
         vvv = val;
         chd_tie = (val - chd_adev_period) * 1.0E9;
         val = val - chd_adev_period;
         last_chd_interval = vvv;
      }
      else if(ticc_mode == 'P') {  // convert period to phase
         chd_tie = (val - chd_adev_period) * 1.0E9;
         last_chd_interval = val;
         val -= chd_adev_period;
      }
      else {
         chd_tie = (0.0 - val) * 1.0E9;
         last_chd_interval = val;
      }

      add_mtie_point(CHD_MTIE, (double) chd_tie);


      if((ticc_mode == 'I') || (ticc_mode == 'F')) val -= chd_ref;  // !!! optionally remove offset between channels 

      chd_offset = val * 1.0E9;

      ++chd_count;

      if(last_ticc_v4) have_chd_offset = 55;
      last_ticc_v4 = v;
      last_chd_ts = v;
      add_chd_adev_point(chd_offset, 0);
   }
   else if(!strncmp(ticc_field, "TI(A->B)", 8)) {  // TICC in time interval mode
      if(0 && (v <= 0.0)) {  // kludge to fixup out-of-order timestamps
         v += 1.0;
         val += 1.0;
      }
      goto interval_a;
   }
   else if(!strncmp(ticc_field, "TI(C->D)", 8)) {  // OCTOTICC in time interval mode
      goto interval_b;
   }
   else if(0 && !strncmp(ticc_field, "TI(E->F)", 8)) {  // OCTOTICC in time interval mode
      goto chan_c;
   }
   else if(0 && !strncmp(ticc_field, "TI(G->H)", 8)) {  // OCTOTICC in time interval mode
      goto chan_d;
   }
   else if(!strncmp(ticc_field, "FS", 2)) {    // HP 513xx style femtoseconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      val = val / 1.0E15; // convert femptoseconds to seconds
      v = val; 
      goto interval_counter;
   }
   else if(!strncmp(ticc_field, "PS", 2)) {    // HP 513xx style picoseconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      val = val / 1.0E12; // convert nanoseconds to seconds
      v = val; 
      goto interval_counter;
   }
   else if(!strncmp(ticc_field, "NS", 2)) {    // HP 513xx style nanoseconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      val = val / 1.0E9; // convert nanooseconds to seconds
      v = val; 
      goto interval_counter;
   }
   else if(!strncmp(ticc_field, "US", 2)) {    // HP 513xx microseconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      val = val / 1.0E6; // convert microseconds to seconds
      v = val; 
      if((user_set_ticc_type == 0) && (ticc_type == COUNTER_TICC)) ticc_type = HP_TICC;  
      goto interval_counter;
   }
   else if(!strncmp(ticc_field, "MS", 2)) {    // HP 513xx style milliseconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      val = val / 1.0E3; // convert nanooseconds to seconds
      v = val; 
      goto interval_counter;
   }
   else if(!strncmp(ticc_field, "SEC", 3)) {  // HP 513xx style seconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      goto interval_counter;
   }
   else if(!strcmp(ticc_field, "S")) {     // HP 513xx seconds
      if(strchr(val_field, ':')) return;  // ignore statistics data
      if((user_set_ticc_type == 0) && (ticc_type == COUNTER_TICC)) ticc_type = HP_TICC;  
      goto interval_counter;
   }
   else if(!strcmp(ticc_field, "GHZ")) {  // HP 513xx style freq
      if(strchr(val_field, ':')) return;  // ignore statistics data
      if((user_set_ticc_type == 0) && (ticc_type == COUNTER_TICC)) ticc_type = HP_TICC;  
      val *= 1.0E9;
      v = val;
      goto interval_counter;
   }
   else if(!strcmp(ticc_field, "MHZ")) {  // HP 513xx style freq
      if(strchr(val_field, ':')) return;  // ignore statistics data
      if((user_set_ticc_type == 0) && (ticc_type == COUNTER_TICC)) ticc_type = HP_TICC;  
      val *= 1.0E6;
      v = val;
      goto interval_counter;
   }
   else if(!strcmp(ticc_field, "KHZ")) {  // HP 513xx style freq
      if(strchr(val_field, ':')) return;  // ignore statistics data
      if((user_set_ticc_type == 0) && (ticc_type == COUNTER_TICC)) ticc_type = HP_TICC;  
      val *= 1.0E3;
      v = val;
      goto interval_counter;
   }
   else if(1) {    // generic counter value seen (no channel ID)
      interval_counter:   // !!!!!!!!!!! we need to handle second generic counter
      if(ticc_mode != 'I') {  // timestamp, period, freq
         if(two_ticcs) goto chan_b; // two counters in use, second counter data
         else          goto chan_a; // main counter data
      }

      // time interval mode: handle phase_wraps here
      if(two_ticcs) {  // this data is for the second counter device
         interval_b:
         if(val < 0.0) {   // correct counter race condition
            val += chb_phase_wrap_interval;
            v += chb_phase_wrap_interval;
         }

         if(chb_phase_wrap_interval) {   // unwrap the phase readings
            if(chb_count == 0) dt = 0.0;
            else dt = (v - chb_last_wrap_phase);

            adt = fabs(dt);
            if(adt > (chb_phase_wrap_interval*PHASE_WRAP_THRESH)) {
               if(dt < 0.0) {                 // underflow wrap (e.g., 1 ns to 99 ns)
                  chb_phase_wrap_adj += chb_phase_wrap_interval;
               }
               else {                                    // overflow wrap (e.g., 99 ns to 1 ns)
                  chb_phase_wrap_adj -= chb_phase_wrap_interval;
               }
            }
         }

         chb_last_wrap_phase = v;
         val += chb_phase_wrap_adj;
         v = val;

         goto chan_b; // two TICCs in use, convert TICC port channel A/B to C/D
      }
      else {
         interval_a:
         if(val < 0.0) {   // correct counter race condition
            val += cha_phase_wrap_interval;
            v += cha_phase_wrap_interval;
         }

         if(cha_phase_wrap_interval) {  // unwrap the phase readings
            if(cha_count == 0) dt = 0.0;
            else dt = (v - cha_last_wrap_phase);

            adt = fabs(dt);
            if(adt > (cha_phase_wrap_interval*PHASE_WRAP_THRESH)) {
               if(dt < 0.0) {                 // underflow wrap (e.g., 1 ns to 99 ns)
                  cha_phase_wrap_adj += cha_phase_wrap_interval;  // -= ???
//if(debug_file) fprintf(debug_file, "# new phase -dt: %g\n", cha_phase_wrap_adj);
               }
               else {                                    // overflow wrap (e.g., 99 ns to 1 ns)
                  cha_phase_wrap_adj -= cha_phase_wrap_interval;  // += ???
//if(debug_file) fprintf(debug_file, "# new phase +dt: %g\n", cha_phase_wrap_adj);
               }
            }
//sprintf(debug_text, "cha phase wrap: v:%.12f  last:%.12f  diff:%.12f  adj:%.12f", v,cha_last_wrap_phase, adt, cha_phase_wrap_adj);
         }

         cha_last_wrap_phase = v;
//if(debug_file) fprintf(debug_file, "v: %g -> ", v);
         val += cha_phase_wrap_adj;
         v = val;
if(0 && debug_file) {
   fprintf(debug_file, "%.12g\n", v);
   fflush(debug_file);
}

         goto chan_a;
      }
   }

   if((ticc_mode == 'D') && last_cha_ts && last_chb_ts) {  // TICC debug mode, calculate TIME2 and FUDGEA values
      delta = last_chb_ts - last_cha_ts;
      if(fabs(delta) < 0.50) {  // calculate average time interval value
         fudge_sum += delta;
         ++fudge_count;
      }
      if(fudge_count) fudge_val = fudge_sum / fudge_count;
      else            fudge_val = 0.0;
sprintf(debug_text, "%s sum:%.0f  count:%.0f    avg cha fudge:%.3f", 
"chA", fudge_sum*1.0E12, fudge_count, fudge_val*1.0E12);
      dac_voltage = (float) (delta*1.0E12);   // we use the DAC plot to show FUDGEA
      last_cha_ts = last_chb_ts = 0.0;
   }

   if(have_pps_offset || have_osc_offset || have_chc_offset || have_chd_offset) {  // only start logging time differences are available
      if(rcvr_type == TICC_RCVR) {  // system clock is driving screen updates
         if(sim_file) {
            ++tick;
            if(1 || (tick >= 100)) {  //
               get_norcvr_message();  // aaattt update screen 
               tick = 0;
            }
         }
         else {
            get_norcvr_message();  // aaattt update screen 
         }
      }
   }

   if(sim_file && sim_delay) {  // throttle sim file messages
      Sleep(sim_delay);
   }
   saw_rcvr_msg = 1;
}


void get_ticc_message(unsigned port)
{
u08 c;
int i;
static u08 last_c = 0;

   // This routine buffers up an incoming TICC message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_ticc_msg()
   // Messages can end with 0x0D, 0x0A, or both.

   if(ticc_sim_file) {  //lfs
      return;
   }

   i = SERIAL_DATA_AVAILABLE(port);
   if(i == 0) {
      i = check_com_timer(port);
      
      if(i || (i == DATA_LOSS_REINIT)) {
         com[port].com_data_lost = DATA_LOSS_NO_INIT;  // prevents futile re-init attempts
         reset_com_timer(port);
         init_com(port, 127);
////com[port].com_running = 4;
if(com[port].com_running > 0) com[port].process_com = 4;
//lfs com[port].process_com = 4;
///      set_ticc_config(port, 0);   // get current config from menu header
BEEP(514);
      }
      return;
   }
   else {
      reset_com_timer(port);
   }

   if(port == RCVR_PORT) {  // TICC is the main input decice (/rxi)
      c = get_com_char();
      if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
         com[RCVR_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }
   else {  // TICC is auxiliary input device (/ei=)
      c = get_ticc_char();  // aaattt
      if(com[TICC_PORT].rcv_error) {      // parity/framing/overrun errors
         com[TICC_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }

   last_c = c;

   if(ticc_sync == 0) {    // syncing to start of message, search for a line feed
      if((c == 0x0D) || (c == 0x0A)) {
         ticc_sync = 1;
         get_sync_time();
      }
      ticc_wptr = 0;
      ticc_rptr = 0;
      return;
   }
   else if(ticc_sync == 1) { // 0x0A has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A)) {
         if(ticc_wptr == 0) return; // end-of-line with no data in the message buffer
         goto ticc_end;  // end of message
      }

      if(ticc_wptr < MAX_TSIP) {   // add char to the message buffer
         ticc_buf[ticc_wptr++] = c;
      }
      else {  // buffer overflow, ignore the message
//         ticc_error |= 0x8000;  // aaattt
         goto rst_msg;
      }
   }
   else {  // end of message
      ticc_end:
      if(ticc_wptr) {           // we have a message
         if((ticc_mode == 'I') && plm_freq && (++plm_cycles % plm_freq)) ;   //lfs decimate ticc input
         else decode_ticc_msg(port); // process the message
         packet_end = 1;
      }

      rst_msg:
      ticc_wptr = 0;     // prepare for next message
      ticc_rptr = 0;
      if((c == 0x0D) || (c == 0x0A)) ticc_sync = 1;
      else ticc_sync = 0;
   }
}


void get_rcvr_ticc_message(unsigned port)
{
u08 c;
static u08 last_c = 0;

   // This routine buffers up an incoming tsip message.  When the end of the
   // message is seen, the message is parsed and decoded with decode_tsip_msg()
   // Messages can end with 0x0D, 0x0A, or both.

   if(SERIAL_DATA_AVAILABLE(port) == 0) {
      check_com_timer(port);
      return;
   }
   else {
      reset_com_timer(port);
   }

   if(port == RCVR_PORT) {  // TICC on the main input decice (/rxi)
      c = get_com_char();
      if(com[RCVR_PORT].rcv_error) {      // parity/framing/overrun errors
         com[RCVR_PORT].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }
   else {  // TICC on the auxiliary input device (/ei=)
      c = get_ticc_char();  // aaattt
      if(com[port].rcv_error) {      // parity/framing/overrun errors
         com[port].rcv_error = 0;
         //!!!!!qqqq    goto rst_msg;
      }
   }


   last_c = c;

   if(tsip_sync == 0) {    // syncing to start of message, search for a line feed
      if((c == 0x0D) || (c == 0x0A)) {
         tsip_sync = 1;
         get_sync_time();
      }
      tsip_wptr = 0;
      tsip_rptr = 0;
      return;
   }
   else if(tsip_sync == 1) { // 0x0A has been seen, now build the message
      if((c == 0x0D) || (c == 0x0A)) {
         if(tsip_wptr == 0) return; // end-of-line with no data in the message buffer
         goto tsip_end;  // end of message
      }

      if(tsip_wptr < MAX_TSIP) {   // add char to the message buffer
         tsip_buf[tsip_wptr++] = c;
      }
      else {  // buffer overflow, ignore the message
         tsip_error |= OVFL_ERROR;
         goto rst_msg;
      }
   }
   else {  // end of message
      tsip_end:
      if(tsip_wptr) {           // we have a message
         if((ticc_mode == 'I') && plm_freq && (++plm_cycles % plm_freq)) ;   // decimate ticc input
         else decode_ticc_msg(port); // process the message
         packet_end = 1;
      }

      rst_msg:
      tsip_wptr = 0;     // prepare for next message
      tsip_rptr = 0;
      if((c == 0x0D) || (c == 0x0A)) tsip_sync = 1;
      else tsip_sync = 0;
   }
}


//
//
//   Information display routines
//
//


void show_cable_delay()
{
double val;
char *s;

   if(zoom_screen) return;
   if(text_mode && first_key) return;
   if(!have_cable_delay) return;

   if(0 && (rcvr_type == RFTG_RCVR)) {
      s = "ft";
      val = cable_delay;
   }
   else {
      s = "ns";
      val = cable_delay*1.0E9;
   }

   if     (val >= 100000000.0) sprintf(out, "Dly:%11.0f %s", val, s);
   else if(val >= 10000000.0)  sprintf(out, "Dly:%11.1f %s", val, s);
   else if(val >= 1000000.0)   sprintf(out, "Dly:%11.2f %s", val, s);
   else if(val >= 100000.0)    sprintf(out, "Dly:%11.3f %s", val, s);
   else if(val >= 10000.0)     sprintf(out, "Dly:%11.4f %s", val, s);
   else if(val >= 1000.0)      sprintf(out, "Dly:%11.5f %s", val, s);
   else                        sprintf(out, "Dly:%11.6f %s", val, s);
   vidstr(VAL_ROW+5, VAL_COL, WHITE, out);
}

void show_test_warning()
{
   erase_screen();
   vidstr(0,0, YELLOW, "Receiver is resetting... this may take a while");
   refresh_page();
   Sleep(3000);
   erase_screen();
   refresh_page();
}

#define ECLIPSE 0.72  // threshold (in degrees) for sun/moon alignment (approx sun/moon size)


int eclipse()
{
double el;
double dist;
int flag;

   // returns 1 if possible solar eclipse
   // returns 2 if possible lunar eclipse
   // return 0 if no eclipse
   if((lat == 0.0) && (lon == 0.0)) {
      eclipse_flag = 0;
      return 0;
   }

   flag = last_eclipse;
// last_eclipse = eclipse_flag;
   if((sun_el > 0.0) && (moon_el > 0.0)) {  // sun and moon are up
      if(fabs(sun_el - moon_el) > ECLIPSE) {  // elevation difference too bih
         eclipse_flag = 0;
         return 0;
      }
      if(fabs(sun_az - moon_az) > ECLIPSE) {  // azimuth difference too big
         eclipse_flag = 0;
         return 0;
      }

      dist = (sun_el - moon_el) * (sun_el - moon_el);     // used to calculate closest sun/moon point
      dist += ((sun_az - moon_az) * (sun_az - moon_az));
      dist = sqrt(dist);

      eclipse_d1 = eclipse_d2;
      eclipse_d2 = eclipse_d3;
      eclipse_d3 = dist;
//if(log_file) fprintf(log_file, "dist:%.10f  d1:%.10f d2:%.10f d3:%.10f\n", dist, eclipse_d1,eclipse_d2,eclipse_d3);
//if(log_file) fprintf(log_file, "dist:%.10f  az:%g  el:%g \n", dist, sun_az-moon_az,  sun_el-moon_el);

      if(flag < 0) {   // program started up during an eclipse condition
         sprintf(log_text, "#! solar eclipse in progress");
         write_log_tow(1);
         last_eclipse = 1;
      }
      eclipse_flag = 1;
      eclipsed = 1;
      return 1;
   }
   return 0;  // note: lunar code needs work... so we skip it for now

   if(1 || ((moon_el > 0.0) && (sun_el < 0.0))) {  // moon up, sun set
//    el = fabs(sun_el); // fabs(sun_el);
//    if(fabs(el - moon_el) > ECLIPSE) return 0;
//    return 2;

      el = fabs(sun_el) - fabs(moon_el);
      el = fabs(el);
      if(el > ECLIPSE) {
         eclipse_flag = 0;
         return 0;
      }

      el = fabs(sun_az - moon_az) - 180.0;
      if(fabs(el) > ECLIPSE) {
         eclipse_flag = 0;
         return 0;
      }

      if(flag < 0) {
         sprintf(log_text, "#! lunar eclipse in progress");
         write_log_tow(1);
         last_eclipse = 2;
      }
      eclipse_flag = 2;
      return 2;
   }

   eclipse_flag = 0;
   return 0;
}




void send_track_port()
{
int i, j;

   // send message "out" to the TRACK_PORT

   j = strlen(out);
   for(i=0; i<j; i++) {
      sendout(TRACK_PORT, (u08) out[i], ADD_CHAR);
   }
   sendout(TRACK_PORT, 0x0D, ADD_CHAR);
   sendout(TRACK_PORT, 0x0A, ADD_CHAR);
   sendout(TRACK_PORT, 0, FLUSH_COM);
}

void send_prn_azel(int prn)
{
   // send sat az/el out the TRACK_PORT if it is enabled

   if((prn >= 1) && (prn <= MAX_PRN)) {
      sprintf(out, "PRN %3d: %9.3f %9.3f", prn, sat[prn].azimuth, sat[prn].elevation);
   }
   else {  // invalid satellite
      strcpy(out, "PRN: 000");
   }
   send_track_port();
}

int track_object()
{
double moon_dist;
double sun_dist;
double range;
int prn;

   // send moon/sun/sat az/el/range info out the TRACK_PORT if it is enabled

   if(com[TRACK_PORT].process_com && (com[TRACK_PORT].com_running > 0)) ;
   else return 0;

   if(track_port_info & SEND_TIME) {
      gregorian(0, jd_utc);
      sprintf(out, "UTC:  %04d/%02d/%02d %02d:%02d:%02d.%03d", 
         g_year,g_month,g_day, g_hours,g_minutes,g_seconds, (int) (g_frac*1000.0));
      send_track_port();
   }

   if((moon_az || moon_el) && (track_port_info & SEND_MOON)) {
      moon_dist = MoonDist;              // - (earth_radius(lat, alt)*sin(moon_el*PI/180.0));
      sprintf(out, "MOON: %9.5f %9.5f %10.3f", moon_az,moon_el,moon_dist);
      send_track_port();
   }

   if((sun_az || sun_el) && (track_port_info & SEND_SUN)) {
      sun_dist = earth_sun_dist(jd_utc); // - (earth_radius(lat, alt)*sin(sun_el*PI/180.0)); 
      sprintf(out, "SUN:  %9.5f %9.5f %13.3f", sun_az,sun_el,sun_dist);
      send_track_port();
   }

   if((track_port_info & SEND_PRN) && (track_prn > 0) && (track_prn <= MAX_PRN)) {
      prn = track_prn;
      if(sat[prn].tracking) {
         range = 0.0;
         if(have_range) range = sat[prn].range / 1000.0;
         sprintf(out, "PRN:  %3d %7.3f %7.3f %10.4f", prn, sat[prn].azimuth, sat[prn].elevation, range);
         send_track_port();
      }
   }
   if(track_port_info & SEND_HIGHEST) {
      prn = highest_sat();
      if((prn > 0) && (prn <= MAX_PRN)) {
         if(sat[prn].tracking) {
            range = 0.0;
            if(have_range) range = sat[prn].range / 1000.0;
            sprintf(out, "HIGH: %3d %7.3f %7.3f %10.4f", prn, sat[prn].azimuth, sat[prn].elevation, range);
            send_track_port();
         }
      }
   }
   if(track_port_info & SEND_SATS) {
      for(prn=1; prn<=MAX_PRN; prn++) {
         if(sat[prn].tracking) {
            range = 0.0;
            if(have_range) range = sat[prn].range / 1000.0;
            sprintf(out, "PRN:  %3d %7.3f %7.3f %10.4f", prn, sat[prn].azimuth, sat[prn].elevation, range);
            send_track_port();
         }
      }
   }

   return 1;
}

void show_sun_azel(int row, int col)
{
int color;
static double last_sun_az = 0.0;
static double last_sun_el = 0.0;
char c;

   color = GREY;
   if(lat || lon || alt) color = WHITE;
   if(eclipsed) color = YELLOW;
if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;

   if(sun_az > last_sun_az) c = UP_ARROW;
   else if(sun_az < last_sun_az) c = DOWN_ARROW;
   else c = ':';
   last_sun_az = sun_az;
   sprintf(out, "Sun az%c  %9.5f%c", c,sun_az, DEGREES);
   if(com[TRACK_PORT].process_com && (com[TRACK_PORT].com_running > 0)) {
      if(track_port_info & SEND_SUN) strupr(out);
   }
   vidstr(row++, col, color, out);

   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;

   if(sun_el > last_sun_el) c = UP_ARROW;
   else if(sun_el < last_sun_el) c = DOWN_ARROW;
   else c = ':';
   last_sun_el = sun_el;
   sprintf(out, "Sun el%c  %9.5f%c", c, sun_el, DEGREES);
   if(com[TRACK_PORT].process_com && (com[TRACK_PORT].com_running > 0)) {
      if(track_port_info & SEND_SUN) strupr(out);
   }
   vidstr(row++, col, color, out);
}

void show_moon_azel(int row, int col)
{
int color;
static double last_moon_az = 0.0;
static double last_moon_el = 0.0;
static double last_moon_phase = 0.0;
char c;

   color = GREY;
   if(lat || lon || alt) color = WHITE;
   if(eclipsed) color = YELLOW;
//
// MoonPhase = moon_info(jd_utc);
// MoonPhase = moon_phase(jd_utc);

   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   if(moon_az > last_moon_az) c = UP_ARROW;
   else if(moon_az < last_moon_az) c = DOWN_ARROW;
   else c = ':';
   last_moon_az = moon_az;
   sprintf(out, "Moon az%c %9.5f%c", c, moon_az, DEGREES);
   if(com[TRACK_PORT].process_com && (com[TRACK_PORT].com_running > 0)) {
      if(track_port_info & SEND_MOON) strupr(out);
   }
   vidstr(row++, col, color, out);

   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;

   if(moon_el > last_moon_el) c = UP_ARROW;
   else if(moon_el < last_moon_el) c = DOWN_ARROW;
   else c = ':';
   last_moon_el = moon_el;
   sprintf(out, "Moon el%c %9.5f%c", c, moon_el, DEGREES);

   if(com[TRACK_PORT].process_com && (com[TRACK_PORT].com_running > 0)) {
      if(track_port_info & SEND_MOON) strupr(out);
   }
   vidstr(row++, col, color, out);

   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   if(MoonPhase > last_moon_phase) c = UP_ARROW;
   else if(MoonPhase < last_moon_phase) c = DOWN_ARROW;
   else c = ':';
   last_moon_phase = MoonPhase;
   sprintf(out, "Phase%c   %9.5f%%", c, (MoonPhase*100.0));
   color = WHITE;
   if(eclipsed) color = YELLOW;
   vidstr(row++, col, WHITE, out);
}

void show_sun_rise_set(int row, int col)
{
char c1, c2, c3;
int color;
double mage;

   if(sunrise_type == 0) return;
   if(all_adevs) return;

   if(do_moonrise || (sunrise_type[0] == 0)) {
      c1 = c2 = c3 = ' ';
   }
   else c1 = c2 = c3 = tolower(sunrise_type[0]);

   if(sun_file && play_sun_song) {
      c2 = SONG_CHAR;
   }
   if(noon_file && play_sun_song) {
      c3 = SONG_CHAR;
   }

   if(have_sun_times & 0x01) color = WHITE;
   else                      color = GREY;
   if(do_moonrise) sprintf(out, "Moonrise: %02d:%02d:%02d%c", rise_hh,rise_mm,rise_ss,c2);
   else            sprintf(out, "Sunrise:  %02d:%02d:%02d%c", rise_hh,rise_mm,rise_ss,c2);
   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   vidstr(row++, col, color, out);

   if(have_sun_times & 0x02) color = WHITE;
   else                      color = GREY;
   if(do_moonrise) sprintf(out, "Transit:  %02d:%02d:%02d%c", noon_hh,noon_mm,noon_ss,c3);
   else            sprintf(out, "Sun noon: %02d:%02d:%02d%c", noon_hh,noon_mm,noon_ss,c3);
   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   vidstr(row++, col, color, out);

   if(have_sun_times & 0x04) color = WHITE;
   else                      color = GREY;
   if(do_moonrise) sprintf(out, "Moon set: %02d:%02d:%02d%c", set_hh,set_mm,set_ss,c1);
   else            sprintf(out, "Sunset:   %02d:%02d:%02d%c", set_hh,set_mm,set_ss,c1);
   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   vidstr(row++, col, color, out);

   if(do_moonrise) {
//    mage = MoonAge;
      if(new_moon_jd && (jd_utc >= new_moon_jd)) mage = (jd_utc - new_moon_jd);
      else if(MoonAge) mage = MoonAge;
      else mage = moon_age(jd_utc);
      sprintf(out, "Moon age: %8.5fd", mage); // moon_age(jd_utc));
   }
   else {
      eot(jd_utc); // uses NOAA algorithm, but seems a second or so off of NREL's numbers (which I don't fully trust, but included a fudge factor to make them match)
      sprintf(out, "EqTime:  %9.5fm", eot_ofs);
   }
   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   vidstr(row++, col, WHITE, out);

   if((zoom_screen == 0) && (row >= MOUSE_ROW)) return;
   if(zoom_screen == 'I') return;
   if((lat || lon) && ugals) {
      if(ugals > last_ugals) c1 = UP_ARROW;
      else if(ugals < last_ugals) c1 = DOWN_ARROW;
      else c1 = '=';
      sprintf(out, "uGals:   %9.5f%c", ugals,c1);
      vidstr(row++, col, WHITE, out);
   }
}


void show_sun_moon(int row, int col)
{
   sun_moon_shown = 0;
   if(all_adevs) return;

//sprintf(plot_title, "zoom: %c   params:%d", zoom_screen, osc_params);
   sun_moon_shown = col;
   if(luxor) {
      sun_el = sun_posn(jd_utc, 0);
      have_sun_el = 1;
      log_sun_posn();

      if(do_moonrise) calc_moonrise();
      else            calc_sunrise(0.0, 21);
      --row;
   }
   else if(rcvr_type == NO_RCVR) ++row;
   else if(1 && (rcvr_type == RFTG_RCVR) && osc_params) {
      if(zoom_screen == 'C') return;
      if(zoom_screen == 'L') return;
   }
// else if(SCREEN_HEIGHT >= SHORT_SCREEN) ; // ++row;
// if(rcvr_type == TSIP_RCVR) col += 42;  // gggg

   show_sun_azel(row+1, col);
   if(text_mode || (SCREEN_HEIGHT >= MEDIUM_HEIGHT)) {
      show_moon_azel(row+4-1, col);
      show_sun_rise_set(row+3+3, col);
   }
   else if(1 || luxor || (SCREEN_HEIGHT >= SHORT_SCREEN) || (rcvr_type == NO_RCVR)) {
      show_moon_azel(row+3, col);
      show_sun_rise_set(row+3+3, col);
   }
}


#ifdef SIG_LEVELS
void show_max_signals()
{
int row,col;
int prn;
int first_prn, last_prn;
char c[32];
float min, max;
float sum;
float count;
int shown;

#define PRN_PER_LINE 5    // max number of PRNs to show per row

   if(all_adevs) return;
   if(rcvr_type == ACRON_RCVR) return;
   if(rcvr_type == NO_RCVR) return;
   if(rcvr_type == TIDE_RCVR) return;
   if(NO_SATS) return;
   if(zoom_screen) return;

   first_prn = 1;
   last_prn = MAX_PRN;

   for(first_prn=1; first_prn<MAX_PRN; first_prn++) {  // find first sat with signals
      if(max_sat_db[first_prn]) break;
   }

   row = DIS_ROW+0+eofs+5;
   col = DIS_COL;
   sun_moon_shown = col;
   sprintf(out, "Satellite max %s", level_type);
   vidstr(row, col, WHITE, out); 
   ++row;

   sum = count = 0.0F;
   max = 0.0F;
   min = 9999.0F;

   shown = 0;
   prn = first_prn;
   sprintf(out, " %3d: ", prn);
   while(prn <= last_prn) {
      if(shown == 0) {  // start of new row
         while(prn < MAX_PRN) {
            if(max_sat_db[prn]) break;
            ++prn;
         }
         sprintf(out, " %3d: ", prn);
      }
      if((prn >= MAX_PRN) && (max_sat_db[prn] == 0)) break;

      if(max_sat_db[prn]) {
         sprintf(c, "%2d ", (int) (max_sat_db[prn]+0.5F));
         sum += max_sat_db[prn];
         if(max_sat_db[prn] > max) max = max_sat_db[prn];
         if(max_sat_db[prn] < min) min = max_sat_db[prn];
         count += 1.0F;
      }
      else strcpy(c,".. ");
      strcat(out, c);

      ++shown;
      if(shown >= PRN_PER_LINE) {  // end-of-line, start a new row
         vidstr(row, col, WHITE, out); 
         sprintf(out, " %3d: ", prn+1);
         shown = 0;

         ++row;
         if(row >= (queue_row+4)) break;
      }
      prn++;
   }
   if(shown) vidstr(row, col, WHITE, out); 
   else --row;

   if(min >= 9999.0F) min = 0.0F;
   if(count) {
      sum = (sum / count) + 0.50F;
   }
   else sum = 0.0F;

   min += 0.50;
   max += 0.50;

   sprintf(out, " avg: %2d    max: %2d", (int) sum, (int) max);
   ++row;
   vidstr(row, col, WHITE, out); 
}
#endif // SIG_LEVELS



int show_brandy_info(int row, int col)
{
int max_row;
int color;

   color = WHITE;
   max_row = MOUSE_ROW;
   if(zoom_screen == 'D') {
      max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
      col = 3;
   }

   color = WHITE;
   sprintf(out, "Instant phase:   %g          ", inst_phase); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Phase control:   %.6f        ", phase_control_val); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Average phase:   %.6f        ", avg_phase); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Freq control:    %-6d         ", (int) freq_control_val); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Last freq corr:  %g          ", last_freq_corr); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Freq trend:      %g          ", freq_trend); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Last correction: %s          ", last_correction); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Phase status:    0x%02X      ", phase_status); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "PLL constraint:  0x%02X      ", pll_constraint);
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "OSC type:        %s          ", brandy_osc); 
   out[32] = 0;
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   return row;
}


int show_rftg_info(int row, int col)
{
int max_row;
int color;

   color = WHITE;
   max_row = MOUSE_ROW;
   if(zoom_screen == 'D') {
      max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
      col = 3;
   }
   else if(osc_params) ;
   else if((rftg_unit == 0) && have_rftg_unit) { // Rb unit
      if(zoom_screen == 'I') max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
      else if(plot_digital_clock) max_row = (row + 9);
   }

   color = WHITE;
   sprintf(out, "Phase error:        %g       ", rftg_phase_err);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Average phase:      %g       ", rftg_avg_phase);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "APE:                %g       ", rftg_ape);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Delta APE 10 min:   %g       ", rftg_delta_ape_10m);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Sensitivity:        %g       ", rftg_sensitivity);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;


   sprintf(out, "Osc voltage:        %g V     ", rftg_oscv);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   if(rftg_unit == 0) {  // RB
      sprintf(out, "Lamp voltage:       %g V     ", ant_v1);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;

      sprintf(out, "XTAL voltage:       %g V     ", ant_v2);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;
   }
   else {  // XO
      sprintf(out, "Antenna current:    %g mA    ", ant_ma);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;

      sprintf(out, "Antenna fault V1:   %g V     ", ant_v1);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;

      sprintf(out, "Antenna fault V2:   %g V     ", ant_v2);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;

      sprintf(out, "ADC:                %g V     ", rftg_adc);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;

      sprintf(out, "DAC 5 minute avg:   %g V     ", rftg_dac_5min);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;
   }


   sprintf(out, "Freq correction:    %g       ", rftg_freq_corr);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   if(fabs(rftg_time_corr)) {
      sprintf(out, "Time correction:    %g       ", rftg_time_corr);
      vidstr(row++, col, color, out);
      if(row >= max_row) return row;
   }


   sprintf(out, "Elapsed time:       %d secs  ", rftg_elapsed);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;


   sprintf(out, "Delta APE:          %g       ", rftg_delta_ape);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "APE2:               %g       ", rftg_ape2);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Constant APE:       %g       ", rftg_const_ape);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Phase ref:          %g       ", rftg_phase_ref);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;
 

   sprintf(out, "Delta temperature:  %g %cC     ", rftg_delta_temp, DEGREES);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Correction sched:   %d secs  ", rftg_corr_sched);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Warmup time:        %d min   ", rftg_warmup_time);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "Avg sample:         %d min   ", rftg_avg_sample);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "PLL port:           0x%02X     ", rftg_pll_port);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   sprintf(out, "PLD port:           0x%02X     ", rftg_pld_port);
   vidstr(row++, col, color, out);
   if(row >= max_row) return row;

   return row;
}



void show_osc_params(int row,int col)
{
double dac;
double drift;
double tempco;
char c[10];
int prn;
int color;
int max_row;

   if(zoom_screen == 'O') return;
   if(zoom_screen == 'H') return;

   prn = 0;
   c[0] = 0;

   if(all_adevs) {
      if(SCREEN_WIDTH > NARROW_SCREEN)   col += 3;
      else if(small_font == 1) col -= 3;
   }

////   if((rcvr_type == BRANDY_RCVR) && (have_info & MANUF_PARAMS)) {
   if(rcvr_type == BRANDY_RCVR) {
      row = show_brandy_info(row, col);
   }
   else if(rcvr_type == LPFRS_RCVR) {
      max_row = MOUSE_ROW;
      if(zoom_screen == 'D') {
         max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
         col = 3;
      }
//    else if(osc_params) ;
      else if(plot_digital_clock) {
         max_row = (row + 9);
      }
      row = show_lpfrs_info(row,col, max_row);
   }
   else if(rcvr_type == PRS_RCVR) {
      max_row = MOUSE_ROW;
      if(zoom_screen == 'D') {
         max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
         col = 3;
      }
//    else if(osc_params) ;
      else if(plot_digital_clock) {
         max_row = (row + 9);
      }
      row = show_prs_info(row,col, max_row);
   }
   else if(rcvr_type == RFTG_RCVR) {
      row = show_rftg_info(row, col);
   }
   else if(rcvr_type == SA35_RCVR) {
      max_row = MOUSE_ROW;
      if(zoom_screen == 'D') {
         max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
         col = 3;
      }
//    else if(osc_params) ;
      else if(plot_digital_clock) {
         max_row = (row + 9);
      }
      row = show_sa35_info(row,col, max_row);
   }
   else if(rcvr_type == SRO_RCVR) {
      max_row = MOUSE_ROW;
      if(zoom_screen == 'D') {
         max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
         col = 3;
      }
//    else if(osc_params) ;
      else if(plot_digital_clock) {
         max_row = (row + 9);
      }
      row = show_sro_info(row,col, max_row);
   }
   else if(rcvr_type == TICC_RCVR) {
      show_ticc_config(row);
   }
   else if(rcvr_type == X72_RCVR) {
      max_row = MOUSE_ROW;
      if(zoom_screen == 'D') {
         max_row = (SCREEN_HEIGHT / TEXT_HEIGHT) - 3;
         col = 3;
      }
//    else if(osc_params) ;
      else if(plot_digital_clock) {
         max_row = (row + 9);
      }
      row = show_x72_info(row,col, max_row);
   }

   else if(zoom_screen) return;

   else if(rcvr_type == STAR_RCVR) {
      if(have_tc & 0x01) color = WHITE;
      else               color = GREY; 
      sprintf(out, "User time constant: %.0f secs    ", time_constant);
      vidstr(row++, col, color, out);
      if(row >= MOUSE_ROW) goto show_max_sigs;

      if(have_tc & 0x02) color = WHITE;
      else               color = GREY; 
      sprintf(out, "Real time constant: %.0f secs    ", real_time_constant);
      vidstr(row++, col, color, out);
      if(row >= MOUSE_ROW) goto show_max_sigs;

      if(have_gpsdo_ref & 0x02) color = WHITE;
      else                      color = GREY; 
      if(gpsdo_ref) sprintf(out, "GPSDO reference:    AUX PPS    ");
      else          sprintf(out, "GPSDO reference:    GPS        ");
      vidstr(row++, col, color, out);
      if(row >= MOUSE_ROW) goto show_max_sigs;

      if(have_star_hbsq & 0x01) color = WHITE;
      else                     color = GREY;
      sprintf(out, "HBSQ squelch time:  %d mins    ", user_hbsq);
      vidstr(row++, col, color, out);
      if(row >= MOUSE_ROW) goto show_max_sigs;

      if(have_star_hbsq & 0x02) color = WHITE;
      else                     color = GREY;
      sprintf(out, "Time until HBSQ:    %d mins    ", current_hbsq);
      vidstr(row++, col, color, out);
      if(row >= MOUSE_ROW) goto show_max_sigs;

      if(star_type == OSA_TYPE) {
         if(have_star_wtr & 0x01) color = WHITE;
         else                     color = GREY;
         sprintf(out, "Wait to restore:    %d secs    ", star_wtr);
         vidstr(row++, col, color, out);
         if(row >= MOUSE_ROW) goto show_max_sigs;

         if(have_star_wtr & 0x02) color = WHITE;
         else                     color = GREY;
         sprintf(out, "GPS WTR timer:      %d secs    ", star_wtr_timer);
         vidstr(row++, col, color, out);
         if(row >= MOUSE_ROW) goto show_max_sigs;

         if(have_star_wtr & 0x04) color = WHITE;
         else                     color = GREY;
         sprintf(out, "AUX WTR timer:      %d secs    ", star_aux_timer);
         vidstr(row++, col, color, out);
         if(row >= MOUSE_ROW) goto show_max_sigs;
      }
   }
   else if(rcvr_type == TSIP_RCVR) {  //tqtq
      if(have_jam_sync) color = WHITE;
      else color = GREY;
      if(jam_sync < 10.0)       sprintf(out, "Jam sync threshold:   %.3f ns    ", jam_sync);
      else if(jam_sync < 100.0) sprintf(out, "Jam sync threshold:  %.3f ns    ", jam_sync);
      else                      sprintf(out, "Jam sync threshold: %.3f ns    ", jam_sync);
      if(saw_ntpx) vidstr(row++, col, GREY,  out);
      else         vidstr(row++, col, color, out);

      if(have_freq_ofs) color = WHITE;
      else color = GREY;
      if(max_freq_offset < 10.0) sprintf(out, "Max freq offset:      %.3f%s    ", max_freq_offset, ppb_string);
      else                       sprintf(out, "Max freq offset:     %.3f%s    ", max_freq_offset, ppb_string);
      if(saw_ntpx) vidstr(row++, col, GREY,  out);
      else         vidstr(row++, col, color, out);

      if(have_tc) color = WHITE;
      else        color = GREY; 
      sprintf(out, "Time constant:      %.3f secs    ", time_constant);
      vidstr(row++, col, color, out);

      if(have_damp) color = WHITE;
      else          color = GREY; 
      sprintf(out, "Damping factor:       %.3f    ", damping_factor);
      vidstr(row++, col, color, out);

      if(gain_color == YELLOW) color = gain_color;
      else if(have_gain) color = WHITE;
      else color = GREY; 
      sprintf(out, "Osc gain:            %+.6f Hz/V    ", osc_gain);
      vidstr(row++, col, color, out);

      if(have_initv) color = WHITE;
      else           color = GREY; 
      sprintf(out, "Initial DAC voltage: %+.6f V    ", initial_voltage);
      if(saw_ntpx) vidstr(row++, col, GREY,  out);
      else         vidstr(row++, col, color, out);

      if(have_minv) color = WHITE;
      else          color = GREY; 
      sprintf(out, "Min EFC voltage:     %+.6f V    ", min_volts);
      vidstr(row++, col, color, out);

      if(have_maxv) color = WHITE;
      else          color = GREY; 
      sprintf(out, "Max EFC voltage:     %+.6f V    ", max_volts);
      vidstr(row++, col, color, out);

      if(have_dac_range) {
         sprintf(out, "EFC DAC range:       %+.2f to %+.2f V ", min_dac_v, max_dac_v);
         if(saw_ntpx) vidstr(row++, col, GREY,  out);
         else         vidstr(row++, col, WHITE, out);
      }


   
      // Calculate oscillator drift rate per day based upon the dac
      // voltage change over the plot display interval.  This assumes
      // that the temperature is stable.
      dac = plot[DAC].a1;
      drift = (dac * (double) osc_gain) * 24.0*60.0*60.0;  // Hz per day
      sprintf(out, "Osc drift rate: %14.6e parts/day   ", drift/10.0E6F);
      vidstr(row+1, col, WHITE, out);

      // Calculate oscillator freq change with temperature over the plot
      // display interval.  This assumes that the temperature has changed
      // during the display interval.
      tempco = plot[TEMP].a1;  // degrees/sec
      if(tempco) {
         tempco = plot[OSC].a1 / tempco;  // (ppb/sec) divided by (degrees/sec)
         tempco /= (-1.0E9);              // convert ppb/degree C into parts/C
         sprintf(out, "Osc tempco:     %14.6e parts/%cC   ", tempco, DEGREES);
         vidstr(row+2, col, WHITE, out);
      }
   }
   else if(rcvr_type == UCCM_RCVR) {
      if(have_pullin) color = WHITE;
      else            color = GREY; 
      sprintf(out, "Pullin range:       %3d PPB      ", pullin_range);
      vidstr(row++, col, color, out);
   }

   show_max_sigs:
#ifdef SIG_LEVELS
if(rcvr_type != RFTG_RCVR) {
   show_max_signals();
}
#endif

   if(0) {  // alternate osc parameter calculations
      if(view_interval == 0) return;
      if(plot_mag == 0) return;
      if(plot[DAC].stat_count == 0.0) return;
      if(plot[OSC].stat_count == 0.0) return;
      ++row;

      dac = plot[DAC].sum_change / plot[DAC].stat_count / view_interval;
      dac /= plot_mag;
      drift = (dac * (double) osc_gain) * 24.0*60.0*60.0;  // Hz per day
      sprintf(out, "Osc drift rate: %14.6e parts/day   ", drift/10.0E6F);
      vidstr(row++, col, WHITE, out);

      tempco = plot[TEMP].sum_change / plot[TEMP].stat_count / view_interval;
      tempco /= plot_mag;
      if(tempco) {
         tempco = (plot[OSC].sum_change/plot[OSC].stat_count/view_interval) / tempco;  // (ppb/sec) divided by (degrees/sec)
         tempco /= (-1.0E9);              // convert ppb/degree C into parts/C
         sprintf(out, "Osc tempco:     %14.6e parts/%cC   ", tempco, DEGREES);
         vidstr(row++, col, WHITE, out);
      }
   }

   return;
}

int highest_sat()
{
float el;
int prn;
int i;

   // return the PRN of the highest elevation satellite

   prn = 0;
   el = 0.0;
   for(i=1; i<=MAX_PRN; i++) { 
      if(sat[i].tracking > 0) {
         if(sat[i].elevation > el) {
            el = sat[i].elevation;
            prn = i;
         }
      }
   }
   return prn;
}


void warn_info_needed()
{
int i;

   // warn the user we need location and/or UTC offset

   i = 0;
   if((lat != 0.0) || (lon != 0.0)) ;
   else {
      vidstr(VAL_ROW+i,VAL_COL, RED, "No location set.  ");
      ++i;
      vidstr(VAL_ROW+i,VAL_COL, RED, "Use the SL command");
      ++i;
      vidstr(VAL_ROW+i,VAL_COL, RED, "to set it.        ");
      ++i;
      if(rcvr_type == NO_RCVR) ++i;
   }

   if(have_utc_ofs < 0) {    // using estimated value
      vidstr(VAL_ROW+i,VAL_COL, RED, "UTC leapsecond   ");
      ++i;
      vidstr(VAL_ROW+i,VAL_COL, RED, "offset guessed.  ");
      ++i;
      vidstr(VAL_ROW+i,VAL_COL, RED, "Use the /uo=#    ");
      ++i;
      vidstr(VAL_ROW+i,VAL_COL, RED, "command to set it");
   }
}


//
//
//   Satellite info table display stuff
//
//

int ura_title;
int show_short_info;
int info_header_col;
#define COL2 30  // where to show the second row of sat info

struct SAT_SORT {
   int prn;
   double val;
} sat_sort[MAX_PRN+1];


void sort_sat_table()
{
int i, j;
int k;
int m;
double val;

   // Creates a list of sat info values (sig levels, az, or el) sorted in 
   // in ascending ot descending order along with their PRNs.  This list 
   // can be used to display the sat info table columns in sorted order.

   if     (sort_by == SORT_SIGS) ;
   else if(sort_by == SORT_ELEV) ;
   else if(sort_by == SORT_AZ) ;
   else if(sort_by == SORT_DOPPLER) ;
   else if(sort_by == SORT_PRN) ;
   else if(sort_by == SORT_CARRIER) ;
   else if(sort_by == SORT_RANGE) ;
   else if(sort_by == SORT_BIAS) ;
   else if(sort_by == SORT_URA) ;
   else if(sort_by == SORT_STATE) ;
   else return;

   j = 0;

   track_count = 0;
   for(i=1; i<=MAX_PRN; i++) {
      if(sat[i].disabled) ; 
      else if(sat[i].level_msg == 0) continue;  // sat prn not tracked
      ++track_count;

      if     (sort_by == SORT_SIGS)    val = sat[i].sig_level;  // the sat's signal level
      else if(sort_by == SORT_ELEV)    val = sat[i].elevation;  // the sat's elevation
      else if(sort_by == SORT_AZ)      val = sat[i].azimuth;    // the sat's azimuth
      else if(sort_by == SORT_BIAS)    val = sat[i].sat_bias;   // the sat's clock bias 
      else if(sort_by == SORT_PRN)     val = (float) i;         // the sat's PRN
      else if(sort_by == SORT_DOPPLER) {
         val = sat[i].doppler;        // the sat's doppler
      }
      else if(sort_by == SORT_CARRIER) {
         val = sat[i].code_phase;     // the sat's carrier phase
      }
      else if(sort_by == SORT_RANGE) {
         val = sat[i].range;          // the sat's pseudorange
      }
      else if(sort_by == SORT_URA)   {
         val = sat[i].sv_accuracy;    // the sat's ura
      }
      else if(sort_by == SORT_STATE)   {
         val = (double) sat[i].state; // the sat's state
      }
      else val = (double) i;

      if(sort_by == SORT_STATE) ;
      else if(val == 0.0) {  // keep invalid vals at the end of the list
         if(sort_ascend) val = 10.0E20;
         else            val = (-10.0E20);
      }

      if(j == 0) {  // first entry
         sat_sort[j].prn = i;
         sat_sort[j].val = val;
         ++j;
         continue;
      }
      else if(sort_ascend) {  // sort in ascending order
         if(val >= sat_sort[j-1].val) {  // insert at end of list
            sat_sort[j].prn = i;
            sat_sort[j].val = val;
            ++j;
            continue;
         }
      }
      else {  // sort in descending order
         if(val <= sat_sort[j-1].val) {  // insert at end of list
            sat_sort[j].prn = i;
            sat_sort[j].val = val;
            ++j;
            continue;
         }
      }

      for(k=0; k<j; k++) {  // see where this value lies in the list so far
         if(sort_ascend) {
            if(val > sat_sort[k].val) continue;  // it's greater than the current value
         }
         else {
            if(val < sat_sort[k].val) continue;  // it's less than the current value
         }

         for(m=j; m>k; m--) {  // move lower value entries down one position
            sat_sort[m].prn = sat_sort[m-1].prn;
            sat_sort[m].val = sat_sort[m-1].val;
         }

         sat_sort[k].prn = i;    // insert new value in the list
         sat_sort[k].val = val;
         ++j;
         break;
      }
   }
}

int show_info_header(int row, int col)
{
int color;
   // show the sat info table header line

   info_header_col = col;
   if(rcvr_type == CS_RCVR) {
      show_cs_log(row,col, 0);
      last_sat_row = row + MAX_CS_LOGS;
      return 1;
   }
   else if(rcvr_type == LPFRS_RCVR) {
      show_osc_params(row,col);
      return 1;
   }
   else if(rcvr_type == PRS_RCVR) {
      show_osc_params(row,col);
      return 1;
   }
   else if(rcvr_type == SA35_RCVR) {
      show_osc_params(row,col);
      return 1;
   }
   else if(rcvr_type == SRO_RCVR) {
      show_osc_params(row,col);
      return 1;
   }
   else if((rcvr_type == RFTG_RCVR) && have_rftg_unit && (rftg_unit == 0)) {
      show_osc_params(row,col);
      return 1;
   }
   else if(rcvr_type == X72_RCVR) {
      show_osc_params(row,col);
      return 1;
   }
   else if(NO_SATS) {
      return 1;
   }

   sprintf(out, " PRN    ");
   if(sort_by == SORT_PRN) vidstr(row,col, GREEN, out);
   else                    vidstr(row,col, WHITE, out);
   if(sat_cols > 1) {
      if(sort_by == SORT_PRN) vidstr(row,col+COL2, GREEN, out);
      else                    vidstr(row,col+COL2, WHITE, out);
   }
   col += strlen(out);

   sprintf(out, "%cAZ   ", DEGREES);
   if(sort_by == SORT_AZ) vidstr(row,col, GREEN, out);
   else                   vidstr(row,col, WHITE, out);
   if(sat_cols > 1) {
      if(sort_by == SORT_AZ) vidstr(row,col+COL2, GREEN, out);
      else                   vidstr(row,col+COL2, WHITE, out);
   }
   col += strlen(out);

   sprintf(out, "%cEL    ", DEGREES);
   if(sort_by == SORT_ELEV) vidstr(row,col, GREEN, out);
   else                     vidstr(row,col, WHITE, out);
   if(sat_cols > 1) {
      if(sort_by == SORT_ELEV) vidstr(row,col+COL2, GREEN, out);
      else                     vidstr(row,col+COL2, WHITE, out);
   }
   col += strlen(out);

// if(rcvr_type == ESIP_RCVR) level_type = "dBHz";
   sprintf(out, "%s  ", level_type);
   if(sort_by == SORT_SIGS) vidstr(row,col, GREEN, out);
   else                     vidstr(row,col, WHITE, out);
   if(sat_cols > 1) {
      if(sort_by == SORT_SIGS) vidstr(row,col+COL2, GREEN, out);
      else                     vidstr(row,col+COL2, WHITE, out);
   }
   col += strlen(out);
   last_sat_row = row;

   if(have_doppler && (sat_cols <= 1)) {
      sprintf(out, " DOPPLER ");
      if(sort_by == SORT_DOPPLER) vidstr(row,col, GREEN, out);
      else                        vidstr(row,col, WHITE, out);
      if(sat_cols > 1) {
         if(sort_by == SORT_DOPPLER) vidstr(row,col+COL2, GREEN, out);
         else                        vidstr(row,col+COL2, WHITE, out);
      }
      col += strlen(out);
   }

   ura_title = 0;
   out[0] = 0;
   color = WHITE;
   if(show_short_info == 0) {
      if(have_phase && (no_raw_table == 0)) {
         if(jd_obs) strcat(out, " CARRIER  ");
         else       strcat(out, "CODE_PHASE"); // thunderbolt
         if(sort_by == SORT_CARRIER) color = GREEN;
      }
      else if(have_state) {
         if    (have_state == SIRF_STATE)  strcat(out, " STATE   ");
         else if(have_state == UBX_STATE ) strcat(out, "  STATE  ");
         else                              strcat(out, "  STATE   ");
         if(sort_by == SORT_STATE) color = GREEN;
      }

      if(out[0]) {
         vidstr(row,col, color, out);
         col += strlen(out);
      }

      out[0] = 0;
      color = WHITE;
      if(no_raw_table) ;
      else if(have_range) {
         strcat(out, "PSEUDORANGE ");
         if(sort_by == SORT_RANGE) color = GREEN;
         vidstr(row,col, color, out);
         col += strlen(out);
      }
      else if(have_bias) {
         strcat(out, " CLOCK_BIAS ");
         if(sort_by == SORT_BIAS) color = GREEN;
         vidstr(row,col, color, out);
         col += strlen(out);
      }

      out[0] = 0;
      color = WHITE;
      if(have_accu) {
         strcat(out, " URA(m)");
         if(sort_by == SORT_URA) color = GREEN;
         ura_title = 1;
      }
   }
   else if(0 && (ACU_GG || ACU_360) && (sat_cols < 2)) {
      out[0] = 0;
      if(have_accu) {
         strcat(out, " URA(m)");
         if(sort_by == SORT_URA) color = GREEN;
         ura_title = 3;
      }
   }
   else if((rcvr_type == FURUNO_RCVR) && (sat_cols < 2)) {
      out[0] = 0;
      if(have_accu) {
         strcat(out, " URA(m)");
         if(sort_by == SORT_URA) color = GREEN;
         ura_title = 2;
      }
   }
   else if(have_state && (have_doppler == 0)) {
      out[0] = 0;
      if(have_state == UBX_STATE) strcat(out, "  STATE ");
      else                        strcat(out, "STATE ");
      if(sort_by == SORT_STATE) color = GREEN;
   }

   vidstr(row, col, color, out);
   col += strlen(out);
   info_header_col = col;
   return 0;
}

#define SAT_SHOW_ROWS ((max_sat_display>rows_avail)? rows_avail:max_sat_display)   // rows_avail

void erase_sat_table(int row,int col, int col_switch, int col2, int top_row, int rows_avail)
{
int i,j;

   // erase the old sat info table display

   if(zoom_screen == 'I') ;
   else if(sat_cols > 1) {
      i = rows_avail*2;

      for(j=1; j<=i; j++) {  // show spaces for unused satellites
         if(all_adevs && (j > 8)) break;  // only room for 8 sats here

         vidstr(row, col, WHITE, &blanks[TEXT_COLS-COL2]);
         if(small_font == 1) vidstr(row, col, WHITE, "  ..");
         else                vidstr(row, col, WHITE, " ..");
         ++row;

         if(j == col_switch) {
            col = col2;
            row = top_row+1;
         }
         if((col >= col2) && (row > (top_row+rows_avail))) break;
      }
   }
   else {
      for(j=1; j<=SAT_SHOW_ROWS; j++) {  // show spaces for unused satellites
         if(all_adevs && (j > 8)) break;  // only room for 8 sats here
         if((col < (TEXT_COLS/2)) && (row >= MOUSE_ROW)) break;

         vidstr(row, col, WHITE, &blanks[TEXT_COLS-FILTER_COL+1]);
         if(small_font == 1) vidstr(row, col, WHITE, "  ..");
         else                vidstr(row, col, WHITE, " ..");
         ++row;
      }
   }
}


void format_sat_state(int state)
{
char fmt[SLEN+1];

   if(have_state == UBX_STATE) {  // ublox
      if     (state == 0) strcpy(fmt,  "  NO SIG  ");
      else if(state == 1) strcpy(fmt,  "  SEARCH  ");
      else if(state == 2) strcpy(fmt,  "  ACQUIRED");
      else if(state == 3) strcpy(fmt,  "  WEAK SIG");
      else if(state == 4) strcpy(fmt,  "  CODE LOK");
      else if(state == 5) strcpy(fmt,  "  CAR LOK5");
      else if(state == 6) strcpy(fmt,  "  CAR LOK6");
      else if(state == 7) strcpy(fmt,  "  CAR LOK7");
      else                sprintf(fmt, "  UNK:%-3d ", state);
      strcat(out, fmt);
   }
   else if(have_state == SIRF_STATE) {  // SIRF tracking flags
      sprintf(fmt, "   %04X  ", state);
      strcat(out, fmt);
   }
   else if(have_state == STAR_STATE) {
      if     (state == 0) strcpy(fmt, "  SEARCH  ");
      else if(state == 1) strcpy(fmt, "  ACQUIRE ");
      else if(state == 2) strcpy(fmt, "  AGC SET ");
      else if(state == 3) strcpy(fmt, "  PREQ ACQ");
      else if(state == 4) strcpy(fmt, "  BIT SYNC");
      else if(state == 5) strcpy(fmt, "  MSG SYNC");
      else if(state == 6) strcpy(fmt, "  TIME AVL");
      else if(state == 7) strcpy(fmt, "  EPH ACQ ");
      else if(state == 8) strcpy(fmt, "  TRACKING");
      else                strcpy(fmt, "  UNKNOWN ");
      strcat(out, fmt);
   }
   else if(have_state == MOTO_STATE) {
      if     (state == 0) strcpy(fmt, "  SEARCH  ");
      else if(state == 1) strcpy(fmt, "  CODE ACQ");
      else if(state == 2) strcpy(fmt, "  SET AGC ");
      else if(state == 3) strcpy(fmt, "  FREQ ACQ");
      else if(state == 4) strcpy(fmt, "  BIT SYNC");
      else if(state == 5) strcpy(fmt, "  MSG SYNC");
      else if(state == 6) strcpy(fmt, "  TIME ACQ");
      else if(state == 7) strcpy(fmt, "  EPH ACQ ");
      else if(state == 8) strcpy(fmt, "  TRACKING");
      else                strcpy(fmt, "  UNKNOWN ");
      strcat(out, fmt);
   }
}


void show_sat_table(int row,int col, int col_switch, int col2, int top_row, int rows_avail)
{
int prn;
int i, j;
float az;
float el;
char c, cc;
u08 az_dir;
u08 el_dir;

double dop;
double phase;
int state;
float sig;
float clock;
float acc;

int datum_crapum;
int crap_count;
char el_string[10];
char az_string[10];
char bias_string[20];
int len, max_len;
char fmt[256];
int n;

   // show the satellite info table

   datum_crapum = 0;
   crap_count = 0;
   max_len = 0;
   fmt[0] = 0;

   if(ms_row) {  // clear out the "More sats..." line
      vidstr(ms_row,ms_col, WHITE,   "                             ");
      ms_row = ms_col = 0;
   }

   j = 0;

   for(prn=1; prn<=MAX_PRN; prn++) {
      if(sat[prn].disabled) ; 
      else if(sat[prn].level_msg == 0x00) continue;
      if(0 && (zoom_screen == 'I')) ;
      else if(tracked_only) {
         if(sat[prn].tracking <= 0) continue;
         if(sat[prn].health_flag == 1) continue;
      }

      if     (sort_by == SORT_ELEV)    i = sat_sort[j].prn;
      else if(sort_by == SORT_SIGS)    i = sat_sort[j].prn;
      else if(sort_by == SORT_AZ)      i = sat_sort[j].prn;
      else if(sort_by == SORT_PRN)     i = sat_sort[j].prn;
      else if(sort_by == SORT_DOPPLER) i = sat_sort[j].prn;
      else if(sort_by == SORT_CARRIER) i = sat_sort[j].prn;
      else if(sort_by == SORT_RANGE)   i = sat_sort[j].prn;
      else if(sort_by == SORT_BIAS)    i = sat_sort[j].prn;
      else if(sort_by == SORT_STATE)   i = sat_sort[j].prn;
      else if(sort_by == SORT_URA)     i = sat_sort[j].prn;
      else                             i = prn;

      if(zoom_screen == 'I') {  // zoomed sat info
         ++j;
      }
      else if(sat_cols > 1) {   // two column sat info display
         ++j;
         if(j >= (rows_avail*2)) {
            vidstr(row,col, WHITE,   "More sats... click sat table!");
            ms_row = row;
            ms_col = col;
            break;
         }

         if(all_adevs && (j > 8)) break;  // only room for 8 sats here
      } 
      else {  // single column sat info display
         ++j;
         if(j >= SAT_SHOW_ROWS) {
            vidstr(row,col, WHITE,   "                             ");
         }
         if(j > SAT_SHOW_ROWS) { 
            vidstr(row,col, WHITE,   "More sats... click sat table.");
            ms_row = row;
            ms_col = col;
            break;
         }
         else if(row >= (MOUSE_ROW)) {
            vidstr(row,col, WHITE,   "More sats... click sat table ");
            ms_row = row;
            ms_col = col;
            break;
         }

         if(j > SAT_SHOW_ROWS) break;
         if(all_adevs && (j > 8)) break;  // only room for 8 sats here
         if((col < (TEXT_COLS/2)) && (row >= MOUSE_ROW)) break;
      }

      // filter out potentially bogus data
      az = sat[i].azimuth;
      if(az != 0.0) ++datum_crapum;
      if((az < 0.0) || (az > 360.0)) az = 0.0;

      az_dir = sat[i].az_dir;
      if(az_dir == 0) az_dir = ' ';
      else if(az == 0.0) az_dir = ' ';

      el = sat[i].elevation;
      if(el != 0.0) ++datum_crapum;
      if((el < 0.0) || (el > 90.0)) el = 0.0;

      el_dir = sat[i].el_dir;
      if(el_dir == 0) el_dir = ' ';
      else if(el == 0.0) el_dir = ' ';

      dop = sat[i].doppler;
      if(1 || (rcvr_type == ESIP_RCVR)) ;
      else if((dop <= -9999.0) || (dop >= 99999.0)) dop = 0.0;

      phase = sat[i].code_phase;
      state = sat[i].state;
      sig = sat[i].sig_level;
      if((rcvr_type == MOTO_RCVR) || (rcvr_type == SCPI_RCVR)) {
         if(sig > 255.0F) sig = 0.0F;
         if(sig <= (0.0F)) sig = 0.0F;
      }
      else {
         if(sig > 100.0F) sig = 0.0F;
         if(sig <= (-100.0F)) sig = 0.0F;
         if(sig < 0.0F) sig = 0.0F - sig;
      }

      clock = sat[i].sat_bias;

      acc = sat[i].sv_accuracy;

      out[0] = 0;


      if((az == 0.0) && (el == 0.0)) {
         strcpy(el_string, "N/A  ");
         strcpy(az_string, " N/A ");
      }
      else if(rcvr_type == RFTG_RCVR) {
         strcpy(el_string, "N/A  ");
         strcpy(az_string, " N/A ");
      }
      else {
         if(az == 0.0) strcpy(az_string, " N/A ");
         else          sprintf(az_string, "%5.1f", az);

         if(el == 0.0F)      strcpy(el_string,  " N/A");
         else if(el < 10.0F) sprintf(el_string, " %-3.1f", el);
         else                sprintf(el_string, "%-4.1f", el);
         if(el_string[3] == ' ') el_string[3] = el_dir;
         else                    el_string[4] = el_dir;
         el_string[5] = 0;
      }

      bias_string[0] = 0;
      if(have_range) {
         if(sat[i].range == 0.0)         sprintf(bias_string, "    N/A     ");
         else if(rcvr_type == ESIP_RCVR) sprintf(bias_string, "%12.3f", sat[i].range);
         else                            sprintf(bias_string, "%12.3f", sat[i].range);
      }
      else if(clock == 0.0) strcpy(bias_string,  "    N/A    ");
      else                  sprintf(bias_string, "%#11.4g", clock);

      
      // show the sat info columns
      c = gnss_letter(i);
      if(i == plot_prn) cc = '*';  // plotting this sat's az/el/sig
      else              cc = ' ';

      if(sig == 0.0) {
         if(i > 99)   sprintf(out,  "%03d%c%c  %s  %s   N/A",  i,cc,c, az_string, el_string);
         else         sprintf(out, " %02d%c%c  %s  %s   N/A",  i,cc,c, az_string, el_string);
      }
      else if(i > 99) sprintf(out,  "%03d%c%c  %s  %s %5.1f",  i,cc,c, az_string, el_string, sig);
      else            sprintf(out, " %02d%c%c  %s  %s %5.1f",  i,cc,c, az_string, el_string, sig);

      if(have_doppler && (sat_cols <= 1)) {
         if(dop == 0.0F) sprintf(fmt, "      N/A");
//       else if(rcvr_type == ESIP_RCVR) sprintf(fmt, " %8.0f", dop);
         else if((dop <= -999999.0) || (dop >= 9999999.0)) sprintf(fmt, " %8.0f", dop);
         else if((dop <= -99999.0) || (dop >= 999999.0))   sprintf(fmt, " %8.0f", dop);
         else if((dop <= -9999.0) || (dop >= 99999.0))     sprintf(fmt, " %8.1f", dop);
         else                                              sprintf(fmt, " %8.2f", dop);
         strcat(out, fmt);
      }

//    if((rcvr_type == FURUNO_RCVR) && (sat_cols < 2)) {
      if(show_short_info && ura_title && (sat_cols < 2)) {  // FURUNO_RCVR, ACU_GG, and ACU_360
         goto show_accu;  // we have room to show the URA data
      }
      else if(show_short_info == 0) {
         if(have_phase && (no_raw_table == 0)) {
            if     (phase == 0.0)           sprintf(fmt, "    N/A   ");
            else if(phase <= (-1000000.0F)) sprintf(fmt, " %9ld", (long)phase);
            else if(phase <= (-100000.0F))  sprintf(fmt, " %9.1f", phase);
            else if(phase >= (10000000.0F)) sprintf(fmt, " %9ld", (long)phase);
            else if(phase >= (1000000.0F))  sprintf(fmt, " %9.1f", phase);
            else                            sprintf(fmt, " %9.2f", phase);
            strcat(out, fmt);
         }
         else if(have_state) {
            format_sat_state(state);
         }

         if(no_raw_table) ;
         else if(have_bias || have_range) {
            sprintf(fmt, " %s", bias_string);
            strcat(out, fmt);
         }

         show_accu:
         if(have_accu) {
            if(acc <= 0.0)           sprintf(fmt, "  N/A ");
            else if(acc == 255.0)    sprintf(fmt, "  UNKN");
            else if(acc >= 10000.0F) sprintf(fmt, " LARGE");
            else if(acc >= 1000.0F)  sprintf(fmt, " %5.0f", acc);
            else if(acc >= 100.0F)   sprintf(fmt, " %5.1f", acc);
            else                     sprintf(fmt, " %5.2f", acc);
            strcat(out, fmt);
         }
      }
      else if(have_state && (have_doppler == 0)) {
         format_sat_state(state);
      }

      if(sat_cols > 1) {
         if((j == (col_switch+1)) || (row >= MOUSE_ROW)) {  // switch to next column
            if(col >= col2) ; // column already switched            
            else if(zoom_screen == 'I') ;
            else {
               col = col2;
               row = top_row+1;
            }
         }
      }

      if(sat[i].disabled) {               // user disabled satellite
         vidstr(row++, col, BLUE, out);
      }
      else if(sat[i].health_flag == 1) {  // unhealthy sat
         vidstr(row++, col, RED, out);
      }
      else if(sat[i].tracking <= 0) {     // sat is visible but not tracked
         vidstr(row++, col, YELLOW, out);
      }
      else {                              // sat is being tracked
         vidstr(row++, col, GREEN, out);
         ++crap_count;
      }
      last_sat_row = (row+1);

      len = strlen(out);
      if(len > max_len) max_len = len;

      if(plot_title[0]) n = 2;
      else              n = 1;
++n; // !!!!! should only happen on very short screens
      if(row >= (TEXT_ROWS-n)) {
         vidstr(row,col, WHITE, "More sats skipped...");
         break;
      }
   }

   if((rcvr_type == TSIP_RCVR) && (tsip_type == TBOLT_TYPE) && (res_t == 0) && detect_rcvr_type) { 
      if(datum_flag && have_sat_azel && (datum_crapum == 0) && (crap_count > 2)) { 
         tsip_type = STARLOC_TYPE;
         config_msg_ofs();
         have_el_mask = have_amu = 0;
      }
   }
}

void dump_prn_info()
{
int i;

   if(prn_file == 0) return;
   if(new_sat_azel == 0) return;
   new_sat_azel = 0;

   for(i=0; i<=SUN_MOON_PRN; i++) {
      if((sat[i].tracking > 0) || (i == SUN_PRN) || (i == MOON_PRN)) {
         fprintf(prn_file, "%.6f %4d %6.2f %6.2f %6.2f\n", jd_utc, i, sat[i].azimuth, sat[i].elevation, sat[i].sig_level);
      }
   }

   ++prn_count;
   fprintf(prn_file, "# %d\n", prn_count);
   if(prn_flush_mode) fflush(prn_file);
}

void show_satinfo()
{
COORD row, col;
u08 time_exit;
u08 info_under_azel;
int prn;
int col2;
int top_row;
int track_count;
int rows_avail;
int msd;
int max_sat_show;
int col_switch;

   // This routine draws the satellite info table.  It also calls the
   // digital clock display routine (since on small screens the digital clock
   // takes the place of the sat info display).  It also controls the alarm
   // clock operation.

   last_sat_row = SAT_ROW+3;
   msd = max_sat_display;
   max_sat_show = max_sats;
   sun_moon_shown = 0;


   track_count = 0;
   for(prn=1; prn<=MAX_PRN; prn++) {  // count actively tracked satellites
      if(sat[prn].level_msg) ++track_count;
   }

   if(text_mode && first_key) {
      find_sat_changes();
      return;
   }
   
   time_exit = 0;
   print_using = 0;

   if(all_adevs && (zoom_screen != 'I')) {   // screen is showing all the adev tables
      if(text_mode) {
         col = 0;
         row = TEXT_ROWS - 8;
      }
      else {
         if(SCREEN_WIDTH >= WIDE_WIDTH) col = CRIT_COL + 19;
         else                           col = CRIT_COL + 12;
         row = 0;
      }
   }
   else {    // normal screen mode
      col = SAT_COL;
      row = SAT_ROW+eofs;
      if(text_mode) ++row;
      else if((TEXT_HEIGHT <= 14) || (SCREEN_HEIGHT >= MEDIUM_HEIGHT)) ++row;
   }

   if(sound_alarm) {
      if(ticker & 0x01)      time_color = ALARM_COLOR;
      else if(dst_ofs)       time_color = DST_TIME_COLOR;
      else if(time_zone_set) time_color = DST_TIME_COLOR;  // !!! std_time_color is rather dim for the big clock
      else                   time_color = WHITE;
   }

   // if sats are not in use show the osc control info
// if(osc_params || (osc_discipline == 0)) {  
   show_short_info = user_set_short;
   if(zoom_screen == 'I') ;
   else if(osc_params && (all_adevs == SINGLE_ADEVS) && (zoom_screen == 0)) {
      show_osc_params(row, col);
      if(rcvr_type == LPFRS_RCVR) goto no_sat_tables;
      if(rcvr_type == PRS_RCVR) goto no_sat_tables;
      if(rcvr_type == SA35_RCVR) goto no_sat_tables;
      if(rcvr_type == SRO_RCVR) goto no_sat_tables;
      if(rcvr_type == RFTG_RCVR) goto no_sat_tables;
      if(rcvr_type == X72_RCVR) goto no_sat_tables;
      find_sat_changes();
      return;
   }
   else if((rcvr_type == RFTG_RCVR) && (zoom_screen == 'C') && osc_params) ; 
//   else if((rcvr_type == RFTG_RCVR) && (zoom_screen == 'I') && osc_params) ; 
   else if(osc_params) {
     if((rcvr_type == LPFRS_RCVR) || (rcvr_type == PRS_RCVR) || (rcvr_type == SA35_RCVR) || (rcvr_type == SRO_RCVR) || (rcvr_type == RFTG_RCVR) || (rcvr_type == X72_RCVR)) {
        if(zoom_screen == 0) show_osc_params(row,col);
        goto no_sat_tables;
     }
     else show_osc_params(row, col);
     find_sat_changes();
     return;
   }

   info_under_azel = 0;
   if(SHARED_AZEL && (AZEL_BOTTOM+(TEXT_HEIGHT*(8+1)) < SCREEN_HEIGHT)) {  
      if(SCREEN_HEIGHT <= MEDIUM_HEIGHT) {
         info_under_azel = 1;
      }
      else if(plot_watch && plot_digital_clock && ebolt) info_under_azel = 1;
      else if(all_adevs) info_under_azel = 1;
   }

   digital_clock_shown = 0;
   #ifdef DIGITAL_CLOCK
      if(zoom_screen == 'I') ;
//    else if(((plot_digital_clock || all_adevs) && ((all_adevs == SINGLE_ADEVS) || (SCREEN_WIDTH > NARROW_SCREEN))) || (zoom_screen == 'C')) {
      else if((plot_digital_clock && ((all_adevs == SINGLE_ADEVS) || (SCREEN_WIDTH > NARROW_SCREEN))) || (zoom_screen == 'C')) {
         time_exit = show_digital_clock(row, col);
         if((time_exit == 0) && (all_adevs == SINGLE_ADEVS)) info_under_azel = 0;

         // there is room to sneak in the sat info table below the az/el map
         if(info_under_azel) {  
            row = AZEL_BOTTOM/TEXT_HEIGHT;
            col = (AZEL_COL/TEXT_WIDTH) + 5; 
            if(ebolt) ;        
            else if(all_adevs) col -= 2;
         }
         else if(time_exit) { // no room on screen for sat info and digital clock
            if(star_sat_sec()) return;
            find_sat_changes();
            return;
         }
      }
   #endif  // DIGITAL_CLOCK

   if(star_sat_sec()) return;

   if(zoom_screen == 'I') {
      erase_screen();
      show_time_info();
      sun_moon_shown = 0;
      if((lat != 0.0) || (lon != 0.0)) {
         show_sun_moon(VAL_ROW-1,VAL_COL);
      }
      format_lla(lat,lon,alt, VAL_ROW,VAL_COL+22, 1);
      row = 10;
   }
   else if(zoom_screen) {
      find_sat_changes();
      return;
   }

   if(luxor) return;
   if(rcvr_type == ACRON_RCVR) {
      warn_info_needed();
   }
   else if(rcvr_type == NO_RCVR) {
      sun_moon_shown = 0;
      if((lat != 0.0) || (lon != 0.0)) {
         show_sun_moon(VAL_ROW-2,VAL_COL);
      }
      else if(rcvr_type != TICC_RCVR) {
         warn_info_needed();
      }
      if(rcvr_type == ACRON_RCVR) ;
      else return;
   }

   if(zoom_screen == 'I') ;
   else if(all_adevs) {  // if no room to show info,  just check for sat changes
      if(text_mode) {
         find_sat_changes();
         return;
      }

      if(first_key && (row >= PLOT_TEXT_ROW)) {
         find_sat_changes();
         return;
      }

      if((digital_clock_shown || ((row+max_sat_show+1) >= all_adev_row))) {
         if(info_under_azel && ((plot_lla == 0) || (all_adevs == SINGLE_ADEVS))) {  
            row = AZEL_BOTTOM/TEXT_HEIGHT;
            col = (AZEL_COL/TEXT_WIDTH) + 5; 
            if(ebolt) ;        
            else if(all_adevs) col -= 2;
         }
         else {
            find_sat_changes();
            return;
         }
      }
   }

   // draw the sat info table header
   if(max_sat_display == 0) return;

   msd = MOUSE_ROW - (SAT_ROW+1) - 1;
   if(plot_digital_clock) msd = clock_show_row - (SAT_ROW+1) - 3;
   if(sat_cols > 1) --msd;
   max_sat_show = msd;

   top_row = SAT_ROW+1;  //row;
   rows_avail = msd;

   if(zoom_screen == 'I') {  // see where to switch display columns
      col_switch = 0;
   }
   else {
      col_switch = rows_avail;
   }

   col2 = col+COL2;

//sprintf(plot_title, "sat cols:%d  rows:%d  max_sats:%d  msd:%d  tracked:%d  sw:%d  avail:%d top:%d mouse:%d", 
//sat_cols, sat_rows,max_sats,max_sat_display, track_count, col_switch,rows_avail,top_row,MOUSE_ROW);

   // build and show the sat info title string
   show_short_info = user_set_short;
   if(all_adevs) show_short_info = 1;
   if(sat_cols > 1) show_short_info = 2;
// else if(rcvr_type == FURUNO_RCVR) show_short_info = 0;
   if(zoom_screen == 'I') show_short_info = 0;

   if(show_info_header(row,col)) {
      goto no_sat_tables;
   }

   top_row = row;
   ++row;

   if(zoom_screen == 'I') {
      show_short_info = 0;
   }
   else if(info_header_col < 40) {   // we don't have much info to display
      show_short_info = 3;  // ... so allow max sig levels to show
   }

   // erase and draw the sat info display
   sort_sat_table();
   erase_sat_table(row,col, col_switch, col2, top_row, rows_avail);
   show_sat_table(row,col,  col_switch, col2, top_row, rows_avail);


   no_sat_tables:
   // all 0 az el values on tracked sats is what a STARLOC_TYPE does... BASTARDS!
   // more than 3 sats with all sats having az/el = 0,0

   find_sat_changes();

   print_using = 0;
   blank_underscore = 0;

#ifdef SIG_LEVELS
   sun_moon_shown = 0;
   if(zoom_screen == 'I') ;
   else if(zoom_screen == 'D') ;
   else if(zoom_screen == 'O') return;
   else if(zoom_screen == 'H') return;
   else if(show_short_info && (sat_cols <= 1)) {
      if(1 || digital_clock_shown) {
         show_sun_moon(DIS_ROW+0+eofs+4, DIS_COL);
      }
      else {
         show_max_signals();
      }
   }
#endif
}


//
//
// Lat/lon/alt formatting stuff
//
//

char *maidenhead_square(double Lat, double Long)
{
static char mls[16];
int i;
int Ext;
Ext = 2;

   // calculate the Maidenhead grid square
   //
   // Based on code by Yves Goergen, http://unclassified.software/source/maidenheadlocator
   // which was based upon code by Dirk Koopman, G1TLH

   Lat = Lat * 180.0 / PI;
   Long = Long * 180.0 / PI;

   i = 0;
   mls[i] = 0;

   Lat += 90.0;
   Long += 180.0;

   mls[i++] = (char) ('A' + (int) (Long / 20.0));
   mls[i++] = (char) ('A' + (int) (Lat / 10.0));

   Long = fmod(Long, 20.0);
   if(Long < 0.0) Long += 20.0;
   Lat = fmod(Lat, 10.0);
   if(Lat < 0.0) Lat += 10.0;

   mls[i++] = (char) ('0' + (int)(Long / 2.0));
   mls[i++] = (char) ('0' + (int)(Lat / 1.0));
   Long = fmod(Long, 2.0);
   if(Long < 0.0) Long += 2.0;
   Lat = fmod(Lat, 1.0);
   if(Lat < 0.0) Lat += 1.0;

   mls[i++] = (char) ('a' + (int)(Long * 12.0));
   mls[i++] = (char) ('a' + (int)(Lat * 24.0));
   Long = fmod(Long, 1.0 / 12.0);
   if(Long < 0) Long += 1.0/12.0;
   Lat = fmod(Lat, 1.0 / 24.0);
   if(Lat < 0.0) Lat += 1.0/24.0;
   mls[i] = 0;

   if(Ext >= 1) {
      mls[i++] = ' ';
      mls[i++] = (char) ('0' + (int)(Long * 120.0));
      mls[i++] = (char) ('0' + (int)(Lat * 240.0));
      Long = fmod(Long, 1.0/120.0);
      if(Long < 0.0) Long += 1.0 / 120.0;
      Lat = fmod(Lat, 1.0 / 240.0);
      if(Lat < 0.0) Lat += 1.0 / 240.0;
      mls[i] = 0;
   }

   if(Ext >= 2) {
      mls[i++] = ' ';
      mls[i++] = (char) ('A' + (int)(Long * 120.0 * 24.0));
      mls[i++] = (char) ('A' + (int)(Lat * 240.0 * 24.0));
      Long = fmod(Long, 1.0 / 120.0 / 24.0);
      if(Long < 0) Long += 1.0 / 120.0 / 24.0;
      Lat = fmod(Lat, 1.0 / 240.0 / 24.0);
      if(Lat < 0) Lat += 1.0 / 240.0 / 24.0;
      mls[i] = 0;
   }

   return &mls[0];
}


//  UTM conversion code based upon code written by Chuck Gantz- chuck.gantz@globalstar.com
double UTMNorthing;
double UTMEasting;
int UTM_Zone;
char utm_zone_string[32];
static char mgrs_square[3];

int utm_lon_zone(double dLat, double dLon)
{
int zone;

   // longitude must be between -180.00 .. 179.9
   if((dLon < -180.0) || (dLon > 180.0)) return (0); // implies failure: 0 is an invalid utm zone

   zone = (int)((180.0 + dLon) / 6.0 + 1.0);

   if((dLat >= 56.0) && (dLat < 64.0)) { // sw Norge (ie, zone 32V)
     if((dLon >= 3.0) && (dLon < 12.0)) zone = 32;
   }
   else if((dLat >= 72.0 && dLat < 84.0)) {  // special zones for Svalbard
     if     ((dLon >= 0.0)  && (dLon < 9.0))  zone = 31;
     else if((dLon >= 9.0)  && (dLon < 21.0)) zone = 33;
     else if((dLon >= 21.0) && (dLon < 33.0)) zone = 35;
     else if((dLon >= 33.0) && (dLon < 42.0)) zone = 37;
   }

   return zone;
}


char utm_lat_zone(double lat, double lon)
{
   if(lat >= 84.0) { // north polar
      if(lon >= 0.0)                        return 'Z'; // east
      else                                  return 'Y'; // west
   }
   else if((84.0 >= lat) && (lat >= 72.0))  return 'X';
   else if((72.0 > lat)  && (lat >= 64.0))  return 'W';
   else if((64.0 > lat)  && (lat >= 56.0))  return 'V';
   else if((56.0 > lat)  && (lat >= 48.0))  return 'U';
   else if((48.0 > lat)  && (lat >= 40.0))  return 'T';
   else if((40.0 > lat)  && (lat >= 32.0))  return 'S';
   else if((32.0 > lat)  && (lat >= 24.0))  return 'R';
   else if((24.0 > lat)  && (lat >= 16.0))  return 'Q';
   else if((16.0 > lat)  && (lat >= 8.0))   return 'P';
   else if((8.0 > lat)   && (lat >= 0.0))   return 'N';
   else if((0.0 > lat)   && (lat >= -8.0))  return 'M';
   else if((-8.0 > lat)  && (lat >= -16.0)) return 'L';
   else if((-16.0 > lat) && (lat >= -24.0)) return 'K';
   else if((-24.0 > lat) && (lat >= -32.0)) return 'J';
   else if((-32.0 > lat) && (lat >= -40.0)) return 'H';
   else if((-40.0 > lat) && (lat >= -48.0)) return 'G';
   else if((-48.0 > lat) && (lat >= -56.0)) return 'F';
   else if((-56.0 > lat) && (lat >= -64.0)) return 'E';
   else if((-64.0 > lat) && (lat >= -72.0)) return 'D';
   else if((-72.0 > lat) && (lat >= -80.0)) return 'C';
   else if (lat <= (-80.0)) { // south polar
      if(lon >= 0.0)                        return 'B'; // east
      else                                  return 'A'; // west
   }
   else                                     return 'Z';
}

void calc_mgrs_square(int set, int row, int col) 
{
char *l1, *l2;

   //
   // Retrieve the Square Identification (two-character letter code), for the
   // given row, column and set identifier (set refers to the zone set:
   // zones 1-6 have a unique set of square identifiers; these identifiers are
   // repeated for zones 7-12, etc.)
   // See p. 10 of the "United States National Grid" white paper for a diagram
   // of the zone sets.
   // 

   if((set < 0) || (row < 0) || (row > 19) || (col < 0) || (col > 7)) {
      strcpy(mgrs_square, "??");
      return;
   }

   // handle case of last row
   if(row == 0) row = 19;
   else         row -= 1;

   // handle case of last column
   if(col == 0)  col = 7;
   else col -= 1;

   set = (set % 6);
   if(set == 0) set = 6;

   switch (set) {
      case 1:
          l1 = "ABCDEFGH";              // column ids
          l2 = "ABCDEFGHJKLMNPQRSTUV";  // row ids
          break;

      case 2:
          l1 = "JKLMNPQR";
          l2 = "FGHJKLMNPQRSTUVABCDE";
          break;

      case 3:
          l1 = "STUVWXYZ";
          l2 = "ABCDEFGHJKLMNPQRSTUV";
          break;

      case 4:
          l1 = "ABCDEFGH";
          l2 = "FGHJKLMNPQRSTUVABCDE";
          break;

      case 5:
          l1 = "JKLMNPQR";
          l2 = "ABCDEFGHJKLMNPQRSTUV";
          break;

      case 6:
          l1 = "STUVWXYZ";
          l2 = "FGHJKLMNPQRSTUVABCDE";
          break;

      default:
          l1 = "????????";
          l2 = "????????????????????";
          break;
   }

   mgrs_square[0] = l1[col];
   mgrs_square[1] = l2[row];
   mgrs_square[2] = 0;
}


#define DMS_TO_DEC(d,m,s) ((d+(m/60.0)+(s/3600.0))*PI/180.0)

void lla_to_ups(double lat, double lon)
{
double c0;
double tz;
double R;
double dlat;

   // convert lat/lon to Universal Polar Stereographic coords

   dlat = lat;

   lat = fabs(lat);  // !!!!!!! is this correct?

   c0 = (1.0-WGS84_E) / (1.0+WGS84_E);
   c0 = pow(c0, WGS84_E/2.0);
   c0 *= ((2.0*WGS84_A) / sqrt(1.0-eccSquared));

   tz = (1.0 + WGS84_E*sin(lat)) / (1.0 - WGS84_E*sin(lat));
   tz = pow(tz, WGS84_E/2.0);
   tz *= tan(PI/4.0 - lat/2.0);

   R = 0.994 * c0 * tz;

   if(dlat >= 0.0) UTMNorthing = 2000000.0 - R*cos(lon);
   else            UTMNorthing = 2000000.0 + R*cos(lon);

   UTMEasting = 2000000.0 + R*sin(lon);
//sprintf(plot_title, "c0:%f tz:%f R:%f N:%f E:%f", c0,tz,R, UTMNorthing,UTMEasting);
}


int lla_to_utm(double dLatRad, double dLonRad)
{
double dLat;
double dLon;
double dLonWork;
double dCentralMeridian_Rad;
double N;
double T;
double K;
double A;
double M;
int row,col;

   // convert radians to degrees
   dLat = dLatRad * 180.0/PI;
   dLon = dLonRad * 180.0/PI;

   // use dLonWork to make sure the longitude is between -180.00 .. 179.9
   dLonWork = (dLon + 180.0) - ((int)((dLon + 180.0) / 360.0)) * 360.0 - 180.0; // -180.00 .. 179.9;
   // convert degrees to radians
   dLonRad = dLonWork * PI / 180.0;

   // set the UTM zone string
   UTM_Zone = utm_lon_zone(dLat, dLonWork);
   sprintf(utm_zone_string, "%02d%c", UTM_Zone, utm_lat_zone(dLat, dLon));

   if((dLat >= 84.0) || (dLat <= (-80.0))) {  // polar regions
      lla_to_ups(dLatRad, dLonRad);
   }
   else { // normal regions
      // set central meridian
      dCentralMeridian_Rad = ((183.0 - (6.0 * (double)UTM_Zone)) * -1.0) * PI / 180.0;

      N = WGS84_A / sqrt(1.0 - eccSquared * sin(dLatRad) * sin(dLatRad));
      T = tan(dLatRad) * tan(dLatRad);
      K = eccPrimeSquared * cos(dLatRad) * cos(dLatRad);
      A = cos(dLatRad) * (dLonRad - dCentralMeridian_Rad);
      M = WGS84_A * ((1.0 - eccSquared / 4.0 - 3.0 * eccSquared * eccSquared / 64.0 - 5.0 * eccSquared * eccSquared * eccSquared / 256.0) * dLatRad
          - (3.0 * eccSquared / 8.0 + 3.0 * eccSquared * eccSquared / 32.0 + 45.0 * eccSquared * eccSquared * eccSquared / 1024.0) * sin(2.0 * dLatRad)
          + (15.0 * eccSquared * eccSquared / 256.0 + 45.0 * eccSquared * eccSquared * eccSquared / 1024.0) * sin(4.0 * dLatRad)
          - (35.0 * eccSquared * eccSquared * eccSquared / 3072.0) * sin(6.0 * dLatRad));

      UTMEasting = (double)(dScaleFactor * N * (A + (1.0 - T + K) * A * A * A / 6.0
                 + (5.0 - 18.0 * T + T * T + 72.0 * K - 58.0 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

      UTMNorthing = (double)(dScaleFactor * (M + N * tan(dLatRad) * (A * A / 2.0 + (5.0 - T + 9.0 * K + 4 * K * K) * A * A * A * A / 24.0
                  + (61.0 - 58.0 * T + T * T + 600.0 * K - 330.0 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
      if(dLat < 0.0) UTMNorthing += 10000000.0; // 10000000 meter offset for southern hemisphere
   }

   col = (0);
   row = (0);
   strcpy(mgrs_square, "??");

   if(dms == NATO_FMT) {
      row = 1;
      while(UTMNorthing >= 100000.0) {
         UTMNorthing -= 100000.0;
         ++row;
      }
      row = (row % 20);
      UTMNorthing = (double) (int) UTMNorthing;

      col = 0;
      while(UTMEasting >= 100000.0) {
         UTMEasting -= 100000.0;
         ++col;
      }
      col = (col % 8);
      UTMEasting  = (double) (int) UTMEasting;

      calc_mgrs_square(UTM_Zone, row,col);
   }
//sprintf(plot_title, "utm: E:%f(%d) N:%f(%d)  %s  mgrs:%s", UTMEasting,col, UTMNorthing,row, utm_zone_string, mgrs_square);

   return (0);
}

char *dms_fmt(double x)
{
int deg, min;
double sec;
static char s[128+1];
char sign;

   if(x < 0.0) {
      x = 0.0-x;
      sign = '-';
   }
   else sign = '+';

   deg = (int) x;
   min = (int) (60.0 * ((double) x - (double) deg));
   sec = ((x - (double) deg) - ((double) min / 60.0)) * 3600.0;
   sprintf(s, "%c%2dd %02dm %9.6fs", sign, deg, min, sec);
   return &s[0];
}

void format_lla(double lat,double lon,double alt,  int row,int col, int disp_tide)
{
u08 color;
char s[4];
double x;
int deg, min;
double sec;
char c1;
char *lat_s, *lon_s, *alt_s;

// test data for UPS projection
//lat = DMS_TO_DEC(84.0, 17.0, 14.024);
//lon = 0.0-DMS_TO_DEC(132.0, 14.0, 52.761);

//lat = DMS_TO_DEC(73.0, 0.0, 0.0);
//lon = DMS_TO_DEC(44.0, 0.0, 0.0);

//lat = -DMS_TO_DEC(87.0, 17.0, 14.400);
//lon = DMS_TO_DEC(132.0, 14.0, 52.303);
// lon *= (-1.0);

   if(luxor) return;
   if(text_mode && first_key) return;
   if(zoom_screen == 'I') ;
   else if(zoom_screen == 'L') ;
   else if(zoom_screen) return;
   else if(0 && disp_tide && show_tides) {
      goto show_tide_info;
   }

   if((SCREEN_WIDTH <= NARROW_SCREEN) && (col > (TEXT_COLS/2))) {
      if(user_set_ref_lla) {
         lat_s = "LAT:";
         lon_s = "LON:";
         alt_s = "ALT:";
      }
      else {
         lat_s = "Lat:";
         lon_s = "Lon:";
         alt_s = "Alt:";
      }
   }
   else {
      if(user_set_ref_lla) {
         lat_s = "LAT: ";
         lon_s = "LON: ";
         alt_s = "ALT: ";
      }
      else {
         lat_s = "Lat: ";
         lon_s = "Lon: ";
         alt_s = "Alt: ";
      }
   }

   color = WHITE;
   if(minor_alarms & MINOR_BAD_POSN) color = YELLOW;
   else if(minor_alarms & MINOR_SURVEY) {  // self-survey in progress
      color = YELLOW;
   }

   if(lat < 0.0) s[0] = s[2] = 'S';
   else          s[0] = s[2] = 'N';

   if(dms == DMS_FMT) s[1] = 0;
   else if((dms == UTM_FMT) || (dms == NATO_FMT)) {
      lla_to_utm(lat, lon);
   }
   else if(dms == GRAD_FMT) {
      s[0] = 'g';
      s[1] = ' ';
      s[3] = 0;
   }
   else if(dms == MIL_FMT) {
      s[0] = 'i';
      s[1] = ' ';
      s[3] = 0;
   }
   else if(dms == RADIAN_FMT) {
      s[0] = 'r';
      s[1] = ' ';
      s[3] = 0;
   }
   else {
      s[0] = DEGREES;
      s[1] = ' ';
      s[3] = 0;
   }

   if(dms == ECEF_FMT) {
      lla_to_ecef(lat, lon, alt);
      lat_s = "X:";
      lon_s = "Y:";
      alt_s = "Z:";
   }


   if(dms == RADIAN_FMT) x = DABS(lat);
   else if(dms == GRAD_FMT) x = DABS(lat*200.0 / PI);
   else if(dms == MIL_FMT) x = DABS(lat*3200.0 / PI);
   else if(dms == ECEF_FMT) x = ecef_x;
   else x = DABS(lat*RAD_TO_DEG);

   if(plot_loc == 0) sprintf(out, "%s (private)    ", lat_s); // (double) (int) x;
   else if(dms == GRIDSQ_FMT) {
      sprintf(out, "MLS: %s", maidenhead_square(lat, lon));
   }
   else if(dms == UTM_FMT) {
      sprintf(out, "%s:%13.4lf E", utm_zone_string, UTMEasting);
   }
   else if(dms == NATO_FMT) {
      sprintf(out, "%s %s      %05d E", utm_zone_string, mgrs_square, (int) UTMEasting);
   }
   else if(dms == DMS_FMT) {
      deg = (int) x;
      min = (int) (60.0 * ((double) x - (double) deg));
      sec = ((x - (double) deg) - ((double) min / 60.0)) * 3600.0;
      sprintf(out, "%s%2d%c%02d'%06.3f\"%s", lat_s, deg, DEGREES, min, sec, s);
   }
   else if(dms == ECEF_FMT) {
      if(x >= 0.0) sprintf(out, "%s %15.6lf  ", lat_s, x);
      else         sprintf(out, "%s%16.6lf  ", lat_s, x);
   }
   else if(dms == MIL_FMT) {
      sprintf(out, "%s%11.6lf%s", lat_s, x, s);
   }
   else sprintf(out, "%s%11.7lf%s", lat_s, x, s);
   vidstr(row+0, col, color, out);

   if(dms == DMS_FMT) {
      if(lon < 0.0) s[0] = 'W';
      else          s[0] = 'E';
   }
   else {
      if(lon < 0.0) s[2] = 'W';
      else          s[2] = 'E';
   }

   if(dms == RADIAN_FMT) x = DABS(lon);
   else if(dms == GRAD_FMT) x = DABS(lon*200.0 / PI);
   else if(dms == MIL_FMT) x = DABS(lon*3200.0 / PI);
   else if(dms == ECEF_FMT) x = ecef_y;
   else x = DABS(lon*RAD_TO_DEG);

   if(plot_loc == 0) sprintf(out, "%s (private)    ", lon_s); // (double) (int) x;
   else if(dms == GRIDSQ_FMT) {
      out[0] = 0;
   }
   else if(dms == UTM_FMT) {
      if((lat >= (84.0*PI/180)) || (lat <= (-80.0*PI/180.0))) {
         sprintf(out, "%s %13.4lf N", "UPS", UTMNorthing);
      }
      else {
         sprintf(out, "%s %13.4lf N", "UTM", UTMNorthing);
      }
   }
   else if(dms == NATO_FMT) {
      sprintf(out, "%s        %05d N", "MGRS", (int) UTMNorthing);
   }
   else if(dms == DMS_FMT) {
      deg = (int) x;
      min = (int) (60.0 * ((double) x - (double) deg));
      sec = ((x - (double) deg) - ((double) min / 60.0)) * 3600.0;
      if(deg >= 100) {
         lon_s = "Lon:";
         sprintf(out, "%s%3d%c%02d'%06.3f\"%s", lon_s, deg, DEGREES, min, sec, s);
      }
      else {
         sprintf(out, "%s%2d%c%02d'%06.3f\"%s", lon_s, deg, DEGREES, min, sec, s);
      }
   }
   else if(dms == ECEF_FMT) {
      if(x >= 0.0) sprintf(out, "%s %15.6lf  ", lon_s, x);
      else         sprintf(out, "%s%16.6lf  ", lon_s, x);
   }
   else if(dms == MIL_FMT) {
      sprintf(out, "%s%11.6lf%s", lon_s, x, s);
   }
   else sprintf(out, "%s%11.7lf%s", lon_s, x, s);
   vidstr(row+1, col, color, out);

   x = alt;
   if(alt_scale[0] == 'f') x *= (100.0/2.54/12.0); // convert meters to feet
   else if(alt_scale[0] == 'l') x *= LG_PER_METER; // convert meters to linguini

   if(0 && (plot_loc == 0)) sprintf(out, "%s (private)      ", alt_s);  // (double) (int) x;
   else if(dms == UTM_FMT) {
      if(x >= 1000.0) {
         if(alt_scale[0] == 'f')      sprintf(out, "%s%12.4lf'   ", alt_s, x);
         else if(alt_scale[0] == 'l') sprintf(out, "%s%11.4lf lg ", alt_s, x);
         else                         sprintf(out, "%s%12.4lf m ",  alt_s, x);
      }
      else {
         if(alt_scale[0] == 'f')      sprintf(out, "%s%12.4lf'   ", alt_s, x);
         else if(alt_scale[0] == 'l') sprintf(out, "%s%11.4lf lg ", alt_s, x);
         else                         sprintf(out, "%s%12.4lf m ",  alt_s, x);
      }
   }
   else if(dms == ECEF_FMT) {
      if(x >= 0.0) sprintf(out, "%s %15.6lf  ", alt_s, ecef_z);
      else         sprintf(out, "%s%16.6lf  ", alt_s, ecef_z);
   }
   else {
      if(x >= 1000.0) {
         if(alt_scale[0] == 'f')      sprintf(out, "%s%11.4lf'   ", alt_s, x);
         else if(alt_scale[0] == 'l') sprintf(out, "%s%11.4lf lg ", alt_s, x);
         else                         sprintf(out, "%s%12.5lf m ",  alt_s, x);
      }
      else {
         if(alt_scale[0] == 'f')      sprintf(out, "%s%11.7lf'   ", alt_s, x);
         else if(alt_scale[0] == 'l') sprintf(out, "%s%11.4lf lg ", alt_s, x);
         else                         sprintf(out, "%s%12.8lf m ",  alt_s, x);
      }
   }
   if(dms == GRIDSQ_FMT) --row;

   vidstr(row+2, col, color, out);
   vidstr(row+3, col, color, "                   ");

   if(disp_tide && show_tides) { // 
      if(zoom_screen == 'I') row += 3;
      goto show_tide_info;
   }

   if(((lat == 0.0) && (lon == 0.0)) || (ugals == 0.0)) ;  // no tide/gravity data available
   else if(zoom_screen == 'I') {
      row += 3;

      show_tide_info:
      color = WHITE;
      if(zoom_screen == 'I') ++row;
      if(lat_tide > last_lat_tide) c1 = UP_ARROW;
      else if(lat_tide < last_lat_tide) c1 = DOWN_ARROW;
      else c1 = '=';
      sprintf(out, "Lat tide:%7.2lfmm%c", lat_tide, c1);
      vidstr(row++, col, color, out);

      if(lon_tide > last_lon_tide) c1 = RIGHT_ARROW;
      else if(lon_tide < last_lon_tide) c1 = LEFT_ARROW;
      else c1 = '=';
      sprintf(out, "Lon tide:%7.2lfmm%c", lon_tide, c1);
      vidstr(row++, col, color, out);

      if(alt_tide > last_alt_tide) c1 = UP_ARROW;
      else if(alt_tide < last_alt_tide) c1 = DOWN_ARROW;
      else c1 = '=';
      sprintf(out, "Alt tide:%7.2lfmm%c", alt_tide, c1);
      vidstr(row++, col, color, out);

      if(zoom_screen == 'I') ++row;
      if(ugals > last_ugals) c1 = UP_ARROW;
      else if(ugals < last_ugals) c1 = DOWN_ARROW;
      else c1 = '=';
      sprintf(out, "Gravity:%8.2lfuG%c", ugals,c1);
      vidstr(row++, col, color, out);
   }
}

void show_lla(int why)
{
   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(all_adevs && (all_adev_row < (ALL_ROW+5))) return;

   if(lat < (0.0-PI)) return;    // filter out any bogosity
   if(lat > PI) return;
   if(lon < (0.0-PI)) return;
   if(lon > PI) return;
   if(alt > 100000.0) return;
   if(alt < (0.0-100000.0)) return;

   // get a default precise position from the last self-surveyed coordinates
   if((have_initial_posn == 0) && (lla_log == 0) && (lat || lon || alt)) {  
      precise_lat = lat;
      precise_lon = lon;
      precise_alt = alt;
      have_precise_lla = (-3);

      #ifdef BUFFER_LLA
         clear_lla_points(0);
      #endif

      cos_factor = cos(lat);
      if(cos_factor == 0.0) cos_factor = 0.001;
      if(rcvr_mode == RCVR_MODE_HOLD) have_initial_posn = 1;
have_initial_posn = 1;  // ggggggggggg
   }
   
   #ifdef PRECISE_STUFF
      if(lla_file && (gps_status == GPS_FIXES) && have_time && (precision_survey || show_fixes)) {
         fprintf(lla_file, "%-6lu %X %13.8lf  %13.8lf  %8.3lf\n", 
         (unsigned long) tow, gps_status, lat*RAD_TO_DEG, lon*RAD_TO_DEG, alt);
      }

      // user requested a precision survey from the command line
      if(have_initial_posn && have_time && user_precision_survey) {
         if(user_precision_survey == 1) {  // start precise survey
            user_precision_survey = 0;
            start_precision_survey(200);
         }
         else {  // start 3D fix mode
            user_precision_survey = 0;
            start_3d_fixes(4, 20);
            config_screen(2202);
         }
      }
   #endif  // PRECISE_STUFF

   format_lla(lat, lon, alt,  POSN_ROW+1+eofs, POSN_COL, 1);
}


//
//
//   Show alarm and receiver state info column
//
//

void show_critical_alarms()
{
   did_crit = 0;

   if(have_scpi_test) {
      if(scpi_test) {
         sprintf(out, "FAIL: %04X", scpi_test);
         vidstr(info_row++, CRIT_COL, RED, out); 
      }
      else vidstr(info_row++, CRIT_COL, GREEN, "TEST:   OK"); 
      --info_avail;
      did_crit = 1;
//    return;
   }

   if(rcvr_type == RT17_RCVR) {
      if(critical_alarms & CRIT_PWR) vidstr(info_row++, CRIT_COL, RED,   "Power: LOW");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "Power:  OK");
      --info_avail;
      return;
   }
   else if(rcvr_type == SCPI_RCVR) {  // Z3801A STATUS message self test results
      if(have_scpi_self_test) {
         if(scpi_self_test) vidstr(info_row++, CRIT_COL, GREEN, "TEST: PASS"); 
         else               vidstr(info_row++, CRIT_COL, RED,   "TEST: FAIL"); 
         --info_avail;
         did_crit = 1;
      }
      if(have_scpi_int_power) {
         if(scpi_int_power) vidstr(info_row++, CRIT_COL, GREEN, "INTPWR: OK"); 
         else               vidstr(info_row++, CRIT_COL, RED,   "INTPWR:BAD"); 
         --info_avail;
         did_crit = 1;
      }
      if(have_scpi_oven_power) {
         if(scpi_oven_power) vidstr(info_row++, CRIT_COL, GREEN, "OVEN:   OK"); 
         else                vidstr(info_row++, CRIT_COL, RED,   "OVEN:  BAD"); 
         --info_avail;
         did_crit = 1;
      }
      if(have_scpi_ocxo) {
         if(scpi_ocxo) vidstr(info_row++, CRIT_COL, GREEN, "OCXO:   OK"); 
         else          vidstr(info_row++, CRIT_COL, RED,   "OCXO: FAIL"); 
         --info_avail;
         did_crit = 1;
      }
      if(have_scpi_efc) {
         if(scpi_efc) vidstr(info_row++, CRIT_COL, GREEN, "EFC:    OK"); 
         else         vidstr(info_row++, CRIT_COL, RED,   "EFC:  FAIL"); 
         --info_avail;
         did_crit = 1;
      }
      if(have_scpi_gps) {
         if(scpi_gps) vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK"); 
         else         vidstr(info_row++, CRIT_COL, RED,   "GPS:  FAIL"); 
         --info_avail;
         did_crit = 1;
      }
   }

   if(!have_critical_alarms) return;
   if(all_adevs && (SCREEN_WIDTH < MEDIUM_WIDTH)) return;

   did_crit = 1;
   if(rcvr_type == NVS_RCVR) {
      if((critical_alarms & CRIT_GPS) && (nvs_test & 0x10)) vidstr(info_row++, CRIT_COL, RED,   "GPS:   BAD");
      else vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK");
      --info_avail;

      if((critical_alarms & CRIT_GPS) && (nvs_test & 0x20)) vidstr(info_row++, CRIT_COL, RED,   "GLO:   BAD");
      else vidstr(info_row++, CRIT_COL, GREEN, "GLO:    OK");
      --info_avail;
      return;
   }
   else if(rcvr_type == STAR_RCVR) {
      if(critical_alarms & CRIT_GPS)  {
         vidstr(info_row++, CRIT_COL, RED,   "GPS: ALARM");
      }
      else {
         vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK");
      }
      --info_avail;

      if(critical_alarms & CRIT_OCXO) vidstr(info_row++, CRIT_COL, RED,   "OSC:   BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "OSC:    OK");
      --info_avail;
      return;
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(critical_alarms & CRIT_ROM)  vidstr(info_row++, CRIT_COL, RED,   "FLASH: BAD");
      else if(no_eeprom_writes || (eeprom_save == 0))  vidstr(info_row++, CRIT_COL, GREEN, "FLASH:  OK");
      else vidstr(info_row++, CRIT_COL, GREEN, "FLASH: WRT");
      --info_avail;

      if(lte_lite) {
         if(critical_alarms & CRIT_OCXO)  vidstr(info_row++, CRIT_COL, RED,   "TCXO:  DAC");
         else                             vidstr(info_row++, CRIT_COL, GREEN, "TCXO:  OK ");
         --info_avail;
      }
      return;
   }
   else if(rcvr_type == UCCM_RCVR) {
   }
   else {
      if(critical_alarms & CRIT_ROM) vidstr(info_row++, CRIT_COL, RED,   "ROM:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "ROM:    OK");
      --info_avail;

      if(critical_alarms & CRIT_RAM) vidstr(info_row++, CRIT_COL, RED,   "RAM:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "RAM:    OK");
      --info_avail;
   }


   if(rcvr_type == ZODIAC_RCVR) {
      if(critical_alarms & CRIT_RTC) vidstr(info_row++, CRIT_COL, RED,   "RTC:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "RTC:    OK");
      --info_avail;
   }
   else if((rcvr_type == NMEA_RCVR) && (nmea_type == GARMIN_NMEA)) {  // Garmin
      if(critical_alarms & CRIT_RTC) vidstr(info_row++, CRIT_COL, RED,   "RTC:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "RTC:    OK");
      --info_avail;
   }
   else if(rcvr_type == UCCM_RCVR) {
   }
   else if(have_scpi_ocxo == 0) {
      if(critical_alarms & CRIT_OCXO) vidstr(info_row++, CRIT_COL, RED,   "OSC:   BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "OSC:    OK");
      --info_avail;
   }

   if(rcvr_type == BRANDY_RCVR) {
      if(critical_alarms & CRIT_FPGA) vidstr(info_row++, CRIT_COL, RED,   "HW:    BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "HW:     OK");
      --info_avail;
   }
   else if(rcvr_type == RFTG_RCVR) {
      if(critical_alarms & CRIT_FPGA) vidstr(info_row++, CRIT_COL, RED,   "TEMP:  BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "TEMP:   OK");
      --info_avail;

      if(critical_alarms & CRIT_GPS) vidstr(info_row++, CRIT_COL, RED,   "GPS:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK");
      --info_avail;
      return;
   }
   else if((rcvr_type == SCPI_RCVR) && (scpi_type != NORTEL_TYPE) && (have_scpi_gps == 0)) {
      if(critical_alarms & CRIT_GPS) vidstr(info_row++, CRIT_COL, RED,   "GPS:   BAD");
      else                           vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK");
      --info_avail;
   }
   else if(rcvr_type == UCCM_RCVR) { 
//    if(critical_alarms & CRIT_GPS) vidstr(info_row++, CRIT_COL, RED,   "GPS:   BAD");
//    else                           vidstr(info_row++, CRIT_COL, GREEN, "GPS:    OK");
//    --info_avail;
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(critical_alarms & CRIT_FPGA) vidstr(info_row++, CRIT_COL, RED,   "DSP:   BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "DSP:    OK");
      --info_avail;
   }
   else {
      if(critical_alarms & CRIT_FPGA) vidstr(info_row++, CRIT_COL, RED,   "FPGA:  BAD");
      else                            vidstr(info_row++, CRIT_COL, GREEN, "FPGA:   OK");
      --info_avail;
   }

   if(have_scpi_int_power == 0) {
      if(critical_alarms & CRIT_PWR)     vidstr(info_row++, CRIT_COL, RED,   "Power: BAD");
      else                               vidstr(info_row++, CRIT_COL, GREEN, "Power:  OK");
      --info_avail;
   }
}


void show_minor_alarms()
{
int bad_mask;
char s[80];
double jd;
int color;

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(rcvr_type == NO_RCVR) return;

   // minor alarm info
   if(rcvr_type == TICC_RCVR) {
      info_avail = (queue_row - info_row);
   }
   if((zoom_screen == 0) && (info_avail <= 0)) return;

   if(rcvr_type == PRS_RCVR) {
      info_row = show_prs_status(info_row,MINOR_COL, queue_row);
      info_avail = (queue_row - info_row);
      return;
   }
   else if(rcvr_type == X72_RCVR) {
      info_row = show_x72_status(info_row,MINOR_COL, queue_row);
      info_avail = (queue_row - info_row);
      return;
   }

   if(!have_eeprom) ; 
   else if(!have_critical_alarms) ;
   else if(rcvr_type == NVS_RCVR) ;
   else if(rcvr_type == RFTG_RCVR) ;
   else if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == VENUS_RCVR) ;
   else {
      if(minor_alarms & MINOR_EEPROM) vidstr(info_row++, MINOR_COL, RED,        "EEPROM BAD   ");
      else                            vidstr(info_row++, MINOR_COL, GREEN,      "EEPROM  OK   ");
      --info_avail;
   }

   if((zoom_screen == 0) && (info_avail <= 0)) return;

   if(rcvr_type == THERMO_RCVR) {
      return;
   }
   else if(rcvr_type == TICC_RCVR) {
      info_row = show_ticc_config(info_row);
      info_avail = (queue_row - info_row);  
      return;
   }
   else if(rcvr_type == CS_RCVR) {
      ++info_avail;  // this gets undone down below
   }
   else if(rcvr_type == LPFRS_RCVR) {
      ++info_avail;  // this gets undone down below
   }
   else if(rcvr_type == PRS_RCVR) {
      ++info_avail;  // this gets undone down below
   }
   else if(rcvr_type == SA35_RCVR) {
      ++info_avail;  // this gets undone down below
   }
   else if(rcvr_type == SRO_RCVR) {
      ++info_avail;  // this gets undone down below
   }
   else if(!have_antenna) {
      if(rcvr_type == TIDE_RCVR) {
         vidstr(info_row++, MINOR_COL, GREY, "Antenna: none ");
      }
      else {
         vidstr(info_row++, MINOR_COL, GREY, "Antenna unkn  ");
      }
   }
   else if((rcvr_type == TM4_RCVR) && have_tm4_antenna && (tm4_antenna == 0)) {
      vidstr(info_row++, MINOR_COL, YELLOW,"Ant: disabled "); 
   }
   else if((rcvr_type == FURUNO_RCVR) || (rcvr_type == RFTG_RCVR) || (rcvr_type == STAR_RCVR) || (rcvr_type == TAIP_RCVR) || (rcvr_type == TM4_RCVR) || (rcvr_type == TRUE_RCVR) || (rcvr_type == ZYFER_RCVR)) {
      if(minor_alarms & MINOR_ANT_NO_PWR) vidstr(info_row++, MINOR_COL, RED,  "Antenna alarm "); 
      else                                vidstr(info_row++, MINOR_COL, GREEN,"Antenna OK    "); 
   }
   else if(SV6_FAMILY) {
      if(minor_alarms & MINOR_ANT_NO_PWR) vidstr(info_row++, MINOR_COL, RED,  "Antenna alarm "); 
      else                                vidstr(info_row++, MINOR_COL, GREEN,"Antenna OK    "); 
   }
   else if((minor_alarms & MINOR_ANT_OPEN) && (minor_alarms & MINOR_ANT_SHORT)) {
      vidstr(info_row++, MINOR_COL, YELLOW,"Antenna no pwr"); 
   }
   else if(minor_alarms & MINOR_ANT_OPEN)  vidstr(info_row++, MINOR_COL, YELLOW,"Antenna open  ");
   else if(minor_alarms & MINOR_ANT_SHORT) vidstr(info_row++, MINOR_COL, RED,   "Antenna short ");
   else                                    vidstr(info_row++, MINOR_COL, GREEN, "Antenna OK    ");
   --info_avail;

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_almanac) {
      if(minor_alarms & MINOR_ALMANAC) vidstr(info_row++, MINOR_COL, YELLOW,    "No almanac   ");
      else                             vidstr(info_row++, MINOR_COL, GREEN,     "Almanac OK   ");
      --info_avail;
   }

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(minor_alarms & MINOR_OSC_CTRL)  {
      if(TIMING_RCVR)                   vidstr(info_row++, MINOR_COL, RED,           "Unk alarm 0x10");
      else if(rcvr_type == BRANDY_RCVR) vidstr(info_row++, MINOR_COL, RED,           "Freq ctrl err ");
      else if(rcvr_type == RFTG_RCVR)   vidstr(info_row++, MINOR_COL, RED,           "OSC LOCK BAD  ");
      else if(rcvr_type == ZYFER_RCVR)  vidstr(info_row++, MINOR_COL, YELLOW,        "TFOM > 4      ");
      else if(osc_control_on)           vidstr(info_row++, MINOR_COL, OSC_PID_COLOR, "OSC PID CTRL  ");
      else                              vidstr(info_row++, MINOR_COL, RED,           "Undisciplined ");
      --info_avail;
   }
   else if(rcvr_type == ESIP_RCVR) {
      if(have_traim) {
         if(traim_mode == 0) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   OFF    ");  
         else if(traim_deleted) {
            if(traim_deleted == 1) sprintf(out, "REMOVED %d SAT  ", traim_deleted);
            else                   sprintf(out, "REMOVED %d SATS ", traim_deleted);
            vidstr(info_row++, MINOR_COL, YELLOW, out);
         }
         else if(traim_mode == 1) {
            if     (traim_alarm == 0) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   NORMAL ");
            else if(traim_alarm == 1) vidstr(info_row++, MINOR_COL, RED,       "TRAIM   ALARM  ");
            else if(traim_alarm == 2) vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNAVAIL");
            else                      vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNKALRM");
         }
         else vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNKMODE");  
         --info_avail;
      }
   }
   else if(rcvr_type == FURUNO_RCVR) {
      if(have_traim) {
         if(traim_mode == 0) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   OFF    ");  
         else if(traim_deleted) {
            sprintf(out, "TRAIM   PRN %-3d", traim_deleted);
            vidstr(info_row++, MINOR_COL, RED, out);
         }
         else if(traim_mode == 1) {
            if     (traim_alarm == 0) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   NORMAL ");
            else if(traim_alarm == 1) vidstr(info_row++, MINOR_COL, RED,       "TRAIM   ALARM  ");
            else if(traim_alarm == 2) vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNAVAIL");
            else                      vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNKALRM");
         }
         else vidstr(info_row++, MINOR_COL, YELLOW,    "TRAIM   UNKMODE");  
         --info_avail;
      }
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(have_traim) {
         sprintf(out, "TRAIM:%5dns  ", traim_threshold);
         if(traim_mode == 0)        vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   OFF    ");  
         else if(traim_status == 0) vidstr(info_row++, MINOR_COL, GREEN,     out); 
         else if(traim_status == 1) vidstr(info_row++, MINOR_COL, RED,       "TRAIM   ALARM  "); 
         else  {
            sprintf(out, "TRAIM   Unk:%-3d", traim_status);
            vidstr(info_row++, MINOR_COL, YELLOW, out);
         }
         --info_avail;
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      if(have_traim) {
         if     (traim_mode == 0) vidstr(info_row++, MINOR_COL, GREEN,     "RAIM    OFF    ");  
         else if(traim_mode == 1) vidstr(info_row++, MINOR_COL, GREEN,     "RAIM    ON     ");  
         else if(traim_mode == 2) vidstr(info_row++, MINOR_COL, GREEN,     "RAIM    FDE    ");  
         else if(traim_mode == 3) vidstr(info_row++, MINOR_COL, GREEN,     "RAIM    ON+FDE ");  
         --info_avail;
      }
   }
   else if(rcvr_type == RFTG_RCVR) {
      if(minor_alarms & MINOR_DISCIPLINE) vidstr(info_row++, MINOR_COL, YELLOW, "PPS err LARGE  ");  
      else                                vidstr(info_row++, MINOR_COL, GREEN,  "PPS err OK     ");  
      --info_avail;

      if(minor_alarms & MINOR_WARMUP)     vidstr(info_row++, MINOR_COL, YELLOW, "Warmup  FAILED ");  
      else                                vidstr(info_row++, MINOR_COL, GREEN,  "Warmup  OK     ");  
      --info_avail;

      if(minor_alarms & MINOR_INACTIVE)   vidstr(info_row++, MINOR_COL, YELLOW, "Mode    STANDBY");  
      else                                vidstr(info_row++, MINOR_COL, GREEN,  "Mode    ACTIVE ");  
      --info_avail;

      if(minor_alarms & MINOR_HOLDOVER)   vidstr(info_row++, MINOR_COL, YELLOW, "Holdover > 8hrs");  
      else                                vidstr(info_row++, MINOR_COL, YELLOW, "               ");  
      --info_avail;
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(have_traim) {
         sprintf(out, "TRAIM:%5dns  ", traim_threshold);
         if     (traim_mode == 0)   vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   OFF    ");  
         else if(traim_status == 0) vidstr(info_row++, MINOR_COL, GREEN, out);
         else if(traim_status == 1) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   DETECT ");
         else if(traim_status == 2) vidstr(info_row++, MINOR_COL, GREEN,     "TRAIM   ISOLATE");
         else  {
            sprintf(out, "TRAIM   Unk:%-3d", traim_status);
            vidstr(info_row++, MINOR_COL, YELLOW, out);
         }
         --info_avail;
      }
   }
   else if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == UCCM_RCVR) ;
   else if(lte_lite) ;
   else if(GPSDO) {
      vidstr(info_row++, MINOR_COL, GREEN,      "Discipline OK ");
      --info_avail;
   }

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_saved_posn) {
      if(minor_alarms & MINOR_BAD_POSN) vidstr(info_row++, MINOR_COL, RED,        "Saved posn BAD");
      else                              vidstr(info_row++, MINOR_COL, GREEN,      "Saved posn OK ");
      --info_avail;
   }

   if(have_tracking) {
      if(minor_alarms & MINOR_NO_TRACK) {
         if(rcvr_type == BRANDY_RCVR) vidstr(info_row++, MINOR_COL, YELLOW,     "Posn interrupt");
         else                         vidstr(info_row++, MINOR_COL, RED,        "No sats usable");
      }
      else vidstr(info_row++, MINOR_COL, GREEN,      "Tracking sats ");
      --info_avail;
   }

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_saved_posn) {
      if(minor_alarms & MINOR_NO_POSN) vidstr(info_row++, MINOR_COL, RED,        "No saved posn ");
      else                             vidstr(info_row++, MINOR_COL, GREEN,      "Position saved");
      --info_avail;
   }

if(leap_dumped) ;
else if(rcvr_type == ZODIAC_RCVR) return;
         
   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_leap_info || leap_dumped) {
      guessed_leap_days = ' ';
      if(!have_leap_days) guess_leap_days();

      if(leap_days >= LEAP_THRESH) sprintf(s, "LEAP: Pending!");
      else if(leap_days >= 100) {
         if(guessed_leap_days == ' ') sprintf(s, "LEAP: %3u days", leap_days);
         else                         sprintf(s, "LEAP:%3u days%c", leap_days, guessed_leap_days);
      }
      else if(leap_days >= 10)  sprintf(s, "LEAP: %2u days%c", leap_days, guessed_leap_days);
      else if(leap_days >= 4)   sprintf(s, "LEAP: %1u days%c ", leap_days, guessed_leap_days);
      else if(leap_days >= 0) {
         jd = (jd_leap + jtime(0,0,0,1.0) - jd_utc) * 24.0;
#define LEAP_ROUND 0.50
         if(jd > 100.0) {  // should never happen (except STAR_RCVR with loss of signal)
            sprintf(s, "LEAP: PENDING!");
         }
         else if(have_jd_leap && (jd >= 0.0)) {
            if(jd >= 1.0) {
               sprintf(s, "LEAP:%3d hours", (int) (jd+LEAP_ROUND));
            }
            else {
               jd *= 60.0;
               if(jd >= 1.0) {
                  sprintf(s, "LEAP: %2d mins!", (int) (jd+LEAP_ROUND));
               }
               else {
                  jd *= 60.0;
                  sprintf(s, "LEAP: %2d secs!", (int) (jd+LEAP_ROUND));
               }
            }
         }
         else {
            sprintf(s, "LEAP: TODAY!  ");
         }
      }
      else sprintf(s, "LEAP: PENDING!");

      if(minor_alarms & MINOR_LEAP_PEND) vidstr(info_row++, MINOR_COL, YELLOW,     s);
      else if(leap_dumped)               vidstr(info_row++, MINOR_COL, YELLOW,     "LEAP: captured");
      else                               vidstr(info_row++, MINOR_COL, GREEN,      "No leap pend  ");
      --info_avail;
   }

if(rcvr_type == UBX_RCVR) return;
if(rcvr_type == ZODIAC_RCVR) return;

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_op_mode) {
      if(minor_alarms & MINOR_TEST_MODE) vidstr(info_row++, MINOR_COL, RED,        "Cal mode set  ");
      else                               vidstr(info_row++, MINOR_COL, GREEN,      "Normal op mode");
      --info_avail;
   }


   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(have_osc_age) {
      if(res_t) {
         if(minor_alarms & MINOR_OSC_AGE) vidstr(info_row++, MINOR_COL, RED,     "Unk alarm 0x01");
         else                             vidstr(info_row++, MINOR_COL, GREY,    "              ");
      }
      else if((rcvr_type == NMEA_RCVR) && (nmea_type == GARMIN_NMEA)) {  // Garmin
         if(minor_alarms & MINOR_OSC_AGE) vidstr(info_row++, MINOR_COL, RED,     "OSC drifting  ");
         else                             vidstr(info_row++, MINOR_COL, GREEN,   "OSC stable    ");
      }
      else if(lte_lite) {
         if(minor_alarms & MINOR_OSC_AGE) vidstr(info_row++, MINOR_COL, RED,     "TCXO V fault  ");
         else                             vidstr(info_row++, MINOR_COL, GREEN,   "TCXO V OK     ");
      }
      else {
         if(minor_alarms & MINOR_OSC_AGE) vidstr(info_row++, MINOR_COL, RED,     "OSC age alarm ");
         else                             vidstr(info_row++, MINOR_COL, GREEN,   "Normal OSC age");
      }
      --info_avail;
   }

   if((zoom_screen == 0) && (info_avail <= 0)) return;
   if(1 || (SCREEN_HEIGHT >= MEDIUM_HEIGHT) || (small_font && (SCREEN_HEIGHT > SHORT_SCREEN))) { // windows uses small font,  so this fits in 800x600 mode
      if(res_t) {
         if(pps_rate & RATE_SKIP_PPS) {
            if(minor_alarms & MINOR_PPS_SKIPPED) vidstr(info_row++, MINOR_COL, GREEN,      "PP2S: skipped  ");
            else                                 vidstr(info_row++, MINOR_COL, GREEN,      "PP2S: generated");
         }
         else {
            if(minor_alarms & MINOR_PPS_SKIPPED) vidstr(info_row++, MINOR_COL, YELLOW,     "PPS: skipped   ");
            else                                 vidstr(info_row++, MINOR_COL, GREEN,      "PPS: generated ");
         }
         --info_avail;
         bad_mask = MINOR_UNKNOWN;
      }
      else if(ACUTIME) {
         if(pps_rate & RATE_SKIP_PPS) {
            if(minor_alarms & MINOR_PPS_SKIPPED) {
               vidstr(info_row++, MINOR_COL, GREEN,      "PP2S: skipped  ");
            }
            else {
               vidstr(info_row++, MINOR_COL, GREEN,      "PP2S: generated");
            }
            --info_avail;
         }
         else {
            if(minor_alarms & MINOR_PPS_SKIPPED) {
               vidstr(info_row++, MINOR_COL, YELLOW,     "PPS: inhibited ");
               --info_avail;
            }
            else if(0) {
               vidstr(info_row++, MINOR_COL, GREEN,      "PPS: generated ");
               --info_avail;
            }
         }
         bad_mask = MINOR_UNKNOWN;
      }
      else if(rcvr_type == STAR_RCVR) bad_mask = MINOR_UNKNOWN;
      else if(rcvr_type == ZODIAC_RCVR) bad_mask = MINOR_UNKNOWN;
      else bad_mask = (MINOR_UNKNOWN | MINOR_PPS_SKIPPED);

      if(minor_alarms & bad_mask)  {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Alarm?: %04X  ",  minor_alarms & MINOR_UNKNOWN);
         vidstr(info_row++, MINOR_COL, RED,   out);
         --info_avail;
      }
   }

   if(lte_lite) {
      if(minor_alarms & MINOR_JL_PHASE) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Phase > 250ns ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }

      if(minor_alarms & MINOR_JL_RUNTIME) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Runtime <300s ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }

      if(minor_alarms & MINOR_JL_HOLD) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Holdover >60s ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }

      if(minor_alarms & MINOR_JL_FREQ) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Freq estimate ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }

      if(minor_alarms & MINOR_JL_CHANGE) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Phase reset   ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }
   }

   if(have_pll) {
      if(minor_alarms & MINOR_PLL) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "PLL reject    ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }

      if(minor_alarms & MINOR_JAMMING) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         sprintf(out, "Jamming seen  ");
         vidstr(info_row++, MINOR_COL, YELLOW, out);
         --info_avail;
      }
   }

   if(rcvr_type == STAR_RCVR) {
      if(have_star_led) {
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         color = GREEN;
         if     (star_led == 0) { sprintf(out, "LED: OFF    ");  color = YELLOW; }
         else if(star_led == 1) { sprintf(out, "LED: RED    ");  color = RED; } 
         else if(star_led == 2) { sprintf(out, "LED: RED*   ");  color = RED; }  
         else if(star_led == 3) { sprintf(out, "LED: GREEN  ");  color = GREEN; }  
         else if(star_led == 4) { sprintf(out, "LED: GREEN* ");  color = GREEN; }
         else if(star_led == 5) { sprintf(out, "LED: RED/GRN");  color = GREEN; }
         else if(star_led == 6) { sprintf(out, "LED: ORANGE ");  color = BROWN; }
         else if(star_led == 7) { sprintf(out, "LED: ORANGE*");  color = BROWN; }
         else                   { sprintf(out, "LED: %d       ", star_led); color = YELLOW; }
         if(seconds & 1) {
            if(strchr(out, '*')) color = GREY;
            else if(star_led == 5) color = RED;
         }
         vidstr(info_row++, FILTER_COL, color, out);
         --info_avail;
      }

      if(have_osa_output) {  // !!!! 4531
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         if(osa_output_type == 1) {
            vidstr(info_row++, FILTER_COL, GREEN, "Out: E1  ");
            --info_avail;
         }
         else if(osa_output_type == 1) {
            vidstr(info_row++, FILTER_COL, GREEN, "Out: FREQ");
            --info_avail;
         }
      }

      if(have_osa_prior) {   // !!!! 4531
         if((zoom_screen == 0) && (info_avail <= 0)) return;
         if(osa_gps_prior == 1) {
            vidstr(info_row++, FILTER_COL, GREEN, "Pri: GPS ");
            --info_avail;
         }
         else if(osa_aux_prior == 1) {
            vidstr(info_row++, FILTER_COL, GREEN, "Pri: AUX");
            --info_avail;
         }
      }
   }
}


void show_state_info()
{
int show_dops;
int dop_count;
int show_filters;
int filter_rows;
int color;
int do_dop;
int dop_spaced;
char *s;

   // This routine draws the filter settings,  dilution of precision,  
   // elevation/signal level masks, and other receiver state info.

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(all_adevs && (SCREEN_WIDTH < WIDE_WIDTH)) return;
   if(rcvr_type == ACRON_RCVR) return;

   if(rcvr_type == LPFRS_RCVR) return;
   else if(rcvr_type == PRS_RCVR) return;
   else if(rcvr_type == RFTG_RCVR) ;
   else if(rcvr_type == SA35_RCVR) return;
   else if(rcvr_type == SRO_RCVR) ;
   else if(rcvr_type == X72_RCVR) return;
   else if(NO_SATS) return;

   if(info_row && (SCREEN_HEIGHT > SHORT_SCREEN)) {  // pretty printing
      ++info_row;
      --info_avail;
      last_pp = info_row;
   }

   dop_count = 0;
   if((have_dops & TDOP) && tdop) ++dop_count;
   if((have_dops & HDOP) && hdop) ++dop_count;
   if((have_dops & VDOP) && vdop) ++dop_count;
   if((have_dops & PDOP) && pdop) ++dop_count;
   if((have_dops & GDOP) && gdop) ++dop_count;
   if((have_dops & NDOP) && ndop) ++dop_count;
   if((have_dops & EDOP) && edop) ++dop_count;
   if((have_dops & XDOP) && xdop) ++dop_count;
   if((have_dops & YDOP) && ydop) ++dop_count;
   if(have_ffom) ++dop_count;
   if(have_tfom) ++dop_count;

   if(rcvr_type == SCPI_RCVR) dop_count = 2;       // tfom and ffom treated as DOPs
   else if(rcvr_type == TRUE_RCVR) dop_count = 2;  // tfom and ffom treated as DOPs 
   else if(rcvr_type == UCCM_RCVR) dop_count = 2;  // tfom and ffom treated as DOPs 
   else if(rcvr_type == ZYFER_RCVR) dop_count = 2; // tfom treated as DOPs 

   show_dops = 0;
   do_dop = 0;
   if(dop_count) {
      if(plot_dops) do_dop = 1;
//    else if(doing_survey) do_dop = 2;
//    else if(rcvr_type == SCPI_RCVR) do_dop = 3;
//    else if((rcvr_mode != 7) && (rcvr_mode != 1) && have_rcvr_mode) do_dop = 4;
   }

   if((all_adevs == SINGLE_ADEVS) || (SCREEN_WIDTH >= WIDE_WIDTH)) {
      if(info_avail <= 0) ; // sssssss
      else if(rcvr_type == CS_RCVR) ;
      else if(rcvr_type == RT17_RCVR) ;    // toots - rt17 fix needed 
      else if(rcvr_type == THERMO_RCVR) ;
      else if(rcvr_type == TICC_RCVR) ;
      else if(pps_enabled) {
         if(rcvr_type == BRANDY_RCVR) {
            if(brandy_pps_rate == 2000) {
               if(pps_polarity) sprintf(out, "PP2S: ON %c  ", DOWN_ARROW);  //falling
               else             sprintf(out, "PP2S: ON %c  ", UP_ARROW);    //rising
               vidstr(info_row++, INFO_COL, GREEN, out);
            }
            else if(brandy_pps_rate == 1000) {
               if(pps_polarity) sprintf(out, "PULSE:ON %c  ", DOWN_ARROW);  //falling
               else             sprintf(out, "PULSE:ON %c  ", UP_ARROW);    //rising
               vidstr(info_row++, INFO_COL, GREEN, out);
            }
            else if(brandy_pps_rate == 10) {
               if(pps_polarity) sprintf(out, "100PPS: ON %c", DOWN_ARROW);  //falling
               else             sprintf(out, "100PPS: ON %c", UP_ARROW);    //rising
               vidstr(info_row++, INFO_COL, GREEN, out);
            }
            else {
               if(pps_polarity) sprintf(out, "USRPPS: ON %c", DOWN_ARROW);  //falling
               else             sprintf(out, "USRPPS: ON %c", UP_ARROW);    //rising
               vidstr(info_row++, INFO_COL, GREEN, out);
            }
            --info_avail;

            if     (brandy_code1 == '0') sprintf(out, "TCODE:NONE  ");
            else if(brandy_code1 == '1') sprintf(out, "TCODE:IRIG-B");
            else if(brandy_code1 == '2') sprintf(out, "TCODE:XR3   ");
            else if(brandy_code1 == '3') sprintf(out, "TCODE:VELA  ");
            else if(brandy_code1 == '4') sprintf(out, "TCODE:NASA36");
            else                         sprintf(out, "TCODE:UNKN-%c", brandy_code1);
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if((rcvr_type == MOTO_RCVR) && pps_rate) {
            if(pps_polarity) sprintf(out, "100PPS: ON %c", DOWN_ARROW);  //falling
            else             sprintf(out, "100PPS: ON %c", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if(pps_rate == RATE_PP2S) {
            if(pps_polarity) sprintf(out, "PP2S: ON %c  ", DOWN_ARROW);  //falling
            else             sprintf(out, "PP2S: ON %c  ", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if(rcvr_type == ESIP_RCVR) {
            if(pps_polarity) sprintf(out, "PPS:  ON %c  ", DOWN_ARROW);  //falling
            else             sprintf(out, "PPS:  ON %c  ", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if((rcvr_type == STAR_RCVR) || (rcvr_type == ZODIAC_RCVR)) {
            if(minor_alarms & MINOR_PPS_SKIPPED) {
               sprintf(out, "PPS: ERROR  "); 
            }
            else if(pps_polarity) sprintf(out, "PPS: ON %c   ", DOWN_ARROW);  //falling
            else                  sprintf(out, "PPS: ON %c   ", UP_ARROW);    //rising
            if(minor_alarms & MINOR_PPS_SKIPPED) vidstr(info_row++, INFO_COL, RED, out);   // traim failure
            else                                 vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;

            if(have_pps_rate) {
               if(info_avail > 0) {
                  if((rcvr_type == STAR_RCVR) && (star_type == OSA_TYPE)) {
                     if(star_tod == 1) vidstr(info_row++, INFO_COL, YELLOW, "TOD: ON     ");
                     else if(star_tod) vidstr(info_row++, INFO_COL, RED,    "TOD: UNKN   ");
                     else              vidstr(info_row++, INFO_COL, GREEN,  "TOD: OFF    ");
                  }
                  else {
                     if(star_tod == 1) vidstr(info_row++, INFO_COL, GREEN,  "TOD: ON     ");
                     else if(star_tod) vidstr(info_row++, INFO_COL, RED,    "TOD: UNKN   ");
                     else              vidstr(info_row++, INFO_COL, YELLOW, "TOD: OFF    ");
                  }
                  --info_avail;
               }
            }
         }
         else if((rcvr_type == UBX_RCVR) && (pps_rate == RATE_100PPS)) {
            if(pps_polarity) sprintf(out, "100PPS: ON %c", DOWN_ARROW);  //falling
            else             sprintf(out, "100PPS: ON %c", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if((rcvr_type == UBX_RCVR) && (pps_rate == RATE_1000PPS)) {
            if(pps_polarity) sprintf(out, "1kPPS: ON %c ", DOWN_ARROW);  //falling
            else             sprintf(out, "1kPPS: ON %c ", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if((rcvr_type == UBX_RCVR) && (pps_rate == RATE_USER)) {
            if(pps_polarity) sprintf(out, "USRPPS: ON %c", DOWN_ARROW);  //falling
            else             sprintf(out, "USRPPS: ON %c", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else if((rcvr_type == Z12_RCVR) && (pps_rate == RATE_USER)) {
            if(pps_polarity) sprintf(out, "USRPPS: ON %c", DOWN_ARROW);  //falling
            else             sprintf(out, "USRPPS: ON %c", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
         else {
            if(pps_polarity) sprintf(out, "PPS: ON %c   ", DOWN_ARROW);  //falling
            else             sprintf(out, "PPS: ON %c   ", UP_ARROW);    //rising
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }

         if(rcvr_type == ESIP_RCVR) {
            if     (esip_time_source == 0) sprintf(out, "SYNC: RTC ");
            else if(esip_time_source == 1) sprintf(out, "SYNC: GPS ");
            else if(esip_time_source == 2) sprintf(out, "SYNC: USNO");
            else if(esip_time_source == 3) sprintf(out, "SYNC: SU  ");
            else                           sprintf(out, "SYNC: UNKN");
            if(esip_time_source == 2) vidstr(info_row++, INFO_COL, GREEN,  out);
            else                      vidstr(info_row++, INFO_COL, YELLOW, out);
            --info_avail;
         }

         if(have_esip_pps_type) {
            if(esip_pps_type) sprintf(out, "TYPE: GCLK  ");
            else              sprintf(out, "TYPE: LEGACY");
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
      }
      else if(NO_PPS_INFO) ;
      else if((rcvr_type == STAR_RCVR) && (star_type == OSA_TYPE)) ;
      else if(rcvr_type == BRANDY_RCVR) {
         if(brandy_code2 == '1') {  // digital code output
            if     (brandy_code1 == '0') sprintf(out, "PULSE:OFF   ");
            else if(brandy_code1 == '1') sprintf(out, "PULSE:IRIG-B");
            else if(brandy_code1 == '2') sprintf(out, "PULSE:XR3   ");
            else if(brandy_code1 == '3') sprintf(out, "PULSE:VELA  ");
            else if(brandy_code1 == '4') sprintf(out, "PULSE:NASA36");
            else                         sprintf(out, "PULSE:UNKN-%c", brandy_code1);
            vidstr(info_row++, INFO_COL, YELLOW, out);
            --info_avail;

            goto show_tcode;
         }
         else {
            sprintf(out, "PULSE:OFF   ");
            vidstr(info_row++, INFO_COL, YELLOW, out);
            --info_avail;

            show_tcode:
            if     (brandy_code1 == '0') sprintf(out, "TCODE:NONE  ");
            else if(brandy_code1 == '1') sprintf(out, "TCODE:IRIG-B");
            else if(brandy_code1 == '2') sprintf(out, "TCODE:XR3   ");
            else if(brandy_code1 == '3') sprintf(out, "TCODE:VELA  ");
            else if(brandy_code1 == '4') sprintf(out, "TCODE:NASA36");
            else                         sprintf(out, "TCODE:UNKN-%c", brandy_code1);
            vidstr(info_row++, INFO_COL, GREEN, out);
            --info_avail;
         }
      }
      else if((rcvr_type == Z12_RCVR) && (have_z12_pps == 0)) {
         sprintf(out, "PPS: NO MSG ");
         vidstr(info_row++, INFO_COL, YELLOW, out);
         --info_avail;
      }
      else {
         sprintf(out, "PPS: OFF    ");
         vidstr(info_row++, INFO_COL, YELLOW, out);
         --info_avail;
      }
   }
   if(rcvr_type == TM4_RCVR) {
      if(have_tm4_pps_source && (info_avail > 0)) {
         sprintf(out, "SRC: %-6d", tm4_pps_source);
         vidstr(info_row++, FILTER_COL, WHITE, out);
         --info_avail;
      }
   }

   if((rcvr_type == VENUS_RCVR) && saw_venus_raw && have_rtk_mode && (info_avail > 0)) {
      if(rtk_mode == 1)      vidstr(info_row++, INFO_COL, GREEN, "BASE MODE   ");
      else if(rtk_mode == 0) vidstr(info_row++, INFO_COL, GREEN, "ROVER MODE  ");
      else {
         sprintf(out, "UNK RTK MODE");
         vidstr(info_row++, INFO_COL, RED,    out);
      }
      --info_avail;
   }

   dop_spaced = 0;
   if(do_dop) { 
      if((info_row != last_pp) && (SCREEN_HEIGHT > SHORT_SCREEN)) {  // pretty printing
         ++info_row;
         --info_avail;
         last_pp = info_row;
         dop_spaced = 1;
      }
      if(info_avail >= dop_count) {
         show_dops = info_row;
      }
   }

   if(show_dops && ((rcvr_type == SCPI_RCVR) || (rcvr_type == UCCM_RCVR) || (rcvr_type == TRUE_RCVR) || (rcvr_type == ZYFER_RCVR))) {
      if(have_tfom && (info_avail > 0)) {
         if(tfom <= 3) color = GREEN;
         else if((tfom == 4) && (rcvr_type == ZYFER_RCVR)) color = GREEN;
         else if(tfom <= 6) color = YELLOW;
         else color = RED;
         sprintf(out, "TFOM:%6d", tfom);
         vidstr(info_row++, FILTER_COL, color, out);
         --info_avail;
      }

      if(have_ffom && (info_avail > 0)) {
         color = GREEN;
         if(rcvr_type == TRUE_RCVR) {
            if(true_debug == 0) color = GREEN;
            else if(true_debug >= 8) color = RED;
            else color = YELLOW;
            sprintf(out, "Dmode:%5d", true_debug);  // this is actually discipline mode
         }
         else {
            if(ffom == 0) color = GREEN;
            else if(ffom >= 2) color = RED;
            else color = YELLOW;
            if     (ffom == 3) sprintf(out, "FFOM:  INIT");
            else if(ffom == 2) sprintf(out, "FFOM:UNLOCK");
            else if(ffom == 1) sprintf(out, "FFOM:SETTLE");
            else if(ffom == 0) sprintf(out, "FFOM:  LOCK");
            else               sprintf(out, "FFOM:%6d", ffom);
         }
         vidstr(info_row++, FILTER_COL, color, out);
         --info_avail;
      }
      if(rcvr_type == ZYFER_RCVR) goto dop_dop;
   }
   else if(show_dops) {
      dop_dop:
      if(info_avail > 0) {
         if((rcvr_type == UBX_RCVR) && (rcvr_mode == RCVR_MODE_HOLD)) ;
         else if(pdop && (have_dops & PDOP)) {
            sprintf(out, "PDOP: %5.2f  ", pdop);
            if(pdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if((rcvr_type == UBX_RCVR) && (rcvr_mode == RCVR_MODE_HOLD)) ;
         else if(hdop && (have_dops & HDOP)) {
            sprintf(out, "HDOP: %5.2f  ", hdop);
            if(hdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if((rcvr_type == UBX_RCVR) && (rcvr_mode == RCVR_MODE_HOLD)) ;
         else if(vdop && (have_dops & VDOP)) {
            sprintf(out, "VDOP: %5.2f  ", vdop);
            if(vdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if(rcvr_type == TICC_RCVR) ;  // DOP value is used by FUDGE autotune
         else if(tdop && (have_dops & TDOP)) {
            sprintf(out, "TDOP: %5.2f  ", tdop);
            if(tdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if((rcvr_type == UBX_RCVR) && (rcvr_mode == RCVR_MODE_HOLD)) ;
         else if(gdop && (have_dops & GDOP)) {
            sprintf(out, "GDOP: %5.2f  ", gdop);
            if(gdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if((rcvr_type == UBX_RCVR) && (rcvr_mode == RCVR_MODE_HOLD)) ;
         else if(ndop && (have_dops & NDOP)) {
            sprintf(out, "NDOP: %5.2f  ", ndop);
            if(ndop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if(edop && (have_dops & EDOP)) {
            sprintf(out, "EDOP: %5.2f  ", edop);
            if(edop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if(xdop && (have_dops & XDOP)) {
            sprintf(out, "XDOP: %5.2f  ", xdop);
            if(xdop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }

      if(info_avail > 0) {
         if(ydop && (have_dops & YDOP)) {
            sprintf(out, "YDOP: %5.2f  ", ydop);
            if(ydop <= 0.0F) vidstr(info_row++, FILTER_COL, GREY,      out);
            else             vidstr(info_row++, FILTER_COL, DOP_COLOR, out);
            --info_avail;
         }
      }
   }


   filter_rows = 0;
   if(have_filter & PV_FILTER)     ++filter_rows;
   if(have_filter & ALT_FILTER)    ++filter_rows;
   if(have_filter & STATIC_FILTER) ++filter_rows;
   if(have_filter & saw_kalman_on) ++filter_rows;
   if(have_filter & MARINE_FILTER) ++filter_rows;
   if(plot_filters == 0) filter_rows = 0;
   if(user_set_dfilter == 0) {
      if(SCREEN_HEIGHT <= SHORT_SCREEN) filter_rows = 0;
   }

   if(filter_rows == 0) show_filters = 0;
   else if(rcvr_type == SCPI_RCVR) show_filters = 0;
   else if(rcvr_type == UCCM_RCVR) show_filters = 0;
   else if(rcvr_type == ZODIAC_RCVR) show_filters = 1;
   else if((info_row != last_pp) && (dop_spaced == 0) && (filter_rows <= 3) && (SCREEN_HEIGHT > SHORT_SCREEN)) {  // pretty printing
      ++info_row;
      --info_avail;
      last_pp = info_row;
      show_filters = 2;
   }
   else if(info_avail >= filter_rows) show_filters = 3;
   else show_filters = 0;

   if(rcvr_type == GPSD_RCVR) return;
   else if(rcvr_type == NMEA_RCVR) return;
   else if(show_filters) {
      if(have_filter & PV_FILTER) {
         sprintf(out, "PV:      %s", pv_filter?"ON ":"OFF");
         vidstr(info_row++, FILTER_COL, pv_filter?WHITE:YELLOW, out);
         --info_avail;
      }

      if(have_filter & STATIC_FILTER) {
         if(rcvr_type == MOTO_RCVR) sprintf(out, "IONO:    %s", static_filter?"ON ":"OFF");
         else                       sprintf(out, "STATIC:  %s", static_filter?"ON ":"OFF");
         vidstr(info_row++, FILTER_COL, static_filter?WHITE:YELLOW, out);
         --info_avail;
      }

      if(have_filter & ALT_FILTER) {
         if(rcvr_type == MOTO_RCVR) sprintf(out, "TROPO:   %s", alt_filter?"ON ":"OFF"); 
         else                       sprintf(out, "ALTITUDE:%s", alt_filter?"ON ":"OFF"); 
         vidstr(info_row++, FILTER_COL, alt_filter?WHITE:YELLOW, out);
         --info_avail;
      }

      if(have_filter & KALMAN_FILTER) {
         if(ebolt || saw_kalman_on) {
            sprintf(out, "KALMAN:  %s", kalman_filter?"ON ":"OFF"); 
            vidstr(info_row++, FILTER_COL, kalman_filter?WHITE:YELLOW, out);
            --info_avail;
         }
         else if(0) {
            sprintf(out, "KALMAN:  %s", kalman_filter?"ON ":"N/A"); 
            vidstr(info_row++, FILTER_COL, kalman_filter?YELLOW:GREY, out);
            --info_avail;
         }
      }

      if(have_filter & MARINE_FILTER) {  // Motorola marine velocity filter
         sprintf(out, "MARINE:  %3d", marine_filter);
         vidstr(info_row++, FILTER_COL, pv_filter?WHITE:YELLOW, out);
         --info_avail;
      }
   }

   if((info_row != last_pp) && (info_avail > 2) && (SCREEN_HEIGHT >= SHORT_SCREEN)) { // pretty printing
      if(show_filters && filter_rows) ;
      else if(show_dops && dop_count) ;
      else {
         ++info_row; 
         --info_avail; 
         last_pp = info_row;
      }
   }

   if(info_avail > 0) {
      if(have_el_mask) {
         sprintf(out, "EL:  %6.2f%c", el_mask, DEGREES);
         if(rcvr_type == SCPI_RCVR) ++show_filters;
         else if(rcvr_type == UCCM_RCVR) ++show_filters;
         vidstr(info_row++, FILTER_COL, WHITE, out);
         --info_avail;
      }
   }

   if(rcvr_type == UCCM_RCVR) {
      if((info_row != last_pp) && (have_ant_v1 || have_ant_ma)) {  // samsung
         ++info_row;
         --info_avail;  // pretty printing
         last_pp = info_row;
      }
      if((info_avail > 0) && have_ant_v1) {
         sprintf(out, "AntV: %6.3f", ant_v1);
         vidstr(info_row++, FILTER_COL, WHITE, out);
         --info_avail;
      }
      if((info_avail > 0) && have_ant_ma) {
         sprintf(out, "AntI: %6.3f", ant_ma);
         vidstr(info_row++, FILTER_COL, WHITE, out);
         --info_avail;
      }
   }
   else if((info_avail > 0) && have_ant_ma) {
      sprintf(out, "AntI: %6.3f", ant_ma);
      vidstr(info_row++, FILTER_COL, WHITE, out);
      --info_avail;
   }

   if(info_avail > 0) {
      if(have_amu) {
         if((res_t && (res_t != RES_T)) || (rcvr_type != TSIP_RCVR)) {
            if(level_type == 0) s = "SNR";
            else if(level_type[0] == 0) s = "SNR";
            else if(level_type[0] == ' ') s = "SNR";
            else s = level_type;
            sprintf(out, "%s: %6.2f", s, amu_mask);
         }
         else if(1 || amu_mode) {  // sig level mask is always in AMU
            sprintf(out, "AMU: %6.2f", amu_mask);
         }
         else {
            sprintf(out, "dBc: %6.2f", amu_mask);
         }
         vidstr(info_row++, FILTER_COL, WHITE, out);
         --info_avail;
      }
   }

   if(rcvr_type == TM4_RCVR) {
      if(have_ett_time_format || have_ett_code_format || have_tm4_ett_enable || have_tm4_lock) {
         if((info_row != last_pp) && (info_avail > 4) && (SCREEN_HEIGHT > SHORT_SCREEN)) {
            ++info_row;   // pretty printing
            --info_avail;
            last_pp = info_row;
         }
      }
      if(have_tm4_lock && (info_avail > 0)) {
         sprintf(out, "LOCK: %-6d", tm4_lock);
         if     (tm4_lock >= 8) vidstr(info_row++, FILTER_COL, WHITE, out);
         else if(tm4_lock >= 5) vidstr(info_row++, FILTER_COL, YELLOW, out);
         else                   vidstr(info_row++, FILTER_COL, RED, out);
         --info_avail;
      }
      if(have_ett_time_format && (info_avail > 0)) {
         if     (ett_time_format == 0) vidstr(info_row++, FILTER_COL, WHITE,  "TIME: TM4 ");
         else if(ett_time_format == 1) vidstr(info_row++, FILTER_COL, WHITE,  "TIME: NTP ");
         else if(ett_time_format == 2) vidstr(info_row++, FILTER_COL, WHITE,  "TIME: NEMA");
         else                          vidstr(info_row++, FILTER_COL, YELLOW, "TIME: Unkn");
         --info_avail;
      }
      if(have_ett_code_format && (info_avail > 0)) {
         if     (ett_code_format == 0) vidstr(info_row++, FILTER_COL, WHITE,  "CODE: IRIGB ");
         else if(ett_code_format == 1) vidstr(info_row++, FILTER_COL, WHITE,  "CODE: NASA36");
         else                          vidstr(info_row++, FILTER_COL, YELLOW, "CODE: Unkn  ");
         --info_avail;
      }
      if(have_tm4_ett_enable && (info_avail > 0)) {
         if(ett_enable == 0) {
            vidstr(info_row++, FILTER_COL, WHITE,  "ETT:  OFF ");
         }
         else if(ett_enable == 1) {
            if     (ett_polarity == '+') sprintf(out, "ETT:  ON%c ", UP_ARROW);
            else if(ett_polarity == '-') sprintf(out, "ETT:  ON%c ", DOWN_ARROW);
            else                         sprintf(out, "ETT:  ON%c ", '?');
            
            if     (ett_polarity == '+') vidstr(info_row++, FILTER_COL, WHITE,  out);
            else if(ett_polarity == '-') vidstr(info_row++, FILTER_COL, WHITE,  out);
            else                         vidstr(info_row++, FILTER_COL, YELLOW, out);
         }
         else vidstr(info_row++, FILTER_COL, YELLOW, "ETT:  Unkn");
         --info_avail;
      }
   }
                    
   if((info_avail > 0) && jd_obs) {
      sprintf(out, "RNX:%3d sec", raw_msg_rate);
      vidstr(info_row++, FILTER_COL, WHITE, out);
      --info_avail;
   }
   if((info_avail > 0) && (rcvr_type == RT17_RCVR)) {
      if(add_clk_ofs) sprintf(out, "CLKOFS: ADD");
      else            sprintf(out, "CLKOFS: OFF");
      vidstr(info_row++, FILTER_COL, WHITE, out);
      --info_avail;
   }
}


void show_build_info(int force)
{
   if(rcvr_type != TSIP_RCVR) return;

   if(build_month > 12) build_month = 0;
   if(build_ok || force) {
      sprintf(out, "Mfg: %02d:00  %02d %s %04d", 
         build_hour, build_day, months[build_month], build_year);
      vidstr(VER_ROW+3, VER_COL, WHITE, out);
   }
}

void show_unit_info()
{
   if(rcvr_type != TSIP_RCVR) return;
   if(ap_month > 12) ap_month = 0;
   if(core_month > 12) core_month = 0;

   if(have_info & VERSION_INFO) {
      if(unit_name[0] == 0) {
         sprintf(out, "App: %2d.%-2d  %02d %s %02d", 
            ap_major, ap_minor,  ap_day, months[ap_month], ap_year);   //!!! docs say 1900
         vidstr(VER_ROW+1, VER_COL, WHITE, out);
      }

      sprintf(out, "GPS: %2d.%-2d  %02d %s %02d", 
         core_major, core_minor,  core_day, months[core_month], core_year);  //!!! docs say 1900
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
   }

   show_build_info(0);
}

void show_gpsd_driver()
{
   if(zoom_screen) return;

   msg_field[17] = 0;
   sprintf(gpsd_driver, "Drv:  %s", &msg_field[1]);
   vidstr(VER_ROW+2, VER_COL, WHITE, gpsd_driver);
}


void show_manuf_params()
{
   if(rcvr_type != TSIP_RCVR) return;

   have_info |= MANUF_PARAMS;

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
   if(just_read) return;

   show_build_info(0);
}


void show_ebolt_info()
{
   show_build_info(1);

#ifdef WINDOWS
   if(com[RCVR_PORT].com_port >= 10)      sprintf(out, "Ser: %2u.%-8lu COM:%d",  hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].com_port);
   else if (com[RCVR_PORT].com_port)      sprintf(out, "Ser: %2u.%-8lu  COM:%d", hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].com_port);
#else   // __linux__  __MACH__  __FreeBSD__
   if(com[RCVR_PORT].com_port >= 10)      sprintf(out, "Ser: %2u.%-8lu TTY:%d",  hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].com_port-1);
   else if (com[RCVR_PORT].com_port)      sprintf(out, "Ser: %2u.%-8lu  TTY:%d", hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].com_port-1);
#endif
   else if(com[RCVR_PORT].usb_port >= 10) sprintf(out, "Ser: %2u.%-8lu USB:%d",  hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].usb_port-1);
   else if(com[RCVR_PORT].usb_port)       sprintf(out, "Ser: %2u.%-8lu  USB:%d", hw_code, (unsigned long) ebolt_serno, com[RCVR_PORT].usb_port-1);
#ifdef TCP_IP 
   else if(com[RCVR_PORT].IP_addr[0]) {
      sprintf(out," IP: %-17.17ss", com[RCVR_PORT].IP_addr); // TCP 
   }
#endif
   else {
      sprintf(out," COM: none");
   }
   vidstr(VER_ROW+4, VER_COL, WHITE, out);
}


void show_version_header()
{
   if(zoom_screen) return;
   if(text_mode && first_key) return;

   if(rpn_mode || (getting_string == CALC_CMD)) {
      vidstr(VER_ROW+0, VER_COL, YELLOW, "CALCULATOR MODE ENABLED!");
   }
   else if(measure_jitter) {
      if(no_poll) vidstr(VER_ROW+0, VER_COL, RED, "Jitter meas - no polling");
      else        vidstr(VER_ROW+0, VER_COL, RED, "Jitter measurement mode ");
   }
   else if(read_only) vidstr(VER_ROW+0, VER_COL, BLUE, "Read-only mode set      ");
   else if(no_send)   vidstr(VER_ROW+0, VER_COL, BLUE, "COM output disabled     ");
   else if(no_poll)   vidstr(VER_ROW+0, VER_COL, BLUE, "Rcvr requests disabled  ");
   else if(just_read) vidstr(VER_ROW+0, VER_COL, BLUE, "Rcvr decode disabled    ");
   else if(disable_kbd > 1) {
      if(script_file) {
         vidstr(VER_ROW+0, VER_COL, BLUE, "Script file error        "); 
      }
      else {
         vidstr(VER_ROW+0, VER_COL, BLUE, "Keyboard is disabled     "); 
      }
   }
// else if(disable_kbd) vidstr(VER_ROW+0, VER_COL, BLUE,   "Press ESC Y to exit    ");
// else if(disable_kbd) vidstr(VER_ROW+0, VER_COL, BLUE,   "Keyboard is disabled   ");
   else if(disable_kbd) vidstr(VER_ROW+0, VER_COL, BLUE,   "Kbd disabled  Press ESC");
   else if(osc_params)  vidstr(VER_ROW+0, VER_COL, YELLOW, "OSC param display      "); 
   else if(plot_version) {
       if(rcvr_type == NO_RCVR) sprintf(out, "V%s - %s ", VERSION, date_string);
       else {
          sprintf(out, "V%s - %s       ", VERSION, date_string);
          out[24] = 0;
       }
       vidstr(VER_ROW+0, VER_COL, BLUE, out);
   }
   else if(rcvr_type == NO_RCVR) {
      vidstr(VER_ROW+0, VER_COL, BLUE, "Press SPACE for help");
   }
   else vidstr(VER_ROW+0, VER_COL, BLUE, "Press SPACE for help    ");

   show_unit_info();
// show_version_info();
}


void show_version_info()
{
char *s;

   // NEW_RCVR

   if(zoom_screen) return;
   if(text_mode && first_key) return;
   if(luxor) return;

   if(rcvr_type == BRANDY_RCVR) {
      sprintf(out, "FW:   %-17.17s", brandy_fw);
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
      sprintf(out, "ENG:  %-17.17s", brandy_engine);
      vidstr(VER_ROW+3, VER_COL, WHITE, out);
   }
   else if((rcvr_type == ESIP_RCVR) && have_info) {
      if(esip_model[0] && !strstr(esip_model, "N/A")) {
         sprintf(out, "ID:   %-17.17s", esip_model);
         vidstr(VER_ROW+2, VER_COL, WHITE,  out);
      }
      else if(esip_device[0]) {
         sprintf(out, "Typ:  %-17.17s", esip_device);
         vidstr(VER_ROW+2, VER_COL, WHITE,  out);
      }

      if(esip_version[0]) {
         sprintf(out, "Ver:  %-17.17s", esip_version);
         vidstr(VER_ROW+3, VER_COL, WHITE,  out);
      }
   }
   else if((rcvr_type == FURUNO_RCVR) && have_info) {
      sprintf(out, "PGM:  %08d", furuno_pgm);
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
      sprintf(out, "VER:  %02d", furuno_ver);
      vidstr(VER_ROW+3, VER_COL, WHITE, out);
   }
   else if(rcvr_type == LPFRS_RCVR) {
      if(lpfrs_id[0]) {
         sprintf(out, "HW:  %-20.20s", lpfrs_id);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(lpfrs_fw[0]) {
         sprintf(out, "FW:  %-20.20s", lpfrs_fw);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(moto_id[6][0]) {
         sprintf(out, "HW:   %-17.17s", &moto_id[6][11]);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(strstr(moto_id[1], "Trimble") && moto_id[3][0]) {
         sprintf(out, "SW:   %-17.17s", &moto_id[3][15]);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
      else {
         if(moto_id[7][0]) {
            sprintf(out, "PN:   %-17.17s", &moto_id[7][11]);
            vidstr(VER_ROW+3, VER_COL, WHITE, out);
         }
      }
   }
   else if(rcvr_type == NVS_RCVR) {
      if(nvs_id[0]) {
         vidstr(VER_ROW+2, VER_COL, WHITE, nvs_id);
      }
      if(nvs_sn) {
         sprintf(out, "SN: %u", nvs_sn);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == PRS_RCVR) {
      if(prs_fw[0]) {
         sprintf(out, "FW:  %-17.17s", prs_fw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(prs_sn[0]) {
         sprintf(out, "SN:  %-17.17s", prs_sn);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == RFTG_RCVR) {
      sprintf(out, "FW:   %-4.4s   HW:%-7d", rftg_fw, rftg_hw);
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
   }
   else if(rcvr_type == SA35_RCVR) {
      if(have_sa35_telem) {
         sprintf(out, "FW:  %-17.17s", sa35_fw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);

         sprintf(out, "SN:  %-17.17s", sa35_id);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == SIRF_RCVR) {
      s = strchr(sirf_sw_id, '_');
      if(s == 0) s = strchr(sirf_sw_id, ' '); 
      if(s) *s = 0;

      sprintf(out, "SW:   %-17.17s", sirf_sw_id);
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
   }
   else if((rcvr_type == SCPI_RCVR) || (rcvr_type == UCCM_RCVR) || (rcvr_type == CS_RCVR)) {
      if(scpi_mfg_id[0]) {
         vidstr(VER_ROW+2, VER_COL, WHITE, scpi_mfg_id);
      }

      if(1 && (rcvr_type == CS_RCVR) && cs_cbtid[0]) {  // show the beam tube id
         sprintf(out, "CBT:  %-17.17s", cs_cbtid);
      }
      else if(scpi_serno[0]) {
         vidstr(VER_ROW+3, VER_COL, WHITE, scpi_serno);
      }
   }
   else if(rcvr_type == SIRF_RCVR) {
      s = strchr(sirf_sw_id, '_');
      if(s == 0) s = strchr(sirf_sw_id, ' '); 
      if(s) *s = 0;

      sprintf(out, "SW:   %-17.17s", sirf_sw_id);
      vidstr(VER_ROW+2, VER_COL, WHITE, out);
   }
   else if(rcvr_type == SRO_RCVR) {
      if(sro_id[0]) {
         sprintf(out, "HW:  %-20.20s", sro_id);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(sro_sn[0]) {
         sprintf(out, "SN:  %-17.17s", sro_sn);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_fw[0]) {
         sprintf(out, "FW:   %-17.17s", star_fw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(star_osc[0]) {
         sprintf(out, "OSC:  %-17.17s", star_osc);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == THERMO_RCVR) {
      if(enviro_sn[0]) {
         sprintf(out, "Ser:  %-17.17s", enviro_sn);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == TICC_RCVR) {
      if(ticc_fw[0]) {
         sprintf(out, "Ver:  %s", ticc_fw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(ticc_sn[0]) {
         sprintf(out, "Ser:  %s", ticc_sn);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }

      if(pause_data)            vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Updates paused  "); 
      else if(ticc_mode == 'T') vidstr(VAL_ROW+0, VAL_COL, WHITE,  "Mode: Timestamp ");
      else if(ticc_mode == 'I') vidstr(VAL_ROW+0, VAL_COL, WHITE,  "Mode: Interval  ");
      else if(ticc_mode == 'P') vidstr(VAL_ROW+0, VAL_COL, WHITE,  "Mode: Period    ");
      else if(ticc_mode == 'L') vidstr(VAL_ROW+0, VAL_COL, WHITE,  "Mode: Timelab   ");
      else if(ticc_mode == 'D') vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Mode: Debug     ");
      else if(ticc_mode == 'F') vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Mode: Frequency ");
      else                      vidstr(VAL_ROW+0, VAL_COL, RED,    "Mode: Unknown   ");
   }
   else if(rcvr_type == TM4_RCVR) {
      if(tm4_id[0]) {
         sprintf(out, "Ver:  %-17.17s", tm4_id);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == TRUE_RCVR) {
      if(tp_sw[0]) {
         sprintf(out, "SW:   %-17.17s", tp_sw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(tp_boot[0]) {
         sprintf(out, "GPS:  %-17.17s", tp_boot);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == UBX_RCVR) {
      if(ubx_sw[0]) {
         sprintf(out, "FW:   %-17.17s", ubx_sw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(ubx_hw[0]) {
         sprintf(out, "HW:   %-17.17s", ubx_hw);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(venus_odm[0]) {
         vidstr(VER_ROW+2, VER_COL, WHITE, venus_odm);
      }
      if(venus_rev[0]) {
         vidstr(VER_ROW+3, VER_COL, WHITE, venus_rev);
      }
   }
   else if(rcvr_type == X72_RCVR) {
      if(have_x72_fw) {
         sprintf(out, "FW:  %-.2f", x72_fw);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(x72_serial[0]) {
         sprintf(out, "SN:  %s", x72_serial);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == Z12_RCVR) {
      if(1 || z12_nav_ver[0]) {
         sprintf(out, "Ver:  %-2.2s  %-4.4s-%-4.4s    ", z12_type, z12_nav_ver,z12_chan_ver);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }
      if(1 || z12_chan_opt[0]) {
         sprintf(out, "Opt:  %-3.3s %-13.13s", z12_chan_opt, z12_rsvd);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(zod_sw[0] || zod_date[0]) {
         sprintf(out, "SW:   %-6.6s %-8.8s  ", zod_sw, zod_date);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(zod_opt[0]) {
         sprintf(out, "HW:   %-17.17s", zod_opt);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
   else if(rcvr_type == ZYFER_RCVR) {
      if(zy_sn[0]) {
         sprintf(out, "SN:   %-17.17s", zy_sn);
         vidstr(VER_ROW+2, VER_COL, WHITE, out);
      }

      if(zy_fw[0]) {
         sprintf(out, "FW:   %-17.17s", zy_fw);
         vidstr(VER_ROW+3, VER_COL, WHITE, out);
      }
   }
}

void show_serial_info()
{
char *on;
char *c, *d, *t, *u;

   if(zoom_screen) return;
   if(text_mode && first_key) return;

   if((com[RCVR_PORT].process_com == 0) || (com[RCVR_PORT].user_disabled_com)) {
      on = "(OFF)";
      c = "com:";
      d = "dev:";
      u = "usb:";
      t = "tty:";
   }
   else {
      on = "     ";
      c = "COM:";
      d = "DEV:";
      u = "USB:";
      t = "TTY:";
   }

   if(luxor) {
      if(com[RCVR_PORT].usb_port == USE_IDEV_NAME)     sprintf(out, "DEV: %s", com[RCVR_PORT].com_dev); 
      else if(com[RCVR_PORT].usb_port == USE_DEV_NAME) sprintf(out, "DEV: %s", com[RCVR_PORT].com_dev); 
      else if(com[RCVR_PORT].usb_port)        sprintf(out, "USB: %d", com[RCVR_PORT].usb_port-1);
#ifdef WINDOWS
      else if(com[RCVR_PORT].com_port)        sprintf(out, "COM: %d", com[RCVR_PORT].com_port);
#else   // __linux__  __MACH__  __FreeBSD__
      else if(com[RCVR_PORT].com_port)        sprintf(out, "TTY: %d", com[RCVR_PORT].com_port-1);
#endif
#ifdef TCP_IP 
      else if(com[RCVR_PORT].IP_addr[0]) {
         sprintf(out," IP: %-17.17s", com[RCVR_PORT].IP_addr); // TCP, no room for sernum
      }
#endif
      else sprintf(out," COM: none");
      if(strlen(out) > 16) strcpy(&out[16-3],"...");   // don't hit 'Power' label
      vidstr(VER_ROW+5, VER_COL, WHITE, out);

      sprintf(out, "SER: %u.%04lu  ", sn_prefix, (unsigned long) serial_num);
   }
   else if(sn_prefix && serial_num) {
      if(com[RCVR_PORT].usb_port == USE_IDEV_NAME)     sprintf(out, "DEV: %-17.17s", com[RCVR_PORT].com_dev); // user specified device
      else if(com[RCVR_PORT].usb_port == USE_DEV_NAME) sprintf(out, "DEV: %-17.17s", com[RCVR_PORT].com_dev); // symlink to /dev/heather
      else if(com[RCVR_PORT].usb_port >= 10)           sprintf(out, "Ser: %2u.%-8lu USB:%d",  sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].usb_port-1);
      else if(com[RCVR_PORT].usb_port)                 sprintf(out, "Ser: %2u.%-8lu  USB:%d", sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].usb_port-1);
#ifdef WINDOWS
      else if(com[RCVR_PORT].com_port >= 10) sprintf(out, "Ser: %2u.%-8lu COM:%d",  sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].com_port);
      else if(com[RCVR_PORT].com_port)       sprintf(out, "Ser: %2u.%-8lu  COM:%d", sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].com_port);
#else   // __linux__  __MACH__  __FreeBSD__
      else if(com[RCVR_PORT].com_port >= 10) sprintf(out, "Ser: %2u.%-8lu TTY:%d",  sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].com_port-1);
      else if(com[RCVR_PORT].com_port)       sprintf(out, "Ser: %2u.%-8lu  TTY:%d", sn_prefix, (unsigned long) serial_num, com[RCVR_PORT].com_port-1);
#endif
#ifdef TCP_IP 
      else if(com[RCVR_PORT].IP_addr[0]) {
         sprintf(out," IP: %-18.18s", com[RCVR_PORT].IP_addr); // TCP, no room for sernum
      }
#endif
      else sprintf(out, "Ser: %2u.%-8lu  COM:none", sn_prefix, (unsigned long) serial_num);
      if(strlen(out) > 27) strcpy(&out[27-3],"...");   // don't hit 'Power' label
   }
   else if(rcvr_type == NO_RCVR) {
      sprintf(out, "COM: None");
   }
   else {
      if(com[RCVR_PORT].usb_port == USE_IDEV_NAME)     sprintf(out, "DEV: %-17.17s", com[RCVR_PORT].com_dev); // user specified device
      else if(com[RCVR_PORT].usb_port == USE_DEV_NAME) sprintf(out, "DEV: %-17.17s", com[RCVR_PORT].com_dev); // symlink to /dev/heather
      else if(com[RCVR_PORT].usb_port >= 10)           sprintf(out, "USB: %-2d %s         ", com[RCVR_PORT].usb_port-1, on);
      else if(com[RCVR_PORT].usb_port)                 sprintf(out, "USB: %-2d %s         ", com[RCVR_PORT].usb_port-1, on);
#ifdef WINDOWS
      else if(com[RCVR_PORT].com_port >= 10) sprintf(out, "COM: %-2d %s       ", com[RCVR_PORT].com_port, on);
      else if(com[RCVR_PORT].com_port)       sprintf(out, "COM: %-2d %s       ", com[RCVR_PORT].com_port, on);
#else   // __linux__  __MACH__  __FreeBSD__
      else if(com[RCVR_PORT].com_port >= 10) sprintf(out, "TTY: %-2d %s       ", com[RCVR_PORT].com_port-1, on);
      else if(com[RCVR_PORT].com_port)       sprintf(out, "TTY: %-2d %s       ", com[RCVR_PORT].com_port-1, on);
#endif
#ifdef TCP_IP 
      else if(com[RCVR_PORT].IP_addr[0]) {
         sprintf(out," IP: %-17.17s", com[RCVR_PORT].IP_addr); // TCP, no room for sernum
      }
#endif
      else sprintf(out, "COM: none             ");
      if(strlen(out) > 25) strcpy(&out[25-3],"...");   // don't hit 'Power' label
   }
   vidstr(VER_ROW+4, VER_COL, WHITE, out);
}


unsigned long last_pl;

void show_time_info()
{
int color;
u08 alarm_state;
long sec;
int row;
int zoomed;
unsigned week;
int flag;

   zoomed = zoom_screen;
   if(1 && (!SMALL_SCREEN) && ((zoom_screen == 'S') || (zoom_screen == 'L') || (zoom_screen == 'M'))) zoomed = 0;
   if(zoom_screen == 'I') zoomed = 0;

   if((text_mode && first_key) || zoomed || luxor) { // screen in use for help/edit info
      time_set_char = ' ';
      return;
   }

   if(alarm_time || alarm_date || egg_timer) alarm_state = ALARM_CHAR;
   else if(dump_time || dump_date || dump_timer || log_time || log_date || log_timer) {
      if(single_dump || single_log) alarm_state = '!';         //!!!!! need separate flags for screen and log dumps
      else                          alarm_state = DUMP_CHAR;
   }
   else if(cuckoo) {
      if(singing_clock) alarm_state = SONG_CHAR;
      else if(ships_clock) alarm_state = '#'; // SONG_CHAR;
      else alarm_state = CHIME_CHAR;
   }
   else alarm_state = ' ';

   if(time_set_char != ' ') {
      sprintf(out, "Time synced %c  ", alarm_state);
      vidstr(TIME_ROW+0, TIME_COL, GREEN, out);
   }
   else if(time_flags & TFLAGS_INVALID) {
      sprintf(out, "Time invalid %c ", alarm_state);
      vidstr(TIME_ROW+0, TIME_COL, RED, out);
      time_color = RED;
   }
   else if(time_flags & TFLAGS_RTC)     {
      sprintf(out, "RTC time %c     ", alarm_state);
      vidstr(TIME_ROW+0, TIME_COL, YELLOW, out);
      time_color = RED;
   }
   else if((time_flags & TFLAGS_NO_UTC_OFS) || !have_utc_ofs) {
      sprintf(out, "NO UTC offset %c", alarm_state);
      if(time_flags & TFLAGS_UTC) vidstr(TIME_ROW+0, TIME_COL, RED, out);
      else                        vidstr(TIME_ROW+0, TIME_COL, YELLOW, out);
      time_color = YELLOW;
   }
   else if((time_flags & TFLAGS_GNSS_MASK) && (rcvr_type == ESIP_RCVR)) {
      if((time_flags & TFLAGS_GNSS_MASK) == TFLAGS_GLONASS)      sprintf(out, "UTC(SU) TIME %c ", alarm_state);
      else if((time_flags & TFLAGS_GNSS_MASK) == TFLAGS_BEIDOU)  sprintf(out, "BEIDOU TIME %c  ", alarm_state);
      else if((time_flags & TFLAGS_GNSS_MASK) == TFLAGS_GALILEO) sprintf(out, "GALILEO TIME %c ", alarm_state);
      else                                                       sprintf(out, "UNKNOWN TIME %c ", alarm_state);
      time_color = YELLOW;
      vidstr(TIME_ROW+0, TIME_COL, time_color, out);
   }
   else if((time_flags & TFLAGS_GNSS_MASK) && (saw_icm || ACU_GG || ACU_360 || (res_t == RES_T_360))) {
      if((time_flags & TFLAGS_GNSS_MASK) == 0x20)      sprintf(out, "GLONASS TIME %c ", alarm_state);
      else if((time_flags & TFLAGS_GNSS_MASK) == 0x30) sprintf(out, "GLONASS TIME %c ", alarm_state); 
      else if((time_flags & TFLAGS_GNSS_MASK) == TFLAGS_GALILEO) sprintf(out, "GALILEO TIME %c ", alarm_state);
      else                                                       sprintf(out, "UNK GNSS TIME%c ", alarm_state);
      time_color = YELLOW;
      vidstr(TIME_ROW+0, TIME_COL, time_color, out);
   }
   else if((time_flags & TFLAGS_USER_TIME) && (STARLOC == 0)) {
      sprintf(out, "USER set time %c", alarm_state);
      vidstr(TIME_ROW+0, TIME_COL, YELLOW, out);
      time_color = YELLOW;
   }
   else if(time_flags & TFLAGS_UTC) {
      if(0 && (rcvr_type == ESIP_RCVR) && (esip_time_source == 3)) {
         sprintf(out, "UTC(SU) OK %c   ", alarm_state);
         if(have_timing_mode) vidstr(TIME_ROW+0, TIME_COL, YELLOW, out);
         else                 vidstr(TIME_ROW+0, TIME_COL, GREY,   out);
      }
      else {
         sprintf(out, "UTC time OK %c  ", alarm_state);
         if(have_timing_mode) vidstr(TIME_ROW+0, TIME_COL, GREEN,  out);
         else                 vidstr(TIME_ROW+0, TIME_COL, GREY,   out);
      }

      if(dst_ofs)            time_color = DST_TIME_COLOR;
      else if(time_zone_set) time_color = DST_TIME_COLOR;  // !!! std_time_color is rather dim for the big clock
      else                   time_color = WHITE;
   }
   else {
      sprintf(out, "GPS time OK %c  ", alarm_state);
      if(have_timing_mode) vidstr(TIME_ROW+0, TIME_COL, YELLOW, out);
      else                 vidstr(TIME_ROW+0, TIME_COL, GREY,   out);
      if(dst_ofs)            time_color = DST_TIME_COLOR;
      else if(time_zone_set) time_color = DST_TIME_COLOR;  // !!! std_time_color is rather dim for the big clock
      else                   time_color = WHITE;
   }

   if(time_color != last_time_color) {  // redraw big clock if time status has changed
      last_time_color = time_color;
   }

   if(leap_time) {  // log possible leap second
      write_log_leapsecond();
   }

   if((last_utc_offset != (-9999)) && (utc_offset != last_utc_offset)) {
      write_log_utc(utc_offset);
   }
   last_utc_offset = utc_offset;


   color = WHITE;
   if(sound_alarm && (ticker & 0x01)) {  // flash screen clocks RED
      color = RED;
   }

   if(seconds_time || fraction_time) {
      sec  = (long) pri_hours * 60L*60L;
      sec += (long) pri_minutes * 60L;
      sec += (long) pri_seconds;
      if(fraction_time) {
         sec *= 1000L;
         sec /= 864L;
         sprintf(out, "%s: .%05ld", tz_info(), sec);
      }
      else {
         sprintf(out, "%s:  %05ld", tz_info(), sec);
      }
      if(dst_ofs)            vidstr(TIME_ROW+2,TIME_COL, DST_TIME_COLOR, out);
      else if(time_zone_set) vidstr(TIME_ROW+2,TIME_COL, STD_TIME_COLOR, out);
      else                   vidstr(TIME_ROW+2,TIME_COL, WHITE, out);

      strcpy(out, fmt_date(0));
      vidstr(TIME_ROW+1,TIME_COL, color, out);
   }
   else {
      sprintf(out, "%02d:%02d:%02d %s", pri_hours,pri_minutes,pri_seconds, tz_info());
      if(dst_ofs)            vidstr(TIME_ROW+1,TIME_COL, DST_TIME_COLOR, out);
      else if(time_zone_set) vidstr(TIME_ROW+1,TIME_COL, STD_TIME_COLOR, out);
      else                   vidstr(TIME_ROW+1,TIME_COL, WHITE, out);

      strcpy(out, fmt_date(0));
      if(rolled && (color == WHITE)) {
         vidstr(TIME_ROW+2,TIME_COL, YELLOW, out);
      }
      else {
         vidstr(TIME_ROW+2,TIME_COL, color, out);
      }
   }
   

   row = TIME_ROW+3;
// if(have_week == 999) color = YELLOW;  // using faked GPS week and tow numbers
   if(have_week) {
      week = (unsigned) gps_week;
      flag = 0;
      if(0 && rolls && (week < 1024)) {  // adjust displayed week for rollovers
         week += 1024 * (unsigned) rolls;
         flag = 1;
      }
      sprintf(out, "Week: %5u  ", week);

      if((color == WHITE) && faked_tow) flag = 1;
      if     (flag)      vidstr(row,TIME_COL, YELLOW, out);
      else if(rolled)    vidstr(row,TIME_COL, color, out);
      else if(rollover)  vidstr(row,TIME_COL, color, out);
      else               vidstr(row,TIME_COL, color, out);
      ++row;
   }

   if(have_tow) {
      sprintf(out, "TOW:%7lu  ", (unsigned long) tow);
      if((color == WHITE) && faked_tow) vidstr(row,TIME_COL, YELLOW, out);
      else                              vidstr(row,TIME_COL, color, out);
      ++row;
   }

   if(have_utc_ofs) {
      sprintf(out, "UTC ofs:%3d  ", utc_offset);
      if(color == RED) ;
      else if(user_set_utc_ofs) color = YELLOW;   // using user value
      else if(have_utc_ofs < 0) color = RED;      // using estimated value
      vidstr(row,TIME_COL, color, out);           // using receiver value
      ++row;
   }

   time_set_char = ' ';
   return;
}

void show_survey_info()
{
int color;
int x72_color;
double x;

   // NEW_RCVR

   if(luxor) return;
   if(rcvr_type == LPFRS_RCVR) ;
   else if(rcvr_type == PRS_RCVR) ;
   else if(rcvr_type == SA35_RCVR) ;
   else if(rcvr_type == SRO_RCVR) ;
   else if(rcvr_type == X72_RCVR) ;
   else if(NO_SATS) return;

   if(minor_alarms & MINOR_SURVEY) {   // self survey is active
      vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, RED,    "Self Survey:  ");
      color = YELLOW;
   }
   else if(precision_survey) { 
      vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, RED,    "Median Survey:");
      color = YELLOW;
   }
   else if(1 && (rcvr_type == TRUE_RCVR) && have_true_scale) {
      x = true_scalefactor * 1000.0;
      color = WHITE;
      if(x < 0.0F)       sprintf(out, "OSC:%.3f Hz/V ", x);
      else if(x > 10.0F) sprintf(out, "OSC:%.3f Hz/V ", x);
      else               sprintf(out, "OSC: %.3f Hz/V ", x);
      vidstr(SURVEY_ROW+1+eofs, SURVEY_COL, color, out);
      return;
   }
   else if(NO_SURVEY_INFO) {  // no survey status / discipline params to show
   }
   else {  // not in survey mode,  grey out this info on the screen
      if(TIMING_RCVR || (rcvr_type == SCPI_RCVR) || (rcvr_type == UCCM_RCVR) || (rcvr_type == ZYFER_RCVR)) {  // show survey info
         color = GREY;
         vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, color,  "Survey data:  ");
      }
      else if(lte_lite && (have_sawtooth == 0)) {
      }
      else if(rcvr_type == BRANDY_RCVR) ;
      else if(rcvr_type == PRS_RCVR) { 
        if(have_prs_ga) color = WHITE;
        else            color = GREY; 
        sprintf(out, "GAin: %d", prs_ga);
        vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, color, out);

        if(have_prs_pt) color = WHITE;
        else            color = GREY; 
        sprintf(out, "PT:   %d", prs_pt);
        vidstr(SURVEY_ROW+1+eofs, SURVEY_COL, color, out);

        if(have_prs_pf) color = WHITE;
        else            color = GREY; 
        sprintf(out, "PF:   %d", prs_pf);
        vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);

        if(have_prs_pi) color = WHITE;
        else            color = GREY; 
        sprintf(out, "PI:   %d", prs_pi);
        vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, out);

        return;
      }
      else if(rcvr_type == SRO_RCVR) {  // !!!!!SRO
         color = WHITE;
         sprintf(out, "TC:%6d sec", sro_tc);
         vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, color, out);
      }
      else if(rcvr_type == TM4_RCVR) {
      }
      else if(rcvr_type == X72_RCVR) {
         if(x72_fw_discipline()) x72_color = WHITE;
         else if(x72_user_dis)   x72_color = WHITE;
         else                    x72_color = GREY;

         if(have_x72_tc) color = x72_color;
         else            color = GREY; 
         sprintf(out, "TC:%6d sec", x72_tc_val);
         vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, color, out);

         if(x72_fw_discipline() == 0) color = GREY;
         else if(have_x72_damping)    color = x72_color;
         else                         color = GREY; 
         sprintf(out, "DAMP: %.3f", x72_damping_val);
         vidstr(SURVEY_ROW+1+eofs, SURVEY_COL, color, out);

         if(x72_fw_discipline())     color = GREY;
         else if(have_x72_jamthresh) color = x72_color;
         else                        color = GREY; 
         sprintf(out, "JAM:%5d ns", (int) x72_jamthresh_val);
         vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);

         if(x72_fw_discipline())    color = GREY;
         else if(have_x72_holdover) color = x72_color;
         else                       color = GREY; 
color = GREY;  // we no longer do the holdover state
         sprintf(out, "HOLD:%4d sec", (int) x72_holdover_val);
         vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, out);

         return;
      }
      else {   // show osc info
        if(have_tc) color = WHITE;
        else        color = GREY; 
        sprintf(out, "TC:   %.1f sec", time_constant);
        vidstr(SURVEY_ROW+0+eofs, SURVEY_COL, color, out);

        if(have_damp) color = WHITE;
        else          color = GREY; 
        sprintf(out, "DAMP: %.3f", damping_factor);
        vidstr(SURVEY_ROW+1+eofs, SURVEY_COL, color, out);

        if(gain_color == YELLOW) color = gain_color;
        else if(have_gain) color = WHITE;
        else color = GREY; 
        if(osc_gain < 0.0F)       sprintf(out, "GAIN:%.3f Hz/V ", osc_gain);
        else if(osc_gain > 10.0F) sprintf(out, "GAIN:%.3f Hz/V ", osc_gain);
        else                      sprintf(out, "GAIN: %.3f Hz/V ", osc_gain);
        vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);

        if(have_initv) color = WHITE;
        else           color = GREY; 
        sprintf(out, "INIT: %.3f V", initial_voltage);
        if(saw_ntpx) vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, GREY,  out);
        else         vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, out);

        return;
      }
   }

   if((survey_length >= 0) && (survey_length <= 100000L)) {
      if(precision_survey)            sprintf(out, "Points:%6lu", (unsigned long) precision_samples);  
      else if(rcvr_type == TSIP_RCVR) sprintf(out, "Samples:%5d", survey_length);
      else if(rcvr_type == ZODIAC_RCVR) {
         if(survey_length < 10) sprintf(out, "%d hour%s      ", survey_length, (survey_length==1)?" ":"s");
         else                   sprintf(out, "%d hour%s     ", survey_length, (survey_length==1)?" ":"s");
      }
      else if(minor_alarms & MINOR_SURVEY) sprintf(out, "In progress  ");
      else                                 sprintf(out, "             ");
      vidstr(SURVEY_ROW+1+eofs, SURVEY_COL, color, out);

      if((rcvr_type == ESIP_RCVR) && (minor_alarms & MINOR_SURVEY)) {
         sprintf(out, "Left: %-6d ", survey_secs);
         vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);
      }
      else if((rcvr_type == FURUNO_RCVR) && (minor_alarms & MINOR_SURVEY)) {
         sprintf(out, "Left: %-6d ", survey_secs);
         vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);
      }
      else if((rcvr_type == TRUE_RCVR) && (minor_alarms & MINOR_SURVEY)) {
         sprintf(out, "Left: %-6d ", survey_secs);
         vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);
      }
   }

   if(precision_survey) {
      if(PRECISE_SURVEY_HOURS) {
         sprintf(out, "Progress:%3ld%%", (survey_minutes*99L)/((long)PRECISE_SURVEY_HOURS*60L)+1L);
      }
      else sprintf(out, "             ");
      vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);
   }
   else if((rcvr_type == UCCM_RCVR) && (scpi_type == SAMSUNG_TYPE)) {
      if(have_progress) sprintf(out, "VAR: %-4d", survey_progress);
      else              sprintf(out, "             ");
      vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);
   }
   else if((survey_progress > 0) && (survey_progress <= 100)) {
      if(SURVEY_PROGRESS) sprintf(out, "Progress:%3d%%", survey_progress);
      else                sprintf(out, "             ");
      vidstr(SURVEY_ROW+2+eofs, SURVEY_COL, color, out);

      if(rcvr_type == UBX_RCVR)  {
         sprintf(out, "VAR: %-9d", ubx_svar);
         vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, out);
      }
   }

   if(precision_survey || check_precise_posn || precise_survey_done) {
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(survey_save) vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, "Save position");
      else            vidstr(SURVEY_ROW+3+eofs, SURVEY_COL, color, "Dont save pos");
   }
}

int show_ticc_config(int row)
{
int col;
int i;
int max_row;

   if(text_mode && first_key) return row;
   if(zoom_screen) return row;
   if(luxor) return row;
   if(rcvr_type == NO_RCVR) return row;
   if(rcvr_type == TIDE_RCVR) return row;

   max_row = queue_row;
   row = MINOR_ROW;
   col = MINOR_COL;
   if(!have_critical_alarms) row = CRIT_ROW;

   for(i=row; i<max_row; i++) {  // clear out old info
      sprintf(out, "                 ");
      vidstr(i,col, WHITE, out);
   }

   if(ticc_type == LARS_TICC) {
      sprintf(out,    "Lars config:     ");
   }
   else if(ticc_type != TAPR_TICC) {
      sprintf(out,    "Counter config:  ");
   }
   else if(user_set_ticc_mode) {
      sprintf(out,    "TICC config not available");
   }
   else {
      sprintf(out,    "TICC Config:     ");
   }

   vidstr(row,col, WHITE, out);
   ++row;
   if(osc_params && all_adevs) {
      if(first_key == 0) {
         vidstr(row,col, YELLOW, "Press key for normal display");
      }
      else {
         vidstr(row,col, YELLOW, "                            ");
      }
   }

   if(have_ticc_edges & 0x01) {
      sprintf(out,      "chA edge:  %c", edge_a);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_edges & 0x02) {
      sprintf(out,      "chB edge:  %c", edge_b);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_edges & 0x04) {
      sprintf(out,      "chC edge:  %c", edge_c);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_edges & 0x08) {
      sprintf(out,      "chD edge:  %c", edge_d);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   if(have_ticc_fudge & 0x01) {
      sprintf(out,      "chA Fudge: %g ps", fudge_a);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_fudge & 0x02) {
      sprintf(out,      "chB Fudge: %g ps", fudge_b);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_fudge & 0x04) {
      sprintf(out,      "chC Fudge: %g ps", fudge_c);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_fudge & 0x08) {
      sprintf(out,      "chD Fudge: %g ps", fudge_d);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   if(have_ticc_time2 & 0x01) {
      sprintf(out,      "chA TIME2: %d", time2_a);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_time2 & 0x02) {
      sprintf(out,      "chB TIME2: %d", time2_b);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_time2 & 0x04) {
      sprintf(out,      "chC TIME2: %d", time2_c);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_time2 & 0x08) {
      sprintf(out,      "chD TIME2: %d", time2_d);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   if(have_ticc_dilat & 0x01) {
      sprintf(out,      "chA Dilat: %d", dilat_a);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_dilat & 0x02) {
      sprintf(out,      "chB Dilat: %d", dilat_b);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_dilat & 0x04) {
      sprintf(out,      "chC Dilat: %d", dilat_c);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_dilat & 0x08) {
      sprintf(out,      "chD Dilat: %d", dilat_d);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   if(have_ticc_timeout) {
      sprintf(out,      "Timeout:   %d", ticc_timeout);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_syncmode) {
      sprintf(out,      "Sync mode: %c", ticc_syncmode);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_cal) {
      sprintf(out,      "Cal periods: %d", ticc_cal);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_speed) {
      sprintf(out,      "Clock: %.3f MHz", ticc_speed);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }
   if(have_ticc_coarse) {
      sprintf(out,      "Coarse: %.1f us", ticc_coarse);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }


   sprintf(out,         "chA NomF: %g Hz", nominal_cha_freq);
   if(++row >= max_row) return row;
   vidstr(row,col, WHITE, out);

   if(ticc_mode == 'I') {
      sprintf(out,      "chA wrap: %g sec", cha_phase_wrap_interval);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   if(two_ticc_mode()) {
      sprintf(out,      "chB nomF: %g Hz", nominal_chb_freq);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);

      if(ticc_mode == 'I') {
         sprintf(out,      "chB wrap: %g sec", chb_phase_wrap_interval);
         if(++row >= max_row) return row;
         vidstr(row,col, WHITE, out);
      }
   }

   if(ticc_type == LARS_TICC) {
      sprintf(out,      "OSC gain: %g Hz/V", lars_gain);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);

      sprintf(out,      "DACinitv: %g     ", lars_initv);
      if(++row >= max_row) return row;
      vidstr(row,col, WHITE, out);
   }

   return row;
}


int show_prs_status(int row,int col, int max_row)
{
int p_low, p_high;

   if(have_prs_lm) {
      if     (prs_lm == 0) vidstr(row,col, GREEN,       "PPS: ON,Unfilt ");
      else if(prs_lm == 1) vidstr(row,col, GREEN,       "PPS: ON,Filter ");
      else if(prs_lm == 2) vidstr(row,col, YELLOW,      "PPS: LOW=Locked");
      else if(prs_lm == 3) vidstr(row,col, YELLOW,      "PPS: HI=Locked ");
      else                 vidstr(row,col, RED,         "PPS: ???       ");
      if(++row > max_row) return row;
   }

   if(have_prs_st == 0) return row;

   if(prs_st[5] & 0x18) {
      if(prs_st[5] & 0x08) {
         vidstr(row,col, RED,    "EEPROM: WR ERR");
         if(++row > max_row) return row;
      }
      if(prs_st[5] & 0x10) {
         vidstr(row,col, RED,    "EEPROM: CORRUPT");
         if(++row > max_row) return row;
      }
   }
   else {
      vidstr(row,col, GREEN,  "EEPROM: OK    ");
      if(++row > max_row) return row;
   }

   if(prs_st[5] & 0x01) {
      vidstr(row,col, RED,    "Lamp restarted");
      if(++row > max_row) return row;
   }
   if(prs_st[5] & 0x02) {
      vidstr(row,col, RED,    "Watchdog error");
      if(++row > max_row) return row;
   }
   if(prs_st[5] & 0x04) {
      vidstr(row,col, RED,    "Interrupt err ");
      if(++row > max_row) return row;
   }
   if(prs_st[5] & 0x80) {
      vidstr(row,col, YELLOW, "Unit reset    ");
      if(++row > max_row) return row;
   }



   p_low = prs_st[0] & 0x05;
   p_high= prs_st[0] & 0x0A;
   if(have_prs_ep && (prs_ep == 0)) {
      vidstr(row,col, RED,       "Power: DISABLED");
   }
   else if(p_low || p_high) {
      if(p_low && p_high) vidstr(row,col, RED,         "Power:  BAD    ");
      else if(p_low)      vidstr(row,col, RED,         "Power:  LOW    ");
      else if(p_high)     vidstr(row,col, RED,         "Power:  HIGH   ");
      else                vidstr(row,col, RED,         "Power:  ???    ");
   }
   else vidstr(row,col, GREEN,       "Power:  OK     ");
   if(++row > max_row) return row;

   if(have_prs_fc2) {
      sprintf(out, "Cycles: %-7d", prs_pwr_cycles);
      vidstr(row,col, GREEN, out);
      if(++row > max_row) return row;

      sprintf(out, "FC wrt: %-7d", prs_fc_writes);
      vidstr(row,col, GREEN, out);
      if(++row > max_row) return row;
   }

   if     (prs_st[0] & 0x10) vidstr(row,col, RED,    "Light:  LOW   ");
   else if(prs_st[0] & 0x20) vidstr(row,col, RED,    "Light:  HIGH  ");
   else                      vidstr(row,col, GREEN,  "Light:  OK    ");
   if(++row > max_row) return row;

   if     (prs_st[0] & 0x40) vidstr(row,col, RED,    "GateV:  LOW   ");
   else if(prs_st[0] & 0x80) vidstr(row,col, RED,    "GateV:  HIGH  ");
   else                      vidstr(row,col, GREEN,  "GateV:  OK    ");
   if(++row > max_row) return row;



   if(prs_st[1] & 0x01) vidstr(row,col, RED,         "Synth:  UNLK  ");
   else                 vidstr(row,col, GREEN,       "Synth:  OK"   );
   if(++row > max_row) return row;

   if     (prs_st[1] & 0x02) vidstr(row,col, RED,    "RF VAR: LOW   ");
   else if(prs_st[1] & 0x04) vidstr(row,col, RED,    "RF VAR: HIGH  ");
   else                      vidstr(row,col, GREEN,  "RF VAR: OK    ");
   if(++row > max_row) return row;

   if     (prs_st[1] & 0x08) vidstr(row,col, RED,    "RF VCO: LOW   ");
   else if(prs_st[1] & 0x10) vidstr(row,col, RED,    "RF VCO: HIGH  ");
   else                      vidstr(row,col, GREEN,  "RF VCO: OK    ");
   if(++row > max_row) return row;

   if     (prs_st[1] & 0x20) vidstr(row,col, RED,    "RF AGC: LOW   ");
   else if(prs_st[1] & 0x40) vidstr(row,col, RED,    "RF AGC: HIGH  ");
   else                      vidstr(row,col, GREEN,  "RF AGC: OK    ");
   if(++row > max_row) return row;

   if(prs_st[1] & 0x80) {
      vidstr(row,col, RED,    "Bad PLL param  ");
      if(++row > max_row) return row;
   }


   if(prs_st[2]) {
      if(prs_st[2] & 0x03) {
         if     (prs_st[2] & 0x01) vidstr(row,col, RED,    "Lamp T: LOW   ");
         else if(prs_st[2] & 0x02) vidstr(row,col, RED,    "Lamp T: HIGH  ");
         if(++row > max_row) return row;
      }

      if(prs_st[2] & 0x0C) {
         if     (prs_st[2] & 0x04) vidstr(row,col, RED,    "Xtal T: LOW   ");
         else if(prs_st[2] & 0x08) vidstr(row,col, RED,    "Xtal T: HIGH  ");
         if(++row > max_row) return row;
      }

      if(prs_st[2] & 0x30) {
         if     (prs_st[2] & 0x10) vidstr(row,col, RED,    "Cell T: LOW   ");
         else if(prs_st[2] & 0x20) vidstr(row,col, RED,    "Cell T: HIGH  ");
         if(++row > max_row) return row;
      }

      if(prs_st[2] & 0xC0) {
         if     (prs_st[2] & 0x40) vidstr(row,col, RED,    "Case T: LOW   ");
         else if(prs_st[2] & 0x80) vidstr(row,col, RED,    "Case T: HIGH  ");
         if(++row > max_row) return row;
      }
   }
   else {
      vidstr(row,col, GREEN,  "Temps:  ALL OK");
      if(++row > max_row) return row;
   }



   if     (prs_st[3] & 0x01) vidstr(row,col, YELLOW, "FLL:    OFF   ");
   else                      vidstr(row,col, GREEN,  "FLL:    ON    ");
   if(++row > max_row) return row;

   if     (prs_st[3] & 0x02) vidstr(row,col, YELLOW, "F-Lock: DISABL");
   else                      vidstr(row,col, GREEN,  "F-Lock: ENABLE");
   if(++row > max_row) return row;

   if     (prs_st[3] & 0x04) vidstr(row,col, RED,    "EFC V:  LOW   ");
   else if(prs_st[3] & 0x08) vidstr(row,col, RED,    "EFC V:  HIGH  ");
   else                      vidstr(row,col, GREEN,  "EFC V:  OK    ");
   if(++row > max_row) return row;

   if     (prs_st[3] & 0x10) vidstr(row,col, RED,    "Cal V:  LOW   ");
   else if(prs_st[3] & 0x20) vidstr(row,col, RED,    "Cal V:  HIGH  ");
   else                      vidstr(row,col, GREEN,  "Cal V:  OK    ");
   if(++row > max_row) return row;



   if(prs_st[4] & 0x01) {
      vidstr(row,col, YELLOW, "PLL diaabled  ");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x02) {
      vidstr(row,col, YELLOW, "PLL acquiring ");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x04) {
      vidstr(row,col, GREEN,  "PLL active    ");
      if(++row > max_row) return row;
   }
   else {
      vidstr(row,col, YELLOW, "PLL inactive  ");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x08) {
      vidstr(row,col, YELLOW, "PPS input err ");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x10) {
      vidstr(row,col, YELLOW, "PPS input slow");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x20) {
      vidstr(row,col, YELLOW, "PLL restarted ");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x40) {
      vidstr(row,col, RED,    "Fctrl saturate");
      if(++row > max_row) return row;
   }

   if(prs_st[4] & 0x80) {
      vidstr(row,col, YELLOW, "NO PPS input  ");
      if(++row > max_row) return row;
   }

   return row;
}

int show_x72_status(int row,int col, int max_row)
{
int color;

   if(have_x72_creg) {
      if(x72_creg & 0x0008) vidstr(row,col, YELLOW, "PPS OUT: OFF  ");
      else                  vidstr(row,col, GREEN,  "PPS OUT: ON   ");
      if(++row > max_row) return row;

      if(x72_fw_discipline()) {
         if((last_x72_dmode != 1) && (last_x72_dmode != 2)) {
            vidstr(row,col, GREEN, "PPS IN:  UNKN ");
         }
         else if(x72_creg & 0x1000) {  // PPS input detected - fw discipline units only
            vidstr(row,col, GREEN,  "PPS IN:  SEEN ");
         }
         else {
            vidstr(row,col, YELLOW, "PPS IN:  NONE ");
         }
         if(++row > max_row) return row;

         if(user_set_x72_dmode && last_x72_dmode && (last_x72_dmode != 3)) {
            if(x72_creg & 0x0800) {  // PPS out locked to PPS in - fw discipline units only
               vidstr(row,col, GREEN,  "PPS OUT: LOCKED");
            }
            else if(x72_creg & 0x1000) {  // PPS input detected - fw discipline units only
               vidstr(row,col, YELLOW, "PPS OUT: UNLOCK");
            }
            else {
               vidstr(row,col, GREEN,  "PPS OUT: UNLOCK");
            }
            if(++row > max_row) return row;
         }
         else {
            vidstr(row,col, GREEN,  "PPS OUT: UNKN  ");
            if(++row > max_row) return row;
         }
      }

      if(x72_creg & 0x0004) vidstr(row,col, YELLOW, "FXO OUT: OFF  ");
      else                  vidstr(row,col, GREEN,  "FXO OUT: ON   ");
      if(++row > max_row) return row;

      if(x72_creg & 0x0010) vidstr(row,col, YELLOW, "ACMOS:   OFF  ");
      else                  vidstr(row,col, GREEN,  "ACMOS:   ON   ");
      if(++row > max_row) return row;

      if(x72_sine_level == 0) {
         vidstr(row,col, YELLOW, "Sine:    OFF  ");
      }
      else {
         sprintf(out,            "Sine ON: %d%%  ", x72_sine_level);
         vidstr(row,col, GREEN,  out);
      }
      if(++row > max_row) return row;


      if(x72_creg & 0x0002) vidstr(row,col, RED,    "Rb lock: OFF  ");
      else                  vidstr(row,col, GREEN,  "Rb lock: OK   ");
      if(++row > max_row) return row;

      if(x72_creg & 0x0400) vidstr(row,col, RED,    "Service: FAULT");
      else                  vidstr(row,col, GREEN,  "Service: OK   ");
      if(++row > max_row) return row;

      if(have_x72_srvc) {
         if(x72_srvc) vidstr(row,col, GREEN,  "SVC pol: HIGH ");
         else         vidstr(row,col, GREEN,  "SVC pol: LOW  ");
         if(++row > max_row) return row;
      }
      else {
         vidstr(row,col, GREEN,  "SVC pol: UNKN ");
         if(++row > max_row) return row;
      }

      if(x72_creg & 0x2000) {
         vidstr(row,col, GREEN,  "EFC INP: ON   ");
         if(++row > max_row) return row;
      }
      else if(have_x72_efc) {
         if(x72_efc) vidstr(row,col, GREEN,  "EFC inp: ON   ");
         else        vidstr(row,col, GREEN,  "EFC inp: OFF  ");
         if(++row > max_row) return row;
      }
      else {
         vidstr(row,col, GREEN,  "EFC inp: UNKN ");
         if(++row > max_row) return row;
      }

      if(have_x72_state) {
         color = YELLOW;
         if(x72_state == X72_STATE_DISCIPLINE) color = GREEN;
         else if(x72_state == X72_STATE_PIDCALC) color = GREEN;
         else if(x72_state == X72_STATE_PIDUPDATE) color = GREEN;
         else if(x72_state == X72_STATE_START0) color = GREEN;

         sprintf(out, "D State: %-3d  ", x72_state);
         if(color != GREEN)    vidstr(row,col, color, out);
         else if(x72_user_dis) vidstr(row,col, OSC_PID_COLOR, out);
         else                  vidstr(row,col, color,  out);
         if(++row > max_row) return row;
      }
      else {
         sprintf(out, "D State: UNKN ");
         vidstr(row,col, GREEN,  out);
         if(++row > max_row) return row;
      }


      if(x72_creg & 0x0001) vidstr(row,col, YELLOW, "L boost: ON   ");
      else                  vidstr(row,col, GREEN,  "L boost: OFF  ");
      if(++row > max_row) return row;

      if(x72_creg & 0x0020) vidstr(row,col, YELLOW, "C boost: ON   ");
      else                  vidstr(row,col, GREEN,  "C boost: OFF  ");
      if(++row > max_row) return row;
   }

   return row;
}


void show_single_sat()
{
   
   if(have_single_prn == 0) {
      vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "Single satellite         ");
   }
   else if(single_sat_prn) {
      sprintf(out, "Single sat: %02d           ", single_sat_prn);
      vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, out);
   }
   else {
      vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "Highest satellite        ");
   }
}

void show_operation_info(int why)
{
int color;
int i;

   if(text_mode && first_key) return;
   if(zoom_screen) return;
   if(luxor) return;
// if(rcvr_type == ACRON_RCVR) return;
   if(rcvr_type == NO_RCVR) return;

   // receiver mode and position
   i = 0;
   if((rcvr_type == SIRF_RCVR) && (!saw_timing_msg)) color = GREEN;
   else if((rcvr_type == UBX_RCVR) && (!saw_timing_msg)) color = GREEN;
   else if((rcvr_type == VENUS_RCVR) && (!saw_timing_msg)) color = GREEN;
   else if(GPSDO || TIMING_RCVR) color = YELLOW;
   else color = GREEN;

   if(rcvr_type == ZODIAC_RCVR) {
      if(single_sat_prn)                     show_single_sat();
      else if(rcvr_mode == RCVR_MODE_3D)     vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,  "Navigation mode          ");
      else if(rcvr_mode == RCVR_MODE_HOLD)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,  "Position hold mode       ");
      else if(rcvr_mode == RCVR_MODE_SURVEY) vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "Survey mode              ");
      else {
         sprintf(out, "Receiver mode ?%02X?  ", rcvr_mode);
         vidstr(POSN_ROW+0+eofs,POSN_COL, RED, out);
      }
   }
   else if(NO_SATS || (rcvr_type == TIDE_RCVR)) {
      if(lat || lon) {
         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "User set location        ");
      }
      else {
         vidstr(POSN_ROW+0+eofs,POSN_COL, RED,    "Use SL to set LLA        ");
      }
   }
   else if(rcvr_type == RFTG_RCVR) {
      if(rftg_unit == 0) vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "No location on RB unit   ");
      else               vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,  "Location                 ");
   }
   else if((rcvr_type == STAR_RCVR) && (star_type == OSA_TYPE)) {
      vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Location                 ");
   }
   else if(single_sat_prn && (rcvr_type != TSIP_RCVR)) {
      show_single_sat();
   }
   else if(rcvr_mode == RCVR_MODE_2D_3D)   vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,  "2D/3D positioning        ");
   else if(rcvr_mode == RCVR_MODE_SINGLE)  show_single_sat();
   else if(rcvr_mode == RCVR_MODE_NO_SATS) {
      if(rcvr_type == BRANDY_RCVR) vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,          "Positioning interrupted  ");
      else                         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,          "No sats usable           ");
   }
   else if(rcvr_mode == RCVR_MODE_2D)      vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,  "2D positioning           ");
   else if(rcvr_mode == RCVR_MODE_3D) {
       if((rcvr_type == VENUS_RCVR) && saw_venus_raw && have_rtk_mode) {  // rnx2
          if(rtk_mode == BASE_MODE) vidstr(POSN_ROW+0+eofs,POSN_COL, color,   "Kinematic Base Mode  ");
          else                      vidstr(POSN_ROW+0+eofs,POSN_COL, color,   "Kinematic Rover Mode ");
       }
       else {
          vidstr(POSN_ROW+0+eofs,POSN_COL, color,   "3D positioning           ");
       }
   }
   else if(rcvr_mode == RCVR_MODE_DGPS)    vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,  "DGPS reference           ");
   else if(rcvr_mode == RCVR_MODE_2DCLK)   vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,  "2D clock hold            ");
   else if(rcvr_mode == RCVR_MODE_HOLD)  {
      if     (rcvr_type == ACRON_RCVR)  vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == BRANDY_RCVR) vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == ESIP_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == MOTO_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == NVS_RCVR)    vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == SCPI_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == STAR_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == TRUE_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == UCCM_RCVR)   vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == UBX_RCVR)    vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == VENUS_RCVR) { 
         if(saw_venus_raw && have_rtk_mode) {  
            if(rtk_mode == BASE_MODE) vidstr(POSN_ROW+0+eofs,POSN_COL, color,   "Static Base Mode     ");
            else                      vidstr(POSN_ROW+0+eofs,POSN_COL, color,   "Static Rover Mode    ");  // should not happen
         }
         else {
            vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN, "Position hold mode       ");
         }
      }
      else if(rcvr_type == ZODIAC_RCVR) vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else if(rcvr_type == ZYFER_RCVR)  vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Position hold mode       ");
      else                              vidstr(POSN_ROW+0+eofs,POSN_COL, GREEN,      "Overdetermined clock     ");
   }
   else if(rcvr_mode == RCVR_MODE_PROP)  {
      if(rcvr_type == SCPI_RCVR) {
         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,                                    "Holdover mode            ");
      }
      else if(rcvr_type == UCCM_RCVR) { 
         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,                                    "Holdover mode            ");
      }
      else if(rcvr_type == STAR_RCVR) { 
         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,                                    "Holdover mode            ");
      }
      else {
         vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW,                                    "Propogate mode           ");
      }
   }
   else if(rcvr_mode == RCVR_MODE_ACQUIRE)  vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "Acquiring sats           ");
   else if(rcvr_mode == RCVR_MODE_BAD_GEOM) vidstr(POSN_ROW+0+eofs,POSN_COL, RED,    "Bad sat geometry         ");
   else if(rcvr_mode == RCVR_MODE_SURVEY)   vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, "Survey mode              ");
   else if(rcvr_mode == RCVR_MODE_UNKNOWN) {
      sprintf(out, "Unknown rcvr mode   ");
      vidstr(POSN_ROW+0+eofs,POSN_COL, YELLOW, out);
   }
   else {
      sprintf(out, "Receiver mode ?%02X?  ", rcvr_mode);
      vidstr(POSN_ROW+0+eofs,POSN_COL, RED, out);
   }

   if(rcvr_mode == RCVR_MODE_HOLD) fix_mode = 0;
   else                            fix_mode = 1;

   show_lla(why);        // lat/lon/alt info
   show_survey_info();   // self survey info

if(rcvr_type == ACRON_RCVR) return;   // NEW_RCVR
if(rcvr_type == FURUNO_RCVR) return;
if((rcvr_type == GPSD_RCVR) && (!saw_gpsdo)) return; // gggg
if(rcvr_type == NMEA_RCVR) return;
if(rcvr_type == THERMO_RCVR) return;
if((rcvr_type == TICC_RCVR) && (ticc_type != LARS_TICC)) return;

   // Oscillator disciplining info
   if(hide_op_mode) ;
   else if(sats_enabled != 0xFFFFFFFF)              vidstr(DIS_ROW+0+eofs, DIS_COL, YELLOW, "Sats excluded   ");
   else if(GPSDO && (rcvr_type != UCCM_RCVR))       vidstr(DIS_ROW+0+eofs, DIS_COL, WHITE,  "Discipline mode:");
   else                                             vidstr(DIS_ROW+0+eofs, DIS_COL, WHITE,  "Operation mode: ");

//sprintf(plot_title, "fwdis:%d  user:%d  state:%d  dmode:%d",  x72_fw_discipline(), x72_user_dis, x72_state, discipline_mode);

   if(rcvr_type == CS_RCVR) {
      if(have_cs_standby && have_cs_cont) {
         if(cs_standby) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW,  "Oper: STANDBY   "); 
         else if(cs_cont == 2) {
            vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,   "Oper: CONTINUOUS"); 
         }
         else if(cs_cont == 1) {
            vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW,  "Oper: CONT ENABL"); 
         }
         else if(cs_cont == 0) {
            vidstr(DIS_ROW+1+eofs, DIS_COL, RED,     "Oper: CONT OFF  "); 
         }
         else {
            vidstr(DIS_ROW+1+eofs, DIS_COL, RED,     "Oper: CONT UNKN "); 
         }
      }
      else {
         vidstr(DIS_ROW+1+eofs, DIS_COL, RED,     "Oper: UNKNOWN   "); 
      }
   }
   else if(rcvr_type == ESIP_RCVR) {
      if     (esip_status == 1) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Warming up      ");
      else if(esip_status == 2) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Time locked     ");
      else if(esip_status == 3) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Holdover        ");
      else if(esip_status == 4) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Free running    ");
      else if(esip_status == 5) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Coarse align    ");
      else if(esip_status == 6) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Fine align      ");
      else                      vidstr(DIS_ROW+1+eofs, DIS_COL, RED,    "Unknown state   ");
   }
   else if(rcvr_type == SRO_RCVR) {
      if     (sro_status == 0) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Warming up      ");
      else if(sro_status == 1) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Tracking setup  ");
      else if(sro_status == 2) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Tracking PPS    ");
      else if(sro_status == 3) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Synced to PPS   ");
      else if(sro_status == 4) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Free running    ");
      else if(sro_status == 5) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "PPS unstable    ");
      else if(sro_status == 6) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "No PPS ref      ");
      else if(sro_status == 7) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Factory state 7 ");
      else if(sro_status == 8) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Factory state 8 ");
      else if(sro_status == 9) vidstr(DIS_ROW+1+eofs, DIS_COL, RED,    "RB unlocked     ");
   }
   else if((rcvr_type == X72_RCVR) && have_x72_state) {
      if(x72_state == X72_STATE_START0)  {
         if(x72_user_dis == 0) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Free running    ");
         else                  vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Startup 0       ");
      }
      else if(x72_state == X72_STATE_START1)     vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Startup 1       ");
      else if(x72_state == X72_STATE_START2)     vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Startup 2       ");
      else if(x72_state == X72_STATE_HOLDOVER)   vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Holdover        ");
      else if(x72_state == X72_STATE_JAM1)       vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Jamsync 1       ");
      else if(x72_state == X72_STATE_JAM2)       vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Jamsync 2       ");
      else if(x72_state == X72_STATE_DISCIPLINE) {
         if(x72_dmode_val == 0) vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,         "Free running    ");
         else if(x72_user_dis)  vidstr(DIS_ROW+1+eofs, DIS_COL, OSC_PID_COLOR, "SW Disciplining ");
         else                   vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,         "FW Disciplining ");
      }
      else if(x72_state == X72_STATE_PIDCALC)    vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "PID calc        ");
      else if(x72_state == X72_STATE_PIDUPDATE)  vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "PID update      ");
      else if(x72_state == X72_STATE_SLOPECALC)  vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "PID slope calc  ");
      else                                       vidstr(DIS_ROW+1+eofs, DIS_COL, RED,    "Unknown         ");
   }
   else if(discipline_mode == DIS_MODE_NORMAL) {
      if((rcvr_type == UCCM_RCVR) && uccm_led_msg[0]) { //kkkkk
         if     (strstr(uccm_led_msg, "NORMAL")) color = GREEN;
         else if(strstr(uccm_led_msg, "LOCKED")) color = GREEN;
         else                                    color = YELLOW;
         vidstr(DIS_ROW+1+eofs, DIS_COL, color,  uccm_led_msg);
      }
      else if(rcvr_type == LPFRS_RCVR) {
         vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Free running    ");
      }
      else if(rcvr_type == PRS_RCVR) {
         vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Disciplining    ");
      }
      else if(rcvr_type == X72_RCVR) {
         vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Free running    ");
      }
      else vidstr(DIS_ROW+1+eofs, DIS_COL, GREEN,  "Normal          ");
   }
   else if(discipline_mode == DIS_MODE_POWERUP)   vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Power-up        ");
   else if(discipline_mode == DIS_MODE_AUTO_HOLD) vidstr(DIS_ROW+1+eofs, DIS_COL, RED,    "Auto holdover   ");  // this could be a YELLOW alert
   else if(discipline_mode == DIS_MODE_MANUAL_HOLD) {
      if     (rcvr_type == SCPI_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Holdover mode   ");
      else if(rcvr_type == UCCM_RCVR) {
         if(scpi_type == UCCMP_TYPE)  vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Holdover mode   ");  // kkkkkk uuuuu
         else                         vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Manual EFC mode ");  // kkkkkk uuuuu
      }
      else if(rcvr_type == GPSD_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Discipline off  ");
      else                            vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Manual holdover ");
   }
   else if(discipline_mode == DIS_MODE_RECOVERY) {
      if(rcvr_type == GPSD_RCVR)      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "No PPS reference");
      else if(rcvr_type == STAR_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Output squelched");
      else if(rcvr_type == TM4_RCVR)  vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Coarse adjust   ");
      else {
         vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Recovery        ");
         holdover_seen |= HOLD_SEEN_REC;
      }
   }
   else if(discipline_mode == DIS_MODE_FAST_RECOVERY) {
      if(rcvr_type == TM4_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Coarse standby  ");
      else                      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Fast recovery   ");
   }
   else if(discipline_mode == DIS_MODE_DISABLED) {
      if(osc_control_on) vidstr(DIS_ROW+1+eofs, DIS_COL, OSC_PID_COLOR,  "OSC PID ENABLED ");
      else if(rcvr_type == PRS_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Free running    ");
      else vidstr(DIS_ROW+1+eofs, DIS_COL, RED,            "Disabled        ");
   }
   else if(discipline_mode == DIS_MODE_UNLOCK) {
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Unlocked        ");
   }
   else if(discipline_mode == DIS_MODE_WARMUP) {
      if(saw_uccm_dmode == 1)  vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Settling        ");
      else                     vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Warming up      ");
   }
   else if(discipline_mode == DIS_MODE_LEARNING) {
      if(rcvr_type == TM4_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Fine adjust     ");
      else                      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Learning        ");
   }
   else if(discipline_mode == DIS_MODE_NO_GPS) {
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "No GPS          ");
   }
   else if(discipline_mode == DIS_MODE_SOFT_HOLD) {
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Soft holdover   ");
   }
   else if(discipline_mode == DIS_MODE_ACQUIRE) {
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, "Acquiring       ");
   }
   else if(discipline_mode == DIS_MODE_FAILED) {
      if(rcvr_type == LPFRS_RCVR)     vidstr(DIS_ROW+1+eofs, DIS_COL, RED, "RB unlocked     ");
      else if(rcvr_type == SA35_RCVR) vidstr(DIS_ROW+1+eofs, DIS_COL, RED, "RB unlocked     ");
      else if(rcvr_type == SRO_RCVR)  vidstr(DIS_ROW+1+eofs, DIS_COL, RED, "RB unlocked     ");
      else                            vidstr(DIS_ROW+1+eofs, DIS_COL, RED, "MODULE FAILED!  ");
   }
   else if(discipline_mode == DIS_MODE_WAIT) {
      sprintf(out, "Waiting: %-7d", true_wait);
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, out);
   }
   else {
      if(res_t) sprintf(out, "Operation ?%02X?  ", discipline_mode);
      else      sprintf(out, "Discipline ?%02X? ", discipline_mode);
      vidstr(DIS_ROW+1+eofs, DIS_COL, YELLOW, out);
   }

if(rcvr_type == GPSD_RCVR) return;
if(rcvr_type == TIDE_RCVR) return;

   color = GREEN;
   if(have_cs_remote) {
      if(have_cs_remote) {
         if(cs_remote) sprintf(out, "Mode: REMOTE                  ");
         else          sprintf(out, "Mode: LOCAL                   ");
      }
      else {
         sprintf(out, "Mode: UNKNOWN                 ");
      }
   }
   else if((rcvr_type == SRO_RCVR) && sro_countdown) {
      sprintf(out, "Gofast timer: %-5d", sro_countdown);
   }
   else if(have_star_atdc) {
      if(star_atdc_on) {
        if(star_atdc_time) {
           sprintf(out, "ATDC: in %d secs              ", star_atdc_time);
           color = YELLOW;
        }
        else {
           sprintf(out, "ATDC: NOT READY               ");
           color = RED;
        }
      }
      else sprintf(out, "ATDC: ACTIVE                  ");
   }
   else if(rcvr_type == RFTG_RCVR) {
      if(holdover_seen) {
        sprintf(out, "Holdover: seen                ");
      }
      else {
        sprintf(out, "Holdover: 0 secs              ");
      }
   }
   else if((rcvr_type == UCCM_RCVR) && (scpi_type == UCCMP_TYPE)) {  //kkkkkk
      if(holdover >= 1000000) {
         sprintf(out, "Holdover:%lu secs            ", (unsigned long) holdover);
      }
      else {
         sprintf(out, "Holdover: %lu secs            ", (unsigned long) holdover);
      }
   }
   else if(rcvr_type == X72_RCVR) {
      strcpy(out, blanks);
      holdover_seen = 0;
      if((x72_user_state == X72_STATE_HOLDOVER) && x72_user_dis) {
         sprintf(out, "Holdover: %d secs            ", X72_HOLDOVER_SIZE-holdover);
         holdover_seen = 1;
      }
   }
   else if(GPSDO && (rcvr_type != STAR_RCVR) && (rcvr_type != UCCM_RCVR)) {
      if(holdover >= 1000000) {
         sprintf(out, "Holdover:%lu secs            ", (unsigned long) holdover);
      }
      else {
         sprintf(out, "Holdover: %lu secs            ", (unsigned long) holdover);
      }
   }
   else strcpy(out, blanks);

   out[20] = 0;
// if((discipline_mode == DIS_MODE_AUTO_HOLD) || (discipline_mode == DIS_MODE_MANUAL_HOLD)) {
   if(discipline_mode != DIS_MODE_NORMAL) {
      color = RED;
      holdover_seen |= HOLD_SEEN_HOLD;
   }
   else if(holdover_seen) color = YELLOW;

   vidstr(DIS_ROW+2+eofs, DIS_COL, color, out);

   if(rcvr_type == CS_RCVR) {
      if(have_cs_sync && (cs_sync[0] != 'O')) {
         sprintf(out, "Syncing: %-5.5s     ", cs_sync);
         vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW, out);
      }
      else if(have_cs_ster && (cs_ster != 0.0)) {
         if(cs_ster < 0.0) sprintf(out, "Steering: %g", cs_ster);
         else              sprintf(out, "Steering: %g ", cs_ster);
         vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW,  out);
      }
      else if(have_cs_disp) {
         if(cs_disp) vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "Display: ON        ");
         else        vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "Display: OFF       ");
      }
      else {
         vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "Display: UNKNOWN   ");
      }
   }
   else if(rcvr_type == SRO_RCVR) {
      sprintf(out, "Freq limited: R4F:%02X", sro_r4F);
      if(sro_r4F & 0x07) vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW, out);
      else               vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "                    ");
   }
   else if(have_star_perf) {
      if(star_hold_perf) vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "Holdover perf GOOD ");
      else               vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW, "Learning holdover  ");
   }
   else if(!have_gps_status) {
      if((rcvr_type == ZYFER_RCVR) && have_zyfer_hint) {
         i = (zy_pll_bad + zy_gps_bad + zy_fix_bad + zy_bias_bad);
         if(i > 1) {
            sprintf(out, "Status:%d,%d,%d,%d,%d", zy_hflag,zy_pll_bad,zy_gps_bad,zy_fix_bad,zy_bias_bad);
            vidstr(DIS_ROW+3+eofs, DIS_COL, RED, out); 
         }
         else if(i == 1) {
            if     (zy_pll_bad)  vidstr(DIS_ROW+3+eofs, DIS_COL, RED, "Pll unlocked    "); 
            else if(zy_gps_bad)  vidstr(DIS_ROW+3+eofs, DIS_COL, RED, "No GPS data     "); 
            else if(zy_fix_bad)  vidstr(DIS_ROW+3+eofs, DIS_COL, RED, "Raw fix bad     "); 
            else if(zy_bias_bad) vidstr(DIS_ROW+3+eofs, DIS_COL, RED, "Bias data bad   "); 
            else {
               sprintf(out, "Status:%d,%d,%d,%d,%d", zy_hflag,zy_pll_bad,zy_gps_bad,zy_fix_bad,zy_bias_bad);
               vidstr(DIS_ROW+3+eofs, DIS_COL, RED, out); 
            }
         }
         else if(i < 0) {
            sprintf(out, "Status:%d,%d,%d,%d,%d", zy_hflag,zy_pll_bad,zy_gps_bad,zy_fix_bad,zy_bias_bad);
            vidstr(DIS_ROW+3+eofs, DIS_COL, RED, out); 
         }
         else if(zy_hflag == 0) {
            vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW, "Status: Learning"); 
         }
         else {
            vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "Status: Normal  "); 
         }
      }
      else if(have_lifetime) {
         sprintf(out, "Life:%7d hrs", scpi_life);
         vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN, out); 
      }
      else if(lte_lite) ;
      else vidstr(DIS_ROW+3+eofs, DIS_COL, GREY,    "No status avail "); 
   }
   else if(gps_status == GPS_FIXES)       vidstr(DIS_ROW+3+eofs, DIS_COL, GREEN,  "Doing fixes     ");
   else if(gps_status == GPS_NO_FIXES)    vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "No fixes        ");
   else if(gps_status == GPS_NO_TIME)     vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "No GPS time     ");
   else if(gps_status == GPS_PDOP_HIGH)   vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "PDOP too high   ");
   else if(gps_status == GPS_NO_SATS)     vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "No usable sats  ");
   else if(gps_status == GPS_ONE_SAT)     vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "1 usable sat    ");
   else if(gps_status == GPS_TWO_SATS)    vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "2 usable sats   ");
   else if(gps_status == GPS_THREE_SATS)  vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "3 usable sats   ");
   else if(gps_status == GPS_SAT_UNAVAIL) vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "sat unusable    ");
   else if(gps_status == GPS_TRAIM_ERR)   vidstr(DIS_ROW+3+eofs, DIS_COL, RED,    "TRAIM rejected  ");
   else {
      sprintf(out, "GPS status:?%02X? ", gps_status);
      vidstr(DIS_ROW+3+eofs, DIS_COL, YELLOW, out);
   }

}


void show_rcvr_rate()
{
int color;

   // show the receiver navigation rate above the screen receiver data block

   color = GREEN;
   if(last_plot_key) color = BLUE;

   if(ticc_port_open() || (enviro_mode() && (rcvr_type != THERMO_RCVR))) {
      if(ticc_port_open() && enviro_mode()) {
         vidstr(VAL_ROW+0, VAL_COL, color,  "Enviro & TICC   ");
         return;
      }
      else if(enviro_mode()) {
         vidstr(VAL_ROW+0, VAL_COL, color,  "Enviro sensor on");
         return;
      }
      else if(ticc_port_open()) {
         vidstr(VAL_ROW+0, VAL_COL, color,  "TICC port ADEVs ");
         return;
      }
   }

   if(have_nav_rate && (nav_rate != 1)) {
      if(nav_rate < 10.0) sprintf(out, "Rcvr rate:%3.1f Hz", nav_rate);
      else                sprintf(out, "Rcvr rate:%3d Hz", (int) nav_rate);
      vidstr(VAL_ROW+0, VAL_COL, color,  out);
   }
   else if((rcvr_type == CS_RCVR) && have_cs_cbtid) {
      sprintf(out, "CBT: %-13.13s", cs_cbtid);
      vidstr(VAL_ROW+0, VAL_COL, color, out);
   }
   else if(rcvr_type == THERMO_RCVR) {
      vidstr(VAL_ROW+0, VAL_COL, color,  "Sensor data     ");
   }
   else {
      vidstr(VAL_ROW+0, VAL_COL, color,  "Receiver data   ");
   }
}

void show_rcvr_type()
{
char *s;

   // show the receiver type in the screen receiver version data block
   // also shows the current disicple mode above the receiver data block
   //
   // NEW_RCVR

   if(rcvr_type == NO_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  System clock"); 
      return;
   }
   else if(rcvr_type == ACRON_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Acron Zeit       "); 
      return;
   }
   else if(unit_name[0]) {
      sprintf(out, "Dev:  %s", unit_name);
      vidstr(VER_ROW+1, VER_COL, WHITE,  out);  
      show_rcvr_rate();
   }
   else if(res_t) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Resolution-T     "); 
      show_rcvr_rate();
   }
   else if(saw_ntpx) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Nortel NTPX      "); 
      show_rcvr_rate();
   }
   else if(saw_nortel) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Nortel NTGS/NTBW "); 
      show_rcvr_rate();
   }
   else if(ACU_GG) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Acutime GG "); 
      show_rcvr_rate();
   }
   else if(ACU_360) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Acutime 360 "); 
      show_rcvr_rate();
   }
   else if(ACUTIME) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Trimble Acutime  "); 
      show_rcvr_rate();
   }
   else if(PALISADE) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Trimble Palisade "); 
      show_rcvr_rate();
   }
   else if(ACE3) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Trimble ACE-III  "); 
      show_rcvr_rate();
   }
   else if(SV6_FAMILY) {
//    vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Trimble SV6/SV8  "); 
      show_rcvr_rate();
   }
   else if(rcvr_type == BRANDY_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Brandywine GPSDO "); 
      show_rcvr_rate();
   }
   else if(rcvr_type == ESIP_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  eSIP Receiver  ");
      show_rcvr_rate();
   }
   else if(rcvr_type == FURUNO_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Furuno Receiver  ");
      show_rcvr_rate();
   }
   else if(rcvr_type == GPSD_RCVR) {  
      if(gpsd_release[0]) {
         sprintf(out, "Rel:  GPSD %-12.12s", gpsd_release);
         vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      }
      else if(gpsd_major || gpsd_minor) {
         sprintf(out, "Dev:  GPSD prot %d.%02d   ", gpsd_major,gpsd_minor);
         vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      }
      else {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  GPSD interface   ");
      }
      show_rcvr_rate();

      if(gpsd_driver[0]) vidstr(VER_ROW+2, VER_COL, WHITE, gpsd_driver);
   }
   else if(rcvr_type == LPFRS_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: LPFRS rubidium   ");
      show_rcvr_rate();
   }
   else if(rcvr_type == MOTO_RCVR) {
      if(0 && moto_id[2][0]) {   // show software version
         s = strchr(&moto_id[2][0], '#');
         if(s) {
            while(*s) {
               ++s;
               if(*s == 0) break;
               if(*s != ' ') {
                  sprintf(out, "SW:   %-19.19s", s);
                  goto show_moto;
               }
            }
         }
      }

      if(furuno_moto) sprintf(out, "Dev:  Furuno %2d chan   ", moto_chans);
      else            sprintf(out, "Dev:  Motorola %2d chan ", moto_chans);

      show_moto:
      vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      show_rcvr_rate();
   }
   else if(rcvr_type == RT17_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Trimble RT17 fmt ");
      show_rcvr_rate();
   }
   else if(rcvr_type == NMEA_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  NMEA GPS Receiver");
      show_rcvr_rate();
   }
   else if(rcvr_type == NVS_RCVR) {
      sprintf(out, "Dev:  NVS %2d channel   ", nvs_chans);
      vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      show_rcvr_rate();
   }
   else if(rcvr_type == PRS_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: PRS-10 rubidium  ");
      show_rcvr_rate();
   }
   else if(rcvr_type == RFTG_RCVR) {
      if((have_rftg_unit) && (rftg_unit == 0)) {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  RFTG-m RB        ");
      }
      else if((have_rftg_unit) && (rftg_unit == 1)) {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  RFTG-m XO        "); 
      }
      else {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  RFTG-m           "); 
      }
      show_rcvr_rate();
   }
   else if(rcvr_type == SA35_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE, "Dev: SA.35m rubidium   ");
      show_rcvr_rate();
   }
   else if(rcvr_type == SCPI_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE, "Dev:  SCPI receiver    ");
      show_rcvr_rate();
   }
   else if(rcvr_type == SIRF_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  SIRF receiver    ");
      show_rcvr_rate();
   }
   else if(rcvr_type == SRO_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: SRO100 rubidium  ");
      show_rcvr_rate();
   }
   else if(rcvr_type == STAR_RCVR) {
      if(star_module[0]) {
         sprintf(out, "Dev:  %s", star_module);
         vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      }
      else {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  STAR receiver    ");
      }
      show_rcvr_rate();
   }
   else if(rcvr_type == TAIP_RCVR) {
      if(taip_product[0]) {
         sprintf(out, "Dev:  %-17.17s", taip_product);
         vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      }
      else {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  TAIP receiver    ");
      }
      show_rcvr_rate();
   }
   else if(rcvr_type == THERMO_RCVR) {
      if(enviro_dev[0]) {
         sprintf(out, "Dev:  %s", enviro_dev);
         vidstr(VER_ROW+1, VER_COL, WHITE,  out);  
      }
      else {
         vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Environmental    ");
      }
      show_rcvr_rate();
   }
   else if(rcvr_type == TICC_RCVR) {
      if     (ticc_type == TAPR_TICC)   vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  TAPR TICC        ");
      else if(ticc_type == HP_TICC)     vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  HP53xxx counter  ");
      else if(ticc_type == PICPET_TICC) vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  PICPET           ");
      else if(ticc_type == LARS_TICC)   vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  LARS GPSDO TIC   ");
      else                              vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Generic counter  ");
//    show_rcvr_rate();
   }
   else if(rcvr_type == TIDE_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Gravity clock"); 
      return;
   }
   else if(rcvr_type == TM4_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Spectrum TM4     ");
      show_rcvr_rate();
   }
   else if(rcvr_type == TRUE_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  TruePosition     ");
      show_rcvr_rate();
   }
   else if(rcvr_type == TSERVE_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  TymServe 2000    ");
      show_rcvr_rate();
   }
   else if(rcvr_type == UCCM_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  UCCM receiver    ");
      show_rcvr_rate();
   }
   else if(rcvr_type == UBX_RCVR) {
      if(saw_timing_msg) vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Ublox timing     ");
      else               vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Ublox receiver   ");
      show_rcvr_rate();
   }
   else if(rcvr_type == VENUS_RCVR) {
      if(lte_lite) {
         sprintf(out, "%s", "Dev:  Jackson Labs LTE ");
      }
      else if(saw_venus_raw) {
         if(venus_kern[0]) sprintf(out, "Dev:  Venus-R %s", venus_kern);
         else              sprintf(out, "%s", "Dev:  Venus RTK rcvr   ");
      }
      else if(saw_timing_msg) {
         if(venus_kern[0]) sprintf(out, "Dev:  Venus-T %s", venus_kern);
         else              sprintf(out, "%s", "Dev:  Venus timing rcvr");
      }
      else {
         if(venus_kern[0]) sprintf(out, "Dev:  Venus %s ", venus_kern);
         else              sprintf(out, "%s", "Dev:  Venus receiver   ");
      }
      vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      show_rcvr_rate();
   }
   else if(rcvr_type == X72_RCVR) {
      if(x72_type == SA22_TYPE)     vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: SA22 rubidium    ");
      else if(x72_type == X99_TYPE) vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: X99 rubidium     ");
      else                          vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev: X72 rubidium     ");
      show_rcvr_rate();
   }
   else if(rcvr_type == ZODIAC_RCVR) {
      if(zod_chans[0]) sprintf(out, "Dev:  Jupiter %2s chan    ", zod_chans);
      else             sprintf(out, "Dev:  Jupiter receiver   ");
      vidstr(VER_ROW+1, VER_COL, WHITE,  out);
      show_rcvr_rate();
   }
   else if(rcvr_type == ZYFER_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Zyfer Nanosync   ");
      show_rcvr_rate();
   }
   else if(rcvr_type == Z12_RCVR) {
      vidstr(VER_ROW+1, VER_COL, WHITE,  "Dev:  Ashtech Z12      ");
      show_rcvr_rate();
   }
   else if(touch_screen && last_plot_key) {
      show_rcvr_rate();
   }
   else if(ticc_port_open()) {
      show_rcvr_rate();
   }
   else if(GPSDO) {
      if(discipline == DIS_LOCKED)  {
         if(ticc_port_open() || (enviro_mode() && (rcvr_type != THERMO_RCVR))) {
            show_rcvr_rate();
         }
         else {
            vidstr(VAL_ROW+0, VAL_COL, GREEN,  "Phase locked    ");
         }
      }
      else if(discipline == DIS_WARMING) vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Warming up      ");
      else if(discipline == DIS_FLOCK)   vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Freq locking    ");
      else if(discipline == DIS_PLACING) vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Placing PPS     ");
      else if(discipline == DIS_FINIT)   vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Filter init     ");
      else if(discipline == DIS_COMP)    vidstr(VAL_ROW+0, VAL_COL, YELLOW, "OCXO comp       ");
      else if(discipline == DIS_OFF) {
         if(osc_control_on) vidstr(VAL_ROW+0, VAL_COL, OSC_PID_COLOR, "Discipline OSC PID   ");
         else               vidstr(VAL_ROW+0, VAL_COL, RED,           "Discipline OFF       ");
      }
      else if(discipline == DIS_RECOVERY) {
         vidstr(VAL_ROW+0, VAL_COL, YELLOW, "Recovery mode   ");
         holdover_seen |= HOLD_SEEN_REC;
      }
      else {
         sprintf(out, "Discipline: %02X  ", discipline);
         vidstr(VAL_ROW+0, VAL_COL, RED, out);
      }
   }
   else if(0) {
      show_rcvr_rate();
   }
}


void show_dac_info()
{
   // show the current DAC related value in the screen receiver data block
   if(rcvr_type == NO_RCVR) return;
   if(rcvr_type == THERMO_RCVR) return;
   if((rcvr_type == TIDE_RCVR) && enviro_mode()) return;

   sprintf(out, "                    ");
// if((rcvr_type == NMEA_RCVR) || (rcvr_type == GPSD_RCVR) || (rcvr_type == STAR_RCVR) || (rcvr_type == TAIP_RCVR)) {
   if((have_dac == 0) && (have_sawtooth == 0) && (have_lars_dac == 0)) {
   }
   else if((have_dac == 0) && (have_sawtooth == 0) && have_lars_dac) {
      sprintf(out, "DACL: %-11.4f %s   ", lars_dac, " ");
   }
   else if(rcvr_type == CS_RCVR) {
      sprintf(out, "DAC:%11.5f %s   ", dac_voltage, plot[DAC].units);
   }
   else if(rcvr_type == TICC_RCVR) {
      if(ticc_type == LARS_TICC) {
         sprintf(out, "DAC:%11.5f %s   ", dac_voltage, plot[DAC].units);
      }
      else {
         sprintf(out, "FdgA:%11.6f %s   ", dac_voltage, "ps");
      }
   }
   else if(lte_lite) {
      sprintf(out, "DAC:%11.6f %s   ", dac_voltage, plot[DAC].units);
   }
   else if(TIMING_RCVR) {
      if(have_sawtooth) {
         if((dac_voltage >= 1000.0) || (dac_voltage <= -100.0)) {
            sprintf(out, "Sawt:%10.5f ns  ", dac_voltage);  // pps_quant);
         }
         else {
            sprintf(out, "Sawt:%10.6f ns  ", dac_voltage);  // pps_quant);
         }
      }
      else sprintf(out, "                    ");
   }
   else if(rcvr_type == TSIP_RCVR) {
      if(SV6_FAMILY) sprintf(out, "                    ");
      else    sprintf(out, "DAC:%11.6f %s   ", dac_voltage, "V");
   }
   else {
      sprintf(out, "DAC:%11.6f %s   ", dac_voltage, plot[DAC].units);
   }

   if     (critical_alarms & CRIT_OCXO)  vidstr(VAL_ROW+2, VAL_COL, RED,    out);
   else if(minor_alarms & MINOR_OSC_AGE) vidstr(VAL_ROW+2, VAL_COL, YELLOW, out);
   else if(osc_control_on)               vidstr(VAL_ROW+2, VAL_COL, OSC_PID_COLOR, out);
   else                                  vidstr(VAL_ROW+2, VAL_COL, WHITE,  out);
}

void show_temp_info()
{
DATA_SIZE val;
char *s;

   // show the current temperature related value in the screen receiver data block
   if(rcvr_type == NO_RCVR) return;
   val = (DATA_SIZE) temperature;

   // upper case indicates environmenal sensor is active
   if(luxor) s = "TEMP1:";
   else if(enviro_mode() && (have_temperature == 0)) {  // flag external temp sensor with upper case
      s = "TEMP1:";  // receiver has no temp sensor, showing environmental sensor data
   }
   else if((have_temperature == 0) && have_lars_temp) {
      s = "TEMPL:";
      val = lars_temp;
   }
   else if(rcvr_type == THERMO_RCVR) {
      s = "TEMP1:";  // showing environmental sensor data
   }
   else if(enviro_mode()) {
      s = "TEMP:";   // rcvr has temp sensor, showing that data
   }
   else if(0 && (ACUTIME || ACU_GG || ACU_360 || PALISADE)) {
      s = "Tval:";
   }
   else {  // using receiver temp sensor
      s = "Temp:";
   }

   if(rcvr_type == CS_RCVR) {
      sprintf(out, "%s     %s%c", s, fmt_temp((double) val), temp_dir);
      vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
   }
   else if((rcvr_type == TIDE_RCVR) && enviro_mode()) {
      goto enviro_data;
   }
   else if((enviro_port_open() == 0) && (rcvr_type == UCCM_RCVR) && (scpi_type == UCCMP_TYPE) && (have_temperature == 0)) {   // samsung
      if(have_uccm_tcor == 0) return;
      s = "TCOR:";
      if((val >= 100000000.0) || (val <= (-10000000.0))) {
         sprintf(out, "%s%10.0f%s   ", s,val, ppt_string);
      }
      else if((val >= 10000000.0) || (val <= (-1000000.0))) {
         sprintf(out, "%s%10.1f%s   ", s,val, ppt_string);
      }
      else if((val >= 1000000.0) || (val <= (-100000.0))) {
         sprintf(out, "%s%10.2f%s   ", s,val, ppt_string);
      }
      else if((val >= 100000.0) || (val <= (-10000.0))) {
         sprintf(out, "%s%10.3f%s   ", s,val, ppt_string);
      }
      else if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%10.4f%s   ", s,val, ppt_string);
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%10.5f%s   ", s,val, ppt_string);
      }
      else {
         sprintf(out, "%s%10.6f%s   ", s,val, ppt_string);
      }
      vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
   }
   else if(!have_temperature && !have_lars_dac) {
      if(enviro_mode()) goto enviro_temp;
      vidstr(VAL_ROW+1, VAL_COL, GREY, "Temp: no sensor");
   }
   else if(ACUTIME || ACU_GG || ACU_360 || PALISADE) {
      sprintf(out, "%s %s%c   ", s, fmt_temp((double) val), temp_dir);
      vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
   }
   else if(rcvr_type == THERMO_RCVR) {
      enviro_data:
      if(have_temperature0) {
         sprintf(out, "%s %s    ", "TEMP0:", fmt_temp((double) tc0));
      }
      else {
         sprintf(out, "                   ");      
      }
      vidstr(VAL_ROW+1, VAL_COL, WHITE, out);

      sprintf(out, "%s %s    ", "TEMP1:", fmt_temp((double) tc1));
      vidstr(VAL_ROW+2, VAL_COL, WHITE, out);

      if(have_temperature2) {
         sprintf(out, "%s %s    ", "TEMP2:", fmt_temp((double) tc2));
      }
      else {
         sprintf(out, "                   ");      
      }
      vidstr(VAL_ROW+3, VAL_COL, WHITE, out);

      if(have_humidity) {
         sprintf(out, "RH:  %10.5f %s ", humidity, plot[HUMIDITY].units);
      }
      else {
         sprintf(out, "                   ");      
      }
      vidstr(VAL_ROW+4, VAL_COL, WHITE, out);

      if(have_pressure) {
         if(HG_PRESS) sprintf(out, "Pres:%10.5f Hg", scale_pressure(pressure));
         else         sprintf(out, "Pres:%10.5f mb", scale_pressure(pressure));
      }
      else {
         sprintf(out, "                   ");      
      }
      vidstr(VAL_ROW+5, VAL_COL, WHITE, out);
   }
   else if((val > (-100.0)) && (val < 100.0)) {
      enviro_temp:
      sprintf(out, "%s %s%c   ", s, fmt_temp((double) val), temp_dir);
      if((rcvr_type == SCPI_RCVR) && (scpi_type == NORTEL_TYPE)) {
         if(val > 70.0)     sprintf(out, "%s >70C     ", s);
         else if(val < 0.0) sprintf(out, "%s <0C      ", s);
         else               sprintf(out, "%s OK       ", s);
      }

      if(rcvr_type == PRS_RCVR) {
         if((val < 0.0) || (val >= 80.0))  {
            vidstr(VAL_ROW+1, VAL_COL, RED, out);
         }
         else if((val < 30.0) || (val >= 80.0))  {
            vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
         }
         else {
            vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
         }
      }
      else if(rcvr_type == X72_RCVR) {
         if(have_x72_dtemplo && have_x72_dtemphi) {  // thresholds from firmware
            if((val < (x72_dtemplo+5.0)) || (val >= (x72_dtemphi-5.0)))  {
               vidstr(VAL_ROW+1, VAL_COL, RED, out);
            }
            else if((val < (x72_dtemplo+10.0)) || (val >= (x72_dtemphi-10.0)))  {
               vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
            }
            else {
               vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
            }
         }
         else if(x72_type == SA22_TYPE) {  // thresholds from data sheet
            if((val < -10.0) || (val >= 75.0))  {
               vidstr(VAL_ROW+1, VAL_COL, RED, out);
            }
            else if((val < -5.0) || (val >= 70.0))  {
               vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
            }
            else {
               vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
            }
         }
         else {
            if((val < -25.0) || (val >= 80.0))  { // thresholds from data sheet 
               vidstr(VAL_ROW+1, VAL_COL, RED, out);
            }
            else if((val < -20.0) || (val >= 75.0))  {
               vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
            }
            else {
               vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
            }
         }
      }
      else if(rcvr_type == MOTO_RCVR) {  // most Motorola compatible rcvrs mess this up
         vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
      }
      else if((val < 0.0) || (val >= 60.0))  {
      }
      else if(rcvr_type == ZYFER_RCVR) {
         if((val < 5.0) || (val >= 60.0)) {
            vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
         }
         else {
            vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
         }
      }
      else if((val < 5.0) || (val >= 55.0)) {
         vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
      }
      else if(1 && !tbolt_e && ((val < 10.0) || (val >= 50.0))) {
         vidstr(VAL_ROW+1, VAL_COL, YELLOW, out);
      }
      else {
         vidstr(VAL_ROW+1, VAL_COL, WHITE, out);
      }
   }
   else {
      sprintf(out, "%s %s%c   ", s, fmt_temp((double) val), temp_dir);
      vidstr(VAL_ROW+1, VAL_COL, RED, out);
   }
}

void show_pps_info()
{
u08 c;
char *s, *s2;
double val;
int row;

   // show the current PPS related value in the screen receiver data block
   if(rcvr_type == NO_RCVR) return;
   if(rcvr_type == THERMO_RCVR) return;
   if((rcvr_type == TIDE_RCVR) && enviro_mode()) return;

   row = VAL_ROW+3;
   c = ':';

   sprintf(out, "                     ");
   if(((have_pps_offset == 0) || (have_pps_offset == 55)) && have_lars_pps) {
      val = lars_pps;
      row = VAL_ROW+3;
      s2 = "PPSL";
      goto ticc_pps;
   }
   else if(have_pps_offset == 0) ;
   else if(lte_lite) goto show_pps;
   else if(rcvr_type == FURUNO_RCVR) ;
   else if((rcvr_type == GPSD_RCVR) && !saw_gpsd_pps) ;  // NEW_RCVR
   else if(rcvr_type == NMEA_RCVR) ;
   else if(rcvr_type == RT17_RCVR) {
      s = "CLK";
      s2 = "ns";
      goto fmt_acu;
   }
   else if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == TAIP_RCVR) ;
   else if(rcvr_type == TRUE_RCVR) ;
   else if((rcvr_type == VENUS_RCVR) && saw_venus_raw) {
      s = "Bias";
      s2 = "m";
      goto fmt_acu;
   }
   else if((rcvr_type == VENUS_RCVR) && (lte_lite == 0)) ;
   else if(SV6_FAMILY && !ACUTIME && !ACU_GG && !ACU_360 && !PALISADE) ;
   else if(luxor) {
      sprintf(out, "PPS%c%11.6f V     ", pps_polarity?DOWN_ARROW:UP_ARROW, (float) pps_offset);
   }
   else if(TIMING_RCVR) {
      if(ACU_GG || ACU_360) {
         if(pps_polarity) c = DOWN_ARROW;
         else             c = UP_ARROW;

         s = "Bias";
         s2 = "ns";

         fmt_acu:
         val = pps_offset;
         if     (val >= 10000000000.0)   sprintf(out, "%s%c >10 seconds     ", s,c);
         else if(val >= 1000000000.0)    sprintf(out, "%s%c%10.0f %s   ", s,c, val, s2);
         else if(val >= 100000000.0)     sprintf(out, "%s%c%10.1f %s   ", s,c, val, s2);
         else if(val >= 10000000.0)      sprintf(out, "%s%c%10.2f %s   ", s,c, val, s2);
         else if(val >= 1000000.0)       sprintf(out, "%s%c%10.3f %s   ", s,c, val, s2);
         else if(val >= 100000.0)        sprintf(out, "%s%c%10.4f %s   ", s,c, val, s2);
         else if(val >= 10000.0)         sprintf(out, "%s%c%10.5f %s   ", s,c, val, s2);
         else if(val >= 0.0)             sprintf(out, "%s%c%10.6f %s   ", s,c, val, s2);
         else if(val <= -100000000.0)    sprintf(out, "%s%c%10.0f %s   ", s,c, val, s2);
         else if(val <= -10000000.0)     sprintf(out, "%s%c%10.1f %s   ", s,c, val, s2);
         else if(val <= -1000000.0)      sprintf(out, "%s%c%10.2f %s   ", s,c, val, s2);
         else if(val <= -100000.0)       sprintf(out, "%s%c%10.3f %s   ", s,c, val, s2);
         else if(val <= -10000.0)        sprintf(out, "%s%c%10.4f %s   ", s,c, val, s2);
         else if(val <= -1000.0)         sprintf(out, "%s%c%10.5f %s   ", s,c, val, s2);
         else                            sprintf(out, "%s%c%10.6f %s   ", s,c, val, s2);
      }
      else if(rcvr_type == ESIP_RCVR) {
         val = (pps_offset);
         if     (val >= 1000000000.0) sprintf(out, "Accu:%10.0f ns   ", val);
         else if(val >= 100000000.0)  sprintf(out, "Accu:%10.0f ns   ", val);
         else if(val >= 10000000.0)   sprintf(out, "Accu:%10.1f ns   ", val);
         else if(val >= 1000000.0)    sprintf(out, "Accu:%10.2f ns   ", val);
         else if(val >= 100000.0)     sprintf(out, "Accu:%10.3f ns   ", val);
         else if(val >= 10000.0)      sprintf(out, "Accu:%10.4f ns   ", val);
         else if(val >= 1000.0)       sprintf(out, "Accu:%10.5f ns   ", val);
         else                         sprintf(out, "Accu:%10.6f ns   ", val);
      }
      else if(rcvr_type == MOTO_RCVR) {
         val = (pps_offset / 1000.0);
         if     (val >= 1000000000.0) sprintf(out, "Accu:%10.0f us   ", val);
         else if(val >= 100000000.0)  sprintf(out, "Accu:%10.0f us   ", val);
         else if(val >= 10000000.0)   sprintf(out, "Accu:%10.1f us   ", val);
         else if(val >= 1000000.0)    sprintf(out, "Accu:%10.2f us   ", val);
         else if(val >= 100000.0)     sprintf(out, "Accu:%10.3f us   ", val);
         else if(val >= 10000.0)      sprintf(out, "Accu:%10.4f us   ", val);
         else if(val >= 1000.0)       sprintf(out, "Accu:%10.5f us   ", val);
         else if(val >= 0.0)          sprintf(out, "Accu:%10.6f us   ", val);
         else if(val <= -1000000.0)   sprintf(out, "Accu:%10.0f us   ", val);
         else if(val <= -100000.0)    sprintf(out, "Accu:%10.1f us   ", val);
         else if(val <= -10000.0)     sprintf(out, "Accu:%10.2f us   ", val);
         else if(val <= -1000.0)      sprintf(out, "Accu:%10.3f us   ", val);
         else if(val <= -100.0)       sprintf(out, "Accu!%10.4f us   ", val);
         else                         sprintf(out, "Accu:%10.6f us   ", val);
      }
      else if(rcvr_type == NVS_RCVR) {
         val = (pps_offset / 1.0);
         if     (val >= 1000000000.0) sprintf(out, "Rgen:%10.0f ns/s ", val);
         else if(val >= 100000000.0)  sprintf(out, "Rgen:%10.0f ns/s ", val);
         else if(val >= 10000000.0)   sprintf(out, "Rgen:%10.1f ns/s ", val);
         else if(val >= 1000000.0)    sprintf(out, "Rgen:%10.2f ns/s ", val);
         else if(val >= 100000.0)     sprintf(out, "Rgen:%10.3f ns/s ", val);
         else if(val >= 10000.0)      sprintf(out, "Rgen:%10.4f ns/s ", val);
         else if(val >= 1000.0)       sprintf(out, "Rgen:%10.5f ns/s ", val);
         else if(val >= 0.0)          sprintf(out, "Rgen:%10.6f ns/s ", val);
         else if(val <= -1000000.0)   sprintf(out, "Rgen:%10.0f ns/s ", val);
         else if(val <= -100000.0)    sprintf(out, "Rgen:%10.1f ns/s ", val);
         else if(val <= -10000.0)     sprintf(out, "Rgen:%10.2f ns/s ", val);
         else if(val <= -1000.0)      sprintf(out, "Rgen:%10.3f ns/s ", val);
         else if(val <= -100.0)       sprintf(out, "Rgen:%10.4f ns/s ", val);
         else                         sprintf(out, "Rgen:%10.6f ns/s ", val);
      }
      else if(rcvr_type == SIRF_RCVR) {
         val = (pps_offset / 1000.0);
         if     (val >= 1000000000.0) sprintf(out, "Drft:%10.0f us   ", val);
         else if(val >= 100000000.0)  sprintf(out, "Drft:%10.0f us   ", val);
         else if(val >= 10000000.0)   sprintf(out, "Drft:%10.1f us   ", val);
         else if(val >= 1000000.0)    sprintf(out, "Drft:%10.2f us   ", val);
         else if(val >= 100000.0)     sprintf(out, "Drft:%10.2f us   ", val);
         else if(val >= 10000.0)      sprintf(out, "Drft:%10.4f us   ", val);
         else if(val >= 1000.0)       sprintf(out, "Drft:%10.4f us   ", val);
         else                         sprintf(out, "Drft:%10.6f us   ", val);
      }
      else if(rcvr_type == UBX_RCVR) {
         val = (pps_offset);
         if     (val >= 1000000000.0) sprintf(out, "Accu:%10.0f ns   ", val);
         else if(val >= 100000000.0)  sprintf(out, "Accu:%10.0f ns   ", val);
         else if(val >= 10000000.0)   sprintf(out, "Accu:%10.1f ns   ", val);
         else if(val >= 1000000.0)    sprintf(out, "Accu:%10.2f ns   ", val);
         else if(val >= 100000.0)     sprintf(out, "Accu:%10.3f ns   ", val);
         else if(val >= 10000.0)      sprintf(out, "Accu:%10.4f ns   ", val);
         else if(val >= 1000.0)       sprintf(out, "Accu:%10.5f ns   ", val);
         else                         sprintf(out, "Accu:%10.6f ns   ", val);
      }
      else if(rcvr_type == ZODIAC_RCVR) {
         c = ':';
         s = "PPS";
         s2 = "ns";
         goto fmt_pps;
      }             
      else {
         val = (pps_offset / 1000.0);
         if     (val >= 1000000000.0) sprintf(out, "Bias:%10.0f us   ", val);
         else if(val >= 100000000.0)  sprintf(out, "Bias:%10.0f us   ", val);
         else if(val >= 10000000.0)   sprintf(out, "Bias:%10.1f us   ", val);
         else if(val >= 1000000.0)    sprintf(out, "Bias:%10.2f us   ", val);
         else if(val >= 100000.0)     sprintf(out, "Bias:%10.3f us   ", val);
         else if(val >= 10000.0)      sprintf(out, "Bias:%10.4f us   ", val);
         else if(val >= 1000.0)       sprintf(out, "Bias:%10.5f us   ", val);
         else if(val <= -1000000.0)   sprintf(out, "Bias:%10.0f us   ", val);
         else if(val <= -100000.0)    sprintf(out, "Bias:%10.1f us   ", val);
         else if(val <= -10000.0)     sprintf(out, "Bias:%10.2f us   ", val);
         else if(val <= -1000.0)      sprintf(out, "Bias:%10.3f us   ", val);
         else if(val <= -100.0)       sprintf(out, "Bias:%10.4f us   ", val);
         else                         sprintf(out, "Bias:%10.6f us   ", val);
      }
   }
   else if(rcvr_type == CS_RCVR) {
      c = ':';

      val = pps_offset;
      if     (val >= 100000000.0)     sprintf(out, "Pump%c%10.0f uA  ", c, val);
      else if(val >= 10000000.0)      sprintf(out, "Pump%c%10.1f uA  ", c, val);
      else if(val >= 1000000.0)       sprintf(out, "Pump%c%10.2f uA  ", c, val);
      else if(val >= 100000.0)        sprintf(out, "Pump%c%10.3f uA  ", c, val);
      else if(val >= 10000.0)         sprintf(out, "Pump%c%10.4f uA  ", c, val);
      else if(val >= 0.0)             sprintf(out, "Pump%c%10.5f uA  ", c, val);
      else                            sprintf(out, "Pump%c%10.5f uA  ", c, val);
   }
   else if(rcvr_type == GPSD_RCVR) {
      if(pps_polarity) c = DOWN_ARROW;
      else             c = UP_ARROW;

      val = (pps_offset / 1000000.0);  // convert nsecs to msecs
      if     (val >= 1000000000.0)    sprintf(out, "Clk%c%11.0f ms   ", c, val);
      else if(val >= 100000000.0)     sprintf(out, "Clk%c%11.1f ms   ", c, val);
      else if(val >= 10000000.0)      sprintf(out, "Clk%c%11.2f ms   ", c, val);
      else if(val >= 1000000.0)       sprintf(out, "Clk%c%11.3f ms   ", c, val);
      else if(val >= 100000.0)        sprintf(out, "Clk%c%11.4f ms   ", c, val);
      else if(val >= 10000.0)         sprintf(out, "Clk%c%11.5f ms   ", c, val);
      else if(val >= 0.0)             sprintf(out, "Clk%c%11.6f ms   ", c, val);
      else if(val <= -100000000.0)    sprintf(out, "Clk%c%11.0f ms   ", c, val);
      else if(val <= -10000000.0)     sprintf(out, "Clk%c%11.1f ms   ", c, val);
      else if(val <= -1000000.0)      sprintf(out, "Clk%c%11.2f ms   ", c, val);
      else if(val <= -100000.0)       sprintf(out, "Clk%c%11.3f ms   ", c, val);
      else if(val <= -10000.0)        sprintf(out, "Clk%c%11.4f ms   ", c, val);
      else if(val <= -1000.0)         sprintf(out, "Clk%c%11.5f ms   ", c, val);
      else                            sprintf(out, "Clk%c%11.6f ms   ", c, val);
   }
   else if(rcvr_type == TICC_RCVR) {
      val = (pps_tie); // TICC_RATE;
      if(ticc_type == LARS_TICC) row = VAL_ROW+3;
      else row = VAL_ROW+1;
      s2 = plot[PPS].plot_id;
      c = ' ';

      ticc_pps:
      pps_enabled = 1;

      s = "ns";

      if(plot[PPS].show_freq) {
         s = "Hz";
         val = tie_to_freq(PPS, val);
      }

      if     (val >= 10000000000.0)   sprintf(out, "%s%c >10 seconds    ", s2, c);
      else if(val >= 1000000000.0)    sprintf(out, "%s%c%11.0f %s  ", s2, c, val,s);
      else if(val >= 100000000.0)     sprintf(out, "%s%c%11.1f %s  ", s2, c, val,s);
      else if(val >= 10000000.0)      sprintf(out, "%s%c%11.2f %s  ", s2, c, val,s);
      else if(val >= 1000000.0)       sprintf(out, "%s%c%11.3f %s  ", s2, c, val,s);
      else if(val >= 100000.0)        sprintf(out, "%s%c%11.4f %s  ", s2, c, val,s);
      else if(val >= 10000.0)         sprintf(out, "%s%c%11.5f %s  ", s2, c, val,s);
      else if(val >= 0.0)             sprintf(out, "%s%c%11.6f %s  ", s2, c, val,s);
      else if(val <= -100000000.0)    sprintf(out, "%s%c%11.0f %s  ", s2, c, val,s);
      else if(val <= -10000000.0)     sprintf(out, "%s%c%11.1f %s  ", s2, c, val,s);
      else if(val <= -1000000.0)      sprintf(out, "%s%c%11.2f %s  ", s2, c, val,s);
      else if(val <= -100000.0)       sprintf(out, "%s%c%11.3f %s  ", s2, c, val,s);
      else if(val <= -10000.0)        sprintf(out, "%s%c%11.4f %s  ", s2, c, val,s);
      else if(val <= -1000.0)         sprintf(out, "%s%c%11.5f %s  ", s2, c, val,s);
      else                            sprintf(out, "%s%c%11.6f %s  ", s2, c, val,s);
   }
   else {
//    sprintf(out, "PPS%c%11.6f ns    ", pps_polarity?DOWN_ARROW:UP_ARROW, (float) pps_offset);
      show_pps:
      if(pps_polarity) c = DOWN_ARROW;
      else             c = UP_ARROW;

      s = "PPS";
      s2 = "ns";

      if((rcvr_type == BRANDY_RCVR) || (rcvr_type == RFTG_RCVR)) {
         s = "PHA";
         c = ':';
      }
      else if(rcvr_type == PRS_RCVR) {
         s = "TT";
         c = ':';
      }
      else if(rcvr_type == ZODIAC_RCVR) {
         c = ':';
      }
      else if(lte_lite) {
         c = ':';
      }

      fmt_pps:
      val = pps_offset;
if(rcvr_type == X72_RCVR) {
   if(plot[PPS].show_freq) {
      c = ':';
      val = tie_to_freq(PPS, val) * 1.0E3;
      s2 = "mHz";
   }
}
      if     (val >= 10000000000.0)   sprintf(out, "%s%c >10 seconds     ", s,c);
      else if(val >= 1000000000.0)    sprintf(out, "%s%c%11.0f %s   ", s,c, val, s2);
      else if(val >= 100000000.0)     sprintf(out, "%s%c%11.1f %s   ", s,c, val, s2);
      else if(val >= 10000000.0)      sprintf(out, "%s%c%11.2f %s   ", s,c, val, s2);
      else if(val >= 1000000.0)       sprintf(out, "%s%c%11.3f %s   ", s,c, val, s2);
      else if(val >= 100000.0)        sprintf(out, "%s%c%11.4f %s   ", s,c, val, s2);
      else if(val >= 10000.0)         sprintf(out, "%s%c%11.5f %s   ", s,c, val, s2);
      else if(val >= 0.0)             sprintf(out, "%s%c%11.6f %s   ", s,c, val, s2);
      else if(val <= -100000000.0)    sprintf(out, "%s%c%11.0f %s   ", s,c, val, s2);
      else if(val <= -10000000.0)     sprintf(out, "%s%c%11.1f %s   ", s,c, val, s2);
      else if(val <= -1000000.0)      sprintf(out, "%s%c%11.2f %s   ", s,c, val, s2);
      else if(val <= -100000.0)       sprintf(out, "%s%c%11.3f %s   ", s,c, val, s2);
      else if(val <= -10000.0)        sprintf(out, "%s%c%11.4f %s   ", s,c, val, s2);
      else if(val <= -1000.0)         sprintf(out, "%s%c%11.5f %s   ", s,c, val, s2);
      else                            sprintf(out, "%s%c%11.6f %s   ", s,c, val, s2);
   }

   if(pps_enabled)                 vidstr(row, VAL_COL, WHITE, out);
   else if(lte_lite)               vidstr(row, VAL_COL, WHITE, out);
   else if(rcvr_type == RT17_RCVR) vidstr(row, VAL_COL, WHITE, out);  // toots - rt17 fix needed 
   else                            vidstr(row, VAL_COL, YELLOW, out);
}

void show_osc_info()
{
u08 c;
char *s;
double val;
int row;

   // show the current OSC related value in the screen receiver data block
   if(rcvr_type == NO_RCVR) return;
   if(rcvr_type == THERMO_RCVR) return;
   if((rcvr_type == TIDE_RCVR) && enviro_mode()) return;

   row = VAL_ROW+4;

   c = ':';
// if(ebolt || res_t) ;
// else if(lte_lite) ;
// else if(rcvr_type == LPFRS_RCVR) ;
// else if(rcvr_type == PRS_RCVR) ;
// else if(rcvr_type == SRO_RCVR) ;
   if(have_osc_polarity) {
      if(osc_polarity) c = DOWN_ARROW;
      else             c = UP_ARROW;
   }

   val = osc_offset;

   sprintf(out, "                     ");
   if((have_osc_offset == 0) && (have_true_eval == 0)) ;
   else if(rcvr_type == FURUNO_RCVR) ;
   else if(rcvr_type == GPSD_RCVR) ;    // NEW_RCVR
   else if(rcvr_type == NMEA_RCVR) ;
   else if(rcvr_type == STAR_RCVR) ;
   else if(rcvr_type == TAIP_RCVR) ;
   else if((rcvr_type == VENUS_RCVR) && (lte_lite == 0) && (saw_venus_raw == 0)) ;
   else if(luxor) {
      val = osc_offset;
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "Osc%c%11.4f%s  ", c, val, "V  ");
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "Osc%c%11.5f%s  ", c, val, "V  ");
      }
      else {
         sprintf(out, "Osc%c%11.6f%s  ", c, val, "V  ");
      }
   }
   else if(rcvr_type == CS_RCVR) {
      c = ':';

      val = osc_offset;
      if     (val >= 100000000.0)     sprintf(out, "Emul%c%10.0f V   ", c, val);
      else if(val >= 10000000.0)      sprintf(out, "Emul%c%10.1f V   ", c, val);
      else if(val >= 1000000.0)       sprintf(out, "Emul%c%10.2f V   ", c, val);
      else if(val >= 100000.0)        sprintf(out, "Emul%c%10.3f V   ", c, val);
      else if(val >= 10000.0)         sprintf(out, "Emul%c%10.4f V   ", c, val);
      else if(val >= 0.0)             sprintf(out, "Emul%c%10.5f V   ", c, val);
      else                            sprintf(out, "Emul%c%10.5f V   ", c, val);
   }
   else if(rcvr_type == NVS_RCVR) {
   }
   else if(rcvr_type == PRS_RCVR) {
      s = ppt_string;
      if(plot[OSC].show_freq) {
         s = " Hz";
         val = tie_to_freq(OSC, osc_offset);
         sprintf(out, "%s%c%11.6f%s   ", plot[OSC].plot_id, c, val, s);
      }
      else goto show_osc;
   }
   else if((rcvr_type == SCPI_RCVR) && (scpi_type == NORTEL_TYPE)) {
   }
   else if(rcvr_type == SCPI_RCVR) {
      val = osc_offset * 1000.0;
      c = ':';
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%11.4f%s   ", plot[OSC].plot_id, c, val, " us");
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%11.5f%s   ", plot[OSC].plot_id, c, val, " us");
      }
      else {
         sprintf(out, "%s%c%11.6f%s   ", plot[OSC].plot_id, c, val, " us");
      }
   }
   else if(rcvr_type == TICC_RCVR) {
      row = VAL_ROW+2;
      c = ' ';

      s = "ns";
      val = (osc_tie); // TICC_RATE; 
      if(plot[OSC].show_freq) {
         s = "Hz";
         val = tie_to_freq(OSC, val);
      }

      if     (val >= 10000000000.0)   sprintf(out, "TIEb%c >10 seconds    ", c);
      else if(val >= 1000000000.0)    sprintf(out, "TIEb%c%11.0f %s  ", c, val,s);
      else if(val >= 100000000.0)     sprintf(out, "TIEb%c%11.1f %s  ", c, val,s);
      else if(val >= 10000000.0)      sprintf(out, "TIEb%c%11.2f %s  ", c, val,s);
      else if(val >= 1000000.0)       sprintf(out, "TIEb%c%11.3f %s  ", c, val,s);
      else if(val >= 100000.0)        sprintf(out, "TIEb%c%11.4f %s  ", c, val,s);
      else if(val >= 10000.0)         sprintf(out, "TIEb%c%11.5f %s  ", c, val,s);
      else if(val >= 0.0)             sprintf(out, "TIEb%c%11.6f %s  ", c, val,s);
      else if(val <= -100000000.0)    sprintf(out, "TIEb%c%11.0f %s  ", c, val,s);
      else if(val <= -10000000.0)     sprintf(out, "TIEb%c%11.1f %s  ", c, val,s);
      else if(val <= -1000000.0)      sprintf(out, "TIEb%c%11.2f %s  ", c, val,s);
      else if(val <= -100000.0)       sprintf(out, "TIEb%c%11.3f %s  ", c, val,s);
      else if(val <= -10000.0)        sprintf(out, "TIEb%c%11.4f %s  ", c, val,s);
      else if(val <= -1000.0)         sprintf(out, "TIEb%c%11.5f %s  ", c, val,s);
      else                            sprintf(out, "TIEb%c%11.6f %s  ", c, val,s);
   }
   else if(rcvr_type == TRUE_RCVR) {
      sprintf(out, "EVAL: %9.6f %s   ", true_eval, "   ");
   }
   else if(rcvr_type == UBX_RCVR) {
      val = osc_offset;
      c = ':';
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%10.0f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%10.1f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
      else {
         sprintf(out, "%s%c%10.2f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
   }
   else if(rcvr_type == UCCM_RCVR) {
      val = osc_offset * 1000.0;
      c = ':';
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%10.3f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%10.4f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else {
         sprintf(out, "%s%c%10.5f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
   }
   else if((rcvr_type == VENUS_RCVR) && saw_venus_raw) {
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%9.3f%s  ", "Drft", c, val, " m/s");
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%9.4f%s  ", "Drft", c, val, " m/s");
      }
      else {
         sprintf(out, "%s%c%9.5f%s  ", "Drft", c, val, " m/s");
      }
   }
   else if(rcvr_type == X72_RCVR) {
      s = " ";
      val = osc_offset;
      sprintf(out, "%s%c%11.5g%s   ", plot[OSC].plot_id, c, val, s);
   }
   else if(rcvr_type == ZODIAC_RCVR) {  // clock bias
      val = osc_offset;
      c = ':';
      if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%10.4f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
      else if((val >= 1000.F) || (val <= (-100.0))) {
         sprintf(out, "%s%c%10.5f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
      else {
         sprintf(out, "%s%c%10.6f%s  ", plot[OSC].plot_id, c, val, " ns");
      }
   }
   else if(TIMING_RCVR) {
      val = osc_offset;
      if(rcvr_type == MOTO_RCVR) ;
      else if(rcvr_type == SIRF_RCVR) ;
      else if(ACU_GG) ppt_string = " ppb";
      else if(ACU_360) ppt_string = " ppb";
      else if(ACUTIME) ppt_string = " ppb";
      else if(PALISADE) ppt_string = "Hz";
      else if(SV6_FAMILY) ppt_string = "Hz";
      else if(lte_lite) ppt_string = " ns";
      else if(show_euro_ppt) ppt_string = "e-9 ";
      else ppt_string = " ppb";

      if((val >= 100000000.0) || (val <= (-10000000.0))) {
         sprintf(out, "%s%c%10.0f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 10000000.0) || (val <= (-1000000.0))) {
         sprintf(out, "%s%c%10.1f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 1000000.0) || (val <= (-100000.0))) {
         sprintf(out, "%s%c%10.2f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 100000.0) || (val <= (-10000.0))) {
         sprintf(out, "%s%c%10.3f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%10.4f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%10.5f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else {
         sprintf(out, "%s%c%10.6f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
   }
   else {
      show_osc:
      val = osc_offset * 1000.0;
      if((val >= 100000000.0) || (val <= (-10000000.0))) {
         sprintf(out, "%s%c%11.0f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 10000000.0) || (val <= (-1000000.0))) {
         sprintf(out, "%s%c%11.1f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 1000000.0) || (val <= (-100000.0))) {
         sprintf(out, "%s%c%11.2f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 100000.0) || (val <= (-10000.0))) {
         sprintf(out, "%s%c%11.3f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 10000.0) || (val <= (-1000.0))) {
         sprintf(out, "%s%c%11.4f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else if((val >= 1000.0) || (val <= (-100.0))) {
         sprintf(out, "%s%c%11.5f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
      else {
         sprintf(out, "%s%c%11.6f%s  ", plot[OSC].plot_id, c, val, ppt_string);
      }
   }

   vidstr(row, VAL_COL, WHITE, out);
}

void show_chc_info()
{
double val;
char c;
char *s;

   if(have_chc_offset == 0) return;

   c = ' ';

   s = "ns";
   val = (chc_tie); // TICC_RATE; 
   if(plot[SEVEN].show_freq) {
      s = "Hz";
      val = tie_to_freq(SEVEN, val);
   }

   if     (val >= 10000000000.0)   sprintf(out, "TIEc%c >10 seconds     ", c);
   else if(val >= 1000000000.0)    sprintf(out, "TIEc%c%11.0f %s   ", c, val,s);
   else if(val >= 100000000.0)     sprintf(out, "TIEc%c%11.1f %s   ", c, val,s);
   else if(val >= 10000000.0)      sprintf(out, "TIEc%c%11.2f %s   ", c, val,s);
   else if(val >= 1000000.0)       sprintf(out, "TIEc%c%11.3f %s   ", c, val,s);
   else if(val >= 100000.0)        sprintf(out, "TIEc%c%11.4f %s   ", c, val,s);
   else if(val >= 10000.0)         sprintf(out, "TIEc%c%11.5f %s   ", c, val,s);
   else if(val >= 0.0)             sprintf(out, "TIEc%c%11.6f %s   ", c, val,s);
   else if(val <= -100000000.0)    sprintf(out, "TIEc%c%11.0f %s   ", c, val,s);
   else if(val <= -10000000.0)     sprintf(out, "TIEc%c%11.1f %s   ", c, val,s);
   else if(val <= -1000000.0)      sprintf(out, "TIEc%c%11.2f %s   ", c, val,s);
   else if(val <= -100000.0)       sprintf(out, "TIEc%c%11.3f %s   ", c, val,s);
   else if(val <= -10000.0)        sprintf(out, "TIEc%c%11.4f %s   ", c, val,s);
   else if(val <= -1000.0)         sprintf(out, "TIEc%c%11.5f %s   ", c, val,s);
   else                            sprintf(out, "TIEc%c%11.6f %s   ", c, val,s);

   vidstr(VAL_ROW+3, VAL_COL, WHITE, out);
}

void show_chd_info()
{
double val;
char c;
char *s;

   if(have_chd_offset == 0) return;

   c = ' ';
   s = "ns";

   val = (chd_tie); // TICC_RATE; 
   if(plot[EIGHT].show_freq) {
      s = "Hz";
      val = tie_to_freq(EIGHT, val);
   }

   if     (val >= 10000000000.0)   sprintf(out, "TIEd%c >10 seconds     ", c);
   else if(val >= 1000000000.0)    sprintf(out, "TIEd%c%11.0f %s   ", c, val,s);
   else if(val >= 100000000.0)     sprintf(out, "TIEd%c%11.1f %s   ", c, val,s);
   else if(val >= 10000000.0)      sprintf(out, "TIEd%c%11.2f %s   ", c, val,s);
   else if(val >= 1000000.0)       sprintf(out, "TIEd%c%11.3f %s   ", c, val,s);
   else if(val >= 100000.0)        sprintf(out, "TIEd%c%11.4f %s   ", c, val,s);
   else if(val >= 10000.0)         sprintf(out, "TIEd%c%11.5f %s   ", c, val,s);
   else if(val >= 0.0)             sprintf(out, "TIEd%c%11.6f %s   ", c, val,s);
   else if(val <= -100000000.0)    sprintf(out, "TIEd%c%11.0f %s   ", c, val,s);
   else if(val <= -10000000.0)     sprintf(out, "TIEd%c%11.1f %s   ", c, val,s);
   else if(val <= -1000000.0)      sprintf(out, "TIEd%c%11.2f %s   ", c, val,s);
   else if(val <= -100000.0)       sprintf(out, "TIEd%c%11.3f %s   ", c, val,s);
   else if(val <= -10000.0)        sprintf(out, "TIEd%c%11.4f %s   ", c, val,s);
   else if(val <= -1000.0)         sprintf(out, "TIEd%c%11.5f %s   ", c, val,s);
   else                            sprintf(out, "TIEd%c%11.6f %s   ", c, val,s);

   vidstr(VAL_ROW+4, VAL_COL, WHITE, out);
}


void erase_info_col()
{
int i;
int row;

   // erase the INFO_COL column from the top of the screen to the "VIEW:" line

   row = queue_row;
   if(all_adevs && (SCREEN_WIDTH < WIDE_WIDTH)) return;
   if(rcvr_type == NO_RCVR) return;

   for(i=0; i<=queue_row; i++) {  // erase old info
      if((i < 5) && (SCREEN_WIDTH < MEDIUM_WIDTH)) {  // don't overwrite possible sat prn values  pretty printing
         vidstr(i,INFO_COL, WHITE, "            ");
      }
      else {
         vidstr(i,INFO_COL, WHITE, "              ");
      }
   }

   info_row = 0;
   info_avail = queue_row+1;
}


void show_param_values(int all)
{
   // this routine shows various receiver data, status, and configuration values

   if(text_mode && first_key) return;
   if(zoom_screen == 'I') {
      show_lla(543);
   }
   if(zoom_screen) return;
   if(luxor) return;

   last_pp = (-1);
   show_cable_delay();      // show cable delay value
   show_version_info();     // show receiver version info

   erase_info_col();
   show_critical_alarms();  // show critical alarms
   if((info_row != last_pp) && did_crit && (SCREEN_HEIGHT > SHORT_SCREEN)) {  //pretty printing
      ++info_row;
      --info_avail;
      last_pp = info_row;
   }

   if((all_adevs == SINGLE_ADEVS) || ((TEXT_HEIGHT <= 12) && (SCREEN_WIDTH >= WIDE_WIDTH))) {
      show_operation_info(1);
      show_minor_alarms();
      show_state_info();
   }
   else if(all_adevs) {
      if(SCREEN_WIDTH >= WIDE_WIDTH) {
         show_minor_alarms();
         show_state_info();
      }
      if(all_adev_row >= (ALL_ROW+5)) show_operation_info(2);
   }


   show_rcvr_type();        // current receiver data values
   show_dac_info();
   show_temp_info();
   show_pps_info();
   show_osc_info();
   show_chc_info();         // plot[SEVEN]
   show_chd_info();         // plot[EIGHT]

   if(all) { 
      show_time_info();
//    show_survey_info();
      refresh_page();
   }
}


void update_plot_data()
{
   // add the latest data to the plot queue and update the screen
   if(have_time && (pause_data == 0)) {
      if(continuous_scroll) update_plot(REFRESH_SCREEN);
      else if((all_adevs == SINGLE_ADEVS) || mixed_adevs) update_plot(REFRESH_SCREEN);
      else if(all_adevs) update_plot(REFRESH_SCREEN);
      else update_plot(NO_REFRESH);

      if(first_sample) {
         if(rcvr_type == SCPI_RCVR) ;
         else if(rcvr_type == UCCM_RCVR) ;
         else {
            if(discipline_mode == DIS_MODE_DISABLED) osc_discipline = 0;
            else                                     osc_discipline = 1;

            if(discipline_mode == DIS_MODE_MANUAL_HOLD) user_holdover = 1;
            else                                        user_holdover = 0;
         }

         if((all_adevs == SINGLE_ADEVS) || mixed_adevs) {
            draw_plot(REFRESH_SCREEN);
         }

         first_sample = 0;
      }
   }
   else {
      refresh_page();
   }
}



//
//
//  System clock only device
//
//


int get_norcvr_message()
{
static int last_tick = (9999);
int this_tick;
double ss;

   // system clock driven receiverless mode handler
   // returns 1 if screen was updated because seconds ticked

   if(sim_file && ((rcvr_type == TICC_RCVR) || (rcvr_type == THERMO_RCVR) || (rcvr_type == Z12_RCVR))) {
      sim_jd += jtime(0,0,0, adev_period);   // aaaaaapppppp
      set_gregorian_time(sim_jd);
      ss = (((double) seconds) + pri_frac);
      if(adev_period > 0.0) ss /= adev_period;
   }
   else {
      get_clock_time();   // get system clock time in UTC

      year = pri_year = clk_year;
      month = pri_month = clk_month;
      day = pri_day = clk_day;

      hours = pri_hours = clk_hours;
      minutes = pri_minutes = clk_minutes;
      seconds = pri_seconds = clk_seconds;
      pri_frac = raw_frac = clk_frac;
      ss = (((double) seconds) + pri_frac) * nav_rate;
   }

   this_tick = (int) ss;
//sprintf(debug_text, "nr:%g  usnr:%d  last:%d this:%d  ss=%g  frac:%g", nav_rate,user_set_nav_rate, last_tick, this_tick, ss, pri_frac);
//if(rcvr_type == TICC_RCVR) last_tick = (9999);  // aaaahhhh make sure every sample gets into the plot queue
if(lte_lite && (have_sawtooth == 0)) last_tick = 9999;

   if(timing_mode == TMODE_GPS) {     // convert utc time to gps time
      utc_to_gps();
   }
   else {
      adjust_rcvr_time(0.0);  // incorporarte possibly negative fractional second into time variables
   }

   if((rcvr_type == TICC_RCVR) && user_set_nav_rate) {
      nav_rate = user_nav_rate;
      have_nav_rate = 555;
   }
if(rcvr_type == Z12_RCVR) {
   jd_zda = jdate(year,month,day) + jtime(hours,minutes,seconds,0.0);
   poll_z12_time(1);
}

   if(last_tick != this_tick) {  // aaaaahhhhh
      last_tick = this_tick;
//if(debug_file) fprintf(debug_file, "Tick!\n");
      update_gps_screen(555);
      return 1;
   }

   if(calc_rcvr) {  // calculator only mode - keep calculator active and zoomed
      if(zoom_screen == '`') ;
      else if(zoom_screen == 'K') ;
      else if(rcvr_type == NO_RCVR) { // toots
         start_calc_zoom(100);
      }
   }

   return 0;
}


//
//
//   Receiver type detection routines
//
//

void request_rcvr_info(int why)
{
   // NEW_RCVR
   if(no_poll) return;
//wwwww if(SV6_FAMILY) return;  // prevent rcvr buffer overlow ttttt wwwww
if((rcvr_type == TSIP_RCVR) && (tsip_type == STARLOC_TYPE)) return;  // prevent rcvr buffer overlow ttttt wwwww
if(rcvr_type == BRANDY_RCVR) return;  // prevent receiver buffer overflow and time skips
if(rcvr_type == LPFRS_RCVR) return;   // speed up polling loop
if(rcvr_type == PRS_RCVR) return;     // speed up polling loop
if(rcvr_type == SA35_RCVR) return;    // speed up polling loop
if(rcvr_type == SRO_RCVR) return;     // speed up polling loop
if(rcvr_type == RFTG_RCVR) return;    // prevent receiver buffer overflow and time skips
if(rcvr_type == THERMO_RCVR) return;

   request_version();
   request_luxor_ver();        // no SV6
   if(luxor_time_set == 0) {   // no SV6
      set_luxor_time();
   }

   request_utc_info();

   request_pps_info();         // no SV6
   if(rcvr_type != BRANDY_RCVR) {  // request_pps_info does the same thing
      request_pps_mode();      
   }
   request_timing_mode();      // no SV6

   request_filter_config();
   request_rcvr_config(why);
   request_survey_params();    // no SV6

   if(rcvr_type != STAR_RCVR) {  // request_rcvr_config() did this
      request_all_dis_params();  // no SV6
   }

   request_sat_list();
}


void init_messages(int why, int reset_ok)
{
int i;

   // initialize the receiver to send periodic messages and request some
   // various configuration info.

   reset_kbd_timer();
if(debug_file) fprintf(debug_file, "### init_messages(%d)  reset_ok:%d\n", why, reset_ok);
   if(sim_file) {
      sprintf(plot_title, "Using simulation input file: %s", sim_name);
      title_type = USER;
   }

   need_msg_init = 0;
   wakeup_nortel();
   if(luxor) {
      request_luxor_ver();
      if(luxor_time_set == 0) set_luxor_time();
   }


   init_receiver(why, reset_ok);   // setup the receiver
   reset_kbd_timer();

   if(user_set_nav_rate) {
      set_nav_rate(user_nav_rate);
   }

   if(user_set_delay || set_pps_polarity || user_set_traim) {   // set cable delay and pps values
      set_pps(user_pps_enable, user_pps_polarity,  delay_value, pps1_delay, pps_threshold, 0);
      if(user_set_traim) set_traim_mode(traim_threshold, 0);
   }


   if(set_osc_polarity) {
      set_osc_sense(user_osc_polarity, 0);
   }

   if(user_set_filters) {
      set_filter_config(user_pv, user_static, user_alt, user_kalman, user_marine, 0);
   }

   request_rcvr_info(201);   // get various receiver status messages
   request_rcvr_health();

   request_sat_list();       // get satellite info
   request_sat_status(0x00);
   if(SV6_FAMILY && !ACU_GG && !ACU_360) {
      request_sv6_config(1);
   }
   reset_kbd_timer();

   if(log_db == 0) {
      request_sig_levels();  // get signal quality info
   }

   if(do_survey && (survey_why > 0) && (user_precision_survey == 0)) {
      set_survey_params(1, 1, do_survey);
      request_survey_params();
      start_self_survey(0x00, 6);
      survey_why = (-999);
   }


   if(user_init_len) {  // send string of user specified bytes after the standard init commands
      for(i=0; i<user_init_len; i++) {
         sendout(RCVR_PORT, user_init_cmd[i], ADD_CHAR);
      }  
      sendout(RCVR_PORT, 0, FLUSH_COM);
   }

   request_primary_timing();    // get time of day
   request_secondary_timing();
   request_all_dis_params();
   reset_kbd_timer();
}



void get_rcvr_message()
{
   // get bytes from serial port and build up a receiver message.  When message
   // is complete, parse it and to what it says.
//NEW_RCVR

   if(need_msg_init) {
      init_messages(need_msg_init, 1);
   }

   if(1 && sim_eof && autoscale_lla) {  //llascale
      Sleep(200);
      show_mouse_lla();
      show_param_values(1); //simeof
   }  
   else if(rcvr_type == ACRON_RCVR)  get_acron_message();
   else if(rcvr_type == BRANDY_RCVR) get_brandy_message(); 
   else if(rcvr_type == CS_RCVR)     get_cs_message(); 
   else if(rcvr_type == ESIP_RCVR)   get_nmea_message();
   else if(rcvr_type == FURUNO_RCVR) get_nmea_message();
   else if(rcvr_type == GPSD_RCVR)   get_gpsd_message();
   else if(rcvr_type == LUXOR_RCVR)  get_tsip_message();
   else if(rcvr_type == LPFRS_RCVR)  get_prs_message(); 
   else if(rcvr_type == MOTO_RCVR)   get_moto_message();
   else if(rcvr_type == RT17_RCVR)   get_rt17_message();
   else if(rcvr_type == NMEA_RCVR)   get_nmea_message();
   else if(rcvr_type == NO_RCVR)     get_norcvr_message();
   else if(rcvr_type == NVS_RCVR)    get_nvs_message();    // NVS format is basically TSIP
   else if(rcvr_type == PRS_RCVR)    get_prs_message(); 
   else if(rcvr_type == RFTG_RCVR)   get_rftg_message(); 
   else if(rcvr_type == SCPI_RCVR)   get_scpi_message(); 
   else if(rcvr_type == SIRF_RCVR)   get_sirf_message(); 
   else if(rcvr_type == SA35_RCVR)   get_prs_message(); 
   else if(rcvr_type == SRO_RCVR)    get_prs_message(); 
   else if(rcvr_type == STAR_RCVR)   get_star_message(); 
   else if(rcvr_type == SS_RCVR)     get_ss_message(); 
   else if(rcvr_type == TAIP_RCVR)   get_taip_message();
   else if(rcvr_type == THERMO_RCVR) get_rcvr_enviro_message(RCVR_PORT);
   else if(rcvr_type == TICC_RCVR)   get_rcvr_ticc_message(RCVR_PORT);
   else if(rcvr_type == TIDE_RCVR)   get_norcvr_message(); 
   else if(rcvr_type == TM4_RCVR)    get_tm4_message(); 
   else if(rcvr_type == TRUE_RCVR)   get_nmea_message();
   else if(rcvr_type == TSERVE_RCVR) get_tserve_message();
   else if(rcvr_type == TSIP_RCVR)   get_tsip_message();
   else if(rcvr_type == UCCM_RCVR)   get_uccm_message();
   else if(rcvr_type == UBX_RCVR)    get_ubx_message();
   else if(rcvr_type == VENUS_RCVR)  get_venus_message();
   else if(rcvr_type == X72_RCVR)    get_x72_message(); 
   else if(rcvr_type == Z12_RCVR)    get_z12_message();
   else if(rcvr_type == ZODIAC_RCVR) get_zod_message();
   else if(rcvr_type == ZYFER_RCVR)  get_nmea_message();
   else                              get_unkn_message();
}


void scpi_init(int type)
{
   // placeholder routine for possible special init code for SCPI devices
}


void wakey_wakey()
{
if(PALISADE) return;
if(SV6_FAMILY) return;  //ttttt
if(sim_file) return;

   if(NO_SCPI_BREAK && (rcvr_type == SCPI_RCVR)) ; 
   else SendBreak(RCVR_PORT);

   enable_gpsd();  // gggg

   scpi_init(0);

//send_byte('#');  // for TAPR_TICC   aaaacccc

   send_byte(0x0D);        // for SCPI wakeup
   eom_flag = EOM;
   send_byte(0x0A);
   eom_flag = ADD_CHAR;
   Sleep(250);

   send_byte(0x0D);
   eom_flag = EOM;
   send_byte(0x0A);
   eom_flag = ADD_CHAR;
   Sleep(250);
////sendout(RCVR_PORT, 0, FLUSH_COM);
// drain_com_data();


// send_tsip_start(0x8E);  // init TSIP receiver to send packets
// send_byte(0xA5);
// send_byte(0x00);
// send_byte(0x55);
// send_byte(0x00);
// send_byte(0x00);
// send_tsip_end();

   if(com[RCVR_PORT].baud_rate == 115200) {  // wake up NVS_RCVR
      send_nvs_start(0x1F);   // 0x72 time message every second
      send_byte((u08) nav_rate);
      send_nvs_end();
   }

if(tsip_packets == 0) {
   send_moto_start("Bb");     // request Motorola sat visibility data
   send_byte(0);
   send_moto_end();

   send_moto_start("Wb");
   send_byte(1);              // for Jupiter-T: 0=MOTOROLA mode,  1=Jupiter-T mode
   send_moto_end();
}

   send_tsip_end();
   send_tsip_end();
   send_tsip_start(0x3C);     // request sat info
   send_byte(0x00);
   send_tsip_end();
////sendout(RCVR_PORT, 0, FLUSH_COM);

   drain_com_data();          // drain serial port data buffer

   reset_com_timer(RCVR_PORT);
}


int nvs_pkt(int id)
{
   // return true if id is a NVS receiver specific TSIP packet
   if     (id == 0x51) return 0;
   else if(id == 0x52) return 0;                 
   else if(id == 0x60) return 1;                 
   else if(id == 0x61) return 1;  //             
   else if(id == 0x72) return 1;  // every second  (!!!!! this could be a SV6 packet)
   else if(id == 0x73) return 0;                 
   else if(id == 0x74) return 0;                 
   else if(id == 0x88) return 1;  // every nav solution
   else if(id == 0x93) return 0;                 
   else if(id == 0xE7) return 0;                 
   else if(id == 0xF5) return 1;  // every second
   else if(id == 0xF7) return 0;                 

   return 0;
}

int ts_data(int k)
{
   if(tsip_buf[k+0] != 0x01) return 0;
   if(tsip_buf[k+4] != ':') return 0;
   if(tsip_buf[k+7] != ':') return 0;
   if(tsip_buf[k+10] != ':') return 0;
   return 1;
}


u64 auto_detect(int baud_only)
{
int i, j, k;
int chars_seen;
int crlf, cr_flag;
int lf;
int lt;
int em_flag;      // delorme earthmate
int enviro_flag;
int esip_flag;
int furuno_flag;
int gpsd_flag;
int jl_flag;
int lpfrs_flag;
int luxor_flag;
int moto_flag;
int nmea_flag;
int nvs_flag;
int pet_flag;
int prs_flag;
int rftg_flag;
int rt17_flag;
int scpi_flag;
int sirf_flag;
int sa35_flag;
int sro_flag;
int ss_flag;
int star_flag;
int taip_flag;
int ticc_flag;
int tm_flag;      // delorme tripmate
int tp_flag;
int tm4_flag;
int ts_flag;
int tsip_flag;
int ubx_flag;
int uccm_flag;
int venus_flag;
int x72_flag;
int z12_flag;
int zodiac_flag;
int zyfer_flag;
int boot_flag;

int bad_par;
int count;
double old_timeout;
double start_time;
double et, last_et;
int c1,c2,c3,c4,c5,c6;
int row, col;
char *s;
int speed_change;
int config_baud;
int c;
int long_pause;

u64 type;  // !!!!! must change this when rcvr_type goes to 64 bit mask

   // This routine attemps to determin the type of receiver the serial
   // port is connected to.
   // NEW_RCVR

   rcvr_type = TSIP_RCVR;  // if NO_RCVR, com port read routine always returns 0
   old_timeout = com[RCVR_PORT].com_timeout;
   long_pause = 0;
   count = 0;

   if(sim_file) ;
   else if(com[RCVR_PORT].process_com == 0) {  // no com port open
      type = rcvr_type = (0);   // this forces NO_RCVR mode with warning message
      long_pause = 1;
      goto no_com;
   }

   detect_rcvr_type = 1;
   detecting = 1;
   speed_change = 0;
   chars_seen = 0;
   if(sim_file) ;
   else if(com[RCVR_PORT].user_set_baud == 0) {
      com[RCVR_PORT].baud_rate = 9600;
      com[RCVR_PORT].data_bits = 8;
      com[RCVR_PORT].parity = parity_defined;
      init_com(RCVR_PORT, 108);
   }

   re_speed:
   j = sizeof(tsip_buf)-1;
   if(j > (512-1)) j = 512;
if(com[RCVR_PORT].baud_rate == 115200) {
   if(sizeof(tsip_buf) > 770) j = 768;  // for better NVS detection
   Sleep(1000);  // for TAPR TICC  xyzzy
}


   com[RCVR_PORT].com_timeout = DETECT_TIMEOUT;   // if nothing received after 1500 msecs, abort
   reset_com_timer(RCVR_PORT);
   tsip_rptr = tsip_wptr = 0;

   erase_screen();
   if     (com[RCVR_PORT].parity == NO_PAR)   c = 'N';
   else if(com[RCVR_PORT].parity == ODD_PAR)  c = 'O';
   else if(com[RCVR_PORT].parity == EVEN_PAR) c = 'E';
   else                                       c = '?';
   sprintf(out, "Detecting receiver type at %d:%d:%c:%d ...", com[RCVR_PORT].baud_rate,com[RCVR_PORT].data_bits,c,com[RCVR_PORT].stop_bits);
   vidstr(0,0, GREEN, out);
   refresh_page();


   if(1) {  // send some commands to try to get receiver to send something
      wakey_wakey();
   }

   i = 0;
   row = 999;
   col = 999;

   get_clock_time();
   start_time = this_msec = clk_jd;
   et = last_et = (this_msec-start_time) * ((24.0*60.0*60.0) * 1000.0);
   while(i < j) {  // get a sample of the data stream
      while(SERIAL_DATA_AVAILABLE(RCVR_PORT) == 0) {
         vidstr(1,1, YELLOW, "Press ESC to exit.");

         sprintf(out, "start:%.9f  this:%.9f  et:%.0f  to:%.0f", start_time, this_msec, et, DETECT_TIMEOUT*2.0);
         vidstr(2,1,GREEN, out);

         get_clock_time();
         this_msec = clk_jd;
         et = (this_msec-start_time) * ((24.0*60.0*60.0) * 1000.0);
         if((et - last_et) > 50.0) {
            last_et = et;
            refresh_page();
         }
         if(et >= (DETECT_TIMEOUT*2.0)) {
            goto analyze;
         }

         abort_wakeup();  // if ESC pressed, exit
      }

      get_clock_time();
      this_msec = clk_jd;
      if(et >= (DETECT_TIMEOUT*2.0)) {
         break;
      }

      c1 = get_com_char();
      c1 &= 0xFF;
//if(raw_file) fprintf(raw_file, "%c", c1);
      tsip_buf[i++] = c1;
      tsip_buf[i] = 0;
      chars_seen = i;

      if(++col >= 32) {  // show data we are getting
         refresh_page();
         col = 0;
         if(++row > 32) row = 5;
      }
      sprintf(out, " %02X", c1&0xFF);
      vidstr(row,col*3,YELLOW, out);
   }

   // look at the data we got and see if we can find data that is 
   // semi-unique to the receiver types
   analyze:         
   reset_com_timer(RCVR_PORT);
   refresh_page();

   crlf = cr_flag = 0;
   lf = 0;
   lt = 0;
   em_flag = 0;
   esip_flag = 0;
   furuno_flag = 0;
   gpsd_flag = 0;
   jl_flag = 0;
   lpfrs_flag = 0;
   luxor_flag = 0;
   moto_flag = 0;
   nmea_flag = 0;
   nvs_flag = 0;
   pet_flag = 0;
   prs_flag = 0;
   rftg_flag = 0;
   rt17_flag = 0;
   scpi_flag = 0;
   sirf_flag = 0;
   sa35_flag = 0;
   sro_flag = 0;
   ss_flag = 0;
   star_flag = 0;
   taip_flag = 0;
   enviro_flag = 0;
   ticc_flag = 0;
   tm_flag = 0;
   tm4_flag = 0;
   tp_flag = 0;
   ts_flag = 0;
   tsip_flag = 0;
   ubx_flag = 0;
   uccm_flag = 0;
   venus_flag = 0;
   x72_flag = 0;
   z12_flag = 0;
   zodiac_flag = 0;
   zyfer_flag = 0;

   boot_flag = 0;
   bad_par = 0;

   for(k=0; k<i; k++) {
      c1 = tsip_buf[k+0]; c1 &= 0xFF;
      c2 = tsip_buf[k+1]; c2 &= 0xFF; 
      c3 = tsip_buf[k+2]; c3 &= 0xFF; 
      c4 = tsip_buf[k+3]; c4 &= 0xFF; 
      c5 = tsip_buf[k+4]; c4 &= 0xFF; 
      c6 = tsip_buf[k+5]; c4 &= 0xFF; 

      if((c1 == '"')  && (c2 == ':'))  ++gpsd_flag;
      if((c1 == '$')  && (c2 == 'G') && (c3 == 'E') && (c4 == 'T')) ++tp_flag;
      else if((c1 == '$')  && (c2 == 'G'))  ++nmea_flag;
      if((c1 == '@')  && (c2 == '@'))  ++moto_flag;
      if((c1 == ';')  && (c2 == '*') && (c3 == LUXOR_ID)) ++luxor_flag;
      if((c1 == '$')  && (c2 == 'T') && (c3 == 'I') && (c4 == 'M')) ++zyfer_flag;
      if((c1 == '$')  && (c2 == 'S') && (c3 == 'I') && (c4 == 'G')) ++zyfer_flag;
      if((c1 == '$')  && (c2 == 'E') && (c3 == 'S') && (c4 == 'S')) ++zyfer_flag;
      if((c1 == '$')  && (c2 == 'P') && (c3 == 'A') && (c4 == 'V')) ++zyfer_flag;
      if((c1 == '$')  && (c2 == 'P') && (c3 == 'J') && (c4 == 'L')) { ++jl_flag; ++venus_flag; }
      if((c1 == '$')  && (c2 == 'C') && (c3 == 'L') && (c4 == 'O')) ++tp_flag;
      if((c1 == '$')  && (c2 == 'E') && (c3 == 'X') && (c4 == 'T')) ++tp_flag;
      if((c1 == '$')  && (c2 == 'P') && (c3 == 'L') && (c4 == 'H')) ++enviro_flag;
      if((c1 == '$')  && (c2 == 'P') && (c3 == 'A') && (c4 == 'S') && (c5 == 'H')) ++z12_flag;
      if((c1 == ':')  && (c2 == '0') && ((c3 == '0') || (c3 == '1')) && (c4 == '0')) ++rftg_flag;
      if((c1 == ':')  && (c2 == '1') && ((c3 == '0') || (c3 == '1')) && (c4 == '0')) ++rftg_flag;
      if((c1 == 'B')  && (c2 == 'O') && (c3 == 'O') && (c4 == 'T')) ++boot_flag;
      if((c1 == 'T')  && (c2 == 'I') && (c3 == 'C') && (c4 == 'C')) ++ticc_flag;
      if((c1 == 'T')  && (c2 == 'A') && (c3 == 'P') && (c4 == 'R')) ++ticc_flag;
      if((c1 == 'd')  && (c2 == 'e') && (c3 == 'f') && (c4 == 'a')) ++ticc_flag;  // "default"
      if((c1 == 'P')  && (c2 == 'F') && (c3 == 'E') && (c4 == 'C')) ++furuno_flag; 
      if((c1 == 'P')  && (c2 == 'E') && (c3 == 'R') && (c4 == 'D')) ++esip_flag; 
      if((c1 == 'P')  && (c2 == 'R') && (c3 == 'S') && (c4 == '_')) ++prs_flag;
      if((c1 == 'E')  && (c2 == 'A') && ((c3 == 'R') || (c3 == 'T')) && (c4 == 'H') && (c5 == 'A')) ++em_flag;
      if((c1 == 'A')  && (c2 == 'S') && ((c3 == 'T') || (c3 == 'R')) && (c4 == 'A')) ++tm_flag;
      if((c1 == ETX)  && (c2 == DLE) && nvs_pkt(c3)) ++nvs_flag;
      if((c1 == ETX)  && (c2 == DLE) && (c3 == LUXOR_ID)) ++luxor_flag;
      if((c1 == DLE)  && (c2 == ETX) && (c3 == DLE))  ++tsip_flag;
//    if((c1 == DLE)  && (c2 == 0x8F)) ++tsip_flag;  // timing message group
      if((c1 == 0x02) && (c2 == 0x00) && (c3 == 0x57) && (c4 == 0xF8)) ++rt17_flag;
      if((c1 == 0x03) && (c2 == 0x02) && (c3 == 0x00) && (c4 == 0x57)) ++rt17_flag;
      if((c1 == 0xB5) && (c2 == 0x62)) ++ubx_flag;
      if((c1 == 0xA0) && (c2 == 0xA2)) ++sirf_flag;
      if((c1 == 0xB0) && (c2 == 0xB3)) ++sirf_flag;
      if((c1 == 0x01) && (c2 == (c3 ^ 0xFF))) ++ss_flag;
      if((c1 == 0xA0) && (c2 == 0xA1)) ++venus_flag;
      if((c1 == 0xFF) && (c2 == 0x81)) ++zodiac_flag;
      if((c1 == 0x0D)  && (c2 == 0x0A) && (c3 == '#') && isdigit(c4) && isdigit(c5)) ++tm4_flag;

      if(pet_data(tsip_buf, k, 1)) ++pet_flag;
      if(ts_data(k)) ++ts_flag;

      if((c1 == 0x0D) && (c2 == 0x0A)) ++crlf;
      else if(c1 == 0x0D) ++cr_flag;

      if((c1 == ';') && (c2 == '*')) {
         if((c3 >= '0') && (c3 <= '9')) ++taip_flag;
         if((c3 >= 'A') && (c3 <= 'F')) ++taip_flag;
      }
      if((c1 == '>') && (c2 == 'R') && (c3 == 'T')) ++taip_flag;
      if((c1 == '>') && (c2 == 'R') && (c3 == 'P')) ++taip_flag;
      if((c1 == '>') && (c2 == 'R') && (c3 == 'L')) ++taip_flag;

      if(c1 == 0x0A) ++lf;
      if(c1 == '<') ++lt;
      if(c1 == 0x0A);
      else if(c1 == 0x0D) ;
      else if((c1 >= 'a') && (c1 <= 'z')) taip_flag = lt = 0;
      else if(c1 < ' ') taip_flag = lt = 0;
      else if(c1 > 0x7E) taip_flag = lt = 0;

      if(     (c1 == 'T') && (c2 == '2') && (c3 == '2'))   ++scpi_flag;
      else if((c1 == 's') && (c2 == 'c') && (c3 == 'p'))   ++scpi_flag;
      else if((c1 == 'E') && (c2 == '-') && (isdigit(c3))) ++scpi_flag;
      else if((c1 == 0x45)  && (c2 == 0xAD) && (c3 == 0xB3) && (c4 == 0xB6)) { ++scpi_flag; ++bad_par; }

      else if((c1 == 'U') && (c2 == 'C') && (c3 == 'C'))   ++uccm_flag;  // UCCM-P
      else if((c1 == 'C') && (c2 == '5') && (c3 == ' '))   ++uccm_flag;  // UCCM-P
      else if((c1 == 'c') && (c2 == '5') && (c3 == ' '))   ++uccm_flag;  // UCCM-P
      else if((c1 == ' ') && (c2 == 'C') && (c3 == 'A'))   ++uccm_flag;  // UCCM-P
      else if((c1 == ' ') && (c2 == 'c') && (c3 == 'a'))   ++uccm_flag;  // UCCM-P
      else if((c1 == 'U') && (c2 == 'n') && (c3 == 'd'))   ++uccm_flag;  // UCCM-P
   }
   tsip_buf[128] = 0;
   if(strstr((char *) &tsip_buf[0], "SYNTAX_ERROR")) ++star_flag;

   sirf_flag /= 2;  // these types have symmetrical indicators
   gpsd_flag /= 2;

   if(zodiac_flag && rt17_flag) zodiac_flag = 0; // toots - rt17 fix needed 

   if(crlf == 0) {  // these types have messages that end in CR LF
      em_flag = 0;
      esip_flag = 0;
      furuno_flag = 0;
      gpsd_flag = 0;
      jl_flag = 0;
      moto_flag = 0;
      nmea_flag = 0;
      uccm_flag = 0;
      pet_flag = 0;
      rftg_flag = 0;
      star_flag = 0;
      enviro_flag = 0;
      ticc_flag = 0;
      tm_flag = 0;
      tm4_flag = 0;
      ts_flag = 0;
      venus_flag = 0;
      x72_flag = 0;
      z12_flag = 0;
      zyfer_flag = 0;
      if(boot_flag == 0) tp_flag = 0;
      zyfer_flag = 0;
   }
   if(cr_flag == 0) {
      lpfrs_flag = 0;
      prs_flag = 0;
      sa35_flag = 0;
      sro_flag = 0;
      x72_flag = 0;
   }

   if(lt == 0) taip_flag = 0;

   if(uccm_flag && (tsip_flag < 2)) tsip_flag = 0;
   if(nvs_flag && (tsip_flag < 2)) nvs_flag = 0;
   if(com[RCVR_PORT].baud_rate != 115200) nvs_flag = 0;

   if(nmea_flag) { // mixed NMEA and binary messages possible, favor the binary
      if(esip_flag > 0) esip_flag = nmea_flag;  
      if(furuno_flag > 0) furuno_flag = nmea_flag;
      if(ubx_flag > 0) ubx_flag = nmea_flag;
      if(venus_flag > 0) venus_flag = nmea_flag;
      if(z12_flag > 0) z12_flag = nmea_flag;
   }

   count = 0;
   type = 0;
   // find the most commonly seen receiver pattern match count
   if(enviro_flag > count) { type = THERMO_RCVR; count = enviro_flag; enviro_type = HEATHER_ENVIRO; }
   if(esip_flag > count)   { type = ESIP_RCVR;   count = esip_flag;   }
   if(furuno_flag > count) { type = FURUNO_RCVR; count = furuno_flag; }
   if(gpsd_flag > count)   { type = GPSD_RCVR;   count = gpsd_flag;   }
   if(lpfrs_flag > count)  { type = LPFRS_RCVR;  count = lpfrs_flag;  }
   if(moto_flag > count)   { type = MOTO_RCVR;   count = moto_flag;   }
   if(pet_flag > count)    { type = TICC_RCVR;   count = pet_flag;  ticc_type = PICPET_TICC; }
   if(prs_flag > count)    { type = PRS_RCVR;    count = prs_flag;    }
   if(rftg_flag > count)   { type = RFTG_RCVR;   count = rftg_flag;   }
   if(rt17_flag > count)   { type = RT17_RCVR;   count = rt17_flag;   }
   if(scpi_flag > count)   { type = SCPI_RCVR;   count = scpi_flag;   }
   if(sirf_flag > count)   { type = SIRF_RCVR;   count = sirf_flag;   }
   if(ss_flag > count)     { type = SS_RCVR;     count = ss_flag;     }
   if(sa35_flag > count)   { type = SRO_RCVR;    count = sa35_flag;   }
   if(sro_flag > count)    { type = SRO_RCVR;    count = sro_flag;    }
   if(star_flag > count)   { type = STAR_RCVR;   count = star_flag;   }
   if(taip_flag > count)   { type = TAIP_RCVR;   count = taip_flag;   }
   if(ticc_flag > count)   { type = TICC_RCVR;   count = ticc_flag;   }
   if(tm4_flag > count)    { type = TM4_RCVR;    count = tm4_flag;    }
   if(tp_flag > count)     { type = TRUE_RCVR;   count = tp_flag;     }
   if(ts_flag > count)     { type = TSERVE_RCVR; count = ts_flag;     }
   if(tsip_flag > count)   { type = TSIP_RCVR;   count = tsip_flag;   }
   if(ubx_flag  > count)   { type = UBX_RCVR;    count = ubx_flag;    }
   if(uccm_flag > count)   { type = UCCM_RCVR;   count = uccm_flag;   }
   if(venus_flag > count)  { type = VENUS_RCVR;  count = venus_flag;  }
   if(x72_flag > count)    { type = X72_RCVR;    count = x72_flag;    }
   if(z12_flag > count)    { type = Z12_RCVR;    count = z12_flag;    }
   if(zodiac_flag > count) { type = ZODIAC_RCVR; count = zodiac_flag; }
   if(zyfer_flag > count)  { type = ZYFER_RCVR;  count = zyfer_flag;  }

// if(em_flag > count)     { type = NMEA_RCVR;   count = em_flag;     }
// if(tm_flag > count)     { type = NMEA_RCVR;   count = tm_flag;     }
   if(nmea_flag > count)   { type = NMEA_RCVR;   count = nmea_flag;   }  // must be last check


   if(count == 0) {  // no recognizeable receiver type, assume NO_RCVR
      if(sim_file) ;
      else if((com[RCVR_PORT].user_set_baud == 0) && (speed_change < 4)) {  // try different serial port config
         ++speed_change;

         com[RCVR_PORT].data_bits = 8;
         com[RCVR_PORT].parity = parity_defined;
         com[RCVR_PORT].stop_bits = 1;

         if(speed_change == 1) {
            com[RCVR_PORT].baud_rate = 115200; 
         }
         else if(speed_change == 2) {
            com[RCVR_PORT].baud_rate = 57600;
         }
         else if(speed_change == 3) {
            com[RCVR_PORT].baud_rate = 19200;
         }
         else if(0 && (speed_change == 4)) {
            com[RCVR_PORT].baud_rate = 19200;
            com[RCVR_PORT].data_bits = 7;
            com[RCVR_PORT].parity = ODD_PAR;
         }
         else if(speed_change == 4) {
            com[RCVR_PORT].baud_rate = 38400;
         }

         init_com(RCVR_PORT, 109);
         drain_port(RCVR_PORT);
if(speed_change == 1) Sleep(1000); //  xyzzy - for TAPR TICC
         goto re_speed;
      }
      type = NO_RCVR;
   }

   no_com:
   config_baud = 0;
   if(type == SCPI_RCVR) {
      if(bad_par) {
         com[RCVR_PORT].data_bits = 7;
         com[RCVR_PORT].parity = ODD_PAR;
         init_com(RCVR_PORT, 110);
      }
else if(com[RCVR_PORT].baud_rate == 19200) {
   if(user_set_scpi_type == 0) scpi_type = LUCENT_TYPE;
}
   }
   else if((type == TSIP_RCVR) && nvs_flag) {
      type = NVS_RCVR;
      config_baud = 1;  // we need to do ODD parity
      detect_rcvr_type = 0;  // so config_rcvr_type will set baud
   }
   else if((type == TSIP_RCVR) && (luxor_flag > 1) && (com[RCVR_PORT].baud_rate == 9600)) {
      type = LUXOR_RCVR;
      tsip_type = LUXOR_TYPE;
      luxor = 11;
      config_baud = 1;  // we need to do ODD parity
      com[RCVR_PORT].parity = ODD_PAR;
      detect_rcvr_type = 0;  // so config_rcvr_type will set baud
   }
   else if(type == ZYFER_RCVR) {
      config_baud = 1;  // we need to do NO parity
      com[RCVR_PORT].parity = NO_PAR;
      detect_rcvr_type = 0;  // so config_rcvr_type will set baud
   }

   if(baud_only) {
      if(type == rcvr_type) {
         config_rcvr_type(1);
         need_msg_init = 2030;
         detect_rcvr_type = 1;
      }
      return rcvr_type;
   }
   else {
      rcvr_type = type;
      config_rcvr_type(config_baud);
      need_msg_init = 2031;
      if(config_baud) detect_rcvr_type = 1;
   }

//sprintf(plot_title, "rcvr:%d  max:%d  tsip:%d  nmea:%d  gpsd:%d  moto:%d  ubx:%d  sirf:%d  scpi:%d  zod:%d  lost:%d", 
//type,count, tsip_flag,nmea_flag,gpsd_flag, moto_flag,ubx_flag,sirf_flag, scpi_flag, zodiac_flag, com[RCVR_PORT].com_data_lost);
//Sleep(3000);

   com[RCVR_PORT].com_timeout = old_timeout;
   reset_com_timer(RCVR_PORT);
   erase_screen();

   if     (rcvr_type == ACRON_RCVR)  s = "Acron receiver";
   else if(rcvr_type == ESIP_RCVR)   s = "Furuno eSIP";
   else if(rcvr_type == FURUNO_RCVR) s = "Furuno PFEC";
   else if(rcvr_type == GPSD_RCVR)   s = "GPSD receiver";
   else if(rcvr_type == LPFRS_RCVR)  s = "LPFRS Rb oscillator";
   else if(rcvr_type == LUXOR_RCVR)  s = "Luxor analyzer";
   else if(rcvr_type == MOTO_RCVR)   s = "Motorola receiver";
   else if(rcvr_type == NMEA_RCVR) {
      if(jl_flag) s = "Jackson Labs LTE";
      else        s = "NMEA receiver";
   }
   else if(rcvr_type == NO_RCVR) {
      if(chars_seen) s = "Unknown rcvr";
      else           s = "No receiver";
   }
   else if(rcvr_type == NVS_RCVR)    s = "NVS receiver";
   else if(rcvr_type == PRS_RCVR)    s = "PRS-10 Rb oscillator";
   else if(rcvr_type == RFTG_RCVR)   s = "Lucent RFTG-m GPSDO";
   else if(rcvr_type == RT17_RCVR)   s = "Trimble RT-17 receiver";
   else if(rcvr_type == SCPI_RCVR)   s = "SCPI device";
   else if(rcvr_type == SIRF_RCVR)   s = "Sirf receiver";
   else if(rcvr_type == SA35_RCVR)   s = "SA.35M oscillator";
   else if(rcvr_type == SRO_RCVR)    s = "SRO100 Rb oscillator";
   else if(rcvr_type == SS_RCVR)     s = "Novatel SSII receiver";
   else if(rcvr_type == STAR_RCVR) {
      if(com[RCVR_PORT].baud_rate == 115200) {
         s = "NEC GPSDO";
         star_type = NEC_TYPE;
      }
      else if(com[RCVR_PORT].baud_rate == 4800) {  // OSA can also be 9600 baud
         s = "OSA 453x GPSDOr";
         star_type = OSA_TYPE;
      }
      else {
         s = "STAR-4 GPSDO";
         star_type = STAR4_TYPE;
      }
   }
   else if(rcvr_type == TAIP_RCVR)   s = "TAIP receiver";
   else if(rcvr_type == THERMO_RCVR) s = "Environmental";
   else if(rcvr_type == TICC_RCVR) {
      if(ticc_type == PICPET_TICC) {
         s = "PICPET";
         if(user_set_ticc_type == 0) {
            ticc_type = PICPET_TICC;
            user_set_ticc_type = 1;
         }
         if(user_set_ticc_mode == 0) {
            ticc_mode = 'T';    // time stamp mode
            user_set_ticc_mode = 4;
            have_ticc_mode = 4;
         }
      }
      else {
         s = "TAPR TICC";
         if(user_set_ticc_type == 0) ticc_type = TAPR_TICC;
      }
   }
   else if(rcvr_type == TM4_RCVR)    s = "Spectrum TM4 GPSDO";
   else if(rcvr_type == TRUE_RCVR)   s = "TruePosition GPSDO";
   else if(rcvr_type == TSERVE_RCVR) s = "TymServe";
   else if(rcvr_type == TSIP_RCVR)   s = "TSIP receiver";
   else if(rcvr_type == UBX_RCVR)    s = "Ublox receiver";
   else if(rcvr_type == UCCM_RCVR)   s = "UCCM receiver";
   else if(rcvr_type == VENUS_RCVR)  {
      if(jl_flag) s = "Jackson Labs LTE";
      else        s = "Venus receiver";
   }
   else if(rcvr_type == X72_RCVR)    s = "X72 Rb oscillator";
   else if(rcvr_type == Z12_RCVR)    s = "Ashtech Z12";
   else if(rcvr_type == ZODIAC_RCVR) s = "Jupiter receiver";
   else if(rcvr_type == ZYFER_RCVR)  s = "Zyfer GPSDO";
   else if(rcvr_type == (0)) {
      s = "No COM port open";
      goto bad_port;
   }
   else {
//    sprintf(out, "Unknown type:%llX", type);
      sprintf(out, "Unknown rcvr type");
      s = &out[0];

      bad_port:
      if(baud_only) return rcvr_type;
      rcvr_type = NO_RCVR;
      config_rcvr_type(config_baud);
      need_msg_init = 2040;
      config_msg_ofs();
   }

   if(SCREEN_WIDTH < TINY_TINY_WIDTH) {
      VCHAR_SCALE *= 3;
      VCHAR_SCALE /= 8;
   }
   else if(SCREEN_HEIGHT < TINY_TINY_HEIGHT) {
      VCHAR_SCALE *= 3;
      VCHAR_SCALE /= 4;
      if(SCREEN_WIDTH < TINY_TINY_WIDTH) VCHAR_SCALE /= 2;
   }
   vchar_string(0,0,CYAN, s);
   refresh_page();
   if(long_pause) Sleep(2000);  // no com port, delay longer so it's visible
   else           Sleep(1000);

   erase_screen();
   refresh_page();
   detecting = 0;
   return rcvr_type;
}

//#define X72_STATE_START0     0   // X72 discipling state
//#define X72_STATE_START1     1
//#define X72_STATE_START2     2
//#define X72_STATE_HOLDOVER   3
//#define X72_STATE_JAM1       4
//#define X72_STATE_JAM2       5
//#define X72_STATE_DISCIPLINE 6
//#define X72_STATE_PIDCALC    7
//#define X72_STATE_PIDUPDATE  8
//#define X72_STATE_SLOPECALC  9

int x72_startup_flag = 1;    // signals the discipline algorith has just been started
int x72_idif, x72_idif_sum;  // PPS differences and difference sum during holdover analysis
int x72_init_done;           // (in Symmetricom algorithm, but not used here)
int x72_1pps_present;        
int x72_holdover_points;     // number of points collected during holdover analysis
int x72_initial_pps;         // PPS value when disciplining first started
int x72_jamsync_flag;        // signals a jamsync is needed to keep PPS in and PPS out aligned
int x72_jamsync_ticks;       // used to wait 6 seconds after changing the X72 TIC register
int x72_jamsync_pass;
int x72_dis_sum;             // accumulates PPS differences over the interval
int x72_sum_sum;             // accumulates consecutive PPS error differences that are over the threshold 
double x72_pps_avg;          // average value of the PPS error over the interval
double interval_start_dds;   // dds value at start of current interval
double last_interval_dds;    // dds value at start of previous interval
int x72_start_timer;

#define SMALL_INTERVAL  400                // small analyis interval
#define LONG_INTERVAL   (3*SMALL_INTERVAL) // analysis intervals longer than this indicate the statistics value should be reliable
#define X72_MIN_DDS_RES (1.0 / (x72_osc*8192.0)) // DDS tuning word minimum resolution
#define PID_RATE 60                // PID update rate for DDS tuning word
int pid_time;

#define X72_PPS_BINS   (X72_PPS_SPREAD+1+X72_PPS_SPREAD)
#define X72_PPS_SPREAD 20   // !!!! this should be based on the X72_JAMSYNC_THRESH
                            // !!!! we need to support changes in the x72_jam... stuff

int x72_pps_list[X72_PPS_BINS+1];  // counts how many times each PPS value has been seen during a pps_interval
double x72_sum_y;   // used to calculate PPS trend line
double x72_sum_yy;
double x72_sum_xy;
double x72_sum_xx;
double x72_sum_x;


double x72_pps_stats(int dump)
{
unsigned i;
unsigned max_bin;
int max_val;
int max_count;
int max_sum;
double val;
double sum;
double count;
double avg;
double mcv;   // most common value seen
double sxx, syy, sxy;
double a0, a1;
double t;

   // Find the most common PPS value seen during the interval
   // and the average PPS value during the interval.  Return the most
   // common value, set global var x72_pps_avg to the interval average.

   max_val = 0;
   max_bin = X72_PPS_SPREAD;
   count = sum = avg = mcv = 0.0;

   for(i=0; i<X72_PPS_BINS; i++) {     // find the bin with the largest count
      sum += (double) x72_pps_list[i] * (double) ((int) i-X72_PPS_SPREAD);
      count += (double) x72_pps_list[i];

if(0 && debug_file && dump) fprintf(debug_file, "i:%d list:%d   bin:%d  sum:%g  count:%g\n", i, x72_pps_list[i], i-X72_PPS_SPREAD, sum, count);
      if(x72_pps_list[i] > max_val) {
         max_bin = i;
         max_val = x72_pps_list[i];
      }
   }

   if(count) avg = sum / count;
   else avg = 0.0;
   x72_pps_avg = avg;

   a1 = a0 = 0.0;
   t = (double) x72_pps_interval;
   if(x72_pps_interval) {
      sxy = x72_sum_xy - ((x72_sum_x*x72_sum_y) / t);
      syy = x72_sum_yy - ((x72_sum_y*x72_sum_y) / t);
      sxx = x72_sum_xx - ((x72_sum_x*x72_sum_x) / t);
      if(sxx) {
         a1 = (sxy / sxx);
         a0 = (x72_sum_y / t) - (a1*(x72_sum_x/t));
      }
   }
   x72_pps_trend = a1*t;

///sprintf(debug_text2, "sum:%g  count:%g  avg:%g  a1:%g a0:%g   trend:%g -> %g", sum, count, avg, a1,a0, x72_pps_trend,x72_pps_trend/t);

   max_count = 0;
   max_sum = 0;
   for(i=0; i<X72_PPS_BINS; i++) {  // how many bins have the max count?
      if(x72_pps_list[i] == 0) continue;
      if(x72_pps_list[i] == max_val) {
         ++max_count;
         max_sum += i;
      }
   }

   val = (double) max_bin;
   if(max_count > 1) {  // more than one bin with max count... average them
      val = (double) max_sum / (double) max_count;
   }

   mcv = (val - (double) X72_PPS_SPREAD);
if(0 && (last_x72_dmode > 2)) {
   sprintf(debug_text4, "max_sum:%d  max_count:%d  avg:%g  mcv:%g", max_sum, max_count, avg, mcv);
   if(debug_file && dump) fprintf(debug_file, "! max_sum:%d  max_count:%d  avg:%g  mcv:%g\n", max_sum, max_count, avg, mcv);
}

   return mcv;
}


void init_x72_pid()
{
   // !!!! placeholder for doing a DDS pid controller
   pid_time = 0;
}

#define MAX_PID_CHANGE (2.0E-11)

#define X72_DDS_SIZE (MAX_X72_TC / X72_DDS_AVG)
#define X72_DDS_AVG  60   // PID uses (PID_RATE * X72_DDS_AVG) seconds of DDS changes
double x72_dds_list[X72_DDS_SIZE+X72_DDS_AVG+1];

double x72_dds_sum;   // sum of the averaging queue entries
int x72_dds_out, x72_dds_in;  // averaging queue in/out pointers
double filtered_dds;

void x72_reset_filter(void)
{
   x72_dds_count = 0;
   x72_dds_list[0] = 0.0;
   x72_dds_in = x72_dds_out = 0;
   x72_dds_sum = 0.0;
   filtered_dds = 0.0;
}

double x72_xxx_dds(double dds)
{
int depth;

   // add the current DDS setting to the dds value averaging queue
#define MIN_DEPTH 20  // was *10

   depth = (x72_tc_val / PID_RATE) + 1;
   if(depth < MIN_DEPTH) depth = MIN_DEPTH;

//if(x72_dds_count > x72_tc_val) {  // queue is full, remove oldest entry
//if(x72_dds_count > 120) {  // queue is full, remove oldest entry
//if(x72_dds_count > (x72_tc_val-2)) {  // queue is full, remove oldest entry
   if(x72_dds_count > depth) {  // queue is full, remove oldest entry
      --x72_dds_count;
      x72_dds_sum -= x72_dds_list[x72_dds_out];
      ++x72_dds_out;
      if(x72_dds_out >= depth) x72_dds_out = 0;
   }

   ++x72_dds_count;    // put new entry into the queue
   x72_dds_sum += dds;
   x72_dds_list[x72_dds_in] = dds;
   ++x72_dds_in;
   if(x72_dds_in >= depth) x72_dds_in = 0;

   if(x72_dds_count) dds = x72_dds_sum / (double) x72_dds_count;
   else dds = last_x72_dds;
   filtered_dds = dds;

   return dds;
}

double x72_avg_dds(double dds)
{
int i;
double sum;

return x72_xxx_dds(dds);

   if(x72_dds_count > 0) {
      for(i=x72_dds_count-1; i>0; i--) {  // shift list down an entry
         x72_dds_list[i] = x72_dds_list[i-1];
      }
   }
   x72_dds_list[0] = dds;   // add latest value
   ++x72_dds_count;
   if(x72_dds_count >= X72_DDS_AVG) x72_dds_count = X72_DDS_AVG;  // count values

   sum = 0.0;
   for(i=0; i<x72_dds_count; i++) {  // calculate average of last DDS values
      sum += x72_dds_list[i];
   }
   sum /= (double) x72_dds_count;
   filtered_dds = sum;

   return sum;
}


void update_x72_pid()
{
double slope;
double new_dds;
double dds_change;
static double last_slope = 0.0;
static int changes = 0;
int flag;

return; // qwerty
   // !!!! placeholder for doing a DDS pid controller
   if(x72_run_time < SMALL_INTERVAL) return;  // don't start doing PIDly stuff until enough data has been seen

   ++pid_time;
   if(x72_tic_timer) pid_time = 0;
   if(pid_time == 0) {
      last_slope = interval_start_dds;
   }

   if(pid_time > PID_RATE) {  // update dds setting every 60 seconds once the TC threshold exceeded
      if(x72_pps_interval > (PID_RATE*3)) {  // *3 *2
         x72_pps_stats(0);
         slope = x72_pps_trend;
         slope /= (double) x72_pps_interval;
         slope /= (double) x72_osc;
if(x72_tic_changed) slope /= 2.0;  // dampen DDS changes after the TIC register is changed

         new_dds = interval_start_dds + slope;
         dds_change = new_dds - last_x72_dds;

         flag = 0;
         if(0 && (fabs(dds_change) > MAX_PID_CHANGE)) {  // only permit small changes here
            if(slope > 0.0) {
               new_dds = last_x72_dds + MAX_PID_CHANGE;
               flag = 1;
            }
            else if(slope < 0.0) {
               new_dds = (last_x72_dds - MAX_PID_CHANGE);
               flag = (-1);
            }
         }
         dds_change = new_dds - last_x72_dds;

         if(fabs(dds_change) > X72_MIN_DDS_RES) {  // DDS change is > than the DDS resolution
            new_dds = x72_avg_dds(new_dds);
            dds_change = new_dds - last_x72_dds;
            if(1 || (fabs(dds_change) > X72_MIN_DDS_RES)) {  // DDS change is > than the DDS resolution
               ++changes;
               if(show_debug_info) sprintf(debug_text2, "update pid %d! time:%d  new_dds:%g  old_dds:%g  slope:%g  interval:%d  change:%g  flag:%d", changes, pid_time, new_dds, last_x72_dds, slope, x72_pps_interval, dds_change, flag);
               if(debug_file) fprintf(debug_file, "!!update pid %d: time:%d  new_dds:%g  old_dds:%g  slope:%g  interval:%d  change:%g flag:%d\n", changes, pid_time, new_dds, last_x72_dds, slope, x72_pps_interval, dds_change, flag);
               set_x72_dds(new_dds);
               pid_time = 0;
               x72_tic_changed = 0;
            }
         }
      }
   }
}


void x72_start_discipline()
{
   // enable X72 discipline algorithm... based upon the outline in the
   // X72 manual

   x72_user_dis = 1;  // we are doing software disciplining
   x72_user_state = X72_STATE_START0;
   x72_init_done = 0;
   x72_1pps_present = 0;
   x72_start_timer = 0;

   if(pps_enabled == 0) {  // PPS output must be enabled in order for TIC command to work
      user_pps_enable = 1;
      set_pps(user_pps_enable, pps_polarity,  delay_value, pps1_delay,  pps_threshold, 4);
   }
}

void update_x72_tic(int val, int flag)
{
static int count = 0;

   // change the X72 TIC register (and maybe show some debug info)

   ++count;
   set_x72_tic(val);
   pid_time = 0;

//sprintf(debug_text5, "Update TIC %d! flag:%d  val:%d ival:%d   js_flag:%d  x72_pps:%d   last tic:%d  new tic:%d  last_pps:%d", count, flag,val,x72_ival, x72_jamsync_flag, x72_pps, last_x72_tic, x72_pps+last_x72_tic, last_x72_pps);
//if(debug_file) fprintf(debug_file, "Update TIC %d! flag:%d  val:%d ival:%d   js_flag:%d  x72_pps:%d   last tic:%d  new tic:%d  last_pps:%d\n", count, flag,val,x72_ival, x72_jamsync_flag, x72_pps, last_x72_tic, x72_pps+last_x72_tic, last_x72_pps);
//BEEP(9000);
}

//
//
//   X72 sofware disciplining code
//
//

void new_x72_interval(int why)
{
unsigned i;

   // start accumulating a new pps interval

   x72_pps_interval = 0;
   x72_dis_sum = 0;
   x72_sum_sum = 0;

   for(i=0; i<X72_PPS_BINS; i++) {
      x72_pps_list[i] = 0;
   }

   x72_sum_y = 0.0;
   x72_sum_x = 0.0; 
   x72_sum_xx = 0.0; 
   x72_sum_yy = 0.0; 
   x72_sum_xy = 0.0; 

   x72_pps_avg = 0.0;
   x72_pps_trend = 0.0;
if(debug_file) fprintf(debug_file, "Clear pps list!  why:%d\n", why);
}

void x72_update_pps_list(int val)
{
double x;
double y;

   // add a new point to the pps list
   if(dac_dac == 0) {
      if(val < (-X72_PPS_SPREAD)) return;
      if(val > X72_PPS_SPREAD) return;
      ++x72_pps_list[val+X72_PPS_SPREAD];
   }

   x = (double) x72_pps_interval;
   y = (double) val;

   x72_sum_x  += x;      // update trend line data
   x72_sum_y  += y;
   x72_sum_xx += (x * x);
   x72_sum_yy += (y * y);
   x72_sum_xy += (x * y);

   ++x72_pps_interval;   // how many points we have so far for this interval

if(show_debug_info && (last_x72_dmode > 2)) sprintf(debug_text3, "add pps %g: %g  ival:%d  tavg:%g  pid_time:%d   dds_count:%d  in:%d  out:%d  filtered_dds:%g", x, y, x72_ival, x72_sum_y/x, pid_time, x72_dds_count, x72_dds_in, x72_dds_out, filtered_dds);
}

void x72_init_state0()
{
   // startup the discipline algorithm

   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }

   x72_startup_flag = 1;
   x72_holdover_points = 0;
   x72_idif_sum = 0;
   new_x72_interval(1);
   x72_initial_pps = x72_pps;
   x72_jamsync_ticks = 0;
   if(x72_start_timer < 0) x72_start_timer = 0;

   if(x72_start_timer < 6) {  // wait for 6 seconds to make sure we have TICs
      ++x72_start_timer;
      return;
   }

   if(have_x72_pps) {  // we have a PPS value, now jamsync the PPS out to PPS in
      update_x72_tic(x72_pps, 1);
      x72_idif = x72_pps_diff;
      init_x72_pid();
//x72_user_state = X72_STATE_START1;
x72_user_state = X72_STATE_JAM2;   // we no longer do the holdover stuff
   }
}

void x72_init_state1()
{
   // wait for initial 1PPS jamsync to complete
   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }

   if(++x72_jamsync_ticks >= 6) {
      x72_jamsync_ticks = 0;
      x72_user_state = X72_STATE_HOLDOVER; // do holdover analysis
   }
}

void x72_holdover_state()
{
   // collect a few minutes of data to see how the frequency is drifting
   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }
   if(x72_holdover_val <= X72_HOLDOVER_SIZE) x72_holdover_val = X72_HOLDOVER_SIZE;


   x72_idif_sum += x72_pps_diff;
   if(x72_holdover_points == 0) x72_idif_sum = 0;
   ++x72_holdover_points;
   holdover = x72_holdover_points;
if(show_debug_info) sprintf(debug_text6, "holdover state: points:%d  idif:%d  sum:%d  mcv:%g  ival:%d", x72_holdover_points, x72_pps_diff, x72_idif_sum, x72_pps_stats(0), x72_ival);

   if(x72_holdover_points >= x72_holdover_val) {  // now go calculate the drift slope and adjust the DDS
      x72_user_state = X72_STATE_SLOPECALC;
   }
}

void x72_slopecalc_state()
{
double slope;
double intercept;
double freq_change;
static int changes = 0;

   // calculate the frequency drift rate during holdover and adjust the DDS
   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }

   slope = ((double) x72_idif_sum) / (double) x72_holdover_points;
   slope /= (double) x72_osc;
   intercept = 0.0;   // !!!!! calc intercept

   if(1 && (x72_jamsync_flag > 1)) ;  // we are forcing a jam sync
   else x72_jamsync_flag = 0;

   x72_jamsync_pass = 1;
   x72_jamsync_ticks = 0;
   x72_holdover_points = 0;
//sprintf(debug_text2, "calc slope: %g  intercept:%g  last_dds:%g  startup:%d", slope, intercept, last_x72_dds, x72_startup_flag);

   if(0 && (fabs(slope) > 300.0E-9)) {
      x72_user_state = X72_STATE_HOLDOVER;
      x72_pps_diff = 0;
      return;
   }

   if(x72_startup_flag) {    // first time through after starting disciplining
      x72_jamsync_flag = 2;  // force a PPS jam sync
   }
   x72_startup_flag = 0;

   if(x72_startup_flag == 0) {
      if(slope) {
         freq_change = last_x72_dds + slope;
         last_interval_dds = interval_start_dds;
         interval_start_dds = freq_change;
         set_x72_dds(freq_change);
         ++changes;
         have_x72_pps = 0;
         x72_jamsync_flag = 2;
      }
      x72_user_state = X72_STATE_JAM1;
      return;
   }

   x72_startup_flag = 0;
///   if(intercept > 1.0E-6) {  // !!!!!!
   if(IABS(fix_x72_tics(x72_pps)) > (int) (1000.0*1.0E-9*x72_osc)) { // pps is off by over 1us... we need to adjust the TIC offset register
////      x72_jamsync_flag = 1;
   }

   x72_user_state = X72_STATE_JAM1;
}

void x72_jam1_state()
{
static int count = 0;

   // adjust the TIC offset register to align the 1PPS in and 1PPS out

   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }

//sprintf(debug_text3, "jamsync pass:%d  flag:%d  pulses:%d", x72_jamsync_pass, x72_jamsync_flag, x72_jamsync_ticks);
   if(x72_jamsync_flag) {
      if(1 || (x72_jamsync_pass == 2)) {
          ++count;
         init_x72_pid();
         update_x72_tic(x72_pps, 2);
         x72_jamsync_ticks = 0;      // we just changed the TIC register to move the PPS output
         x72_jamsync_flag = 0;       // now wait for the change to take effect
      }
   }

   x72_user_state = X72_STATE_JAM2;
}

void x72_jam2_state()
{
   // wait for change in TIC register to complete

   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }

   if(++x72_jamsync_ticks >= 6) {  // allow 6 seconds for a TIC change to take effect
      x72_jamsync_ticks = 0;
      new_x72_interval(2);
      x72_user_state = X72_STATE_DISCIPLINE;  // start the disciplining
   }
}

void x72_discipline_state()
{
static int change_count;
double slope;
int val;
int i1, i2;
int flag;
double x;
double dds_change;

   // discipline the output frequency 

   if(pps_enabled == 0) {  // should never happen
      x72_start_discipline();
      return;
   }
   if(x72_tc_val <= 0) {
      x72_tc_val = X72_TIME_CONST;
       x72_reset_filter();
   }
   if(x72_jamthresh_val > X72_JAMSYNC_THRESH) x72_jamthresh_val = X72_JAMSYNC_THRESH;
   if(x72_jamthresh_val <= 0) x72_jamthresh_val = X72_JAMSYNC_THRESH;

   val = x72_pps;
   val = fix_x72_tics(val);
if(show_debug_info) sprintf(debug_text, "disciplining!  interval:%d   ival:%d  last:%d  sum:%d mcv:%g   dds:%g   x72_pps:%d -> %d   ppo:%g", x72_pps_interval, x72_ival,last_ival,x72_dis_sum,x72_pps_stats(0),  last_x72_dds, x72_pps, val, pps_offset);
   val = IABS(val);

   if((val > (int) (x72_jamthresh_val*1.0E-9*x72_osc))) {  // PPS is off by a large amount, do an immediate jamsync
if(show_debug_info) sprintf(debug_text5, "disipline holdover pps limit!!! %d", x72_pps);
      x72_start_discipline();
// !!!!!!!! if DDS is too far off and drift exceeds this rate, we'll never start disciplining
//x72_pps_stats(0);
//slope = x72_pps_trend;
//slope /= (double) x72_pps_interval;
//goto jamit_damnit;
      return;
   }

   if(x72_pps_interval == 0) last_dis_ival = x72_ival;
   i1 = fix_x72_tics(x72_ival);           // fixup possible wrap near 0
   i2 = fix_x72_tics(last_dis_ival);
   last_dis_ival = x72_ival;

   x72_update_pps_list(i1);      // add fixed up ival to pps list

   x72_dis_sum += (i1 - i2);     // accumulate difference between the last two PPS values
   if(IABS(x72_dis_sum) >= 2) ++x72_sum_sum;   // error sum exceeds threshold, see for how long
   else                       x72_sum_sum = 0; // error sum is back in allowed range

   flag = 0;
#define FORCE_TIC 3  // 3 -> 50 ns   was 6
   if((IABS(x72_dis_sum) >= FORCE_TIC) && (x72_pps_interval >= (LONG_INTERVAL*2))) {   // was *1
      flag = 1;   // accumulated PPS error is large over a long interval
   }
   else if(1 && (IABS(x72_dis_sum) >= (FORCE_TIC*3))) {  // was *2 - bigger error triggers an immediate DDS change
      flag = 2;
   }

   if(IABS(x72_sum_sum) >= 5) {  // PPS is off by 2 or more tics for over 5 consecutive seconds
      if((x72_pps_interval >= x72_tc_val) || (flag == 2)) { // we have enough data to evaluate
         x = x72_pps_stats(1);
         if(x || flag) { // PPS most common value is not zero or large PPS error
            // update DDS based on the interval average PPS error
            if(1 && (x72_pps_interval < LONG_INTERVAL)) { // qwerty drift rate is a bit large, scale average value betwen 1.0 and 2.0 times the average
               slope = x72_pps_avg * (1.0 + (((double) (x72_pps_interval - x72_tc_val)) / (2.0*(double) x72_tc_val)) );
            }
            else {  // very slow drift rate
               slope = x72_pps_trend;
            }
            slope /= (double) x72_pps_interval;
         }
         else slope = 0.0;

//jamit_damnit:
         if(slope) {  // adjust the DDS frequency to cancel the average PPS drift during the interval
            slope /= (double) x72_osc;
            last_interval_dds = interval_start_dds;
            interval_start_dds = last_x72_dds + slope;
interval_start_dds = x72_avg_dds(interval_start_dds);
            ++change_count;
            dds_change = interval_start_dds-last_x72_dds;
if(show_debug_info) {
   BEEP(516);
   sprintf(plot_title, "New dds %d!  %g olddds:%g  change:%g  interval:%d  ival:%d  lastiv:%d  sum:%d  mcv:%g  avg:%g  flag:%d", change_count, interval_start_dds,last_x72_dds,dds_change, x72_pps_interval, x72_ival, last_dis_ival, x72_dis_sum, x72_pps_stats(0), x72_pps_avg, flag);
   mark_q_entry[9] = plot_q_in;
}
if(debug_file) fprintf(debug_file, "New dds %d!  %g olddds:%g  change:%g  interval:%d  ival:%d  lastiv:%d  sum:%d mcv:%g  avg:%g  flag:%d\n", change_count,interval_start_dds,last_x72_dds,dds_change, x72_pps_interval, x72_ival, last_dis_ival, x72_dis_sum, x72_pps_stats(0), x72_pps_avg, flag);

            set_x72_dds(interval_start_dds);
            have_x72_pps = 0;
            last_dis_ival = x72_ival;
            new_x72_interval(3);

            update_x72_tic(last_x72_pps, 3);  // re-align PPS out to PPS in
            x72_jamsync_ticks = 0;   // we just changed the TIC register to move the PPS output
            x72_jamsync_flag = 0;    // now wait for the change to take effect
            x72_user_state = X72_STATE_JAM2;
         }
      }
   }
   else {  // PID is not currently used
//      update_x72_pid();
   }
update_x72_pid();

   return;
}


void x72_sw_discipline()
{
   // X72 software discipline algorithm state dispatcher

   if(x72_restore_timeout > 0) {  // message sync lost, pause disciplining
      --x72_restore_timeout;
      return;
   }

   if(x72_user_dis == 0) {
//    x72_user_state = x72_state = X72_STATE_DISCIPLINE;
      return;  // not doing software disciplning
   }


//sprintf(debug_text, "X72 state: %d  disci:%d  rblock:%04X  have_pps:%d  x72_pps:%d  dds:%g", x72_user_state, x72_user_dis, x72_creg & 0x0002, have_x72_pps, x72_pps, last_x72_dds);
   discipline_mode = DIS_MODE_AUTO_HOLD;
   if(x72_creg & 0x0002) {
      return;  // Rb not locked
   }
   if(x72_creg & 0x0008) {
      discipline_mode = DIS_MODE_NORMAL;
      return;  // PPS output not enabled
   }

   x72_state = x72_user_state;  // so firmware diciplining state display code works with software disciplining
   have_x72_state = 1;

   // dispatch to X72 sw discipline state handler
   if     (x72_user_state == X72_STATE_START0)     x72_init_state0();
   else if(x72_user_state == X72_STATE_START1)     x72_init_state1();
   else if(x72_user_state == X72_STATE_START2)     ;  // not used
   else if(x72_user_state == X72_STATE_HOLDOVER)   x72_holdover_state();  // not used
   else if(x72_user_state == X72_STATE_JAM1)       x72_jam1_state();      // not used
   else if(x72_user_state == X72_STATE_JAM2) {
      discipline_mode = DIS_MODE_NORMAL;  // !!! comment out to show TIC updates as holdover marks at the top of the plot
      x72_jam2_state();
   }
   else if(x72_user_state == X72_STATE_DISCIPLINE) {
      discipline_mode = DIS_MODE_NORMAL;
      x72_discipline_state();
   }
   else if(x72_user_state == X72_STATE_PIDCALC)    ;  // not used
   else if(x72_user_state == X72_STATE_PIDUPDATE)  ;  // not used
   else if(x72_user_state == X72_STATE_SLOPECALC)  x72_slopecalc_state();  // not used
   else x72_init_state0();

}

